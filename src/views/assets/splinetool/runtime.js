var QO = Object.create; var A0 = Object.defineProperty; var KO = Object.getOwnPropertyDescriptor; var ZO = Object.getOwnPropertyNames; var JO = Object.getPrototypeOf, $O = Object.prototype.hasOwnProperty; var ic = (i, t) => () => (t || i((t = { exports: {} }).exports, t), t.exports), eR = (i, t) => { for (var e in t) A0(i, e, { get: t[e], enumerable: !0 }) }, tR = (i, t, e, n) => { if (t && typeof t == "object" || typeof t == "function") for (let r of ZO(t)) !$O.call(i, r) && r !== e && A0(i, r, { get: () => t[r], enumerable: !(n = KO(t, r)) || n.enumerable }); return i }; var sc = (i, t, e) => (e = i != null ? QO(JO(i)) : {}, tR(t || !i || !i.__esModule ? A0(e, "default", { value: i, enumerable: !0 }) : e, i)); var iP = ic((mw, rP) => { (function (i, t) { typeof mw == "object" ? rP.exports = t() : typeof define == "function" && define.amd ? define(t) : i.Alea = t() })(mw, function () { "use strict"; return i.importState = function (e) { var n = new i; return n.importState(e), n }, i; function i () { return function (e) { var n = 0, r = 0, s = 0, o = 1; e.length == 0 && (e = [+new Date]); var a = t(); n = a(" "), r = a(" "), s = a(" "); for (var l = 0; l < e.length; l++)n -= a(e[l]), n < 0 && (n += 1), r -= a(e[l]), r < 0 && (r += 1), s -= a(e[l]), s < 0 && (s += 1); a = null; var u = function () { var c = 2091639 * n + o * 23283064365386963e-26; return n = r, r = s, s = c - (o = c | 0) }; return u.next = u, u.uint32 = function () { return u() * 4294967296 }, u.fract53 = function () { return u() + (u() * 2097152 | 0) * 11102230246251565e-32 }, u.version = "Alea 0.9", u.args = e, u.exportState = function () { return [n, r, s, o] }, u.importState = function (c) { n = +c[0] || 0, r = +c[1] || 0, s = +c[2] || 0, o = +c[3] || 0 }, u }(Array.prototype.slice.call(arguments)) } function t () { var e = 4022871197, n = function (r) { r = r.toString(); for (var s = 0; s < r.length; s++) { e += r.charCodeAt(s); var o = .02519603282416938 * e; e = o >>> 0, o -= e, o *= e, e = o >>> 0, o -= e, e += o * 4294967296 } return (e >>> 0) * 23283064365386963e-26 }; return n.version = "Mash 0.9", n } }) }); var yw = ic((xy, lP) => { (function (i, t) { typeof xy == "object" && typeof lP < "u" ? t(xy) : typeof define == "function" && define.amd ? define(["exports"], t) : t((i = typeof globalThis < "u" ? globalThis : i || self).SVDJS = {}) })(xy, function (i) { "use strict"; i.SVD = function (t, e, n, r, s) { if (e = e === void 0 || e, n = n === void 0 || n, s = 1e-64 / (r = r || Math.pow(2, -52)), !t) throw new TypeError("Matrix a is not defined"); var o, a, l, u, c, h, d, f, p, m, g, y, v = t[0].length, x = t.length; if (x < v) throw new TypeError("Invalid matrix: m < n"); for (var b = [], S = [], _ = [], E = e === "f" ? x : v, w = m = d = 0; w < x; w++)S[w] = new Array(E).fill(0); for (w = 0; w < v; w++)_[w] = new Array(v).fill(0); var M, T = new Array(v).fill(0); for (w = 0; w < x; w++)for (o = 0; o < v; o++)S[w][o] = t[w][o]; for (w = 0; w < v; w++) { for (b[w] = d, p = 0, l = w + 1, o = w; o < x; o++)p += Math.pow(S[o][w], 2); if (p < s) d = 0; else for (f = (h = S[w][w]) * (d = h < 0 ? Math.sqrt(p) : -Math.sqrt(p)) - p, S[w][w] = h - d, o = l; o < v; o++) { for (p = 0, a = w; a < x; a++)p += S[a][w] * S[a][o]; for (h = p / f, a = w; a < x; a++)S[a][o] = S[a][o] + h * S[a][w] } for (T[w] = d, p = 0, o = l; o < v; o++)p += Math.pow(S[w][o], 2); if (p < s) d = 0; else { for (f = (h = S[w][w + 1]) * (d = h < 0 ? Math.sqrt(p) : -Math.sqrt(p)) - p, S[w][w + 1] = h - d, o = l; o < v; o++)b[o] = S[w][o] / f; for (o = l; o < x; o++) { for (p = 0, a = l; a < v; a++)p += S[o][a] * S[w][a]; for (a = l; a < v; a++)S[o][a] = S[o][a] + p * b[a] } } m < (g = Math.abs(T[w]) + Math.abs(b[w])) && (m = g) } if (n) for (w = v - 1; 0 <= w; w--) { if (d !== 0) { for (f = S[w][w + 1] * d, o = l; o < v; o++)_[o][w] = S[w][o] / f; for (o = l; o < v; o++) { for (p = 0, a = l; a < v; a++)p += S[w][a] * _[a][o]; for (a = l; a < v; a++)_[a][o] = _[a][o] + p * _[a][w] } } for (o = l; o < v; o++)_[w][o] = 0, _[o][w] = 0; _[w][w] = 1, d = b[w], l = w } if (e) { if (e === "f") for (w = v; w < x; w++) { for (o = v; o < x; o++)S[w][o] = 0; S[w][w] = 1 } for (w = v - 1; 0 <= w; w--) { for (l = w + 1, d = T[w], o = l; o < E; o++)S[w][o] = 0; if (d !== 0) { for (f = S[w][w] * d, o = l; o < E; o++) { for (p = 0, a = l; a < x; a++)p += S[a][w] * S[a][o]; for (h = p / f, a = w; a < x; a++)S[a][o] = S[a][o] + h * S[a][w] } for (o = w; o < x; o++)S[o][w] = S[o][w] / d } else for (o = w; o < x; o++)S[o][w] = 0; S[w][w] = S[w][w] + 1 } } for (r *= m, a = v - 1; 0 <= a; a--)for (var I = 0; I < 50; I++) { for (M = !1, l = a; 0 <= l; l--) { if (Math.abs(b[l]) <= r) { M = !0; break } if (Math.abs(T[l - 1]) <= r) break } if (!M) { for (c = 0, u = l - (p = 1), w = l; w < a + 1 && (h = p * b[w], b[w] = c * b[w], !(Math.abs(h) <= r)); w++)if (d = T[w], T[w] = Math.sqrt(h * h + d * d), c = d / (f = T[w]), p = -h / f, e) for (o = 0; o < x; o++)g = S[o][u], y = S[o][w], S[o][u] = g * c + y * p, S[o][w] = -g * p + y * c } if (y = T[a], l === a) { if (y < 0 && (T[a] = -y, n)) for (o = 0; o < v; o++)_[o][a] = -_[o][a]; break } for (m = T[l], h = (((g = T[a - 1]) - y) * (g + y) + ((d = b[a - 1]) - (f = b[a])) * (d + f)) / (2 * f * g), d = Math.sqrt(h * h + 1), h = ((m - y) * (m + y) + f * (g / (h < 0 ? h - d : h + d) - f)) / m, w = l + (p = c = 1); w < a + 1; w++) { if (d = b[w], g = T[w], f = p * d, d *= c, y = Math.sqrt(h * h + f * f), h = m * (c = h / (b[w - 1] = y)) + d * (p = f / y), d = -m * p + d * c, f = g * p, g *= c, n) for (o = 0; o < v; o++)m = _[o][w - 1], y = _[o][w], _[o][w - 1] = m * c + y * p, _[o][w] = -m * p + y * c; if (y = Math.sqrt(h * h + f * f), h = (c = h / (T[w - 1] = y)) * d + (p = f / y) * g, m = -p * d + c * g, e) for (o = 0; o < x; o++)g = S[o][w - 1], y = S[o][w], S[o][w - 1] = g * c + y * p, S[o][w] = -g * p + y * c } b[l] = 0, b[a] = h, T[a] = m } for (w = 0; w < v; w++)T[w] < r && (T[w] = 0); return { u: S, q: T, v: _ } }, i.VERSION = "1.1.1", Object.defineProperty(i, "__esModule", { value: !0 }) }) }); var NP = ic((Lw, Nw) => { (function (i, t) { typeof Lw == "object" && typeof Nw < "u" ? Nw.exports = t() : typeof define == "function" && define.amd ? define(t) : (i = i || self, i.TinyQueue = t()) })(Lw, function () { "use strict"; var i = function (n, r) { if (n === void 0 && (n = []), r === void 0 && (r = t), this.data = n, this.length = this.data.length, this.compare = r, this.length > 0) for (var s = (this.length >> 1) - 1; s >= 0; s--)this._down(s) }; i.prototype.push = function (n) { this.data.push(n), this.length++, this._up(this.length - 1) }, i.prototype.pop = function () { if (this.length !== 0) { var n = this.data[0], r = this.data.pop(); return this.length--, this.length > 0 && (this.data[0] = r, this._down(0)), n } }, i.prototype.peek = function () { return this.data[0] }, i.prototype._up = function (n) { for (var r = this, s = r.data, o = r.compare, a = s[n]; n > 0;) { var l = n - 1 >> 1, u = s[l]; if (o(a, u) >= 0) break; s[n] = u, n = l } s[n] = a }, i.prototype._down = function (n) { for (var r = this, s = r.data, o = r.compare, a = this.length >> 1, l = s[n]; n < a;) { var u = (n << 1) + 1, c = s[u], h = u + 1; if (h < this.length && o(s[h], c) < 0 && (u = h, c = s[h]), o(c, l) >= 0) break; s[n] = c, n = u } s[n] = l }; function t (e, n) { return e < n ? -1 : e > n ? 1 : 0 } return i }) }); var FP = ic((Dce, Bw) => { "use strict"; var Ey = NP(); Ey.default && (Ey = Ey.default); Bw.exports = BP; Bw.exports.default = BP; function BP (i, t, e) { t = t || 1; for (var n, r, s, o, a = 0; a < i[0].length; a++) { var l = i[0][a]; (!a || l[0] < n) && (n = l[0]), (!a || l[1] < r) && (r = l[1]), (!a || l[0] > s) && (s = l[0]), (!a || l[1] > o) && (o = l[1]) } var u = s - n, c = o - r, h = Math.min(u, c), d = h / 2; if (h === 0) { var f = [n, r]; return f.distance = 0, f } for (var p = new Ey(void 0, sW), m = n; m < s; m += h)for (var g = r; g < o; g += h)p.push(new Na(m + d, g + d, d, i)); var y = aW(i), v = new Na(n + u / 2, r + c / 2, 0, i); v.d > y.d && (y = v); for (var x = p.length; p.length;) { var b = p.pop(); b.d > y.d && (y = b, e && console.log("found best %d after %d probes", Math.round(1e4 * b.d) / 1e4, x)), !(b.max - y.d <= t) && (d = b.h / 2, p.push(new Na(b.x - d, b.y - d, d, i)), p.push(new Na(b.x + d, b.y - d, d, i)), p.push(new Na(b.x - d, b.y + d, d, i)), p.push(new Na(b.x + d, b.y + d, d, i)), x += 4) } e && (console.log("num probes: " + x), console.log("best distance: " + y.d)); var S = [y.x, y.y]; return S.distance = y.d, S } function sW (i, t) { return t.max - i.max } function Na (i, t, e, n) { this.x = i, this.y = t, this.h = e, this.d = oW(i, t, n), this.max = this.d + this.h * Math.SQRT2 } function oW (i, t, e) { for (var n = !1, r = 1 / 0, s = 0; s < e.length; s++)for (var o = e[s], a = 0, l = o.length, u = l - 1; a < l; u = a++) { var c = o[a], h = o[u]; c[1] > t != h[1] > t && i < (h[0] - c[0]) * (t - c[1]) / (h[1] - c[1]) + c[0] && (n = !n), r = Math.min(r, lW(i, t, c, h)) } return r === 0 ? 0 : (n ? 1 : -1) * Math.sqrt(r) } function aW (i) { for (var t = 0, e = 0, n = 0, r = i[0], s = 0, o = r.length, a = o - 1; s < o; a = s++) { var l = r[s], u = r[a], c = l[0] * u[1] - u[0] * l[1]; e += (l[0] + u[0]) * c, n += (l[1] + u[1]) * c, t += c * 3 } return t === 0 ? new Na(r[0][0], r[0][1], 0, i) : new Na(e / t, n / t, 0, i) } function lW (i, t, e, n) { var r = e[0], s = e[1], o = n[0] - r, a = n[1] - s; if (o !== 0 || a !== 0) { var l = ((i - r) * o + (t - s) * a) / (o * o + a * a); l > 1 ? (r = n[0], s = n[1]) : l > 0 && (r += o * l, s += a * l) } return o = i - r, a = t - s, o * o + a * a } }); var O2 = ic(Qy => { (function () { "use strict"; var i = function () { this.init() }; i.prototype = { init: function () { var c = this || t; return c._counter = 1e3, c._html5AudioPool = [], c.html5PoolSize = 10, c._codecs = {}, c._howls = [], c._muted = !1, c._volume = 1, c._canPlayEvent = "canplaythrough", c._navigator = typeof window < "u" && window.navigator ? window.navigator : null, c.masterGain = null, c.noAudio = !1, c.usingWebAudio = !0, c.autoSuspend = !0, c.ctx = null, c.autoUnlock = !0, c._setup(), c }, volume: function (c) { var h = this || t; if (c = parseFloat(c), h.ctx || u(), typeof c < "u" && c >= 0 && c <= 1) { if (h._volume = c, h._muted) return h; h.usingWebAudio && h.masterGain.gain.setValueAtTime(c, t.ctx.currentTime); for (var d = 0; d < h._howls.length; d++)if (!h._howls[d]._webAudio) for (var f = h._howls[d]._getSoundIds(), p = 0; p < f.length; p++) { var m = h._howls[d]._soundById(f[p]); m && m._node && (m._node.volume = m._volume * c) } return h } return h._volume }, mute: function (c) { var h = this || t; h.ctx || u(), h._muted = c, h.usingWebAudio && h.masterGain.gain.setValueAtTime(c ? 0 : h._volume, t.ctx.currentTime); for (var d = 0; d < h._howls.length; d++)if (!h._howls[d]._webAudio) for (var f = h._howls[d]._getSoundIds(), p = 0; p < f.length; p++) { var m = h._howls[d]._soundById(f[p]); m && m._node && (m._node.muted = c ? !0 : m._muted) } return h }, stop: function () { for (var c = this || t, h = 0; h < c._howls.length; h++)c._howls[h].stop(); return c }, unload: function () { for (var c = this || t, h = c._howls.length - 1; h >= 0; h--)c._howls[h].unload(); return c.usingWebAudio && c.ctx && typeof c.ctx.close < "u" && (c.ctx.close(), c.ctx = null, u()), c }, codecs: function (c) { return (this || t)._codecs[c.replace(/^x-/, "")] }, _setup: function () { var c = this || t; if (c.state = c.ctx && c.ctx.state || "suspended", c._autoSuspend(), !c.usingWebAudio) if (typeof Audio < "u") try { var h = new Audio; typeof h.oncanplaythrough > "u" && (c._canPlayEvent = "canplay") } catch { c.noAudio = !0 } else c.noAudio = !0; try { var h = new Audio; h.muted && (c.noAudio = !0) } catch { } return c.noAudio || c._setupCodecs(), c }, _setupCodecs: function () { var c = this || t, h = null; try { h = typeof Audio < "u" ? new Audio : null } catch { return c } if (!h || typeof h.canPlayType != "function") return c; var d = h.canPlayType("audio/mpeg;").replace(/^no$/, ""), f = c._navigator ? c._navigator.userAgent : "", p = f.match(/OPR\/([0-6].)/g), m = p && parseInt(p[0].split("/")[1], 10) < 33, g = f.indexOf("Safari") !== -1 && f.indexOf("Chrome") === -1, y = f.match(/Version\/(.*?) /), v = g && y && parseInt(y[1], 10) < 15; return c._codecs = { mp3: !!(!m && (d || h.canPlayType("audio/mp3;").replace(/^no$/, ""))), mpeg: !!d, opus: !!h.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""), ogg: !!h.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), oga: !!h.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""), wav: !!(h.canPlayType('audio/wav; codecs="1"') || h.canPlayType("audio/wav")).replace(/^no$/, ""), aac: !!h.canPlayType("audio/aac;").replace(/^no$/, ""), caf: !!h.canPlayType("audio/x-caf;").replace(/^no$/, ""), m4a: !!(h.canPlayType("audio/x-m4a;") || h.canPlayType("audio/m4a;") || h.canPlayType("audio/aac;")).replace(/^no$/, ""), m4b: !!(h.canPlayType("audio/x-m4b;") || h.canPlayType("audio/m4b;") || h.canPlayType("audio/aac;")).replace(/^no$/, ""), mp4: !!(h.canPlayType("audio/x-mp4;") || h.canPlayType("audio/mp4;") || h.canPlayType("audio/aac;")).replace(/^no$/, ""), weba: !!(!v && h.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), webm: !!(!v && h.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")), dolby: !!h.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""), flac: !!(h.canPlayType("audio/x-flac;") || h.canPlayType("audio/flac;")).replace(/^no$/, "") }, c }, _unlockAudio: function () { var c = this || t; if (!(c._audioUnlocked || !c.ctx)) { c._audioUnlocked = !1, c.autoUnlock = !1, !c._mobileUnloaded && c.ctx.sampleRate !== 44100 && (c._mobileUnloaded = !0, c.unload()), c._scratchBuffer = c.ctx.createBuffer(1, 1, 22050); var h = function (d) { for (; c._html5AudioPool.length < c.html5PoolSize;)try { var f = new Audio; f._unlocked = !0, c._releaseHtml5Audio(f) } catch { c.noAudio = !0; break } for (var p = 0; p < c._howls.length; p++)if (!c._howls[p]._webAudio) for (var m = c._howls[p]._getSoundIds(), g = 0; g < m.length; g++) { var y = c._howls[p]._soundById(m[g]); y && y._node && !y._node._unlocked && (y._node._unlocked = !0, y._node.load()) } c._autoResume(); var v = c.ctx.createBufferSource(); v.buffer = c._scratchBuffer, v.connect(c.ctx.destination), typeof v.start > "u" ? v.noteOn(0) : v.start(0), typeof c.ctx.resume == "function" && c.ctx.resume(), v.onended = function () { v.disconnect(0), c._audioUnlocked = !0, document.removeEventListener("touchstart", h, !0), document.removeEventListener("touchend", h, !0), document.removeEventListener("click", h, !0), document.removeEventListener("keydown", h, !0); for (var x = 0; x < c._howls.length; x++)c._howls[x]._emit("unlock") } }; return document.addEventListener("touchstart", h, !0), document.addEventListener("touchend", h, !0), document.addEventListener("click", h, !0), document.addEventListener("keydown", h, !0), c } }, _obtainHtml5Audio: function () { var c = this || t; if (c._html5AudioPool.length) return c._html5AudioPool.pop(); var h = new Audio().play(); return h && typeof Promise < "u" && (h instanceof Promise || typeof h.then == "function") && h.catch(function () { console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.") }), new Audio }, _releaseHtml5Audio: function (c) { var h = this || t; return c._unlocked && h._html5AudioPool.push(c), h }, _autoSuspend: function () { var c = this; if (!(!c.autoSuspend || !c.ctx || typeof c.ctx.suspend > "u" || !t.usingWebAudio)) { for (var h = 0; h < c._howls.length; h++)if (c._howls[h]._webAudio) { for (var d = 0; d < c._howls[h]._sounds.length; d++)if (!c._howls[h]._sounds[d]._paused) return c } return c._suspendTimer && clearTimeout(c._suspendTimer), c._suspendTimer = setTimeout(function () { if (c.autoSuspend) { c._suspendTimer = null, c.state = "suspending"; var f = function () { c.state = "suspended", c._resumeAfterSuspend && (delete c._resumeAfterSuspend, c._autoResume()) }; c.ctx.suspend().then(f, f) } }, 3e4), c } }, _autoResume: function () { var c = this; if (!(!c.ctx || typeof c.ctx.resume > "u" || !t.usingWebAudio)) return c.state === "running" && c.ctx.state !== "interrupted" && c._suspendTimer ? (clearTimeout(c._suspendTimer), c._suspendTimer = null) : c.state === "suspended" || c.state === "running" && c.ctx.state === "interrupted" ? (c.ctx.resume().then(function () { c.state = "running"; for (var h = 0; h < c._howls.length; h++)c._howls[h]._emit("resume") }), c._suspendTimer && (clearTimeout(c._suspendTimer), c._suspendTimer = null)) : c.state === "suspending" && (c._resumeAfterSuspend = !0), c } }; var t = new i, e = function (c) { var h = this; if (!c.src || c.src.length === 0) { console.error("An array of source files must be passed with any new Howl."); return } h.init(c) }; e.prototype = { init: function (c) { var h = this; return t.ctx || u(), h._autoplay = c.autoplay || !1, h._format = typeof c.format != "string" ? c.format : [c.format], h._html5 = c.html5 || !1, h._muted = c.mute || !1, h._loop = c.loop || !1, h._pool = c.pool || 5, h._preload = typeof c.preload == "boolean" || c.preload === "metadata" ? c.preload : !0, h._rate = c.rate || 1, h._sprite = c.sprite || {}, h._src = typeof c.src != "string" ? c.src : [c.src], h._volume = c.volume !== void 0 ? c.volume : 1, h._xhr = { method: c.xhr && c.xhr.method ? c.xhr.method : "GET", headers: c.xhr && c.xhr.headers ? c.xhr.headers : null, withCredentials: c.xhr && c.xhr.withCredentials ? c.xhr.withCredentials : !1 }, h._duration = 0, h._state = "unloaded", h._sounds = [], h._endTimers = {}, h._queue = [], h._playLock = !1, h._onend = c.onend ? [{ fn: c.onend }] : [], h._onfade = c.onfade ? [{ fn: c.onfade }] : [], h._onload = c.onload ? [{ fn: c.onload }] : [], h._onloaderror = c.onloaderror ? [{ fn: c.onloaderror }] : [], h._onplayerror = c.onplayerror ? [{ fn: c.onplayerror }] : [], h._onpause = c.onpause ? [{ fn: c.onpause }] : [], h._onplay = c.onplay ? [{ fn: c.onplay }] : [], h._onstop = c.onstop ? [{ fn: c.onstop }] : [], h._onmute = c.onmute ? [{ fn: c.onmute }] : [], h._onvolume = c.onvolume ? [{ fn: c.onvolume }] : [], h._onrate = c.onrate ? [{ fn: c.onrate }] : [], h._onseek = c.onseek ? [{ fn: c.onseek }] : [], h._onunlock = c.onunlock ? [{ fn: c.onunlock }] : [], h._onresume = [], h._webAudio = t.usingWebAudio && !h._html5, typeof t.ctx < "u" && t.ctx && t.autoUnlock && t._unlockAudio(), t._howls.push(h), h._autoplay && h._queue.push({ event: "play", action: function () { h.play() } }), h._preload && h._preload !== "none" && h.load(), h }, load: function () { var c = this, h = null; if (t.noAudio) { c._emit("loaderror", null, "No audio support."); return } typeof c._src == "string" && (c._src = [c._src]); for (var d = 0; d < c._src.length; d++) { var f, p; if (c._format && c._format[d]) f = c._format[d]; else { if (p = c._src[d], typeof p != "string") { c._emit("loaderror", null, "Non-string found in selected audio sources - ignoring."); continue } f = /^data:audio\/([^;,]+);/i.exec(p), f || (f = /\.([^.]+)$/.exec(p.split("?", 1)[0])), f && (f = f[1].toLowerCase()) } if (f || console.warn('No file extension was found. Consider using the "format" property or specify an extension.'), f && t.codecs(f)) { h = c._src[d]; break } } if (!h) { c._emit("loaderror", null, "No codec support for selected audio sources."); return } return c._src = h, c._state = "loading", window.location.protocol === "https:" && h.slice(0, 5) === "http:" && (c._html5 = !0, c._webAudio = !1), new n(c), c._webAudio && s(c), c }, play: function (c, h) { var d = this, f = null; if (typeof c == "number") f = c, c = null; else { if (typeof c == "string" && d._state === "loaded" && !d._sprite[c]) return null; if (typeof c > "u" && (c = "__default", !d._playLock)) { for (var p = 0, m = 0; m < d._sounds.length; m++)d._sounds[m]._paused && !d._sounds[m]._ended && (p++, f = d._sounds[m]._id); p === 1 ? c = null : f = null } } var g = f ? d._soundById(f) : d._inactiveSound(); if (!g) return null; if (f && !c && (c = g._sprite || "__default"), d._state !== "loaded") { g._sprite = c, g._ended = !1; var y = g._id; return d._queue.push({ event: "play", action: function () { d.play(y) } }), y } if (f && !g._paused) return h || d._loadQueue("play"), g._id; d._webAudio && t._autoResume(); var v = Math.max(0, g._seek > 0 ? g._seek : d._sprite[c][0] / 1e3), x = Math.max(0, (d._sprite[c][0] + d._sprite[c][1]) / 1e3 - v), b = x * 1e3 / Math.abs(g._rate), S = d._sprite[c][0] / 1e3, _ = (d._sprite[c][0] + d._sprite[c][1]) / 1e3; g._sprite = c, g._ended = !1; var E = function () { g._paused = !1, g._seek = v, g._start = S, g._stop = _, g._loop = !!(g._loop || d._sprite[c][2]) }; if (v >= _) { d._ended(g); return } var w = g._node; if (d._webAudio) { var M = function () { d._playLock = !1, E(), d._refreshBuffer(g); var P = g._muted || d._muted ? 0 : g._volume; w.gain.setValueAtTime(P, t.ctx.currentTime), g._playStart = t.ctx.currentTime, typeof w.bufferSource.start > "u" ? g._loop ? w.bufferSource.noteGrainOn(0, v, 86400) : w.bufferSource.noteGrainOn(0, v, x) : g._loop ? w.bufferSource.start(0, v, 86400) : w.bufferSource.start(0, v, x), b !== 1 / 0 && (d._endTimers[g._id] = setTimeout(d._ended.bind(d, g), b)), h || setTimeout(function () { d._emit("play", g._id), d._loadQueue() }, 0) }; t.state === "running" && t.ctx.state !== "interrupted" ? M() : (d._playLock = !0, d.once("resume", M), d._clearTimer(g._id)) } else { var T = function () { w.currentTime = v, w.muted = g._muted || d._muted || t._muted || w.muted, w.volume = g._volume * t.volume(), w.playbackRate = g._rate; try { var P = w.play(); if (P && typeof Promise < "u" && (P instanceof Promise || typeof P.then == "function") ? (d._playLock = !0, E(), P.then(function () { d._playLock = !1, w._unlocked = !0, h ? d._loadQueue() : d._emit("play", g._id) }).catch(function () { d._playLock = !1, d._emit("playerror", g._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."), g._ended = !0, g._paused = !0 })) : h || (d._playLock = !1, E(), d._emit("play", g._id)), w.playbackRate = g._rate, w.paused) { d._emit("playerror", g._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."); return } c !== "__default" || g._loop ? d._endTimers[g._id] = setTimeout(d._ended.bind(d, g), b) : (d._endTimers[g._id] = function () { d._ended(g), w.removeEventListener("ended", d._endTimers[g._id], !1) }, w.addEventListener("ended", d._endTimers[g._id], !1)) } catch (D) { d._emit("playerror", g._id, D) } }; w.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" && (w.src = d._src, w.load()); var I = window && window.ejecta || !w.readyState && t._navigator.isCocoonJS; if (w.readyState >= 3 || I) T(); else { d._playLock = !0, d._state = "loading"; var C = function () { d._state = "loaded", T(), w.removeEventListener(t._canPlayEvent, C, !1) }; w.addEventListener(t._canPlayEvent, C, !1), d._clearTimer(g._id) } } return g._id }, pause: function (c) { var h = this; if (h._state !== "loaded" || h._playLock) return h._queue.push({ event: "pause", action: function () { h.pause(c) } }), h; for (var d = h._getSoundIds(c), f = 0; f < d.length; f++) { h._clearTimer(d[f]); var p = h._soundById(d[f]); if (p && !p._paused && (p._seek = h.seek(d[f]), p._rateSeek = 0, p._paused = !0, h._stopFade(d[f]), p._node)) if (h._webAudio) { if (!p._node.bufferSource) continue; typeof p._node.bufferSource.stop > "u" ? p._node.bufferSource.noteOff(0) : p._node.bufferSource.stop(0), h._cleanBuffer(p._node) } else (!isNaN(p._node.duration) || p._node.duration === 1 / 0) && p._node.pause(); arguments[1] || h._emit("pause", p ? p._id : null) } return h }, stop: function (c, h) { var d = this; if (d._state !== "loaded" || d._playLock) return d._queue.push({ event: "stop", action: function () { d.stop(c) } }), d; for (var f = d._getSoundIds(c), p = 0; p < f.length; p++) { d._clearTimer(f[p]); var m = d._soundById(f[p]); m && (m._seek = m._start || 0, m._rateSeek = 0, m._paused = !0, m._ended = !0, d._stopFade(f[p]), m._node && (d._webAudio ? m._node.bufferSource && (typeof m._node.bufferSource.stop > "u" ? m._node.bufferSource.noteOff(0) : m._node.bufferSource.stop(0), d._cleanBuffer(m._node)) : (!isNaN(m._node.duration) || m._node.duration === 1 / 0) && (m._node.currentTime = m._start || 0, m._node.pause(), m._node.duration === 1 / 0 && d._clearSound(m._node))), h || d._emit("stop", m._id)) } return d }, mute: function (c, h) { var d = this; if (d._state !== "loaded" || d._playLock) return d._queue.push({ event: "mute", action: function () { d.mute(c, h) } }), d; if (typeof h > "u") if (typeof c == "boolean") d._muted = c; else return d._muted; for (var f = d._getSoundIds(h), p = 0; p < f.length; p++) { var m = d._soundById(f[p]); m && (m._muted = c, m._interval && d._stopFade(m._id), d._webAudio && m._node ? m._node.gain.setValueAtTime(c ? 0 : m._volume, t.ctx.currentTime) : m._node && (m._node.muted = t._muted ? !0 : c), d._emit("mute", m._id)) } return d }, volume: function () { var c = this, h = arguments, d, f; if (h.length === 0) return c._volume; if (h.length === 1 || h.length === 2 && typeof h[1] > "u") { var p = c._getSoundIds(), m = p.indexOf(h[0]); m >= 0 ? f = parseInt(h[0], 10) : d = parseFloat(h[0]) } else h.length >= 2 && (d = parseFloat(h[0]), f = parseInt(h[1], 10)); var g; if (typeof d < "u" && d >= 0 && d <= 1) { if (c._state !== "loaded" || c._playLock) return c._queue.push({ event: "volume", action: function () { c.volume.apply(c, h) } }), c; typeof f > "u" && (c._volume = d), f = c._getSoundIds(f); for (var y = 0; y < f.length; y++)g = c._soundById(f[y]), g && (g._volume = d, h[2] || c._stopFade(f[y]), c._webAudio && g._node && !g._muted ? g._node.gain.setValueAtTime(d, t.ctx.currentTime) : g._node && !g._muted && (g._node.volume = d * t.volume()), c._emit("volume", g._id)) } else return g = f ? c._soundById(f) : c._sounds[0], g ? g._volume : 0; return c }, fade: function (c, h, d, f) { var p = this; if (p._state !== "loaded" || p._playLock) return p._queue.push({ event: "fade", action: function () { p.fade(c, h, d, f) } }), p; c = Math.min(Math.max(0, parseFloat(c)), 1), h = Math.min(Math.max(0, parseFloat(h)), 1), d = parseFloat(d), p.volume(c, f); for (var m = p._getSoundIds(f), g = 0; g < m.length; g++) { var y = p._soundById(m[g]); if (y) { if (f || p._stopFade(m[g]), p._webAudio && !y._muted) { var v = t.ctx.currentTime, x = v + d / 1e3; y._volume = c, y._node.gain.setValueAtTime(c, v), y._node.gain.linearRampToValueAtTime(h, x) } p._startFadeInterval(y, c, h, d, m[g], typeof f > "u") } } return p }, _startFadeInterval: function (c, h, d, f, p, m) { var g = this, y = h, v = d - h, x = Math.abs(v / .01), b = Math.max(4, x > 0 ? f / x : f), S = Date.now(); c._fadeTo = d, c._interval = setInterval(function () { var _ = (Date.now() - S) / f; S = Date.now(), y += v * _, y = Math.round(y * 100) / 100, v < 0 ? y = Math.max(d, y) : y = Math.min(d, y), g._webAudio ? c._volume = y : g.volume(y, c._id, !0), m && (g._volume = y), (d < h && y <= d || d > h && y >= d) && (clearInterval(c._interval), c._interval = null, c._fadeTo = null, g.volume(d, c._id), g._emit("fade", c._id)) }, b) }, _stopFade: function (c) { var h = this, d = h._soundById(c); return d && d._interval && (h._webAudio && d._node.gain.cancelScheduledValues(t.ctx.currentTime), clearInterval(d._interval), d._interval = null, h.volume(d._fadeTo, c), d._fadeTo = null, h._emit("fade", c)), h }, loop: function () { var c = this, h = arguments, d, f, p; if (h.length === 0) return c._loop; if (h.length === 1) if (typeof h[0] == "boolean") d = h[0], c._loop = d; else return p = c._soundById(parseInt(h[0], 10)), p ? p._loop : !1; else h.length === 2 && (d = h[0], f = parseInt(h[1], 10)); for (var m = c._getSoundIds(f), g = 0; g < m.length; g++)p = c._soundById(m[g]), p && (p._loop = d, c._webAudio && p._node && p._node.bufferSource && (p._node.bufferSource.loop = d, d && (p._node.bufferSource.loopStart = p._start || 0, p._node.bufferSource.loopEnd = p._stop, c.playing(m[g]) && (c.pause(m[g], !0), c.play(m[g], !0))))); return c }, rate: function () { var c = this, h = arguments, d, f; if (h.length === 0) f = c._sounds[0]._id; else if (h.length === 1) { var p = c._getSoundIds(), m = p.indexOf(h[0]); m >= 0 ? f = parseInt(h[0], 10) : d = parseFloat(h[0]) } else h.length === 2 && (d = parseFloat(h[0]), f = parseInt(h[1], 10)); var g; if (typeof d == "number") { if (c._state !== "loaded" || c._playLock) return c._queue.push({ event: "rate", action: function () { c.rate.apply(c, h) } }), c; typeof f > "u" && (c._rate = d), f = c._getSoundIds(f); for (var y = 0; y < f.length; y++)if (g = c._soundById(f[y]), g) { c.playing(f[y]) && (g._rateSeek = c.seek(f[y]), g._playStart = c._webAudio ? t.ctx.currentTime : g._playStart), g._rate = d, c._webAudio && g._node && g._node.bufferSource ? g._node.bufferSource.playbackRate.setValueAtTime(d, t.ctx.currentTime) : g._node && (g._node.playbackRate = d); var v = c.seek(f[y]), x = (c._sprite[g._sprite][0] + c._sprite[g._sprite][1]) / 1e3 - v, b = x * 1e3 / Math.abs(g._rate); (c._endTimers[f[y]] || !g._paused) && (c._clearTimer(f[y]), c._endTimers[f[y]] = setTimeout(c._ended.bind(c, g), b)), c._emit("rate", g._id) } } else return g = c._soundById(f), g ? g._rate : c._rate; return c }, seek: function () { var c = this, h = arguments, d, f; if (h.length === 0) c._sounds.length && (f = c._sounds[0]._id); else if (h.length === 1) { var p = c._getSoundIds(), m = p.indexOf(h[0]); m >= 0 ? f = parseInt(h[0], 10) : c._sounds.length && (f = c._sounds[0]._id, d = parseFloat(h[0])) } else h.length === 2 && (d = parseFloat(h[0]), f = parseInt(h[1], 10)); if (typeof f > "u") return 0; if (typeof d == "number" && (c._state !== "loaded" || c._playLock)) return c._queue.push({ event: "seek", action: function () { c.seek.apply(c, h) } }), c; var g = c._soundById(f); if (g) if (typeof d == "number" && d >= 0) { var y = c.playing(f); y && c.pause(f, !0), g._seek = d, g._ended = !1, c._clearTimer(f), !c._webAudio && g._node && !isNaN(g._node.duration) && (g._node.currentTime = d); var v = function () { y && c.play(f, !0), c._emit("seek", f) }; if (y && !c._webAudio) { var x = function () { c._playLock ? setTimeout(x, 0) : v() }; setTimeout(x, 0) } else v() } else if (c._webAudio) { var b = c.playing(f) ? t.ctx.currentTime - g._playStart : 0, S = g._rateSeek ? g._rateSeek - g._seek : 0; return g._seek + (S + b * Math.abs(g._rate)) } else return g._node.currentTime; return c }, playing: function (c) { var h = this; if (typeof c == "number") { var d = h._soundById(c); return d ? !d._paused : !1 } for (var f = 0; f < h._sounds.length; f++)if (!h._sounds[f]._paused) return !0; return !1 }, duration: function (c) { var h = this, d = h._duration, f = h._soundById(c); return f && (d = h._sprite[f._sprite][1] / 1e3), d }, state: function () { return this._state }, unload: function () { for (var c = this, h = c._sounds, d = 0; d < h.length; d++)h[d]._paused || c.stop(h[d]._id), c._webAudio || (c._clearSound(h[d]._node), h[d]._node.removeEventListener("error", h[d]._errorFn, !1), h[d]._node.removeEventListener(t._canPlayEvent, h[d]._loadFn, !1), h[d]._node.removeEventListener("ended", h[d]._endFn, !1), t._releaseHtml5Audio(h[d]._node)), delete h[d]._node, c._clearTimer(h[d]._id); var f = t._howls.indexOf(c); f >= 0 && t._howls.splice(f, 1); var p = !0; for (d = 0; d < t._howls.length; d++)if (t._howls[d]._src === c._src || c._src.indexOf(t._howls[d]._src) >= 0) { p = !1; break } return r && p && delete r[c._src], t.noAudio = !1, c._state = "unloaded", c._sounds = [], c = null, null }, on: function (c, h, d, f) { var p = this, m = p["_on" + c]; return typeof h == "function" && m.push(f ? { id: d, fn: h, once: f } : { id: d, fn: h }), p }, off: function (c, h, d) { var f = this, p = f["_on" + c], m = 0; if (typeof h == "number" && (d = h, h = null), h || d) for (m = 0; m < p.length; m++) { var g = d === p[m].id; if (h === p[m].fn && g || !h && g) { p.splice(m, 1); break } } else if (c) f["_on" + c] = []; else { var y = Object.keys(f); for (m = 0; m < y.length; m++)y[m].indexOf("_on") === 0 && Array.isArray(f[y[m]]) && (f[y[m]] = []) } return f }, once: function (c, h, d) { var f = this; return f.on(c, h, d, 1), f }, _emit: function (c, h, d) { for (var f = this, p = f["_on" + c], m = p.length - 1; m >= 0; m--)(!p[m].id || p[m].id === h || c === "load") && (setTimeout(function (g) { g.call(this, h, d) }.bind(f, p[m].fn), 0), p[m].once && f.off(c, p[m].fn, p[m].id)); return f._loadQueue(c), f }, _loadQueue: function (c) { var h = this; if (h._queue.length > 0) { var d = h._queue[0]; d.event === c && (h._queue.shift(), h._loadQueue()), c || d.action() } return h }, _ended: function (c) { var h = this, d = c._sprite; if (!h._webAudio && c._node && !c._node.paused && !c._node.ended && c._node.currentTime < c._stop) return setTimeout(h._ended.bind(h, c), 100), h; var f = !!(c._loop || h._sprite[d][2]); if (h._emit("end", c._id), !h._webAudio && f && h.stop(c._id, !0).play(c._id), h._webAudio && f) { h._emit("play", c._id), c._seek = c._start || 0, c._rateSeek = 0, c._playStart = t.ctx.currentTime; var p = (c._stop - c._start) * 1e3 / Math.abs(c._rate); h._endTimers[c._id] = setTimeout(h._ended.bind(h, c), p) } return h._webAudio && !f && (c._paused = !0, c._ended = !0, c._seek = c._start || 0, c._rateSeek = 0, h._clearTimer(c._id), h._cleanBuffer(c._node), t._autoSuspend()), !h._webAudio && !f && h.stop(c._id, !0), h }, _clearTimer: function (c) { var h = this; if (h._endTimers[c]) { if (typeof h._endTimers[c] != "function") clearTimeout(h._endTimers[c]); else { var d = h._soundById(c); d && d._node && d._node.removeEventListener("ended", h._endTimers[c], !1) } delete h._endTimers[c] } return h }, _soundById: function (c) { for (var h = this, d = 0; d < h._sounds.length; d++)if (c === h._sounds[d]._id) return h._sounds[d]; return null }, _inactiveSound: function () { var c = this; c._drain(); for (var h = 0; h < c._sounds.length; h++)if (c._sounds[h]._ended) return c._sounds[h].reset(); return new n(c) }, _drain: function () { var c = this, h = c._pool, d = 0, f = 0; if (!(c._sounds.length < h)) { for (f = 0; f < c._sounds.length; f++)c._sounds[f]._ended && d++; for (f = c._sounds.length - 1; f >= 0; f--) { if (d <= h) return; c._sounds[f]._ended && (c._webAudio && c._sounds[f]._node && c._sounds[f]._node.disconnect(0), c._sounds.splice(f, 1), d--) } } }, _getSoundIds: function (c) { var h = this; if (typeof c > "u") { for (var d = [], f = 0; f < h._sounds.length; f++)d.push(h._sounds[f]._id); return d } else return [c] }, _refreshBuffer: function (c) { var h = this; return c._node.bufferSource = t.ctx.createBufferSource(), c._node.bufferSource.buffer = r[h._src], c._panner ? c._node.bufferSource.connect(c._panner) : c._node.bufferSource.connect(c._node), c._node.bufferSource.loop = c._loop, c._loop && (c._node.bufferSource.loopStart = c._start || 0, c._node.bufferSource.loopEnd = c._stop || 0), c._node.bufferSource.playbackRate.setValueAtTime(c._rate, t.ctx.currentTime), h }, _cleanBuffer: function (c) { var h = this, d = t._navigator && t._navigator.vendor.indexOf("Apple") >= 0; if (t._scratchBuffer && c.bufferSource && (c.bufferSource.onended = null, c.bufferSource.disconnect(0), d)) try { c.bufferSource.buffer = t._scratchBuffer } catch { } return c.bufferSource = null, h }, _clearSound: function (c) { var h = /MSIE |Trident\//.test(t._navigator && t._navigator.userAgent); h || (c.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") } }; var n = function (c) { this._parent = c, this.init() }; n.prototype = { init: function () { var c = this, h = c._parent; return c._muted = h._muted, c._loop = h._loop, c._volume = h._volume, c._rate = h._rate, c._seek = 0, c._paused = !0, c._ended = !0, c._sprite = "__default", c._id = ++t._counter, h._sounds.push(c), c.create(), c }, create: function () { var c = this, h = c._parent, d = t._muted || c._muted || c._parent._muted ? 0 : c._volume; return h._webAudio ? (c._node = typeof t.ctx.createGain > "u" ? t.ctx.createGainNode() : t.ctx.createGain(), c._node.gain.setValueAtTime(d, t.ctx.currentTime), c._node.paused = !0, c._node.connect(t.masterGain)) : t.noAudio || (c._node = t._obtainHtml5Audio(), c._errorFn = c._errorListener.bind(c), c._node.addEventListener("error", c._errorFn, !1), c._loadFn = c._loadListener.bind(c), c._node.addEventListener(t._canPlayEvent, c._loadFn, !1), c._endFn = c._endListener.bind(c), c._node.addEventListener("ended", c._endFn, !1), c._node.src = h._src, c._node.preload = h._preload === !0 ? "auto" : h._preload, c._node.volume = d * t.volume(), c._node.load()), c }, reset: function () { var c = this, h = c._parent; return c._muted = h._muted, c._loop = h._loop, c._volume = h._volume, c._rate = h._rate, c._seek = 0, c._rateSeek = 0, c._paused = !0, c._ended = !0, c._sprite = "__default", c._id = ++t._counter, c }, _errorListener: function () { var c = this; c._parent._emit("loaderror", c._id, c._node.error ? c._node.error.code : 0), c._node.removeEventListener("error", c._errorFn, !1) }, _loadListener: function () { var c = this, h = c._parent; h._duration = Math.ceil(c._node.duration * 10) / 10, Object.keys(h._sprite).length === 0 && (h._sprite = { __default: [0, h._duration * 1e3] }), h._state !== "loaded" && (h._state = "loaded", h._emit("load"), h._loadQueue()), c._node.removeEventListener(t._canPlayEvent, c._loadFn, !1) }, _endListener: function () { var c = this, h = c._parent; h._duration === 1 / 0 && (h._duration = Math.ceil(c._node.duration * 10) / 10, h._sprite.__default[1] === 1 / 0 && (h._sprite.__default[1] = h._duration * 1e3), h._ended(c)), c._node.removeEventListener("ended", c._endFn, !1) } }; var r = {}, s = function (c) { var h = c._src; if (r[h]) { c._duration = r[h].duration, l(c); return } if (/^data:[^;]+;base64,/.test(h)) { for (var d = atob(h.split(",")[1]), f = new Uint8Array(d.length), p = 0; p < d.length; ++p)f[p] = d.charCodeAt(p); a(f.buffer, c) } else { var m = new XMLHttpRequest; m.open(c._xhr.method, h, !0), m.withCredentials = c._xhr.withCredentials, m.responseType = "arraybuffer", c._xhr.headers && Object.keys(c._xhr.headers).forEach(function (g) { m.setRequestHeader(g, c._xhr.headers[g]) }), m.onload = function () { var g = (m.status + "")[0]; if (g !== "0" && g !== "2" && g !== "3") { c._emit("loaderror", null, "Failed loading audio file with status: " + m.status + "."); return } a(m.response, c) }, m.onerror = function () { c._webAudio && (c._html5 = !0, c._webAudio = !1, c._sounds = [], delete r[h], c.load()) }, o(m) } }, o = function (c) { try { c.send() } catch { c.onerror() } }, a = function (c, h) { var d = function () { h._emit("loaderror", null, "Decoding audio data failed.") }, f = function (p) { p && h._sounds.length > 0 ? (r[h._src] = p, l(h, p)) : d() }; typeof Promise < "u" && t.ctx.decodeAudioData.length === 1 ? t.ctx.decodeAudioData(c).then(f).catch(d) : t.ctx.decodeAudioData(c, f, d) }, l = function (c, h) { h && !c._duration && (c._duration = h.duration), Object.keys(c._sprite).length === 0 && (c._sprite = { __default: [0, c._duration * 1e3] }), c._state !== "loaded" && (c._state = "loaded", c._emit("load"), c._loadQueue()) }, u = function () { if (t.usingWebAudio) { try { typeof AudioContext < "u" ? t.ctx = new AudioContext : typeof webkitAudioContext < "u" ? t.ctx = new webkitAudioContext : t.usingWebAudio = !1 } catch { t.usingWebAudio = !1 } t.ctx || (t.usingWebAudio = !1); var c = /iP(hone|od|ad)/.test(t._navigator && t._navigator.platform), h = t._navigator && t._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/), d = h ? parseInt(h[1], 10) : null; if (c && d && d < 9) { var f = /safari/.test(t._navigator && t._navigator.userAgent.toLowerCase()); t._navigator && !f && (t.usingWebAudio = !1) } t.usingWebAudio && (t.masterGain = typeof t.ctx.createGain > "u" ? t.ctx.createGainNode() : t.ctx.createGain(), t.masterGain.gain.setValueAtTime(t._muted ? 0 : t._volume, t.ctx.currentTime), t.masterGain.connect(t.ctx.destination)), t._setup() } }; typeof define == "function" && define.amd && define([], function () { return { Howler: t, Howl: e } }), typeof Qy < "u" && (Qy.Howler = t, Qy.Howl = e), typeof global < "u" ? (global.HowlerGlobal = i, global.Howler = t, global.Howl = e, global.Sound = n) : typeof window < "u" && (window.HowlerGlobal = i, window.Howler = t, window.Howl = e, window.Sound = n) })(); (function () { "use strict"; HowlerGlobal.prototype._pos = [0, 0, 0], HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0], HowlerGlobal.prototype.stereo = function (t) { var e = this; if (!e.ctx || !e.ctx.listener) return e; for (var n = e._howls.length - 1; n >= 0; n--)e._howls[n].stereo(t); return e }, HowlerGlobal.prototype.pos = function (t, e, n) { var r = this; if (!r.ctx || !r.ctx.listener) return r; if (e = typeof e != "number" ? r._pos[1] : e, n = typeof n != "number" ? r._pos[2] : n, typeof t == "number") r._pos = [t, e, n], typeof r.ctx.listener.positionX < "u" ? (r.ctx.listener.positionX.setTargetAtTime(r._pos[0], Howler.ctx.currentTime, .1), r.ctx.listener.positionY.setTargetAtTime(r._pos[1], Howler.ctx.currentTime, .1), r.ctx.listener.positionZ.setTargetAtTime(r._pos[2], Howler.ctx.currentTime, .1)) : r.ctx.listener.setPosition(r._pos[0], r._pos[1], r._pos[2]); else return r._pos; return r }, HowlerGlobal.prototype.orientation = function (t, e, n, r, s, o) { var a = this; if (!a.ctx || !a.ctx.listener) return a; var l = a._orientation; if (e = typeof e != "number" ? l[1] : e, n = typeof n != "number" ? l[2] : n, r = typeof r != "number" ? l[3] : r, s = typeof s != "number" ? l[4] : s, o = typeof o != "number" ? l[5] : o, typeof t == "number") a._orientation = [t, e, n, r, s, o], typeof a.ctx.listener.forwardX < "u" ? (a.ctx.listener.forwardX.setTargetAtTime(t, Howler.ctx.currentTime, .1), a.ctx.listener.forwardY.setTargetAtTime(e, Howler.ctx.currentTime, .1), a.ctx.listener.forwardZ.setTargetAtTime(n, Howler.ctx.currentTime, .1), a.ctx.listener.upX.setTargetAtTime(r, Howler.ctx.currentTime, .1), a.ctx.listener.upY.setTargetAtTime(s, Howler.ctx.currentTime, .1), a.ctx.listener.upZ.setTargetAtTime(o, Howler.ctx.currentTime, .1)) : a.ctx.listener.setOrientation(t, e, n, r, s, o); else return l; return a }, Howl.prototype.init = function (t) { return function (e) { var n = this; return n._orientation = e.orientation || [1, 0, 0], n._stereo = e.stereo || null, n._pos = e.pos || null, n._pannerAttr = { coneInnerAngle: typeof e.coneInnerAngle < "u" ? e.coneInnerAngle : 360, coneOuterAngle: typeof e.coneOuterAngle < "u" ? e.coneOuterAngle : 360, coneOuterGain: typeof e.coneOuterGain < "u" ? e.coneOuterGain : 0, distanceModel: typeof e.distanceModel < "u" ? e.distanceModel : "inverse", maxDistance: typeof e.maxDistance < "u" ? e.maxDistance : 1e4, panningModel: typeof e.panningModel < "u" ? e.panningModel : "HRTF", refDistance: typeof e.refDistance < "u" ? e.refDistance : 1, rolloffFactor: typeof e.rolloffFactor < "u" ? e.rolloffFactor : 1 }, n._onstereo = e.onstereo ? [{ fn: e.onstereo }] : [], n._onpos = e.onpos ? [{ fn: e.onpos }] : [], n._onorientation = e.onorientation ? [{ fn: e.onorientation }] : [], t.call(this, e) } }(Howl.prototype.init), Howl.prototype.stereo = function (t, e) { var n = this; if (!n._webAudio) return n; if (n._state !== "loaded") return n._queue.push({ event: "stereo", action: function () { n.stereo(t, e) } }), n; var r = typeof Howler.ctx.createStereoPanner > "u" ? "spatial" : "stereo"; if (typeof e > "u") if (typeof t == "number") n._stereo = t, n._pos = [t, 0, 0]; else return n._stereo; for (var s = n._getSoundIds(e), o = 0; o < s.length; o++) { var a = n._soundById(s[o]); if (a) if (typeof t == "number") a._stereo = t, a._pos = [t, 0, 0], a._node && (a._pannerAttr.panningModel = "equalpower", (!a._panner || !a._panner.pan) && i(a, r), r === "spatial" ? typeof a._panner.positionX < "u" ? (a._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), a._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime), a._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime)) : a._panner.setPosition(t, 0, 0) : a._panner.pan.setValueAtTime(t, Howler.ctx.currentTime)), n._emit("stereo", a._id); else return a._stereo } return n }, Howl.prototype.pos = function (t, e, n, r) { var s = this; if (!s._webAudio) return s; if (s._state !== "loaded") return s._queue.push({ event: "pos", action: function () { s.pos(t, e, n, r) } }), s; if (e = typeof e != "number" ? 0 : e, n = typeof n != "number" ? -.5 : n, typeof r > "u") if (typeof t == "number") s._pos = [t, e, n]; else return s._pos; for (var o = s._getSoundIds(r), a = 0; a < o.length; a++) { var l = s._soundById(o[a]); if (l) if (typeof t == "number") l._pos = [t, e, n], l._node && ((!l._panner || l._panner.pan) && i(l, "spatial"), typeof l._panner.positionX < "u" ? (l._panner.positionX.setValueAtTime(t, Howler.ctx.currentTime), l._panner.positionY.setValueAtTime(e, Howler.ctx.currentTime), l._panner.positionZ.setValueAtTime(n, Howler.ctx.currentTime)) : l._panner.setPosition(t, e, n)), s._emit("pos", l._id); else return l._pos } return s }, Howl.prototype.orientation = function (t, e, n, r) { var s = this; if (!s._webAudio) return s; if (s._state !== "loaded") return s._queue.push({ event: "orientation", action: function () { s.orientation(t, e, n, r) } }), s; if (e = typeof e != "number" ? s._orientation[1] : e, n = typeof n != "number" ? s._orientation[2] : n, typeof r > "u") if (typeof t == "number") s._orientation = [t, e, n]; else return s._orientation; for (var o = s._getSoundIds(r), a = 0; a < o.length; a++) { var l = s._soundById(o[a]); if (l) if (typeof t == "number") l._orientation = [t, e, n], l._node && (l._panner || (l._pos || (l._pos = s._pos || [0, 0, -.5]), i(l, "spatial")), typeof l._panner.orientationX < "u" ? (l._panner.orientationX.setValueAtTime(t, Howler.ctx.currentTime), l._panner.orientationY.setValueAtTime(e, Howler.ctx.currentTime), l._panner.orientationZ.setValueAtTime(n, Howler.ctx.currentTime)) : l._panner.setOrientation(t, e, n)), s._emit("orientation", l._id); else return l._orientation } return s }, Howl.prototype.pannerAttr = function () { var t = this, e = arguments, n, r, s; if (!t._webAudio) return t; if (e.length === 0) return t._pannerAttr; if (e.length === 1) if (typeof e[0] == "object") n = e[0], typeof r > "u" && (n.pannerAttr || (n.pannerAttr = { coneInnerAngle: n.coneInnerAngle, coneOuterAngle: n.coneOuterAngle, coneOuterGain: n.coneOuterGain, distanceModel: n.distanceModel, maxDistance: n.maxDistance, refDistance: n.refDistance, rolloffFactor: n.rolloffFactor, panningModel: n.panningModel }), t._pannerAttr = { coneInnerAngle: typeof n.pannerAttr.coneInnerAngle < "u" ? n.pannerAttr.coneInnerAngle : t._coneInnerAngle, coneOuterAngle: typeof n.pannerAttr.coneOuterAngle < "u" ? n.pannerAttr.coneOuterAngle : t._coneOuterAngle, coneOuterGain: typeof n.pannerAttr.coneOuterGain < "u" ? n.pannerAttr.coneOuterGain : t._coneOuterGain, distanceModel: typeof n.pannerAttr.distanceModel < "u" ? n.pannerAttr.distanceModel : t._distanceModel, maxDistance: typeof n.pannerAttr.maxDistance < "u" ? n.pannerAttr.maxDistance : t._maxDistance, refDistance: typeof n.pannerAttr.refDistance < "u" ? n.pannerAttr.refDistance : t._refDistance, rolloffFactor: typeof n.pannerAttr.rolloffFactor < "u" ? n.pannerAttr.rolloffFactor : t._rolloffFactor, panningModel: typeof n.pannerAttr.panningModel < "u" ? n.pannerAttr.panningModel : t._panningModel }); else return s = t._soundById(parseInt(e[0], 10)), s ? s._pannerAttr : t._pannerAttr; else e.length === 2 && (n = e[0], r = parseInt(e[1], 10)); for (var o = t._getSoundIds(r), a = 0; a < o.length; a++)if (s = t._soundById(o[a]), s) { var l = s._pannerAttr; l = { coneInnerAngle: typeof n.coneInnerAngle < "u" ? n.coneInnerAngle : l.coneInnerAngle, coneOuterAngle: typeof n.coneOuterAngle < "u" ? n.coneOuterAngle : l.coneOuterAngle, coneOuterGain: typeof n.coneOuterGain < "u" ? n.coneOuterGain : l.coneOuterGain, distanceModel: typeof n.distanceModel < "u" ? n.distanceModel : l.distanceModel, maxDistance: typeof n.maxDistance < "u" ? n.maxDistance : l.maxDistance, refDistance: typeof n.refDistance < "u" ? n.refDistance : l.refDistance, rolloffFactor: typeof n.rolloffFactor < "u" ? n.rolloffFactor : l.rolloffFactor, panningModel: typeof n.panningModel < "u" ? n.panningModel : l.panningModel }; var u = s._panner; u ? (u.coneInnerAngle = l.coneInnerAngle, u.coneOuterAngle = l.coneOuterAngle, u.coneOuterGain = l.coneOuterGain, u.distanceModel = l.distanceModel, u.maxDistance = l.maxDistance, u.refDistance = l.refDistance, u.rolloffFactor = l.rolloffFactor, u.panningModel = l.panningModel) : (s._pos || (s._pos = t._pos || [0, 0, -.5]), i(s, "spatial")) } return t }, Sound.prototype.init = function (t) { return function () { var e = this, n = e._parent; e._orientation = n._orientation, e._stereo = n._stereo, e._pos = n._pos, e._pannerAttr = n._pannerAttr, t.call(this), e._stereo ? n.stereo(e._stereo) : e._pos && n.pos(e._pos[0], e._pos[1], e._pos[2], e._id) } }(Sound.prototype.init), Sound.prototype.reset = function (t) { return function () { var e = this, n = e._parent; return e._orientation = n._orientation, e._stereo = n._stereo, e._pos = n._pos, e._pannerAttr = n._pannerAttr, e._stereo ? n.stereo(e._stereo) : e._pos ? n.pos(e._pos[0], e._pos[1], e._pos[2], e._id) : e._panner && (e._panner.disconnect(0), e._panner = void 0, n._refreshBuffer(e)), t.call(this) } }(Sound.prototype.reset); var i = function (t, e) { e = e || "spatial", e === "spatial" ? (t._panner = Howler.ctx.createPanner(), t._panner.coneInnerAngle = t._pannerAttr.coneInnerAngle, t._panner.coneOuterAngle = t._pannerAttr.coneOuterAngle, t._panner.coneOuterGain = t._pannerAttr.coneOuterGain, t._panner.distanceModel = t._pannerAttr.distanceModel, t._panner.maxDistance = t._pannerAttr.maxDistance, t._panner.refDistance = t._pannerAttr.refDistance, t._panner.rolloffFactor = t._pannerAttr.rolloffFactor, t._panner.panningModel = t._pannerAttr.panningModel, typeof t._panner.positionX < "u" ? (t._panner.positionX.setValueAtTime(t._pos[0], Howler.ctx.currentTime), t._panner.positionY.setValueAtTime(t._pos[1], Howler.ctx.currentTime), t._panner.positionZ.setValueAtTime(t._pos[2], Howler.ctx.currentTime)) : t._panner.setPosition(t._pos[0], t._pos[1], t._pos[2]), typeof t._panner.orientationX < "u" ? (t._panner.orientationX.setValueAtTime(t._orientation[0], Howler.ctx.currentTime), t._panner.orientationY.setValueAtTime(t._orientation[1], Howler.ctx.currentTime), t._panner.orientationZ.setValueAtTime(t._orientation[2], Howler.ctx.currentTime)) : t._panner.setOrientation(t._orientation[0], t._orientation[1], t._orientation[2])) : (t._panner = Howler.ctx.createStereoPanner(), t._panner.pan.setValueAtTime(t._stereo, Howler.ctx.currentTime)), t._panner.connect(t._node), t._paused || t._parent.pause(t._id, !0).play(t._id, !0) } })() }); var VO = ic((b3e, GO) => { GO.exports = function (t, e) { for (var n = t.split("."), r = e.split("."), s = 0; s < 3; s++) { var o = Number(n[s]), a = Number(r[s]); if (o > a) return 1; if (a > o) return -1; if (!isNaN(o) && isNaN(a)) return 1; if (isNaN(o) && !isNaN(a)) return -1 } return 0 } }); var vo = "149"; var ui = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }, nR = 0, X1 = 1, rR = 2; var Fm = 1, iR = 2, Ld = 3, ai = 0, Ln = 1, Nr = 2; var Ot = 0, Ec = 1, Q1 = 2, K1 = 3, Z1 = 4, sR = 5, bc = 100, oR = 101, aR = 102, J1 = 103, $1 = 104, lR = 200, cR = 201, uR = 202, hR = 203, E_ = 204, M_ = 205, dR = 206, fR = 207, pR = 208, mR = 209, gR = 210, yR = 0, vR = 1, xR = 2, ax = 3, bR = 4, wR = 5, SR = 6, AR = 7, T_ = 0, _R = 1, ER = 2, fo = 0, MR = 1, TR = 2, CR = 3, PR = 4, IR = 5, C_ = 300, ta = 301, na = 302, lx = 303, cx = 304, Yc = 306, ji = 1e3, Yt = 1001, ux = 1002, Dt = 1003, eA = 1004; var _0 = 1005; var Ke = 1006, DR = 1007; var ll = 1008; var Zt = 1009, OR = 1010, RR = 1011, P_ = 1012, LR = 1013, uo = 1014, gr = 1015, cl = 1016, NR = 1017, BR = 1018, ea = 1020, FR = 1021, oi = 1023, kR = 1024, UR = 1025, ol = 1026, ra = 1027, zR = 1028, GR = 1029, Hx = 1030, VR = 1031, HR = 1033, E0 = 33776, M0 = 33777, T0 = 33778, C0 = 33779, tA = 35840, nA = 35841, rA = 35842, iA = 35843, jR = 36196, sA = 37492, oA = 37496, aA = 37808, lA = 37809, cA = 37810, uA = 37811, hA = 37812, dA = 37813, fA = 37814, pA = 37815, mA = 37816, gA = 37817, yA = 37818, vA = 37819, xA = 37820, bA = 37821, P0 = 36492, WR = 36283, wA = 36284, SA = 36285, AA = 36286, jx = 2200, Wx = 2201, tf = 2202, cm = 2300, um = 2301, I0 = 2302, wc = 2400, Sc = 2401, hm = 2402, qx = 2500, qR = 2501; var li = 3e3, Je = 3001, tr = 3200, Yx = 3201, YR = 0, XR = 1; var gs = "srgb", Gd = "srgb-linear"; var D0 = 7680; var QR = 519, hx = 35044; var _A = "300 es", dx = 1035, kt = class { addEventListener (t, e) { this._listeners === void 0 && (this._listeners = {}); let n = this._listeners; n[t] === void 0 && (n[t] = []), n[t].indexOf(e) === -1 && n[t].push(e) } hasEventListener (t, e) { if (this._listeners === void 0) return !1; let n = this._listeners; return n[t] !== void 0 && n[t].indexOf(e) !== -1 } removeEventListener (t, e) { if (this._listeners === void 0) return; let r = this._listeners[t]; if (r !== void 0) { let s = r.indexOf(e); s !== -1 && r.splice(s, 1) } } dispatchEvent (t) { if (this._listeners === void 0) return; let n = this._listeners[t.type]; if (n !== void 0) { t.target = this; let r = n.slice(0); for (let s = 0, o = r.length; s < o; s++)r[s].call(this, t); t.target = null } } }, Mr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"], EA = 1234567, Bd = Math.PI / 180, Vd = 180 / Math.PI; function bi () { let i = Math.random() * 4294967295 | 0, t = Math.random() * 4294967295 | 0, e = Math.random() * 4294967295 | 0, n = Math.random() * 4294967295 | 0; return (Mr[i & 255] + Mr[i >> 8 & 255] + Mr[i >> 16 & 255] + Mr[i >> 24 & 255] + "-" + Mr[t & 255] + Mr[t >> 8 & 255] + "-" + Mr[t >> 16 & 15 | 64] + Mr[t >> 24 & 255] + "-" + Mr[e & 63 | 128] + Mr[e >> 8 & 255] + "-" + Mr[e >> 16 & 255] + Mr[e >> 24 & 255] + Mr[n & 255] + Mr[n >> 8 & 255] + Mr[n >> 16 & 255] + Mr[n >> 24 & 255]).toLowerCase() } function zn (i, t, e) { return Math.max(t, Math.min(e, i)) } function Xx (i, t) { return (i % t + t) % t } function KR (i, t, e, n, r) { return n + (i - t) * (r - n) / (e - t) } function ZR (i, t, e) { return i !== t ? (e - i) / (t - i) : 0 } function Fd (i, t, e) { return (1 - e) * i + e * t } function JR (i, t, e, n) { return Fd(i, t, 1 - Math.exp(-e * n)) } function $R (i, t = 1) { return t - Math.abs(Xx(i, t * 2) - t) } function eL (i, t, e) { return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t), i * i * (3 - 2 * i)) } function tL (i, t, e) { return i <= t ? 0 : i >= e ? 1 : (i = (i - t) / (e - t), i * i * i * (i * (i * 6 - 15) + 10)) } function nL (i, t) { return i + Math.floor(Math.random() * (t - i + 1)) } function rL (i, t) { return i + Math.random() * (t - i) } function iL (i) { return i * (.5 - Math.random()) } function sL (i) { i !== void 0 && (EA = i); let t = EA += 1831565813; return t = Math.imul(t ^ t >>> 15, t | 1), t ^= t + Math.imul(t ^ t >>> 7, t | 61), ((t ^ t >>> 14) >>> 0) / 4294967296 } function oL (i) { return i * Bd } function aL (i) { return i * Vd } function fx (i) { return (i & i - 1) === 0 && i !== 0 } function I_ (i) { return Math.pow(2, Math.ceil(Math.log(i) / Math.LN2)) } function dm (i) { return Math.pow(2, Math.floor(Math.log(i) / Math.LN2)) } function lL (i, t, e, n, r) { let s = Math.cos, o = Math.sin, a = s(e / 2), l = o(e / 2), u = s((t + n) / 2), c = o((t + n) / 2), h = s((t - n) / 2), d = o((t - n) / 2), f = s((n - t) / 2), p = o((n - t) / 2); switch (r) { case "XYX": i.set(a * c, l * h, l * d, a * u); break; case "YZY": i.set(l * d, a * c, l * h, a * u); break; case "ZXZ": i.set(l * h, l * d, a * c, a * u); break; case "XZX": i.set(a * c, l * p, l * f, a * u); break; case "YXY": i.set(l * f, a * c, l * p, a * u); break; case "ZYZ": i.set(l * p, l * f, a * c, a * u); break; default: console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + r) } } function ho (i, t) { switch (t.constructor) { case Float32Array: return i; case Uint16Array: return i / 65535; case Uint8Array: return i / 255; case Int16Array: return Math.max(i / 32767, -1); case Int8Array: return Math.max(i / 127, -1); default: throw new Error("Invalid component type.") } } function zt (i, t) { switch (t.constructor) { case Float32Array: return i; case Uint16Array: return Math.round(i * 65535); case Uint8Array: return Math.round(i * 255); case Int16Array: return Math.round(i * 32767); case Int8Array: return Math.round(i * 127); default: throw new Error("Invalid component type.") } } var Ge = Object.freeze({ __proto__: null, DEG2RAD: Bd, RAD2DEG: Vd, ceilPowerOfTwo: I_, clamp: zn, damp: JR, degToRad: oL, denormalize: ho, euclideanModulo: Xx, floorPowerOfTwo: dm, generateUUID: bi, inverseLerp: ZR, isPowerOfTwo: fx, lerp: Fd, mapLinear: KR, normalize: zt, pingpong: $R, radToDeg: aL, randFloat: rL, randFloatSpread: iL, randInt: nL, seededRandom: sL, setQuaternionFromProperEuler: lL, smootherstep: tL, smoothstep: eL }), B = class { constructor(t = 0, e = 0) { B.prototype.isVector2 = !0, this.x = t, this.y = e } get width () { return this.x } set width (t) { this.x = t } get height () { return this.y } set height (t) { this.y = t } set (t, e) { return this.x = t, this.y = e, this } setScalar (t) { return this.x = t, this.y = t, this } setX (t) { return this.x = t, this } setY (t) { return this.y = t, this } setComponent (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent (t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw new Error("index is out of range: " + t) } } clone () { return new this.constructor(this.x, this.y) } copy (t) { return this.x = t.x, this.y = t.y, this } add (t) { return this.x += t.x, this.y += t.y, this } addScalar (t) { return this.x += t, this.y += t, this } addVectors (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this } addScaledVector (t, e) { return this.x += t.x * e, this.y += t.y * e, this } sub (t) { return this.x -= t.x, this.y -= t.y, this } subScalar (t) { return this.x -= t, this.y -= t, this } subVectors (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this } multiply (t) { return this.x *= t.x, this.y *= t.y, this } multiplyScalar (t) { return this.x *= t, this.y *= t, this } divide (t) { return this.x /= t.x, this.y /= t.y, this } divideScalar (t) { return this.multiplyScalar(1 / t) } applyMatrix3 (t) { let e = this.x, n = this.y, r = t.elements; return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this } min (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this } max (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this } clamp (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this } clampScalar (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this } clampLength (t, e) { let n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this } ceil () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this } round () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this } roundToZero () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this } negate () { return this.x = -this.x, this.y = -this.y, this } dot (t) { return this.x * t.x + this.y * t.y } cross (t) { return this.x * t.y - this.y * t.x } lengthSq () { return this.x * this.x + this.y * this.y } length () { return Math.sqrt(this.x * this.x + this.y * this.y) } manhattanLength () { return Math.abs(this.x) + Math.abs(this.y) } normalize () { return this.divideScalar(this.length() || 1) } angle () { return Math.atan2(-this.y, -this.x) + Math.PI } distanceTo (t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared (t) { let e = this.x - t.x, n = this.y - t.y; return e * e + n * n } manhattanDistanceTo (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) } setLength (t) { return this.normalize().multiplyScalar(t) } lerp (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this } lerpVectors (t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this } equals (t) { return t.x === this.x && t.y === this.y } fromArray (t, e = 0) { return this.x = t[e], this.y = t[e + 1], this } toArray (t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t } fromBufferAttribute (t, e) { return this.x = t.getX(e), this.y = t.getY(e), this } rotateAround (t, e) { let n = Math.cos(e), r = Math.sin(e), s = this.x - t.x, o = this.y - t.y; return this.x = s * n - o * r + t.x, this.y = s * r + o * n + t.y, this } random () { return this.x = Math.random(), this.y = Math.random(), this } *[Symbol.iterator] () { yield this.x, yield this.y } }, Xt = class { constructor() { Xt.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1] } set (t, e, n, r, s, o, a, l, u) { let c = this.elements; return c[0] = t, c[1] = r, c[2] = a, c[3] = e, c[4] = s, c[5] = l, c[6] = n, c[7] = o, c[8] = u, this } identity () { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this } copy (t) { let e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this } extractBasis (t, e, n) { return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this } setFromMatrix4 (t) { let e = t.elements; return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this } multiply (t) { return this.multiplyMatrices(this, t) } premultiply (t) { return this.multiplyMatrices(t, this) } multiplyMatrices (t, e) { let n = t.elements, r = e.elements, s = this.elements, o = n[0], a = n[3], l = n[6], u = n[1], c = n[4], h = n[7], d = n[2], f = n[5], p = n[8], m = r[0], g = r[3], y = r[6], v = r[1], x = r[4], b = r[7], S = r[2], _ = r[5], E = r[8]; return s[0] = o * m + a * v + l * S, s[3] = o * g + a * x + l * _, s[6] = o * y + a * b + l * E, s[1] = u * m + c * v + h * S, s[4] = u * g + c * x + h * _, s[7] = u * y + c * b + h * E, s[2] = d * m + f * v + p * S, s[5] = d * g + f * x + p * _, s[8] = d * y + f * b + p * E, this } multiplyScalar (t) { let e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this } determinant () { let t = this.elements, e = t[0], n = t[1], r = t[2], s = t[3], o = t[4], a = t[5], l = t[6], u = t[7], c = t[8]; return e * o * c - e * a * u - n * s * c + n * a * l + r * s * u - r * o * l } invert () { let t = this.elements, e = t[0], n = t[1], r = t[2], s = t[3], o = t[4], a = t[5], l = t[6], u = t[7], c = t[8], h = c * o - a * u, d = a * l - c * s, f = u * s - o * l, p = e * h + n * d + r * f; if (p === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0); let m = 1 / p; return t[0] = h * m, t[1] = (r * u - c * n) * m, t[2] = (a * n - r * o) * m, t[3] = d * m, t[4] = (c * e - r * l) * m, t[5] = (r * s - a * e) * m, t[6] = f * m, t[7] = (n * l - u * e) * m, t[8] = (o * e - n * s) * m, this } transpose () { let t, e = this.elements; return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this } getNormalMatrix (t) { return this.setFromMatrix4(t).invert().transpose() } transposeIntoArray (t) { let e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this } setUvTransform (t, e, n, r, s, o, a) { let l = Math.cos(s), u = Math.sin(s); return this.set(n * l, n * u, -n * (l * o + u * a) + o + t, -r * u, r * l, -r * (-u * o + l * a) + a + e, 0, 0, 1), this } scale (t, e) { return this.premultiply(O0.makeScale(t, e)), this } rotate (t) { return this.premultiply(O0.makeRotation(-t)), this } translate (t, e) { return this.premultiply(O0.makeTranslation(t, e)), this } makeTranslation (t, e) { return this.set(1, 0, t, 0, 1, e, 0, 0, 1), this } makeRotation (t) { let e = Math.cos(t), n = Math.sin(t); return this.set(e, -n, 0, n, e, 0, 0, 0, 1), this } makeScale (t, e) { return this.set(t, 0, 0, 0, e, 0, 0, 0, 1), this } equals (t) { let e = this.elements, n = t.elements; for (let r = 0; r < 9; r++)if (e[r] !== n[r]) return !1; return !0 } fromArray (t, e = 0) { for (let n = 0; n < 9; n++)this.elements[n] = t[n + e]; return this } toArray (t = [], e = 0) { let n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t } clone () { return new this.constructor().fromArray(this.elements) } }, O0 = new Xt; function D_ (i) { for (let t = i.length - 1; t >= 0; --t)if (i[t] >= 65535) return !0; return !1 } var cL = { Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array }; function Np (i, t) { return new cL[i](t) } function fm (i) { return document.createElementNS("http://www.w3.org/1999/xhtml", i) } function al (i) { return i < .04045 ? i * .0773993808 : Math.pow(i * .9478672986 + .0521327014, 2.4) } function lm (i) { return i < .0031308 ? i * 12.92 : 1.055 * Math.pow(i, .41666) - .055 } var R0 = { [gs]: { [Gd]: al }, [Gd]: { [gs]: lm } }, Or = { legacyMode: !0, get workingColorSpace () { return Gd }, set workingColorSpace (i) { console.warn("THREE.ColorManagement: .workingColorSpace is readonly.") }, convert: function (i, t, e) { if (this.legacyMode || t === e || !t || !e) return i; if (R0[t] && R0[t][e] !== void 0) { let n = R0[t][e]; return i.r = n(i.r), i.g = n(i.g), i.b = n(i.b), i } throw new Error("Unsupported color space conversion.") }, fromWorkingColorSpace: function (i, t) { return this.convert(i, this.workingColorSpace, t) }, toWorkingColorSpace: function (i, t) { return this.convert(i, t, this.workingColorSpace) } }, O_ = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }, Un = { r: 0, g: 0, b: 0 }, Gi = { h: 0, s: 0, l: 0 }, Bp = { h: 0, s: 0, l: 0 }; function L0 (i, t, e) { return e < 0 && (e += 1), e > 1 && (e -= 1), e < 1 / 6 ? i + (t - i) * 6 * e : e < 1 / 2 ? t : e < 2 / 3 ? i + (t - i) * 6 * (2 / 3 - e) : i } function Fp (i, t) { return t.r = i.r, t.g = i.g, t.b = i.b, t } var Le = class { constructor(t, e, n) { return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, e === void 0 && n === void 0 ? this.set(t) : this.setRGB(t, e, n) } set (t) { return t && t.isColor ? this.copy(t) : typeof t == "number" ? this.setHex(t) : typeof t == "string" && this.setStyle(t), this } setScalar (t) { return this.r = t, this.g = t, this.b = t, this } setHex (t, e = gs) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (t & 255) / 255, Or.toWorkingColorSpace(this, e), this } setRGB (t, e, n, r = Or.workingColorSpace) { return this.r = t, this.g = e, this.b = n, Or.toWorkingColorSpace(this, r), this } setHSL (t, e, n, r = Or.workingColorSpace) { if (t = Xx(t, 1), e = zn(e, 0, 1), n = zn(n, 0, 1), e === 0) this.r = this.g = this.b = n; else { let s = n <= .5 ? n * (1 + e) : n + e - n * e, o = 2 * n - s; this.r = L0(o, s, t + 1 / 3), this.g = L0(o, s, t), this.b = L0(o, s, t - 1 / 3) } return Or.toWorkingColorSpace(this, r), this } setStyle (t, e = gs) { function n (s) { s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } let r; if (r = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(t)) { let s, o = r[1], a = r[2]; switch (o) { case "rgb": case "rgba": if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(255, parseInt(s[1], 10)) / 255, this.g = Math.min(255, parseInt(s[2], 10)) / 255, this.b = Math.min(255, parseInt(s[3], 10)) / 255, Or.toWorkingColorSpace(this, e), n(s[4]), this; if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.r = Math.min(100, parseInt(s[1], 10)) / 100, this.g = Math.min(100, parseInt(s[2], 10)) / 100, this.b = Math.min(100, parseInt(s[3], 10)) / 100, Or.toWorkingColorSpace(this, e), n(s[4]), this; break; case "hsl": case "hsla": if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) { let l = parseFloat(s[1]) / 360, u = parseFloat(s[2]) / 100, c = parseFloat(s[3]) / 100; return n(s[4]), this.setHSL(l, u, c, e) } break } } else if (r = /^\#([A-Fa-f\d]+)$/.exec(t)) { let s = r[1], o = s.length; if (o === 3) return this.r = parseInt(s.charAt(0) + s.charAt(0), 16) / 255, this.g = parseInt(s.charAt(1) + s.charAt(1), 16) / 255, this.b = parseInt(s.charAt(2) + s.charAt(2), 16) / 255, Or.toWorkingColorSpace(this, e), this; if (o === 6) return this.r = parseInt(s.charAt(0) + s.charAt(1), 16) / 255, this.g = parseInt(s.charAt(2) + s.charAt(3), 16) / 255, this.b = parseInt(s.charAt(4) + s.charAt(5), 16) / 255, Or.toWorkingColorSpace(this, e), this } return t && t.length > 0 ? this.setColorName(t, e) : this } setColorName (t, e = gs) { let n = O_[t.toLowerCase()]; return n !== void 0 ? this.setHex(n, e) : console.warn("THREE.Color: Unknown color " + t), this } clone () { return new this.constructor(this.r, this.g, this.b) } copy (t) { return this.r = t.r, this.g = t.g, this.b = t.b, this } copySRGBToLinear (t) { return this.r = al(t.r), this.g = al(t.g), this.b = al(t.b), this } copyLinearToSRGB (t) { return this.r = lm(t.r), this.g = lm(t.g), this.b = lm(t.b), this } convertSRGBToLinear () { return this.copySRGBToLinear(this), this } convertLinearToSRGB () { return this.copyLinearToSRGB(this), this } getHex (t = gs) { return Or.fromWorkingColorSpace(Fp(this, Un), t), zn(Un.r * 255, 0, 255) << 16 ^ zn(Un.g * 255, 0, 255) << 8 ^ zn(Un.b * 255, 0, 255) << 0 } getHexString (t = gs) { return ("000000" + this.getHex(t).toString(16)).slice(-6) } getHSL (t, e = Or.workingColorSpace) { Or.fromWorkingColorSpace(Fp(this, Un), e); let n = Un.r, r = Un.g, s = Un.b, o = Math.max(n, r, s), a = Math.min(n, r, s), l, u, c = (a + o) / 2; if (a === o) l = 0, u = 0; else { let h = o - a; switch (u = c <= .5 ? h / (o + a) : h / (2 - o - a), o) { case n: l = (r - s) / h + (r < s ? 6 : 0); break; case r: l = (s - n) / h + 2; break; case s: l = (n - r) / h + 4; break }l /= 6 } return t.h = l, t.s = u, t.l = c, t } getRGB (t, e = Or.workingColorSpace) { return Or.fromWorkingColorSpace(Fp(this, Un), e), t.r = Un.r, t.g = Un.g, t.b = Un.b, t } getStyle (t = gs) { return Or.fromWorkingColorSpace(Fp(this, Un), t), t !== gs ? `color(${t} ${Un.r} ${Un.g} ${Un.b})` : `rgb(${Un.r * 255 | 0},${Un.g * 255 | 0},${Un.b * 255 | 0})` } offsetHSL (t, e, n) { return this.getHSL(Gi), Gi.h += t, Gi.s += e, Gi.l += n, this.setHSL(Gi.h, Gi.s, Gi.l), this } add (t) { return this.r += t.r, this.g += t.g, this.b += t.b, this } addColors (t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this } addScalar (t) { return this.r += t, this.g += t, this.b += t, this } sub (t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this } multiply (t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this } multiplyScalar (t) { return this.r *= t, this.g *= t, this.b *= t, this } lerp (t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this } lerpColors (t, e, n) { return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this } lerpHSL (t, e) { this.getHSL(Gi), t.getHSL(Bp); let n = Fd(Gi.h, Bp.h, e), r = Fd(Gi.s, Bp.s, e), s = Fd(Gi.l, Bp.l, e); return this.setHSL(n, r, s), this } equals (t) { return t.r === this.r && t.g === this.g && t.b === this.b } fromArray (t, e = 0) { return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this } toArray (t = [], e = 0) { return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t } fromBufferAttribute (t, e) { return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), this } toJSON () { return this.getHex() } *[Symbol.iterator] () { yield this.r, yield this.g, yield this.b } }; Le.NAMES = O_; var oc, pm = class { static getDataURL (t) { if (/^data:/i.test(t.src) || typeof HTMLCanvasElement > "u") return t.src; let e; if (t instanceof HTMLCanvasElement) e = t; else { oc === void 0 && (oc = fm("canvas")), oc.width = t.width, oc.height = t.height; let n = oc.getContext("2d"); t instanceof ImageData ? n.putImageData(t, 0, 0) : n.drawImage(t, 0, 0, t.width, t.height), e = oc } return e.width > 2048 || e.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", t), e.toDataURL("image/jpeg", .6)) : e.toDataURL("image/png") } static sRGBToLinear (t) { if (typeof HTMLImageElement < "u" && t instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && t instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && t instanceof ImageBitmap) { let e = fm("canvas"); e.width = t.width, e.height = t.height; let n = e.getContext("2d"); n.drawImage(t, 0, 0, t.width, t.height); let r = n.getImageData(0, 0, t.width, t.height), s = r.data; for (let o = 0; o < s.length; o++)s[o] = al(s[o] / 255) * 255; return n.putImageData(r, 0, 0), e } else if (t.data) { let e = t.data.slice(0); for (let n = 0; n < e.length; n++)e instanceof Uint8Array || e instanceof Uint8ClampedArray ? e[n] = Math.floor(al(e[n] / 255) * 255) : e[n] = al(e[n]); return { data: e, width: t.width, height: t.height } } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), t } }, mm = class { constructor(t = null) { this.isSource = !0, this.uuid = bi(), this.data = t, this.version = 0 } set needsUpdate (t) { t === !0 && this.version++ } toJSON (t) { let e = t === void 0 || typeof t == "string"; if (!e && t.images[this.uuid] !== void 0) return t.images[this.uuid]; let n = { uuid: this.uuid, url: "" }, r = this.data; if (r !== null) { let s; if (Array.isArray(r)) { s = []; for (let o = 0, a = r.length; o < a; o++)r[o].isDataTexture ? s.push(N0(r[o].image)) : s.push(N0(r[o])) } else s = N0(r); n.url = s } return e || (t.images[this.uuid] = n), n } }; function N0 (i) { return typeof HTMLImageElement < "u" && i instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && i instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && i instanceof ImageBitmap ? pm.getDataURL(i) : i.data ? { data: Array.from(i.data), width: i.width, height: i.height, type: i.data.constructor.name } : (console.warn("THREE.Texture: Unable to serialize Texture."), {}) } var uL = 0, Qt = class extends kt { constructor(t = Qt.DEFAULT_IMAGE, e = Qt.DEFAULT_MAPPING, n = Yt, r = Yt, s = Ke, o = ll, a = oi, l = Zt, u = Qt.DEFAULT_ANISOTROPY, c = li) { super(), this.isTexture = !0, Object.defineProperty(this, "id", { value: uL++ }), this.uuid = bi(), this.name = "", this.source = new mm(t), this.mipmaps = [], this.mapping = e, this.wrapS = n, this.wrapT = r, this.magFilter = s, this.minFilter = o, this.anisotropy = u, this.format = a, this.internalFormat = null, this.type = l, this.offset = new B(0, 0), this.repeat = new B(1, 1), this.center = new B(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Xt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = c, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1 } get image () { return this.source.data } set image (t) { this.source.data = t } updateMatrix () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) } clone () { return new this.constructor().copy(this) } copy (t) { return this.name = t.name, this.source = t.source, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.internalFormat = t.internalFormat, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this.userData = JSON.parse(JSON.stringify(t.userData)), this.needsUpdate = !0, this } toJSON (t) { let e = t === void 0 || typeof t == "string"; if (!e && t.textures[this.uuid] !== void 0) return t.textures[this.uuid]; let n = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, image: this.source.toJSON(t).uuid, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, generateMipmaps: this.generateMipmaps, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; return Object.keys(this.userData).length > 0 && (n.userData = this.userData), e || (t.textures[this.uuid] = n), n } dispose () { this.dispatchEvent({ type: "dispose" }) } transformUv (t) { if (this.mapping !== C_) return t; if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) { case ji: t.x = t.x - Math.floor(t.x); break; case Yt: t.x = t.x < 0 ? 0 : 1; break; case ux: Math.abs(Math.floor(t.x) % 2) === 1 ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x); break }if (t.y < 0 || t.y > 1) switch (this.wrapT) { case ji: t.y = t.y - Math.floor(t.y); break; case Yt: t.y = t.y < 0 ? 0 : 1; break; case ux: Math.abs(Math.floor(t.y) % 2) === 1 ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y); break }return this.flipY && (t.y = 1 - t.y), t } set needsUpdate (t) { t === !0 && (this.version++, this.source.needsUpdate = !0) } }; Qt.DEFAULT_IMAGE = null; Qt.DEFAULT_MAPPING = C_; Qt.DEFAULT_ANISOTROPY = 1; var qe = class { constructor(t = 0, e = 0, n = 0, r = 1) { qe.prototype.isVector4 = !0, this.x = t, this.y = e, this.z = n, this.w = r } get width () { return this.z } set width (t) { this.z = t } get height () { return this.w } set height (t) { this.w = t } set (t, e, n, r) { return this.x = t, this.y = e, this.z = n, this.w = r, this } setScalar (t) { return this.x = t, this.y = t, this.z = t, this.w = t, this } setX (t) { return this.x = t, this } setY (t) { return this.y = t, this } setZ (t) { return this.z = t, this } setW (t) { return this.w = t, this } setComponent (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw new Error("index is out of range: " + t) } } clone () { return new this.constructor(this.x, this.y, this.z, this.w) } copy (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w !== void 0 ? t.w : 1, this } add (t) { return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this } addScalar (t) { return this.x += t, this.y += t, this.z += t, this.w += t, this } addVectors (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this } addScaledVector (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this } sub (t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this } subScalar (t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this } subVectors (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this } multiply (t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this } multiplyScalar (t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this } applyMatrix4 (t) { let e = this.x, n = this.y, r = this.z, s = this.w, o = t.elements; return this.x = o[0] * e + o[4] * n + o[8] * r + o[12] * s, this.y = o[1] * e + o[5] * n + o[9] * r + o[13] * s, this.z = o[2] * e + o[6] * n + o[10] * r + o[14] * s, this.w = o[3] * e + o[7] * n + o[11] * r + o[15] * s, this } divideScalar (t) { return this.multiplyScalar(1 / t) } setAxisAngleFromQuaternion (t) { this.w = 2 * Math.acos(t.w); let e = Math.sqrt(1 - t.w * t.w); return e < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this } setAxisAngleFromRotationMatrix (t) { let e, n, r, s, l = t.elements, u = l[0], c = l[4], h = l[8], d = l[1], f = l[5], p = l[9], m = l[2], g = l[6], y = l[10]; if (Math.abs(c - d) < .01 && Math.abs(h - m) < .01 && Math.abs(p - g) < .01) { if (Math.abs(c + d) < .1 && Math.abs(h + m) < .1 && Math.abs(p + g) < .1 && Math.abs(u + f + y - 3) < .1) return this.set(1, 0, 0, 0), this; e = Math.PI; let x = (u + 1) / 2, b = (f + 1) / 2, S = (y + 1) / 2, _ = (c + d) / 4, E = (h + m) / 4, w = (p + g) / 4; return x > b && x > S ? x < .01 ? (n = 0, r = .707106781, s = .707106781) : (n = Math.sqrt(x), r = _ / n, s = E / n) : b > S ? b < .01 ? (n = .707106781, r = 0, s = .707106781) : (r = Math.sqrt(b), n = _ / r, s = w / r) : S < .01 ? (n = .707106781, r = .707106781, s = 0) : (s = Math.sqrt(S), n = E / s, r = w / s), this.set(n, r, s, e), this } let v = Math.sqrt((g - p) * (g - p) + (h - m) * (h - m) + (d - c) * (d - c)); return Math.abs(v) < .001 && (v = 1), this.x = (g - p) / v, this.y = (h - m) / v, this.z = (d - c) / v, this.w = Math.acos((u + f + y - 1) / 2), this } min (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this } max (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this } clamp (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this } clampScalar (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this } clampLength (t, e) { let n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this } ceil () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this } round () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this } roundToZero () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this } negate () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this } dot (t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w } lengthSq () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w } length () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) } manhattanLength () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) } normalize () { return this.divideScalar(this.length() || 1) } setLength (t) { return this.normalize().multiplyScalar(t) } lerp (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this } lerpVectors (t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this } equals (t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w } fromArray (t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this } toArray (t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t } fromBufferAttribute (t, e) { return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this } random () { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this } *[Symbol.iterator] () { yield this.x, yield this.y, yield this.z, yield this.w } }, at = class extends kt { constructor(t = 1, e = 1, n = {}) { super(), this.isWebGLRenderTarget = !0, this.width = t, this.height = e, this.depth = 1, this.scissor = new qe(0, 0, t, e), this.scissorTest = !1, this.viewport = new qe(0, 0, t, e); let r = { width: t, height: e, depth: 1 }; this.texture = new Qt(r, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.flipY = !1, this.texture.generateMipmaps = n.generateMipmaps !== void 0 ? n.generateMipmaps : !1, this.texture.internalFormat = n.internalFormat !== void 0 ? n.internalFormat : null, this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Ke, this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0, this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1, this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null, this.samples = n.samples !== void 0 ? n.samples : 0 } setSize (t, e, n = 1) { (this.width !== t || this.height !== e || this.depth !== n) && (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) } clone () { return new this.constructor().copy(this) } copy (t) { this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.texture.isRenderTargetTexture = !0; let e = Object.assign({}, t.texture.image); return this.texture.source = new mm(e), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.samples = t.samples, this } dispose () { this.dispatchEvent({ type: "dispose" }) } }, gm = class extends Qt { constructor(t = null, e = 1, n = 1, r = 1) { super(null), this.isDataArrayTexture = !0, this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = Dt, this.minFilter = Dt, this.wrapR = Yt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } }; var ym = class extends Qt { constructor(t = null, e = 1, n = 1, r = 1) { super(null), this.isData3DTexture = !0, this.image = { data: t, width: e, height: n, depth: r }, this.magFilter = Dt, this.minFilter = Dt, this.wrapR = Yt, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } }; var vm = class extends at { constructor(t = 1, e = 1, n = 1, r = {}) { super(t, e, r), this.isWebGLMultipleRenderTargets = !0; let s = this.texture; this.texture = []; for (let o = 0; o < n; o++)this.texture[o] = s.clone(), this.texture[o].isRenderTargetTexture = !0 } setSize (t, e, n = 1) { if (this.width !== t || this.height !== e || this.depth !== n) { this.width = t, this.height = e, this.depth = n; for (let r = 0, s = this.texture.length; r < s; r++)this.texture[r].image.width = t, this.texture[r].image.height = e, this.texture[r].image.depth = n; this.dispose() } return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this } copy (t) { this.dispose(), this.width = t.width, this.height = t.height, this.depth = t.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, t.depthTexture !== null && (this.depthTexture = t.depthTexture.clone()), this.texture.length = 0; for (let e = 0, n = t.texture.length; e < n; e++)this.texture[e] = t.texture[e].clone(), this.texture[e].isRenderTargetTexture = !0; return this } }, Ye = class { constructor(t = 0, e = 0, n = 0, r = 1) { this.isQuaternion = !0, this._x = t, this._y = e, this._z = n, this._w = r } static slerpFlat (t, e, n, r, s, o, a) { let l = n[r + 0], u = n[r + 1], c = n[r + 2], h = n[r + 3], d = s[o + 0], f = s[o + 1], p = s[o + 2], m = s[o + 3]; if (a === 0) { t[e + 0] = l, t[e + 1] = u, t[e + 2] = c, t[e + 3] = h; return } if (a === 1) { t[e + 0] = d, t[e + 1] = f, t[e + 2] = p, t[e + 3] = m; return } if (h !== m || l !== d || u !== f || c !== p) { let g = 1 - a, y = l * d + u * f + c * p + h * m, v = y >= 0 ? 1 : -1, x = 1 - y * y; if (x > Number.EPSILON) { let S = Math.sqrt(x), _ = Math.atan2(S, y * v); g = Math.sin(g * _) / S, a = Math.sin(a * _) / S } let b = a * v; if (l = l * g + d * b, u = u * g + f * b, c = c * g + p * b, h = h * g + m * b, g === 1 - a) { let S = 1 / Math.sqrt(l * l + u * u + c * c + h * h); l *= S, u *= S, c *= S, h *= S } } t[e] = l, t[e + 1] = u, t[e + 2] = c, t[e + 3] = h } static multiplyQuaternionsFlat (t, e, n, r, s, o) { let a = n[r], l = n[r + 1], u = n[r + 2], c = n[r + 3], h = s[o], d = s[o + 1], f = s[o + 2], p = s[o + 3]; return t[e] = a * p + c * h + l * f - u * d, t[e + 1] = l * p + c * d + u * h - a * f, t[e + 2] = u * p + c * f + a * d - l * h, t[e + 3] = c * p - a * h - l * d - u * f, t } get x () { return this._x } set x (t) { this._x = t, this._onChangeCallback() } get y () { return this._y } set y (t) { this._y = t, this._onChangeCallback() } get z () { return this._z } set z (t) { this._z = t, this._onChangeCallback() } get w () { return this._w } set w (t) { this._w = t, this._onChangeCallback() } set (t, e, n, r) { return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this } clone () { return new this.constructor(this._x, this._y, this._z, this._w) } copy (t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this } setFromEuler (t, e) { let n = t._x, r = t._y, s = t._z, o = t._order, a = Math.cos, l = Math.sin, u = a(n / 2), c = a(r / 2), h = a(s / 2), d = l(n / 2), f = l(r / 2), p = l(s / 2); switch (o) { case "XYZ": this._x = d * c * h + u * f * p, this._y = u * f * h - d * c * p, this._z = u * c * p + d * f * h, this._w = u * c * h - d * f * p; break; case "YXZ": this._x = d * c * h + u * f * p, this._y = u * f * h - d * c * p, this._z = u * c * p - d * f * h, this._w = u * c * h + d * f * p; break; case "ZXY": this._x = d * c * h - u * f * p, this._y = u * f * h + d * c * p, this._z = u * c * p + d * f * h, this._w = u * c * h - d * f * p; break; case "ZYX": this._x = d * c * h - u * f * p, this._y = u * f * h + d * c * p, this._z = u * c * p - d * f * h, this._w = u * c * h + d * f * p; break; case "YZX": this._x = d * c * h + u * f * p, this._y = u * f * h + d * c * p, this._z = u * c * p - d * f * h, this._w = u * c * h - d * f * p; break; case "XZY": this._x = d * c * h - u * f * p, this._y = u * f * h - d * c * p, this._z = u * c * p + d * f * h, this._w = u * c * h + d * f * p; break; default: console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o) }return e !== !1 && this._onChangeCallback(), this } setFromAxisAngle (t, e) { let n = e / 2, r = Math.sin(n); return this._x = t.x * r, this._y = t.y * r, this._z = t.z * r, this._w = Math.cos(n), this._onChangeCallback(), this } setFromRotationMatrix (t) { let e = t.elements, n = e[0], r = e[4], s = e[8], o = e[1], a = e[5], l = e[9], u = e[2], c = e[6], h = e[10], d = n + a + h; if (d > 0) { let f = .5 / Math.sqrt(d + 1); this._w = .25 / f, this._x = (c - l) * f, this._y = (s - u) * f, this._z = (o - r) * f } else if (n > a && n > h) { let f = 2 * Math.sqrt(1 + n - a - h); this._w = (c - l) / f, this._x = .25 * f, this._y = (r + o) / f, this._z = (s + u) / f } else if (a > h) { let f = 2 * Math.sqrt(1 + a - n - h); this._w = (s - u) / f, this._x = (r + o) / f, this._y = .25 * f, this._z = (l + c) / f } else { let f = 2 * Math.sqrt(1 + h - n - a); this._w = (o - r) / f, this._x = (s + u) / f, this._y = (l + c) / f, this._z = .25 * f } return this._onChangeCallback(), this } setFromUnitVectors (t, e) { let n = t.dot(e) + 1; return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize() } angleTo (t) { return 2 * Math.acos(Math.abs(zn(this.dot(t), -1, 1))) } rotateTowards (t, e) { let n = this.angleTo(t); if (n === 0) return this; let r = Math.min(1, e / n); return this.slerp(t, r), this } identity () { return this.set(0, 0, 0, 1) } invert () { return this.conjugate() } conjugate () { return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this } dot (t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w } lengthSq () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w } length () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) } normalize () { let t = this.length(); return t === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this } multiply (t) { return this.multiplyQuaternions(this, t) } premultiply (t) { return this.multiplyQuaternions(t, this) } multiplyQuaternions (t, e) { let n = t._x, r = t._y, s = t._z, o = t._w, a = e._x, l = e._y, u = e._z, c = e._w; return this._x = n * c + o * a + r * u - s * l, this._y = r * c + o * l + s * a - n * u, this._z = s * c + o * u + n * l - r * a, this._w = o * c - n * a - r * l - s * u, this._onChangeCallback(), this } slerp (t, e) { if (e === 0) return this; if (e === 1) return this.copy(t); let n = this._x, r = this._y, s = this._z, o = this._w, a = o * t._w + n * t._x + r * t._y + s * t._z; if (a < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), a >= 1) return this._w = o, this._x = n, this._y = r, this._z = s, this; let l = 1 - a * a; if (l <= Number.EPSILON) { let f = 1 - e; return this._w = f * o + e * this._w, this._x = f * n + e * this._x, this._y = f * r + e * this._y, this._z = f * s + e * this._z, this.normalize(), this._onChangeCallback(), this } let u = Math.sqrt(l), c = Math.atan2(u, a), h = Math.sin((1 - e) * c) / u, d = Math.sin(e * c) / u; return this._w = o * h + this._w * d, this._x = n * h + this._x * d, this._y = r * h + this._y * d, this._z = s * h + this._z * d, this._onChangeCallback(), this } slerpQuaternions (t, e, n) { return this.copy(t).slerp(e, n) } random () { let t = Math.random(), e = Math.sqrt(1 - t), n = Math.sqrt(t), r = 2 * Math.PI * Math.random(), s = 2 * Math.PI * Math.random(); return this.set(e * Math.cos(r), n * Math.sin(s), n * Math.cos(s), e * Math.sin(r)) } equals (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w } fromArray (t, e = 0) { return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this } toArray (t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t } fromBufferAttribute (t, e) { return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this } _onChange (t) { return this._onChangeCallback = t, this } _onChangeCallback () { } *[Symbol.iterator] () { yield this._x, yield this._y, yield this._z, yield this._w } }, A = class { constructor(t = 0, e = 0, n = 0) { A.prototype.isVector3 = !0, this.x = t, this.y = e, this.z = n } set (t, e, n) { return n === void 0 && (n = this.z), this.x = t, this.y = e, this.z = n, this } setScalar (t) { return this.x = t, this.y = t, this.z = t, this } setX (t) { return this.x = t, this } setY (t) { return this.y = t, this } setZ (t) { return this.z = t, this } setComponent (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw new Error("index is out of range: " + t) }return this } getComponent (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw new Error("index is out of range: " + t) } } clone () { return new this.constructor(this.x, this.y, this.z) } copy (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this } add (t) { return this.x += t.x, this.y += t.y, this.z += t.z, this } addScalar (t) { return this.x += t, this.y += t, this.z += t, this } addVectors (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this } addScaledVector (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this } sub (t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this } subScalar (t) { return this.x -= t, this.y -= t, this.z -= t, this } subVectors (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this } multiply (t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z, this } multiplyScalar (t) { return this.x *= t, this.y *= t, this.z *= t, this } multiplyVectors (t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this } applyEuler (t) { return this.applyQuaternion(MA.setFromEuler(t)) } applyAxisAngle (t, e) { return this.applyQuaternion(MA.setFromAxisAngle(t, e)) } applyMatrix3 (t) { let e = this.x, n = this.y, r = this.z, s = t.elements; return this.x = s[0] * e + s[3] * n + s[6] * r, this.y = s[1] * e + s[4] * n + s[7] * r, this.z = s[2] * e + s[5] * n + s[8] * r, this } applyNormalMatrix (t) { return this.applyMatrix3(t).normalize() } applyMatrix4 (t) { let e = this.x, n = this.y, r = this.z, s = t.elements, o = 1 / (s[3] * e + s[7] * n + s[11] * r + s[15]); return this.x = (s[0] * e + s[4] * n + s[8] * r + s[12]) * o, this.y = (s[1] * e + s[5] * n + s[9] * r + s[13]) * o, this.z = (s[2] * e + s[6] * n + s[10] * r + s[14]) * o, this } applyQuaternion (t) { let e = this.x, n = this.y, r = this.z, s = t.x, o = t.y, a = t.z, l = t.w, u = l * e + o * r - a * n, c = l * n + a * e - s * r, h = l * r + s * n - o * e, d = -s * e - o * n - a * r; return this.x = u * l + d * -s + c * -a - h * -o, this.y = c * l + d * -o + h * -s - u * -a, this.z = h * l + d * -a + u * -o - c * -s, this } project (t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) } unproject (t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) } transformDirection (t) { let e = this.x, n = this.y, r = this.z, s = t.elements; return this.x = s[0] * e + s[4] * n + s[8] * r, this.y = s[1] * e + s[5] * n + s[9] * r, this.z = s[2] * e + s[6] * n + s[10] * r, this.normalize() } divide (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this } divideScalar (t) { return this.multiplyScalar(1 / t) } min (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this } max (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this } clamp (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this } clampScalar (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this } clampLength (t, e) { let n = this.length(); return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n))) } floor () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this } ceil () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this } round () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this } roundToZero () { return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this } negate () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this } dot (t) { return this.x * t.x + this.y * t.y + this.z * t.z } lengthSq () { return this.x * this.x + this.y * this.y + this.z * this.z } length () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) } manhattanLength () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) } normalize () { return this.divideScalar(this.length() || 1) } setLength (t) { return this.normalize().multiplyScalar(t) } lerp (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this } lerpVectors (t, e, n) { return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this } cross (t) { return this.crossVectors(this, t) } crossVectors (t, e) { let n = t.x, r = t.y, s = t.z, o = e.x, a = e.y, l = e.z; return this.x = r * l - s * a, this.y = s * o - n * l, this.z = n * a - r * o, this } projectOnVector (t) { let e = t.lengthSq(); if (e === 0) return this.set(0, 0, 0); let n = t.dot(this) / e; return this.copy(t).multiplyScalar(n) } projectOnPlane (t) { return B0.copy(this).projectOnVector(t), this.sub(B0) } reflect (t) { return this.sub(B0.copy(t).multiplyScalar(2 * this.dot(t))) } angleTo (t) { let e = Math.sqrt(this.lengthSq() * t.lengthSq()); if (e === 0) return Math.PI / 2; let n = this.dot(t) / e; return Math.acos(zn(n, -1, 1)) } distanceTo (t) { return Math.sqrt(this.distanceToSquared(t)) } distanceToSquared (t) { let e = this.x - t.x, n = this.y - t.y, r = this.z - t.z; return e * e + n * n + r * r } manhattanDistanceTo (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) } setFromSpherical (t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) } setFromSphericalCoords (t, e, n) { let r = Math.sin(e) * t; return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this } setFromCylindrical (t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) } setFromCylindricalCoords (t, e, n) { return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this } setFromMatrixPosition (t) { let e = t.elements; return this.x = e[12], this.y = e[13], this.z = e[14], this } setFromMatrixScale (t) { let e = this.setFromMatrixColumn(t, 0).length(), n = this.setFromMatrixColumn(t, 1).length(), r = this.setFromMatrixColumn(t, 2).length(); return this.x = e, this.y = n, this.z = r, this } setFromMatrixColumn (t, e) { return this.fromArray(t.elements, e * 4) } setFromMatrix3Column (t, e) { return this.fromArray(t.elements, e * 3) } setFromEuler (t) { return this.x = t._x, this.y = t._y, this.z = t._z, this } equals (t) { return t.x === this.x && t.y === this.y && t.z === this.z } fromArray (t, e = 0) { return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this } toArray (t = [], e = 0) { return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t } fromBufferAttribute (t, e) { return this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this } random () { return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this } randomDirection () { let t = (Math.random() - .5) * 2, e = Math.random() * Math.PI * 2, n = Math.sqrt(1 - t ** 2); return this.x = n * Math.cos(e), this.y = n * Math.sin(e), this.z = t, this } *[Symbol.iterator] () { yield this.x, yield this.y, yield this.z } }, B0 = new A, MA = new Ye, _t = class { constructor(t = new A(1 / 0, 1 / 0, 1 / 0), e = new A(-1 / 0, -1 / 0, -1 / 0)) { this.isBox3 = !0, this.min = t, this.max = e } set (t, e) { return this.min.copy(t), this.max.copy(e), this } setFromArray (t) { let e = 1 / 0, n = 1 / 0, r = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0; for (let l = 0, u = t.length; l < u; l += 3) { let c = t[l], h = t[l + 1], d = t[l + 2]; c < e && (e = c), h < n && (n = h), d < r && (r = d), c > s && (s = c), h > o && (o = h), d > a && (a = d) } return this.min.set(e, n, r), this.max.set(s, o, a), this } setFromBufferAttribute (t) { let e = 1 / 0, n = 1 / 0, r = 1 / 0, s = -1 / 0, o = -1 / 0, a = -1 / 0; for (let l = 0, u = t.count; l < u; l++) { let c = t.getX(l), h = t.getY(l), d = t.getZ(l); c < e && (e = c), h < n && (n = h), d < r && (r = d), c > s && (s = c), h > o && (o = h), d > a && (a = d) } return this.min.set(e, n, r), this.max.set(s, o, a), this } setFromPoints (t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this } setFromCenterAndSize (t, e) { let n = tl.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this } setFromObject (t, e = !1) { return this.makeEmpty(), this.expandByObject(t, e) } clone () { return new this.constructor().copy(this) } copy (t) { return this.min.copy(t.min), this.max.copy(t.max), this } makeEmpty () { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this } isEmpty () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z } getCenter (t) { return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) } getSize (t) { return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) } expandByPoint (t) { return this.min.min(t), this.max.max(t), this } expandByVector (t) { return this.min.sub(t), this.max.add(t), this } expandByScalar (t) { return this.min.addScalar(-t), this.max.addScalar(t), this } expandByObject (t, e = !1) { t.updateWorldMatrix(!1, !1); let n = t.geometry; if (n !== void 0) if (e && n.attributes != null && n.attributes.position !== void 0) { let s = n.attributes.position; for (let o = 0, a = s.count; o < a; o++)tl.fromBufferAttribute(s, o).applyMatrix4(t.matrixWorld), this.expandByPoint(tl) } else n.boundingBox === null && n.computeBoundingBox(), F0.copy(n.boundingBox), F0.applyMatrix4(t.matrixWorld), this.union(F0); let r = t.children; for (let s = 0, o = r.length; s < o; s++)this.expandByObject(r[s], e); return this } containsPoint (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) } containsBox (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z } getParameter (t, e) { return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) } intersectsBox (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) } intersectsSphere (t) { return this.clampPoint(t.center, tl), tl.distanceToSquared(t.center) <= t.radius * t.radius } intersectsPlane (t) { let e, n; return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant } intersectsTriangle (t) { if (this.isEmpty()) return !1; this.getCenter(Md), kp.subVectors(this.max, Md), ac.subVectors(t.a, Md), lc.subVectors(t.b, Md), cc.subVectors(t.c, Md), Qo.subVectors(lc, ac), Ko.subVectors(cc, lc), nl.subVectors(ac, cc); let e = [0, -Qo.z, Qo.y, 0, -Ko.z, Ko.y, 0, -nl.z, nl.y, Qo.z, 0, -Qo.x, Ko.z, 0, -Ko.x, nl.z, 0, -nl.x, -Qo.y, Qo.x, 0, -Ko.y, Ko.x, 0, -nl.y, nl.x, 0]; return !k0(e, ac, lc, cc, kp) || (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !k0(e, ac, lc, cc, kp)) ? !1 : (Up.crossVectors(Qo, Ko), e = [Up.x, Up.y, Up.z], k0(e, ac, lc, cc, kp)) } clampPoint (t, e) { return e.copy(t).clamp(this.min, this.max) } distanceToPoint (t) { return tl.copy(t).clamp(this.min, this.max).sub(t).length() } getBoundingSphere (t) { return this.getCenter(t.center), t.radius = this.getSize(tl).length() * .5, t } intersect (t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this } union (t) { return this.min.min(t.min), this.max.max(t.max), this } applyMatrix4 (t) { return this.isEmpty() ? this : (io[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), io[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), io[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), io[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), io[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), io[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), io[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), io[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(io), this) } translate (t) { return this.min.add(t), this.max.add(t), this } equals (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }, io = [new A, new A, new A, new A, new A, new A, new A, new A], tl = new A, F0 = new _t, ac = new A, lc = new A, cc = new A, Qo = new A, Ko = new A, nl = new A, Md = new A, kp = new A, Up = new A, rl = new A; function k0 (i, t, e, n, r) { for (let s = 0, o = i.length - 3; s <= o; s += 3) { rl.fromArray(i, s); let a = r.x * Math.abs(rl.x) + r.y * Math.abs(rl.y) + r.z * Math.abs(rl.z), l = t.dot(rl), u = e.dot(rl), c = n.dot(rl); if (Math.max(-Math.max(l, u, c), Math.min(l, u, c)) > a) return !1 } return !0 } var hL = new _t, Td = new A, U0 = new A, dn = class { constructor(t = new A, e = -1) { this.center = t, this.radius = e } set (t, e) { return this.center.copy(t), this.radius = e, this } setFromPoints (t, e) { let n = this.center; e !== void 0 ? n.copy(e) : hL.setFromPoints(t).getCenter(n); let r = 0; for (let s = 0, o = t.length; s < o; s++)r = Math.max(r, n.distanceToSquared(t[s])); return this.radius = Math.sqrt(r), this } copy (t) { return this.center.copy(t.center), this.radius = t.radius, this } isEmpty () { return this.radius < 0 } makeEmpty () { return this.center.set(0, 0, 0), this.radius = -1, this } containsPoint (t) { return t.distanceToSquared(this.center) <= this.radius * this.radius } distanceToPoint (t) { return t.distanceTo(this.center) - this.radius } intersectsSphere (t) { let e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e } intersectsBox (t) { return t.intersectsSphere(this) } intersectsPlane (t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius } clampPoint (t, e) { let n = this.center.distanceToSquared(t); return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e } getBoundingBox (t) { return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t) } applyMatrix4 (t) { return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this } translate (t) { return this.center.add(t), this } expandByPoint (t) { if (this.isEmpty()) return this.center.copy(t), this.radius = 0, this; Td.subVectors(t, this.center); let e = Td.lengthSq(); if (e > this.radius * this.radius) { let n = Math.sqrt(e), r = (n - this.radius) * .5; this.center.addScaledVector(Td, r / n), this.radius += r } return this } union (t) { return t.isEmpty() ? this : this.isEmpty() ? (this.copy(t), this) : (this.center.equals(t.center) === !0 ? this.radius = Math.max(this.radius, t.radius) : (U0.subVectors(t.center, this.center).setLength(t.radius), this.expandByPoint(Td.copy(t.center).add(U0)), this.expandByPoint(Td.copy(t.center).sub(U0))), this) } equals (t) { return t.center.equals(this.center) && t.radius === this.radius } clone () { return new this.constructor().copy(this) } }, so = new A, z0 = new A, zp = new A, Zo = new A, G0 = new A, Gp = new A, V0 = new A, Wi = class { constructor(t = new A, e = new A(0, 0, -1)) { this.origin = t, this.direction = e } set (t, e) { return this.origin.copy(t), this.direction.copy(e), this } copy (t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this } at (t, e) { return e.copy(this.direction).multiplyScalar(t).add(this.origin) } lookAt (t) { return this.direction.copy(t).sub(this.origin).normalize(), this } recast (t) { return this.origin.copy(this.at(t, so)), this } closestPointToPoint (t, e) { e.subVectors(t, this.origin); let n = e.dot(this.direction); return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin) } distanceToPoint (t) { return Math.sqrt(this.distanceSqToPoint(t)) } distanceSqToPoint (t) { let e = so.subVectors(t, this.origin).dot(this.direction); return e < 0 ? this.origin.distanceToSquared(t) : (so.copy(this.direction).multiplyScalar(e).add(this.origin), so.distanceToSquared(t)) } distanceSqToSegment (t, e, n, r) { z0.copy(t).add(e).multiplyScalar(.5), zp.copy(e).sub(t).normalize(), Zo.copy(this.origin).sub(z0); let s = t.distanceTo(e) * .5, o = -this.direction.dot(zp), a = Zo.dot(this.direction), l = -Zo.dot(zp), u = Zo.lengthSq(), c = Math.abs(1 - o * o), h, d, f, p; if (c > 0) if (h = o * l - a, d = o * a - l, p = s * c, h >= 0) if (d >= -p) if (d <= p) { let m = 1 / c; h *= m, d *= m, f = h * (h + o * d + 2 * a) + d * (o * h + d + 2 * l) + u } else d = s, h = Math.max(0, -(o * d + a)), f = -h * h + d * (d + 2 * l) + u; else d = -s, h = Math.max(0, -(o * d + a)), f = -h * h + d * (d + 2 * l) + u; else d <= -p ? (h = Math.max(0, -(-o * s + a)), d = h > 0 ? -s : Math.min(Math.max(-s, -l), s), f = -h * h + d * (d + 2 * l) + u) : d <= p ? (h = 0, d = Math.min(Math.max(-s, -l), s), f = d * (d + 2 * l) + u) : (h = Math.max(0, -(o * s + a)), d = h > 0 ? s : Math.min(Math.max(-s, -l), s), f = -h * h + d * (d + 2 * l) + u); else d = o > 0 ? -s : s, h = Math.max(0, -(o * d + a)), f = -h * h + d * (d + 2 * l) + u; return n && n.copy(this.direction).multiplyScalar(h).add(this.origin), r && r.copy(zp).multiplyScalar(d).add(z0), f } intersectSphere (t, e) { so.subVectors(t.center, this.origin); let n = so.dot(this.direction), r = so.dot(so) - n * n, s = t.radius * t.radius; if (r > s) return null; let o = Math.sqrt(s - r), a = n - o, l = n + o; return a < 0 && l < 0 ? null : a < 0 ? this.at(l, e) : this.at(a, e) } intersectsSphere (t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius } distanceToPlane (t) { let e = t.normal.dot(this.direction); if (e === 0) return t.distanceToPoint(this.origin) === 0 ? 0 : null; let n = -(this.origin.dot(t.normal) + t.constant) / e; return n >= 0 ? n : null } intersectPlane (t, e) { let n = this.distanceToPlane(t); return n === null ? null : this.at(n, e) } intersectsPlane (t) { let e = t.distanceToPoint(this.origin); return e === 0 || t.normal.dot(this.direction) * e < 0 } intersectBox (t, e) { let n, r, s, o, a, l, u = 1 / this.direction.x, c = 1 / this.direction.y, h = 1 / this.direction.z, d = this.origin; return u >= 0 ? (n = (t.min.x - d.x) * u, r = (t.max.x - d.x) * u) : (n = (t.max.x - d.x) * u, r = (t.min.x - d.x) * u), c >= 0 ? (s = (t.min.y - d.y) * c, o = (t.max.y - d.y) * c) : (s = (t.max.y - d.y) * c, o = (t.min.y - d.y) * c), n > o || s > r || ((s > n || isNaN(n)) && (n = s), (o < r || isNaN(r)) && (r = o), h >= 0 ? (a = (t.min.z - d.z) * h, l = (t.max.z - d.z) * h) : (a = (t.max.z - d.z) * h, l = (t.min.z - d.z) * h), n > l || a > r) || ((a > n || n !== n) && (n = a), (l < r || r !== r) && (r = l), r < 0) ? null : this.at(n >= 0 ? n : r, e) } intersectsBox (t) { return this.intersectBox(t, so) !== null } intersectTriangle (t, e, n, r, s) { G0.subVectors(e, t), Gp.subVectors(n, t), V0.crossVectors(G0, Gp); let o = this.direction.dot(V0), a; if (o > 0) { if (r) return null; a = 1 } else if (o < 0) a = -1, o = -o; else return null; Zo.subVectors(this.origin, t); let l = a * this.direction.dot(Gp.crossVectors(Zo, Gp)); if (l < 0) return null; let u = a * this.direction.dot(G0.cross(Zo)); if (u < 0 || l + u > o) return null; let c = -a * Zo.dot(V0); return c < 0 ? null : this.at(c / o, s) } applyMatrix4 (t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this } equals (t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } clone () { return new this.constructor().copy(this) } }, se = class { constructor() { se.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1] } set (t, e, n, r, s, o, a, l, u, c, h, d, f, p, m, g) { let y = this.elements; return y[0] = t, y[4] = e, y[8] = n, y[12] = r, y[1] = s, y[5] = o, y[9] = a, y[13] = l, y[2] = u, y[6] = c, y[10] = h, y[14] = d, y[3] = f, y[7] = p, y[11] = m, y[15] = g, this } identity () { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } clone () { return new se().fromArray(this.elements) } copy (t) { let e = this.elements, n = t.elements; return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this } copyPosition (t) { let e = this.elements, n = t.elements; return e[12] = n[12], e[13] = n[13], e[14] = n[14], this } setFromMatrix3 (t) { let e = t.elements; return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this } extractBasis (t, e, n) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this } makeBasis (t, e, n) { return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this } extractRotation (t) { let e = this.elements, n = t.elements, r = 1 / uc.setFromMatrixColumn(t, 0).length(), s = 1 / uc.setFromMatrixColumn(t, 1).length(), o = 1 / uc.setFromMatrixColumn(t, 2).length(); return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * s, e[5] = n[5] * s, e[6] = n[6] * s, e[7] = 0, e[8] = n[8] * o, e[9] = n[9] * o, e[10] = n[10] * o, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromEuler (t) { let e = this.elements, n = t.x, r = t.y, s = t.z, o = Math.cos(n), a = Math.sin(n), l = Math.cos(r), u = Math.sin(r), c = Math.cos(s), h = Math.sin(s); if (t.order === "XYZ") { let d = o * c, f = o * h, p = a * c, m = a * h; e[0] = l * c, e[4] = -l * h, e[8] = u, e[1] = f + p * u, e[5] = d - m * u, e[9] = -a * l, e[2] = m - d * u, e[6] = p + f * u, e[10] = o * l } else if (t.order === "YXZ") { let d = l * c, f = l * h, p = u * c, m = u * h; e[0] = d + m * a, e[4] = p * a - f, e[8] = o * u, e[1] = o * h, e[5] = o * c, e[9] = -a, e[2] = f * a - p, e[6] = m + d * a, e[10] = o * l } else if (t.order === "ZXY") { let d = l * c, f = l * h, p = u * c, m = u * h; e[0] = d - m * a, e[4] = -o * h, e[8] = p + f * a, e[1] = f + p * a, e[5] = o * c, e[9] = m - d * a, e[2] = -o * u, e[6] = a, e[10] = o * l } else if (t.order === "ZYX") { let d = o * c, f = o * h, p = a * c, m = a * h; e[0] = l * c, e[4] = p * u - f, e[8] = d * u + m, e[1] = l * h, e[5] = m * u + d, e[9] = f * u - p, e[2] = -u, e[6] = a * l, e[10] = o * l } else if (t.order === "YZX") { let d = o * l, f = o * u, p = a * l, m = a * u; e[0] = l * c, e[4] = m - d * h, e[8] = p * h + f, e[1] = h, e[5] = o * c, e[9] = -a * c, e[2] = -u * c, e[6] = f * h + p, e[10] = d - m * h } else if (t.order === "XZY") { let d = o * l, f = o * u, p = a * l, m = a * u; e[0] = l * c, e[4] = -h, e[8] = u * c, e[1] = d * h + m, e[5] = o * c, e[9] = f * h - p, e[2] = p * h - f, e[6] = a * c, e[10] = m * h + d } return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this } makeRotationFromQuaternion (t) { return this.compose(dL, t, fL) } lookAt (t, e, n) { let r = this.elements; return ii.subVectors(t, e), ii.lengthSq() === 0 && (ii.z = 1), ii.normalize(), Jo.crossVectors(n, ii), Jo.lengthSq() === 0 && (Math.abs(n.z) === 1 ? ii.x += 1e-4 : ii.z += 1e-4, ii.normalize(), Jo.crossVectors(n, ii)), Jo.normalize(), Vp.crossVectors(ii, Jo), r[0] = Jo.x, r[4] = Vp.x, r[8] = ii.x, r[1] = Jo.y, r[5] = Vp.y, r[9] = ii.y, r[2] = Jo.z, r[6] = Vp.z, r[10] = ii.z, this } multiply (t) { return this.multiplyMatrices(this, t) } premultiply (t) { return this.multiplyMatrices(t, this) } multiplyMatrices (t, e) { let n = t.elements, r = e.elements, s = this.elements, o = n[0], a = n[4], l = n[8], u = n[12], c = n[1], h = n[5], d = n[9], f = n[13], p = n[2], m = n[6], g = n[10], y = n[14], v = n[3], x = n[7], b = n[11], S = n[15], _ = r[0], E = r[4], w = r[8], M = r[12], T = r[1], I = r[5], C = r[9], P = r[13], D = r[2], L = r[6], H = r[10], U = r[14], V = r[3], G = r[7], z = r[11], $ = r[15]; return s[0] = o * _ + a * T + l * D + u * V, s[4] = o * E + a * I + l * L + u * G, s[8] = o * w + a * C + l * H + u * z, s[12] = o * M + a * P + l * U + u * $, s[1] = c * _ + h * T + d * D + f * V, s[5] = c * E + h * I + d * L + f * G, s[9] = c * w + h * C + d * H + f * z, s[13] = c * M + h * P + d * U + f * $, s[2] = p * _ + m * T + g * D + y * V, s[6] = p * E + m * I + g * L + y * G, s[10] = p * w + m * C + g * H + y * z, s[14] = p * M + m * P + g * U + y * $, s[3] = v * _ + x * T + b * D + S * V, s[7] = v * E + x * I + b * L + S * G, s[11] = v * w + x * C + b * H + S * z, s[15] = v * M + x * P + b * U + S * $, this } multiplyScalar (t) { let e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this } determinant () { let t = this.elements, e = t[0], n = t[4], r = t[8], s = t[12], o = t[1], a = t[5], l = t[9], u = t[13], c = t[2], h = t[6], d = t[10], f = t[14], p = t[3], m = t[7], g = t[11], y = t[15]; return p * (+s * l * h - r * u * h - s * a * d + n * u * d + r * a * f - n * l * f) + m * (+e * l * f - e * u * d + s * o * d - r * o * f + r * u * c - s * l * c) + g * (+e * u * h - e * a * f - s * o * h + n * o * f + s * a * c - n * u * c) + y * (-r * a * c - e * l * h + e * a * d + r * o * h - n * o * d + n * l * c) } transpose () { let t = this.elements, e; return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this } setPosition (t, e, n) { let r = this.elements; return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this } invert () { let t = this.elements, e = t[0], n = t[1], r = t[2], s = t[3], o = t[4], a = t[5], l = t[6], u = t[7], c = t[8], h = t[9], d = t[10], f = t[11], p = t[12], m = t[13], g = t[14], y = t[15], v = h * g * u - m * d * u + m * l * f - a * g * f - h * l * y + a * d * y, x = p * d * u - c * g * u - p * l * f + o * g * f + c * l * y - o * d * y, b = c * m * u - p * h * u + p * a * f - o * m * f - c * a * y + o * h * y, S = p * h * l - c * m * l - p * a * d + o * m * d + c * a * g - o * h * g, _ = e * v + n * x + r * b + s * S; if (_ === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0); let E = 1 / _; return t[0] = v * E, t[1] = (m * d * s - h * g * s - m * r * f + n * g * f + h * r * y - n * d * y) * E, t[2] = (a * g * s - m * l * s + m * r * u - n * g * u - a * r * y + n * l * y) * E, t[3] = (h * l * s - a * d * s - h * r * u + n * d * u + a * r * f - n * l * f) * E, t[4] = x * E, t[5] = (c * g * s - p * d * s + p * r * f - e * g * f - c * r * y + e * d * y) * E, t[6] = (p * l * s - o * g * s - p * r * u + e * g * u + o * r * y - e * l * y) * E, t[7] = (o * d * s - c * l * s + c * r * u - e * d * u - o * r * f + e * l * f) * E, t[8] = b * E, t[9] = (p * h * s - c * m * s - p * n * f + e * m * f + c * n * y - e * h * y) * E, t[10] = (o * m * s - p * a * s + p * n * u - e * m * u - o * n * y + e * a * y) * E, t[11] = (c * a * s - o * h * s - c * n * u + e * h * u + o * n * f - e * a * f) * E, t[12] = S * E, t[13] = (c * m * r - p * h * r + p * n * d - e * m * d - c * n * g + e * h * g) * E, t[14] = (p * a * r - o * m * r - p * n * l + e * m * l + o * n * g - e * a * g) * E, t[15] = (o * h * r - c * a * r + c * n * l - e * h * l - o * n * d + e * a * d) * E, this } scale (t) { let e = this.elements, n = t.x, r = t.y, s = t.z; return e[0] *= n, e[4] *= r, e[8] *= s, e[1] *= n, e[5] *= r, e[9] *= s, e[2] *= n, e[6] *= r, e[10] *= s, e[3] *= n, e[7] *= r, e[11] *= s, this } getMaxScaleOnAxis () { let t = this.elements, e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2], n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6], r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10]; return Math.sqrt(Math.max(e, n, r)) } makeTranslation (t, e, n) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this } makeRotationX (t) { let e = Math.cos(t), n = Math.sin(t); return this.set(1, 0, 0, 0, 0, e, -n, 0, 0, n, e, 0, 0, 0, 0, 1), this } makeRotationY (t) { let e = Math.cos(t), n = Math.sin(t); return this.set(e, 0, n, 0, 0, 1, 0, 0, -n, 0, e, 0, 0, 0, 0, 1), this } makeRotationZ (t) { let e = Math.cos(t), n = Math.sin(t); return this.set(e, -n, 0, 0, n, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this } makeRotationAxis (t, e) { let n = Math.cos(e), r = Math.sin(e), s = 1 - n, o = t.x, a = t.y, l = t.z, u = s * o, c = s * a; return this.set(u * o + n, u * a - r * l, u * l + r * a, 0, u * a + r * l, c * a + n, c * l - r * o, 0, u * l - r * a, c * l + r * o, s * l * l + n, 0, 0, 0, 0, 1), this } makeScale (t, e, n) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this } makeShear (t, e, n, r, s, o) { return this.set(1, n, s, 0, t, 1, o, 0, e, r, 1, 0, 0, 0, 0, 1), this } compose (t, e, n) { let r = this.elements, s = e._x, o = e._y, a = e._z, l = e._w, u = s + s, c = o + o, h = a + a, d = s * u, f = s * c, p = s * h, m = o * c, g = o * h, y = a * h, v = l * u, x = l * c, b = l * h, S = n.x, _ = n.y, E = n.z; return r[0] = (1 - (m + y)) * S, r[1] = (f + b) * S, r[2] = (p - x) * S, r[3] = 0, r[4] = (f - b) * _, r[5] = (1 - (d + y)) * _, r[6] = (g + v) * _, r[7] = 0, r[8] = (p + x) * E, r[9] = (g - v) * E, r[10] = (1 - (d + m)) * E, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this } decompose (t, e, n) { let r = this.elements, s = uc.set(r[0], r[1], r[2]).length(), o = uc.set(r[4], r[5], r[6]).length(), a = uc.set(r[8], r[9], r[10]).length(); this.determinant() < 0 && (s = -s), t.x = r[12], t.y = r[13], t.z = r[14], Vi.copy(this); let u = 1 / s, c = 1 / o, h = 1 / a; return Vi.elements[0] *= u, Vi.elements[1] *= u, Vi.elements[2] *= u, Vi.elements[4] *= c, Vi.elements[5] *= c, Vi.elements[6] *= c, Vi.elements[8] *= h, Vi.elements[9] *= h, Vi.elements[10] *= h, e.setFromRotationMatrix(Vi), n.x = s, n.y = o, n.z = a, this } makePerspective (t, e, n, r, s, o) { let a = this.elements, l = 2 * s / (e - t), u = 2 * s / (n - r), c = (e + t) / (e - t), h = (n + r) / (n - r), d = -(o + s) / (o - s), f = -2 * o * s / (o - s); return a[0] = l, a[4] = 0, a[8] = c, a[12] = 0, a[1] = 0, a[5] = u, a[9] = h, a[13] = 0, a[2] = 0, a[6] = 0, a[10] = d, a[14] = f, a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this } makeOrthographic (t, e, n, r, s, o) { let a = this.elements, l = 1 / (e - t), u = 1 / (n - r), c = 1 / (o - s), h = (e + t) * l, d = (n + r) * u, f = (o + s) * c; return a[0] = 2 * l, a[4] = 0, a[8] = 0, a[12] = -h, a[1] = 0, a[5] = 2 * u, a[9] = 0, a[13] = -d, a[2] = 0, a[6] = 0, a[10] = -2 * c, a[14] = -f, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this } equals (t) { let e = this.elements, n = t.elements; for (let r = 0; r < 16; r++)if (e[r] !== n[r]) return !1; return !0 } fromArray (t, e = 0) { for (let n = 0; n < 16; n++)this.elements[n] = t[n + e]; return this } toArray (t = [], e = 0) { let n = this.elements; return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t } }, uc = new A, Vi = new se, dL = new A(0, 0, 0), fL = new A(1, 1, 1), Jo = new A, Vp = new A, ii = new A, TA = new se, CA = new Ye, Gt = class { constructor(t = 0, e = 0, n = 0, r = Gt.DEFAULT_ORDER) { this.isEuler = !0, this._x = t, this._y = e, this._z = n, this._order = r } get x () { return this._x } set x (t) { this._x = t, this._onChangeCallback() } get y () { return this._y } set y (t) { this._y = t, this._onChangeCallback() } get z () { return this._z } set z (t) { this._z = t, this._onChangeCallback() } get order () { return this._order } set order (t) { this._order = t, this._onChangeCallback() } set (t, e, n, r = this._order) { return this._x = t, this._y = e, this._z = n, this._order = r, this._onChangeCallback(), this } clone () { return new this.constructor(this._x, this._y, this._z, this._order) } copy (t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this } setFromRotationMatrix (t, e = this._order, n = !0) { let r = t.elements, s = r[0], o = r[4], a = r[8], l = r[1], u = r[5], c = r[9], h = r[2], d = r[6], f = r[10]; switch (e) { case "XYZ": this._y = Math.asin(zn(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-c, f), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, u), this._z = 0); break; case "YXZ": this._x = Math.asin(-zn(c, -1, 1)), Math.abs(c) < .9999999 ? (this._y = Math.atan2(a, f), this._z = Math.atan2(l, u)) : (this._y = Math.atan2(-h, s), this._z = 0); break; case "ZXY": this._x = Math.asin(zn(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-h, f), this._z = Math.atan2(-o, u)) : (this._y = 0, this._z = Math.atan2(l, s)); break; case "ZYX": this._y = Math.asin(-zn(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(d, f), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, u)); break; case "YZX": this._z = Math.asin(zn(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-c, u), this._y = Math.atan2(-h, s)) : (this._x = 0, this._y = Math.atan2(a, f)); break; case "XZY": this._z = Math.asin(-zn(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, u), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-c, f), this._y = 0); break; default: console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e) }return this._order = e, n === !0 && this._onChangeCallback(), this } setFromQuaternion (t, e, n) { return TA.makeRotationFromQuaternion(t), this.setFromRotationMatrix(TA, e, n) } setFromVector3 (t, e = this._order) { return this.set(t.x, t.y, t.z, e) } reorder (t) { return CA.setFromEuler(this), this.setFromQuaternion(CA, t) } equals (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order } fromArray (t) { return this._x = t[0], this._y = t[1], this._z = t[2], t[3] !== void 0 && (this._order = t[3]), this._onChangeCallback(), this } toArray (t = [], e = 0) { return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t } _onChange (t) { return this._onChangeCallback = t, this } _onChangeCallback () { } *[Symbol.iterator] () { yield this._x, yield this._y, yield this._z, yield this._order } }; Gt.DEFAULT_ORDER = "XYZ"; var Hd = class { constructor() { this.mask = 1 } set (t) { this.mask = (1 << t | 0) >>> 0 } enable (t) { this.mask |= 1 << t | 0 } enableAll () { this.mask = -1 } toggle (t) { this.mask ^= 1 << t | 0 } disable (t) { this.mask &= ~(1 << t | 0) } disableAll () { this.mask = 0 } test (t) { return (this.mask & t.mask) !== 0 } isEnabled (t) { return (this.mask & (1 << t | 0)) !== 0 } }, pL = 0, PA = new A, hc = new Ye, oo = new se, Hp = new A, Cd = new A, mL = new A, gL = new Ye, IA = new A(1, 0, 0), DA = new A(0, 1, 0), OA = new A(0, 0, 1), yL = { type: "added" }, RA = { type: "removed" }, ft = class extends kt { constructor() { super(), this.isObject3D = !0, Object.defineProperty(this, "id", { value: pL++ }), this.uuid = bi(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = ft.DEFAULT_UP.clone(); let t = new A, e = new Gt, n = new Ye, r = new A(1, 1, 1); function s () { n.setFromEuler(e, !1) } function o () { e.setFromQuaternion(n, void 0, !1) } e._onChange(s), n._onChange(o), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: n }, scale: { configurable: !0, enumerable: !0, value: r }, modelViewMatrix: { value: new se }, normalMatrix: { value: new Xt } }), this.matrix = new se, this.matrixWorld = new se, this.matrixAutoUpdate = ft.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.matrixWorldAutoUpdate = ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.layers = new Hd, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {} } onBeforeRender () { } onAfterRender () { } applyMatrix4 (t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) } applyQuaternion (t) { return this.quaternion.premultiply(t), this } setRotationFromAxisAngle (t, e) { this.quaternion.setFromAxisAngle(t, e) } setRotationFromEuler (t) { this.quaternion.setFromEuler(t, !0) } setRotationFromMatrix (t) { this.quaternion.setFromRotationMatrix(t) } setRotationFromQuaternion (t) { this.quaternion.copy(t) } rotateOnAxis (t, e) { return hc.setFromAxisAngle(t, e), this.quaternion.multiply(hc), this } rotateOnWorldAxis (t, e) { return hc.setFromAxisAngle(t, e), this.quaternion.premultiply(hc), this } rotateX (t) { return this.rotateOnAxis(IA, t) } rotateY (t) { return this.rotateOnAxis(DA, t) } rotateZ (t) { return this.rotateOnAxis(OA, t) } translateOnAxis (t, e) { return PA.copy(t).applyQuaternion(this.quaternion), this.position.add(PA.multiplyScalar(e)), this } translateX (t) { return this.translateOnAxis(IA, t) } translateY (t) { return this.translateOnAxis(DA, t) } translateZ (t) { return this.translateOnAxis(OA, t) } localToWorld (t) { return this.updateWorldMatrix(!0, !1), t.applyMatrix4(this.matrixWorld) } worldToLocal (t) { return this.updateWorldMatrix(!0, !1), t.applyMatrix4(oo.copy(this.matrixWorld).invert()) } lookAt (t, e, n) { t.isVector3 ? Hp.copy(t) : Hp.set(t, e, n); let r = this.parent; this.updateWorldMatrix(!0, !1), Cd.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? oo.lookAt(Cd, Hp, this.up) : oo.lookAt(Hp, Cd, this.up), this.quaternion.setFromRotationMatrix(oo), r && (oo.extractRotation(r.matrixWorld), hc.setFromRotationMatrix(oo), this.quaternion.premultiply(hc.invert())) } add (t) { if (arguments.length > 1) { for (let e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (t.parent !== null && t.parent.remove(t), t.parent = this, this.children.push(t), t.dispatchEvent(yL)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) } remove (t) { if (arguments.length > 1) { for (let n = 0; n < arguments.length; n++)this.remove(arguments[n]); return this } let e = this.children.indexOf(t); return e !== -1 && (t.parent = null, this.children.splice(e, 1), t.dispatchEvent(RA)), this } removeFromParent () { let t = this.parent; return t !== null && t.remove(this), this } clear () { for (let t = 0; t < this.children.length; t++) { let e = this.children[t]; e.parent = null, e.dispatchEvent(RA) } return this.children.length = 0, this } attach (t) { return this.updateWorldMatrix(!0, !1), oo.copy(this.matrixWorld).invert(), t.parent !== null && (t.parent.updateWorldMatrix(!0, !1), oo.multiply(t.parent.matrixWorld)), t.applyMatrix4(oo), this.add(t), t.updateWorldMatrix(!1, !0), this } getObjectById (t) { return this.getObjectByProperty("id", t) } getObjectByName (t) { return this.getObjectByProperty("name", t) } getObjectByProperty (t, e) { if (this[t] === e) return this; for (let n = 0, r = this.children.length; n < r; n++) { let o = this.children[n].getObjectByProperty(t, e); if (o !== void 0) return o } } getObjectsByProperty (t, e) { let n = []; this[t] === e && n.push(this); for (let r = 0, s = this.children.length; r < s; r++) { let o = this.children[r].getObjectsByProperty(t, e); o.length > 0 && (n = n.concat(o)) } return n } getWorldPosition (t) { return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld) } getWorldQuaternion (t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Cd, t, mL), t } getWorldScale (t) { return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Cd, gL, t), t } getWorldDirection (t) { this.updateWorldMatrix(!0, !1); let e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() } raycast () { } traverse (t) { t(this); let e = this.children; for (let n = 0, r = e.length; n < r; n++)e[n].traverse(t) } traverseVisible (t) { if (this.visible === !1) return; t(this); let e = this.children; for (let n = 0, r = e.length; n < r; n++)e[n].traverseVisible(t) } traverseAncestors (t) { let e = this.parent; e !== null && (t(e), e.traverseAncestors(t)) } updateMatrix () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 } updateMatrixWorld (t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); let e = this.children; for (let n = 0, r = e.length; n < r; n++) { let s = e[n]; (s.matrixWorldAutoUpdate === !0 || t === !0) && s.updateMatrixWorld(t) } } updateWorldMatrix (t, e) { let n = this.parent; if (t === !0 && n !== null && n.matrixWorldAutoUpdate === !0 && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), e === !0) { let r = this.children; for (let s = 0, o = r.length; s < o; s++) { let a = r[s]; a.matrixWorldAutoUpdate === !0 && a.updateWorldMatrix(!1, !0) } } } toJSON (t) { let e = t === void 0 || typeof t == "string", n = {}; e && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}, skeletons: {}, animations: {}, nodes: {} }, n.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); let r = {}; r.uuid = this.uuid, r.type = this.type, this.name !== "" && (r.name = this.name), this.castShadow === !0 && (r.castShadow = !0), this.receiveShadow === !0 && (r.receiveShadow = !0), this.visible === !1 && (r.visible = !1), this.frustumCulled === !1 && (r.frustumCulled = !1), this.renderOrder !== 0 && (r.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (r.userData = this.userData), r.layers = this.layers.mask, r.matrix = this.matrix.toArray(), this.matrixAutoUpdate === !1 && (r.matrixAutoUpdate = !1), this.isInstancedMesh && (r.type = "InstancedMesh", r.count = this.count, r.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (r.instanceColor = this.instanceColor.toJSON())); function s (a, l) { return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(t)), l.uuid } if (this.isScene) this.background && (this.background.isColor ? r.background = this.background.toJSON() : this.background.isTexture && (r.background = this.background.toJSON(t).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (r.environment = this.environment.toJSON(t).uuid); else if (this.isMesh || this.isLine || this.isPoints) { r.geometry = s(t.geometries, this.geometry); let a = this.geometry.parameters; if (a !== void 0 && a.shapes !== void 0) { let l = a.shapes; if (Array.isArray(l)) for (let u = 0, c = l.length; u < c; u++) { let h = l[u]; s(t.shapes, h) } else s(t.shapes, l) } } if (this.isSkinnedMesh && (r.bindMode = this.bindMode, r.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(t.skeletons, this.skeleton), r.skeleton = this.skeleton.uuid)), this.material !== void 0) if (Array.isArray(this.material)) { let a = []; for (let l = 0, u = this.material.length; l < u; l++)a.push(s(t.materials, this.material[l])); r.material = a } else r.material = s(t.materials, this.material); if (this.children.length > 0) { r.children = []; for (let a = 0; a < this.children.length; a++)r.children.push(this.children[a].toJSON(t).object) } if (this.animations.length > 0) { r.animations = []; for (let a = 0; a < this.animations.length; a++) { let l = this.animations[a]; r.animations.push(s(t.animations, l)) } } if (e) { let a = o(t.geometries), l = o(t.materials), u = o(t.textures), c = o(t.images), h = o(t.shapes), d = o(t.skeletons), f = o(t.animations), p = o(t.nodes); a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), u.length > 0 && (n.textures = u), c.length > 0 && (n.images = c), h.length > 0 && (n.shapes = h), d.length > 0 && (n.skeletons = d), f.length > 0 && (n.animations = f), p.length > 0 && (n.nodes = p) } return n.object = r, n; function o (a) { let l = []; for (let u in a) { let c = a[u]; delete c.metadata, l.push(c) } return l } } clone (t) { return new this.constructor().copy(this, t) } copy (t, e = !0) { if (this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.rotation.order = t.rotation.order, this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.matrixWorldAutoUpdate = t.matrixWorldAutoUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), e === !0) for (let n = 0; n < t.children.length; n++) { let r = t.children[n]; this.add(r.clone()) } return this } }; ft.DEFAULT_UP = new A(0, 1, 0); ft.DEFAULT_MATRIX_AUTO_UPDATE = !0; ft.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0; var Hi = new A, ao = new A, H0 = new A, lo = new A, dc = new A, fc = new A, LA = new A, j0 = new A, W0 = new A, q0 = new A, nn = class { constructor(t = new A, e = new A, n = new A) { this.a = t, this.b = e, this.c = n } static getNormal (t, e, n, r) { r.subVectors(n, e), Hi.subVectors(t, e), r.cross(Hi); let s = r.lengthSq(); return s > 0 ? r.multiplyScalar(1 / Math.sqrt(s)) : r.set(0, 0, 0) } static getBarycoord (t, e, n, r, s) { Hi.subVectors(r, e), ao.subVectors(n, e), H0.subVectors(t, e); let o = Hi.dot(Hi), a = Hi.dot(ao), l = Hi.dot(H0), u = ao.dot(ao), c = ao.dot(H0), h = o * u - a * a; if (h === 0) return s.set(-2, -1, -1); let d = 1 / h, f = (u * l - a * c) * d, p = (o * c - a * l) * d; return s.set(1 - f - p, p, f) } static containsPoint (t, e, n, r) { return this.getBarycoord(t, e, n, r, lo), lo.x >= 0 && lo.y >= 0 && lo.x + lo.y <= 1 } static getUV (t, e, n, r, s, o, a, l) { return this.getBarycoord(t, e, n, r, lo), l.set(0, 0), l.addScaledVector(s, lo.x), l.addScaledVector(o, lo.y), l.addScaledVector(a, lo.z), l } static isFrontFacing (t, e, n, r) { return Hi.subVectors(n, e), ao.subVectors(t, e), Hi.cross(ao).dot(r) < 0 } set (t, e, n) { return this.a.copy(t), this.b.copy(e), this.c.copy(n), this } setFromPointsAndIndices (t, e, n, r) { return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this } setFromAttributeAndIndices (t, e, n, r) { return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, r), this } clone () { return new this.constructor().copy(this) } copy (t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this } getArea () { return Hi.subVectors(this.c, this.b), ao.subVectors(this.a, this.b), Hi.cross(ao).length() * .5 } getMidpoint (t) { return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) } getNormal (t) { return nn.getNormal(this.a, this.b, this.c, t) } getPlane (t) { return t.setFromCoplanarPoints(this.a, this.b, this.c) } getBarycoord (t, e) { return nn.getBarycoord(t, this.a, this.b, this.c, e) } getUV (t, e, n, r, s) { return nn.getUV(t, this.a, this.b, this.c, e, n, r, s) } containsPoint (t) { return nn.containsPoint(t, this.a, this.b, this.c) } isFrontFacing (t) { return nn.isFrontFacing(this.a, this.b, this.c, t) } intersectsBox (t) { return t.intersectsTriangle(this) } closestPointToPoint (t, e) { let n = this.a, r = this.b, s = this.c, o, a; dc.subVectors(r, n), fc.subVectors(s, n), j0.subVectors(t, n); let l = dc.dot(j0), u = fc.dot(j0); if (l <= 0 && u <= 0) return e.copy(n); W0.subVectors(t, r); let c = dc.dot(W0), h = fc.dot(W0); if (c >= 0 && h <= c) return e.copy(r); let d = l * h - c * u; if (d <= 0 && l >= 0 && c <= 0) return o = l / (l - c), e.copy(n).addScaledVector(dc, o); q0.subVectors(t, s); let f = dc.dot(q0), p = fc.dot(q0); if (p >= 0 && f <= p) return e.copy(s); let m = f * u - l * p; if (m <= 0 && u >= 0 && p <= 0) return a = u / (u - p), e.copy(n).addScaledVector(fc, a); let g = c * p - f * h; if (g <= 0 && h - c >= 0 && f - p >= 0) return LA.subVectors(s, r), a = (h - c) / (h - c + (f - p)), e.copy(r).addScaledVector(LA, a); let y = 1 / (g + m + d); return o = m * y, a = d * y, e.copy(n).addScaledVector(dc, o).addScaledVector(fc, a) } equals (t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } }, vL = 0, ul = class extends kt { constructor() { super(), this.isMaterial = !0, Object.defineProperty(this, "id", { value: vL++ }), this.uuid = bi(), this.name = "", this.type = "Material", this.blending = Ec, this.side = ai, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = E_, this.blendDst = M_, this.blendEquation = bc, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = ax, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = QR, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = D0, this.stencilZFail = D0, this.stencilZPass = D0, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0 } get alphaTest () { return this._alphaTest } set alphaTest (t) { this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t } onBuild () { } onBeforeRender () { } onBeforeCompile () { } customProgramCacheKey () { return this.onBeforeCompile.toString() } setValues (t) { if (t !== void 0) for (let e in t) { let n = t[e]; if (n === void 0) { console.warn("THREE.Material: '" + e + "' parameter is undefined."); continue } let r = this[e]; if (r === void 0) { console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material."); continue } r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n } } toJSON (t) { let e = t === void 0 || typeof t == "string"; e && (t = { textures: {}, images: {} }); let n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(t).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(t).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(t).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(t).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(t).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(t).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(t).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(t).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Ec && (n.blending = this.blending), this.side !== ai && (n.side = this.side), this.vertexColors && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, n.colorWrite = this.colorWrite, n.stencilWrite = this.stencilWrite, n.stencilWriteMask = this.stencilWriteMask, n.stencilFunc = this.stencilFunc, n.stencilRef = this.stencilRef, n.stencilFuncMask = this.stencilFuncMask, n.stencilFail = this.stencilFail, n.stencilZFail = this.stencilZFail, n.stencilZPass = this.stencilZPass, this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = this.premultipliedAlpha), this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass), this.wireframe === !0 && (n.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = this.flatShading), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData); function r (s) { let o = []; for (let a in s) { let l = s[a]; delete l.metadata, o.push(l) } return o } if (e) { let s = r(t.textures), o = r(t.images); s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o) } return n } clone () { return new this.constructor().copy(this) } copy (t) { this.name = t.name, this.blending = t.blending, this.side = t.side, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.stencilWriteMask = t.stencilWriteMask, this.stencilFunc = t.stencilFunc, this.stencilRef = t.stencilRef, this.stencilFuncMask = t.stencilFuncMask, this.stencilFail = t.stencilFail, this.stencilZFail = t.stencilZFail, this.stencilZPass = t.stencilZPass, this.stencilWrite = t.stencilWrite; let e = t.clippingPlanes, n = null; if (e !== null) { let r = e.length; n = new Array(r); for (let s = 0; s !== r; ++s)n[s] = e[s].clone() } return this.clippingPlanes = n, this.clipIntersection = t.clipIntersection, this.clipShadows = t.clipShadows, this.shadowSide = t.shadowSide, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.alphaToCoverage = t.alphaToCoverage, this.premultipliedAlpha = t.premultipliedAlpha, this.forceSinglePass = t.forceSinglePass, this.visible = t.visible, this.toneMapped = t.toneMapped, this.userData = JSON.parse(JSON.stringify(t.userData)), this } dispose () { this.dispatchEvent({ type: "dispose" }) } set needsUpdate (t) { t === !0 && this.version++ } }, po = class extends ul { constructor(t) { super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new Le(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = T_, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(t) } copy (t) { return super.copy(t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.fog = t.fog, this } }, On = new A, jp = new B, ze = class { constructor(t, e, n = !1) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.isBufferAttribute = !0, this.name = "", this.array = t, this.itemSize = e, this.count = t !== void 0 ? t.length / e : 0, this.normalized = n, this.usage = hx, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } onUploadCallback () { } set needsUpdate (t) { t === !0 && this.version++ } setUsage (t) { return this.usage = t, this } copy (t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.usage = t.usage, this } copyAt (t, e, n) { t *= this.itemSize, n *= e.itemSize; for (let r = 0, s = this.itemSize; r < s; r++)this.array[t + r] = e.array[n + r]; return this } copyArray (t) { return this.array.set(t), this } applyMatrix3 (t) { if (this.itemSize === 2) for (let e = 0, n = this.count; e < n; e++)jp.fromBufferAttribute(this, e), jp.applyMatrix3(t), this.setXY(e, jp.x, jp.y); else if (this.itemSize === 3) for (let e = 0, n = this.count; e < n; e++)On.fromBufferAttribute(this, e), On.applyMatrix3(t), this.setXYZ(e, On.x, On.y, On.z); return this } applyMatrix4 (t) { for (let e = 0, n = this.count; e < n; e++)On.fromBufferAttribute(this, e), On.applyMatrix4(t), this.setXYZ(e, On.x, On.y, On.z); return this } applyNormalMatrix (t) { for (let e = 0, n = this.count; e < n; e++)On.fromBufferAttribute(this, e), On.applyNormalMatrix(t), this.setXYZ(e, On.x, On.y, On.z); return this } transformDirection (t) { for (let e = 0, n = this.count; e < n; e++)On.fromBufferAttribute(this, e), On.transformDirection(t), this.setXYZ(e, On.x, On.y, On.z); return this } set (t, e = 0) { return this.array.set(t, e), this } getX (t) { let e = this.array[t * this.itemSize]; return this.normalized && (e = ho(e, this.array)), e } setX (t, e) { return this.normalized && (e = zt(e, this.array)), this.array[t * this.itemSize] = e, this } getY (t) { let e = this.array[t * this.itemSize + 1]; return this.normalized && (e = ho(e, this.array)), e } setY (t, e) { return this.normalized && (e = zt(e, this.array)), this.array[t * this.itemSize + 1] = e, this } getZ (t) { let e = this.array[t * this.itemSize + 2]; return this.normalized && (e = ho(e, this.array)), e } setZ (t, e) { return this.normalized && (e = zt(e, this.array)), this.array[t * this.itemSize + 2] = e, this } getW (t) { let e = this.array[t * this.itemSize + 3]; return this.normalized && (e = ho(e, this.array)), e } setW (t, e) { return this.normalized && (e = zt(e, this.array)), this.array[t * this.itemSize + 3] = e, this } setXY (t, e, n) { return t *= this.itemSize, this.normalized && (e = zt(e, this.array), n = zt(n, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this } setXYZ (t, e, n, r) { return t *= this.itemSize, this.normalized && (e = zt(e, this.array), n = zt(n, this.array), r = zt(r, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this } setXYZW (t, e, n, r, s) { return t *= this.itemSize, this.normalized && (e = zt(e, this.array), n = zt(n, this.array), r = zt(r, this.array), s = zt(s, this.array)), this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = s, this } onUpload (t) { return this.onUploadCallback = t, this } clone () { return new this.constructor(this.array, this.itemSize).copy(this) } toJSON () { let t = { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.from(this.array), normalized: this.normalized }; return this.name !== "" && (t.name = this.name), this.usage !== hx && (t.usage = this.usage), (this.updateRange.offset !== 0 || this.updateRange.count !== -1) && (t.updateRange = this.updateRange), t } copyColorsArray () { console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.") } copyVector2sArray () { console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.") } copyVector3sArray () { console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.") } copyVector4sArray () { console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.") } }; var xm = class extends ze { constructor(t, e, n) { super(new Uint16Array(t), e, n) } }; var xs = class extends ze { constructor(t, e, n) { super(new Uint32Array(t), e, n) } }; var _e = class extends ze { constructor(t, e, n) { super(new Float32Array(t), e, n) } }; var xL = 0, xi = new se, Y0 = new ft, pc = new A, si = new _t, Pd = new _t, $n = new A, Ce = class extends kt { constructor() { super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", { value: xL++ }), this.uuid = bi(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } getIndex () { return this.index } setIndex (t) { return Array.isArray(t) ? this.index = new (D_(t) ? xs : xm)(t, 1) : this.index = t, this } getAttribute (t) { return this.attributes[t] } setAttribute (t, e) { return this.attributes[t] = e, this } deleteAttribute (t) { return delete this.attributes[t], this } hasAttribute (t) { return this.attributes[t] !== void 0 } addGroup (t, e, n = 0) { this.groups.push({ start: t, count: e, materialIndex: n }) } clearGroups () { this.groups = [] } setDrawRange (t, e) { this.drawRange.start = t, this.drawRange.count = e } applyMatrix4 (t) { let e = this.attributes.position; e !== void 0 && (e.applyMatrix4(t), e.needsUpdate = !0); let n = this.attributes.normal; if (n !== void 0) { let s = new Xt().getNormalMatrix(t); n.applyNormalMatrix(s), n.needsUpdate = !0 } let r = this.attributes.tangent; return r !== void 0 && (r.transformDirection(t), r.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this } applyQuaternion (t) { return xi.makeRotationFromQuaternion(t), this.applyMatrix4(xi), this } rotateX (t) { return xi.makeRotationX(t), this.applyMatrix4(xi), this } rotateY (t) { return xi.makeRotationY(t), this.applyMatrix4(xi), this } rotateZ (t) { return xi.makeRotationZ(t), this.applyMatrix4(xi), this } translate (t, e, n) { return xi.makeTranslation(t, e, n), this.applyMatrix4(xi), this } scale (t, e, n) { return xi.makeScale(t, e, n), this.applyMatrix4(xi), this } lookAt (t) { return Y0.lookAt(t), Y0.updateMatrix(), this.applyMatrix4(Y0.matrix), this } center () { return this.computeBoundingBox(), this.boundingBox.getCenter(pc).negate(), this.translate(pc.x, pc.y, pc.z), this } setFromPoints (t) { let e = []; for (let n = 0, r = t.length; n < r; n++) { let s = t[n]; e.push(s.x, s.y, s.z || 0) } return this.setAttribute("position", new _e(e, 3)), this } computeBoundingBox () { this.boundingBox === null && (this.boundingBox = new _t); let t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingBox.set(new A(-1 / 0, -1 / 0, -1 / 0), new A(1 / 0, 1 / 0, 1 / 0)); return } if (t !== void 0) { if (this.boundingBox.setFromBufferAttribute(t), e) for (let n = 0, r = e.length; n < r; n++) { let s = e[n]; si.setFromBufferAttribute(s), this.morphTargetsRelative ? ($n.addVectors(this.boundingBox.min, si.min), this.boundingBox.expandByPoint($n), $n.addVectors(this.boundingBox.max, si.max), this.boundingBox.expandByPoint($n)) : (this.boundingBox.expandByPoint(si.min), this.boundingBox.expandByPoint(si.max)) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } computeBoundingSphere () { this.boundingSphere === null && (this.boundingSphere = new dn); let t = this.attributes.position, e = this.morphAttributes.position; if (t && t.isGLBufferAttribute) { console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), this.boundingSphere.set(new A, 1 / 0); return } if (t) { let n = this.boundingSphere.center; if (si.setFromBufferAttribute(t), e) for (let s = 0, o = e.length; s < o; s++) { let a = e[s]; Pd.setFromBufferAttribute(a), this.morphTargetsRelative ? ($n.addVectors(si.min, Pd.min), si.expandByPoint($n), $n.addVectors(si.max, Pd.max), si.expandByPoint($n)) : (si.expandByPoint(Pd.min), si.expandByPoint(Pd.max)) } si.getCenter(n); let r = 0; for (let s = 0, o = t.count; s < o; s++)$n.fromBufferAttribute(t, s), r = Math.max(r, n.distanceToSquared($n)); if (e) for (let s = 0, o = e.length; s < o; s++) { let a = e[s], l = this.morphTargetsRelative; for (let u = 0, c = a.count; u < c; u++)$n.fromBufferAttribute(a, u), l && (pc.fromBufferAttribute(t, u), $n.add(pc)), r = Math.max(r, n.distanceToSquared($n)) } this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } computeTangents () { let t = this.index, e = this.attributes; if (t === null || e.position === void 0 || e.normal === void 0 || e.uv === void 0) { console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"); return } let n = t.array, r = e.position.array, s = e.normal.array, o = e.uv.array, a = r.length / 3; this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new ze(new Float32Array(4 * a), 4)); let l = this.getAttribute("tangent").array, u = [], c = []; for (let T = 0; T < a; T++)u[T] = new A, c[T] = new A; let h = new A, d = new A, f = new A, p = new B, m = new B, g = new B, y = new A, v = new A; function x (T, I, C) { h.fromArray(r, T * 3), d.fromArray(r, I * 3), f.fromArray(r, C * 3), p.fromArray(o, T * 2), m.fromArray(o, I * 2), g.fromArray(o, C * 2), d.sub(h), f.sub(h), m.sub(p), g.sub(p); let P = 1 / (m.x * g.y - g.x * m.y); !isFinite(P) || (y.copy(d).multiplyScalar(g.y).addScaledVector(f, -m.y).multiplyScalar(P), v.copy(f).multiplyScalar(m.x).addScaledVector(d, -g.x).multiplyScalar(P), u[T].add(y), u[I].add(y), u[C].add(y), c[T].add(v), c[I].add(v), c[C].add(v)) } let b = this.groups; b.length === 0 && (b = [{ start: 0, count: n.length }]); for (let T = 0, I = b.length; T < I; ++T) { let C = b[T], P = C.start, D = C.count; for (let L = P, H = P + D; L < H; L += 3)x(n[L + 0], n[L + 1], n[L + 2]) } let S = new A, _ = new A, E = new A, w = new A; function M (T) { E.fromArray(s, T * 3), w.copy(E); let I = u[T]; S.copy(I), S.sub(E.multiplyScalar(E.dot(I))).normalize(), _.crossVectors(w, I); let P = _.dot(c[T]) < 0 ? -1 : 1; l[T * 4] = S.x, l[T * 4 + 1] = S.y, l[T * 4 + 2] = S.z, l[T * 4 + 3] = P } for (let T = 0, I = b.length; T < I; ++T) { let C = b[T], P = C.start, D = C.count; for (let L = P, H = P + D; L < H; L += 3)M(n[L + 0]), M(n[L + 1]), M(n[L + 2]) } } computeVertexNormals () { let t = this.index, e = this.getAttribute("position"); if (e !== void 0) { let n = this.getAttribute("normal"); if (n === void 0) n = new ze(new Float32Array(e.count * 3), 3), this.setAttribute("normal", n); else for (let d = 0, f = n.count; d < f; d++)n.setXYZ(d, 0, 0, 0); let r = new A, s = new A, o = new A, a = new A, l = new A, u = new A, c = new A, h = new A; if (t) for (let d = 0, f = t.count; d < f; d += 3) { let p = t.getX(d + 0), m = t.getX(d + 1), g = t.getX(d + 2); r.fromBufferAttribute(e, p), s.fromBufferAttribute(e, m), o.fromBufferAttribute(e, g), c.subVectors(o, s), h.subVectors(r, s), c.cross(h), a.fromBufferAttribute(n, p), l.fromBufferAttribute(n, m), u.fromBufferAttribute(n, g), a.add(c), l.add(c), u.add(c), n.setXYZ(p, a.x, a.y, a.z), n.setXYZ(m, l.x, l.y, l.z), n.setXYZ(g, u.x, u.y, u.z) } else for (let d = 0, f = e.count; d < f; d += 3)r.fromBufferAttribute(e, d + 0), s.fromBufferAttribute(e, d + 1), o.fromBufferAttribute(e, d + 2), c.subVectors(o, s), h.subVectors(r, s), c.cross(h), n.setXYZ(d + 0, c.x, c.y, c.z), n.setXYZ(d + 1, c.x, c.y, c.z), n.setXYZ(d + 2, c.x, c.y, c.z); this.normalizeNormals(), n.needsUpdate = !0 } } merge () { return console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead."), this } normalizeNormals () { let t = this.attributes.normal; for (let e = 0, n = t.count; e < n; e++)$n.fromBufferAttribute(t, e), $n.normalize(), t.setXYZ(e, $n.x, $n.y, $n.z) } toNonIndexed () { function t (a, l) { let u = a.array, c = a.itemSize, h = a.normalized, d = new u.constructor(l.length * c), f = 0, p = 0; for (let m = 0, g = l.length; m < g; m++) { a.isInterleavedBufferAttribute ? f = l[m] * a.data.stride + a.offset : f = l[m] * c; for (let y = 0; y < c; y++)d[p++] = u[f++] } return new ze(d, c, h) } if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this; let e = new Ce, n = this.index.array, r = this.attributes; for (let a in r) { let l = r[a], u = t(l, n); e.setAttribute(a, u) } let s = this.morphAttributes; for (let a in s) { let l = [], u = s[a]; for (let c = 0, h = u.length; c < h; c++) { let d = u[c], f = t(d, n); l.push(f) } e.morphAttributes[a] = l } e.morphTargetsRelative = this.morphTargetsRelative; let o = this.groups; for (let a = 0, l = o.length; a < l; a++) { let u = o[a]; e.addGroup(u.start, u.count, u.materialIndex) } return e } toJSON () { let t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), Object.keys(this.userData).length > 0 && (t.userData = this.userData), this.parameters !== void 0) { let l = this.parameters; for (let u in l) l[u] !== void 0 && (t[u] = l[u]); return t } t.data = { attributes: {} }; let e = this.index; e !== null && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) }); let n = this.attributes; for (let l in n) { let u = n[l]; t.data.attributes[l] = u.toJSON(t.data) } let r = {}, s = !1; for (let l in this.morphAttributes) { let u = this.morphAttributes[l], c = []; for (let h = 0, d = u.length; h < d; h++) { let f = u[h]; c.push(f.toJSON(t.data)) } c.length > 0 && (r[l] = c, s = !0) } s && (t.data.morphAttributes = r, t.data.morphTargetsRelative = this.morphTargetsRelative); let o = this.groups; o.length > 0 && (t.data.groups = JSON.parse(JSON.stringify(o))); let a = this.boundingSphere; return a !== null && (t.data.boundingSphere = { center: a.center.toArray(), radius: a.radius }), t } clone () { return new this.constructor().copy(this) } copy (t) { this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null; let e = {}; this.name = t.name; let n = t.index; n !== null && this.setIndex(n.clone(e)); let r = t.attributes; for (let u in r) { let c = r[u]; this.setAttribute(u, c.clone(e)) } let s = t.morphAttributes; for (let u in s) { let c = [], h = s[u]; for (let d = 0, f = h.length; d < f; d++)c.push(h[d].clone(e)); this.morphAttributes[u] = c } this.morphTargetsRelative = t.morphTargetsRelative; let o = t.groups; for (let u = 0, c = o.length; u < c; u++) { let h = o[u]; this.addGroup(h.start, h.count, h.materialIndex) } let a = t.boundingBox; a !== null && (this.boundingBox = a.clone()); let l = t.boundingSphere; return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, t.parameters !== void 0 && (this.parameters = Object.assign({}, t.parameters)), this } dispose () { this.dispatchEvent({ type: "dispose" }) } }, NA = new se, mc = new Wi, X0 = new dn, Id = new A, Dd = new A, Od = new A, Q0 = new A, Wp = new A, qp = new B, Yp = new B, Xp = new B, K0 = new A, Qp = new A, Rn = class extends ft { constructor(t = new Ce, e = new po) { super(), this.isMesh = !0, this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets() } copy (t, e) { return super.copy(t, e), t.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), t.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this.material = t.material, this.geometry = t.geometry, this } updateMorphTargets () { let e = this.geometry.morphAttributes, n = Object.keys(e); if (n.length > 0) { let r = e[n[0]]; if (r !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, o = r.length; s < o; s++) { let a = r[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s } } } } getVertexPosition (t, e) { let n = this.geometry, r = n.attributes.position, s = n.morphAttributes.position, o = n.morphTargetsRelative; e.fromBufferAttribute(r, t); let a = this.morphTargetInfluences; if (s && a) { Wp.set(0, 0, 0); for (let l = 0, u = s.length; l < u; l++) { let c = a[l], h = s[l]; c !== 0 && (Q0.fromBufferAttribute(h, t), o ? Wp.addScaledVector(Q0, c) : Wp.addScaledVector(Q0.sub(e), c)) } e.add(Wp) } return this.isSkinnedMesh && this.boneTransform(t, e), e } raycast (t, e) { let n = this.geometry, r = this.material, s = this.matrixWorld; if (r === void 0 || (n.boundingSphere === null && n.computeBoundingSphere(), X0.copy(n.boundingSphere), X0.applyMatrix4(s), t.ray.intersectsSphere(X0) === !1) || (NA.copy(s).invert(), mc.copy(t.ray).applyMatrix4(NA), n.boundingBox !== null && mc.intersectsBox(n.boundingBox) === !1)) return; let o, a = n.index, l = n.attributes.position, u = n.attributes.uv, c = n.attributes.uv2, h = n.groups, d = n.drawRange; if (a !== null) if (Array.isArray(r)) for (let f = 0, p = h.length; f < p; f++) { let m = h[f], g = r[m.materialIndex], y = Math.max(m.start, d.start), v = Math.min(a.count, Math.min(m.start + m.count, d.start + d.count)); for (let x = y, b = v; x < b; x += 3) { let S = a.getX(x), _ = a.getX(x + 1), E = a.getX(x + 2); o = Kp(this, g, t, mc, u, c, S, _, E), o && (o.faceIndex = Math.floor(x / 3), o.face.materialIndex = m.materialIndex, e.push(o)) } } else { let f = Math.max(0, d.start), p = Math.min(a.count, d.start + d.count); for (let m = f, g = p; m < g; m += 3) { let y = a.getX(m), v = a.getX(m + 1), x = a.getX(m + 2); o = Kp(this, r, t, mc, u, c, y, v, x), o && (o.faceIndex = Math.floor(m / 3), e.push(o)) } } else if (l !== void 0) if (Array.isArray(r)) for (let f = 0, p = h.length; f < p; f++) { let m = h[f], g = r[m.materialIndex], y = Math.max(m.start, d.start), v = Math.min(l.count, Math.min(m.start + m.count, d.start + d.count)); for (let x = y, b = v; x < b; x += 3) { let S = x, _ = x + 1, E = x + 2; o = Kp(this, g, t, mc, u, c, S, _, E), o && (o.faceIndex = Math.floor(x / 3), o.face.materialIndex = m.materialIndex, e.push(o)) } } else { let f = Math.max(0, d.start), p = Math.min(l.count, d.start + d.count); for (let m = f, g = p; m < g; m += 3) { let y = m, v = m + 1, x = m + 2; o = Kp(this, r, t, mc, u, c, y, v, x), o && (o.faceIndex = Math.floor(m / 3), e.push(o)) } } } }; function bL (i, t, e, n, r, s, o, a) { let l; if (t.side === Ln ? l = n.intersectTriangle(o, s, r, !0, a) : l = n.intersectTriangle(r, s, o, t.side === ai, a), l === null) return null; Qp.copy(a), Qp.applyMatrix4(i.matrixWorld); let u = e.ray.origin.distanceTo(Qp); return u < e.near || u > e.far ? null : { distance: u, point: Qp.clone(), object: i } } function Kp (i, t, e, n, r, s, o, a, l) { i.getVertexPosition(o, Id), i.getVertexPosition(a, Dd), i.getVertexPosition(l, Od); let u = bL(i, t, e, n, Id, Dd, Od, K0); if (u) { r && (qp.fromBufferAttribute(r, o), Yp.fromBufferAttribute(r, a), Xp.fromBufferAttribute(r, l), u.uv = nn.getUV(K0, Id, Dd, Od, qp, Yp, Xp, new B)), s && (qp.fromBufferAttribute(s, o), Yp.fromBufferAttribute(s, a), Xp.fromBufferAttribute(s, l), u.uv2 = nn.getUV(K0, Id, Dd, Od, qp, Yp, Xp, new B)); let c = { a: o, b: a, c: l, normal: new A, materialIndex: 0 }; nn.getNormal(Id, Dd, Od, c.normal), u.face = c } return u } var er = class extends Ce { constructor(t = 1, e = 1, n = 1, r = 1, s = 1, o = 1) { super(), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: n, widthSegments: r, heightSegments: s, depthSegments: o }; let a = this; r = Math.floor(r), s = Math.floor(s), o = Math.floor(o); let l = [], u = [], c = [], h = [], d = 0, f = 0; p("z", "y", "x", -1, -1, n, e, t, o, s, 0), p("z", "y", "x", 1, -1, n, e, -t, o, s, 1), p("x", "z", "y", 1, 1, t, n, e, r, o, 2), p("x", "z", "y", 1, -1, t, n, -e, r, o, 3), p("x", "y", "z", 1, -1, t, e, n, r, s, 4), p("x", "y", "z", -1, -1, t, e, -n, r, s, 5), this.setIndex(l), this.setAttribute("position", new _e(u, 3)), this.setAttribute("normal", new _e(c, 3)), this.setAttribute("uv", new _e(h, 2)); function p (m, g, y, v, x, b, S, _, E, w, M) { let T = b / E, I = S / w, C = b / 2, P = S / 2, D = _ / 2, L = E + 1, H = w + 1, U = 0, V = 0, G = new A; for (let z = 0; z < H; z++) { let $ = z * I - P; for (let F = 0; F < L; F++) { let j = F * T - C; G[m] = j * v, G[g] = $ * x, G[y] = D, u.push(G.x, G.y, G.z), G[m] = 0, G[g] = 0, G[y] = _ > 0 ? 1 : -1, c.push(G.x, G.y, G.z), h.push(F / E), h.push(1 - z / w), U += 1 } } for (let z = 0; z < w; z++)for (let $ = 0; $ < E; $++) { let F = d + $ + L * z, j = d + $ + L * (z + 1), X = d + ($ + 1) + L * (z + 1), q = d + ($ + 1) + L * z; l.push(F, j, q), l.push(j, X, q), V += 6 } a.addGroup(f, V, M), f += V, d += U } } static fromJSON (t) { return new er(t.width, t.height, t.depth, t.widthSegments, t.heightSegments, t.depthSegments) } }; function Tc (i) { let t = {}; for (let e in i) { t[e] = {}; for (let n in i[e]) { let r = i[e][n]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture || r.isQuaternion) ? t[e][n] = r.clone() : Array.isArray(r) ? t[e][n] = r.slice() : t[e][n] = r } } return t } function Lr (i) { let t = {}; for (let e = 0; e < i.length; e++) { let n = Tc(i[e]); for (let r in n) t[r] = n[r] } return t } function wL (i) { let t = []; for (let e = 0; e < i.length; e++)t.push(i[e].clone()); return t } function R_ (i) { return i.getRenderTarget() === null && i.outputEncoding === Je ? gs : Gd } var Yi = { clone: Tc, merge: Lr }, SL = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, AL = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`, it = class extends ul { constructor(t) { super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = SL, this.fragmentShader = AL, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, t !== void 0 && this.setValues(t) } copy (t) { return super.copy(t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = Tc(t.uniforms), this.uniformsGroups = wL(t.uniformsGroups), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.fog = t.fog, this.lights = t.lights, this.clipping = t.clipping, this.extensions = Object.assign({}, t.extensions), this.glslVersion = t.glslVersion, this } toJSON (t) { let e = super.toJSON(t); e.glslVersion = this.glslVersion, e.uniforms = {}; for (let r in this.uniforms) { let o = this.uniforms[r].value; o && o.isTexture ? e.uniforms[r] = { type: "t", value: o.toJSON(t).uuid } : o && o.isColor ? e.uniforms[r] = { type: "c", value: o.getHex() } : o && o.isVector2 ? e.uniforms[r] = { type: "v2", value: o.toArray() } : o && o.isVector3 ? e.uniforms[r] = { type: "v3", value: o.toArray() } : o && o.isVector4 ? e.uniforms[r] = { type: "v4", value: o.toArray() } : o && o.isMatrix3 ? e.uniforms[r] = { type: "m3", value: o.toArray() } : o && o.isMatrix4 ? e.uniforms[r] = { type: "m4", value: o.toArray() } : e.uniforms[r] = { value: o } } Object.keys(this.defines).length > 0 && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader; let n = {}; for (let r in this.extensions) this.extensions[r] === !0 && (n[r] = !0); return Object.keys(n).length > 0 && (e.extensions = n), e } }, qi = class extends ft { constructor() { super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new se, this.projectionMatrix = new se, this.projectionMatrixInverse = new se } copy (t, e) { return super.copy(t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this } getWorldDirection (t) { this.updateWorldMatrix(!0, !1); let e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() } updateMatrixWorld (t) { super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix (t, e) { super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } clone () { return new this.constructor().copy(this) } }, xn = class extends qi { constructor(t = 50, e = 1, n = .1, r = 2e3) { super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } copy (t, e) { return super.copy(t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = t.view === null ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this } setFocalLength (t) { let e = .5 * this.getFilmHeight() / t; this.fov = Vd * 2 * Math.atan(e), this.updateProjectionMatrix() } getFocalLength () { let t = Math.tan(Bd * .5 * this.fov); return .5 * this.getFilmHeight() / t } getEffectiveFOV () { return Vd * 2 * Math.atan(Math.tan(Bd * .5 * this.fov) / this.zoom) } getFilmWidth () { return this.filmGauge * Math.min(this.aspect, 1) } getFilmHeight () { return this.filmGauge / Math.max(this.aspect, 1) } setViewOffset (t, e, n, r, s, o) { this.aspect = t / e, this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix() } clearViewOffset () { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix () { let t = this.near, e = t * Math.tan(Bd * .5 * this.fov) / this.zoom, n = 2 * e, r = this.aspect * n, s = -.5 * r, o = this.view; if (this.view !== null && this.view.enabled) { let l = o.fullWidth, u = o.fullHeight; s += o.offsetX * r / l, e -= o.offsetY * n / u, r *= o.width / l, n *= o.height / u } let a = this.filmOffset; a !== 0 && (s += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON (t) { let e = super.toJSON(t); return e.object.fov = this.fov, e.object.zoom = this.zoom, e.object.near = this.near, e.object.far = this.far, e.object.focus = this.focus, e.object.aspect = this.aspect, this.view !== null && (e.object.view = Object.assign({}, this.view)), e.object.filmGauge = this.filmGauge, e.object.filmOffset = this.filmOffset, e } }, gc = -90, yc = 1, px = class extends ft { constructor(t, e, n) { super(), this.type = "CubeCamera", this.renderTarget = n; let r = new xn(gc, yc, t, e); r.layers = this.layers, r.up.set(0, 1, 0), r.lookAt(1, 0, 0), this.add(r); let s = new xn(gc, yc, t, e); s.layers = this.layers, s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), this.add(s); let o = new xn(gc, yc, t, e); o.layers = this.layers, o.up.set(0, 0, -1), o.lookAt(0, 1, 0), this.add(o); let a = new xn(gc, yc, t, e); a.layers = this.layers, a.up.set(0, 0, 1), a.lookAt(0, -1, 0), this.add(a); let l = new xn(gc, yc, t, e); l.layers = this.layers, l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l); let u = new xn(gc, yc, t, e); u.layers = this.layers, u.up.set(0, 1, 0), u.lookAt(0, 0, -1), this.add(u) } update (t, e) { this.parent === null && this.updateMatrixWorld(); let n = this.renderTarget, [r, s, o, a, l, u] = this.children, c = t.getRenderTarget(), h = t.toneMapping, d = t.xr.enabled; t.toneMapping = fo, t.xr.enabled = !1; let f = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, s), t.setRenderTarget(n, 2), t.render(e, o), t.setRenderTarget(n, 3), t.render(e, a), t.setRenderTarget(n, 4), t.render(e, l), n.texture.generateMipmaps = f, t.setRenderTarget(n, 5), t.render(e, u), t.setRenderTarget(c), t.toneMapping = h, t.xr.enabled = d, n.texture.needsPMREMUpdate = !0 } }, Cc = class extends Qt { constructor(t, e, n, r, s, o, a, l, u, c) { t = t !== void 0 ? t : [], e = e !== void 0 ? e : ta, super(t, e, n, r, s, o, a, l, u, c), this.isCubeTexture = !0, this.flipY = !1 } get images () { return this.image } set images (t) { this.image = t } }, mx = class extends at {
		constructor(t = 1, e = {}) { super(t, t, e), this.isWebGLCubeRenderTarget = !0; let n = { width: t, height: t, depth: 1 }, r = [n, n, n, n, n, n]; this.texture = new Cc(r, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = e.generateMipmaps !== void 0 ? e.generateMipmaps : !1, this.texture.minFilter = e.minFilter !== void 0 ? e.minFilter : Ke } fromEquirectangularTexture (t, e) {
			this.texture.type = e.type, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter; let n = {
				uniforms: { tEquirect: { value: null } }, vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`, fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`}, r = new er(5, 5, 5), s = new it({ name: "CubemapFromEquirect", uniforms: Tc(n.uniforms), vertexShader: n.vertexShader, fragmentShader: n.fragmentShader, side: Ln, blending: Ot }); s.uniforms.tEquirect.value = e; let o = new Rn(r, s), a = e.minFilter; return e.minFilter === ll && (e.minFilter = Ke), new px(1, 10, this).update(t, o), e.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
		} clear (t, e, n, r) { let s = t.getRenderTarget(); for (let o = 0; o < 6; o++)t.setRenderTarget(this, o), t.clear(e, n, r); t.setRenderTarget(s) }
	}, Z0 = new A, _L = new A, EL = new Xt, bn = class { constructor(t = new A(1, 0, 0), e = 0) { this.isPlane = !0, this.normal = t, this.constant = e } set (t, e) { return this.normal.copy(t), this.constant = e, this } setComponents (t, e, n, r) { return this.normal.set(t, e, n), this.constant = r, this } setFromNormalAndCoplanarPoint (t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this } setFromCoplanarPoints (t, e, n) { let r = Z0.subVectors(n, e).cross(_L.subVectors(t, e)).normalize(); return this.setFromNormalAndCoplanarPoint(r, t), this } copy (t) { return this.normal.copy(t.normal), this.constant = t.constant, this } normalize () { let t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this } negate () { return this.constant *= -1, this.normal.negate(), this } distanceToPoint (t) { return this.normal.dot(t) + this.constant } distanceToSphere (t) { return this.distanceToPoint(t.center) - t.radius } projectPoint (t, e) { return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) } intersectLine (t, e) { let n = t.delta(Z0), r = this.normal.dot(n); if (r === 0) return this.distanceToPoint(t.start) === 0 ? e.copy(t.start) : null; let s = -(t.start.dot(this.normal) + this.constant) / r; return s < 0 || s > 1 ? null : e.copy(n).multiplyScalar(s).add(t.start) } intersectsLine (t) { let e = this.distanceToPoint(t.start), n = this.distanceToPoint(t.end); return e < 0 && n > 0 || n < 0 && e > 0 } intersectsBox (t) { return t.intersectsPlane(this) } intersectsSphere (t) { return t.intersectsPlane(this) } coplanarPoint (t) { return t.copy(this.normal).multiplyScalar(-this.constant) } applyMatrix4 (t, e) { let n = e || EL.getNormalMatrix(t), r = this.coplanarPoint(Z0).applyMatrix4(t), s = this.normal.applyMatrix3(n).normalize(); return this.constant = -r.dot(s), this } translate (t) { return this.constant -= t.dot(this.normal), this } equals (t) { return t.normal.equals(this.normal) && t.constant === this.constant } clone () { return new this.constructor().copy(this) } }, vc = new dn, Zp = new A, jd = class { constructor(t = new bn, e = new bn, n = new bn, r = new bn, s = new bn, o = new bn) { this.planes = [t, e, n, r, s, o] } set (t, e, n, r, s, o) { let a = this.planes; return a[0].copy(t), a[1].copy(e), a[2].copy(n), a[3].copy(r), a[4].copy(s), a[5].copy(o), this } copy (t) { let e = this.planes; for (let n = 0; n < 6; n++)e[n].copy(t.planes[n]); return this } setFromProjectionMatrix (t) { let e = this.planes, n = t.elements, r = n[0], s = n[1], o = n[2], a = n[3], l = n[4], u = n[5], c = n[6], h = n[7], d = n[8], f = n[9], p = n[10], m = n[11], g = n[12], y = n[13], v = n[14], x = n[15]; return e[0].setComponents(a - r, h - l, m - d, x - g).normalize(), e[1].setComponents(a + r, h + l, m + d, x + g).normalize(), e[2].setComponents(a + s, h + u, m + f, x + y).normalize(), e[3].setComponents(a - s, h - u, m - f, x - y).normalize(), e[4].setComponents(a - o, h - c, m - p, x - v).normalize(), e[5].setComponents(a + o, h + c, m + p, x + v).normalize(), this } intersectsObject (t) { let e = t.geometry; return e.boundingSphere === null && e.computeBoundingSphere(), vc.copy(e.boundingSphere).applyMatrix4(t.matrixWorld), this.intersectsSphere(vc) } intersectsSprite (t) { return vc.center.set(0, 0, 0), vc.radius = .7071067811865476, vc.applyMatrix4(t.matrixWorld), this.intersectsSphere(vc) } intersectsSphere (t) { let e = this.planes, n = t.center, r = -t.radius; for (let s = 0; s < 6; s++)if (e[s].distanceToPoint(n) < r) return !1; return !0 } intersectsBox (t) { let e = this.planes; for (let n = 0; n < 6; n++) { let r = e[n]; if (Zp.x = r.normal.x > 0 ? t.max.x : t.min.x, Zp.y = r.normal.y > 0 ? t.max.y : t.min.y, Zp.z = r.normal.z > 0 ? t.max.z : t.min.z, r.distanceToPoint(Zp) < 0) return !1 } return !0 } containsPoint (t) { let e = this.planes; for (let n = 0; n < 6; n++)if (e[n].distanceToPoint(t) < 0) return !1; return !0 } clone () { return new this.constructor().copy(this) } }; function L_ () { let i = null, t = !1, e = null, n = null; function r (s, o) { e(s, o), n = i.requestAnimationFrame(r) } return { start: function () { t !== !0 && e !== null && (n = i.requestAnimationFrame(r), t = !0) }, stop: function () { i.cancelAnimationFrame(n), t = !1 }, setAnimationLoop: function (s) { e = s }, setContext: function (s) { i = s } } } function ML (i, t) { let e = t.isWebGL2, n = new WeakMap; function r (u, c) { let h = u.array, d = u.usage, f = i.createBuffer(); i.bindBuffer(c, f), i.bufferData(c, h, d), u.onUploadCallback(); let p; if (h instanceof Float32Array) p = 5126; else if (h instanceof Uint16Array) if (u.isFloat16BufferAttribute) if (e) p = 5131; else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."); else p = 5123; else if (h instanceof Int16Array) p = 5122; else if (h instanceof Uint32Array) p = 5125; else if (h instanceof Int32Array) p = 5124; else if (h instanceof Int8Array) p = 5120; else if (h instanceof Uint8Array) p = 5121; else if (h instanceof Uint8ClampedArray) p = 5121; else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h); return { buffer: f, type: p, bytesPerElement: h.BYTES_PER_ELEMENT, version: u.version } } function s (u, c, h) { let d = c.array, f = c.updateRange; i.bindBuffer(h, u), f.count === -1 ? i.bufferSubData(h, 0, d) : (e ? i.bufferSubData(h, f.offset * d.BYTES_PER_ELEMENT, d, f.offset, f.count) : i.bufferSubData(h, f.offset * d.BYTES_PER_ELEMENT, d.subarray(f.offset, f.offset + f.count)), f.count = -1), c.onUploadCallback() } function o (u) { return u.isInterleavedBufferAttribute && (u = u.data), n.get(u) } function a (u) { u.isInterleavedBufferAttribute && (u = u.data); let c = n.get(u); c && (i.deleteBuffer(c.buffer), n.delete(u)) } function l (u, c) { if (u.isGLBufferAttribute) { let d = n.get(u); (!d || d.version < u.version) && n.set(u, { buffer: u.buffer, type: u.type, bytesPerElement: u.elementSize, version: u.version }); return } u.isInterleavedBufferAttribute && (u = u.data); let h = n.get(u); h === void 0 ? n.set(u, r(u, c)) : h.version < u.version && (s(h.buffer, u, c), h.version = u.version) } return { get: o, remove: a, update: l } } var mo = class extends Ce { constructor(t = 1, e = 1, n = 1, r = 1) { super(), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: n, heightSegments: r }; let s = t / 2, o = e / 2, a = Math.floor(n), l = Math.floor(r), u = a + 1, c = l + 1, h = t / a, d = e / l, f = [], p = [], m = [], g = []; for (let y = 0; y < c; y++) { let v = y * d - o; for (let x = 0; x < u; x++) { let b = x * h - s; p.push(b, -v, 0), m.push(0, 0, 1), g.push(x / a), g.push(1 - y / l) } } for (let y = 0; y < l; y++)for (let v = 0; v < a; v++) { let x = v + u * y, b = v + u * (y + 1), S = v + 1 + u * (y + 1), _ = v + 1 + u * y; f.push(x, b, _), f.push(b, S, _) } this.setIndex(f), this.setAttribute("position", new _e(p, 3)), this.setAttribute("normal", new _e(m, 3)), this.setAttribute("uv", new _e(g, 2)) } static fromJSON (t) { return new mo(t.width, t.height, t.widthSegments, t.heightSegments) } }, TL = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`, CL = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, PL = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`, IL = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`, DL = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`, OL = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`, RL = "vec3 transformed = vec3( position );", LL = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`, NL = `vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
#ifdef USE_IRIDESCENCE
	vec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`, BL = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`, FL = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`, kL = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`, UL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`, zL = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`, GL = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`, VL = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`, HL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`, jL = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`, WL = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`, qL = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`, YL = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`, XL = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`, QL = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`, KL = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`, ZL = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`, JL = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`, $L = "gl_FragColor = linearToOutputTexel( gl_FragColor );", e3 = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`, t3 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`, n3 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`, r3 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`, i3 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`, s3 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`, o3 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`, a3 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`, l3 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`, c3 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`, u3 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`, h3 = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`, d3 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`, f3 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`, p3 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`, m3 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`, g3 = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`, y3 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`, v3 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`, x3 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`, b3 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`, w3 = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`, S3 = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	#ifdef USE_IRIDESCENCE
		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );
	#else
		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	#endif
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`, A3 = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`, _3 = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`, E3 = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`, M3 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`, T3 = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`, C3 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`, P3 = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`, I3 = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`, D3 = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`, O3 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`, R3 = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`, L3 = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`, N3 = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`, B3 = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`, F3 = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`, k3 = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`, U3 = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`, z3 = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`, G3 = `#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`, V3 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, H3 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`, j3 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`, W3 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`, q3 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`, Y3 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`, X3 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`, Q3 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`, K3 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`, Z3 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`, J3 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`, $3 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`, eN = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`, tN = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`, nN = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`, rN = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`, iN = `#if NUM_SPOT_LIGHT_COORDS > 0
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
  uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`, sN = `#if NUM_SPOT_LIGHT_COORDS > 0
  uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
  varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`, oN = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`, aN = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`, lN = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`, cN = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`, uN = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`, hN = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`, dN = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`, fN = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`, pN = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`, mN = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`, gN = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`, yN = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef texture2DLodEXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`, vN = `#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`, xN = `#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`, bN = `#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`, wN = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`, SN = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`, AN = `#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`, _N = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`, EN = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`, MN = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, TN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, CN = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, PN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`, IN = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, DN = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`, ON = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`, RN = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`, LN = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`, NN = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`, BN = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`, FN = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, kN = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, UN = `#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`, zN = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, GN = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, VN = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, HN = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`, jN = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, WN = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`, qN = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`, YN = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, XN = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, QN = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`, KN = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, ZN = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, JN = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`, $N = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`, eB = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`, tB = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`, nB = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, rB = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`, iB = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`, ot = { alphamap_fragment: TL, alphamap_pars_fragment: CL, alphatest_fragment: PL, alphatest_pars_fragment: IL, aomap_fragment: DL, aomap_pars_fragment: OL, begin_vertex: RL, beginnormal_vertex: LL, bsdfs: NL, iridescence_fragment: BL, bumpmap_pars_fragment: FL, clipping_planes_fragment: kL, clipping_planes_pars_fragment: UL, clipping_planes_pars_vertex: zL, clipping_planes_vertex: GL, color_fragment: VL, color_pars_fragment: HL, color_pars_vertex: jL, color_vertex: WL, common: qL, cube_uv_reflection_fragment: YL, defaultnormal_vertex: XL, displacementmap_pars_vertex: QL, displacementmap_vertex: KL, emissivemap_fragment: ZL, emissivemap_pars_fragment: JL, encodings_fragment: $L, encodings_pars_fragment: e3, envmap_fragment: t3, envmap_common_pars_fragment: n3, envmap_pars_fragment: r3, envmap_pars_vertex: i3, envmap_physical_pars_fragment: g3, envmap_vertex: s3, fog_vertex: o3, fog_pars_vertex: a3, fog_fragment: l3, fog_pars_fragment: c3, gradientmap_pars_fragment: u3, lightmap_fragment: h3, lightmap_pars_fragment: d3, lights_lambert_fragment: f3, lights_lambert_pars_fragment: p3, lights_pars_begin: m3, lights_toon_fragment: y3, lights_toon_pars_fragment: v3, lights_phong_fragment: x3, lights_phong_pars_fragment: b3, lights_physical_fragment: w3, lights_physical_pars_fragment: S3, lights_fragment_begin: A3, lights_fragment_maps: _3, lights_fragment_end: E3, logdepthbuf_fragment: M3, logdepthbuf_pars_fragment: T3, logdepthbuf_pars_vertex: C3, logdepthbuf_vertex: P3, map_fragment: I3, map_pars_fragment: D3, map_particle_fragment: O3, map_particle_pars_fragment: R3, metalnessmap_fragment: L3, metalnessmap_pars_fragment: N3, morphcolor_vertex: B3, morphnormal_vertex: F3, morphtarget_pars_vertex: k3, morphtarget_vertex: U3, normal_fragment_begin: z3, normal_fragment_maps: G3, normal_pars_fragment: V3, normal_pars_vertex: H3, normal_vertex: j3, normalmap_pars_fragment: W3, clearcoat_normal_fragment_begin: q3, clearcoat_normal_fragment_maps: Y3, clearcoat_pars_fragment: X3, iridescence_pars_fragment: Q3, output_fragment: K3, packing: Z3, premultiplied_alpha_fragment: J3, project_vertex: $3, dithering_fragment: eN, dithering_pars_fragment: tN, roughnessmap_fragment: nN, roughnessmap_pars_fragment: rN, shadowmap_pars_fragment: iN, shadowmap_pars_vertex: sN, shadowmap_vertex: oN, shadowmask_pars_fragment: aN, skinbase_vertex: lN, skinning_pars_vertex: cN, skinning_vertex: uN, skinnormal_vertex: hN, specularmap_fragment: dN, specularmap_pars_fragment: fN, tonemapping_fragment: pN, tonemapping_pars_fragment: mN, transmission_fragment: gN, transmission_pars_fragment: yN, uv_pars_fragment: vN, uv_pars_vertex: xN, uv_vertex: bN, uv2_pars_fragment: wN, uv2_pars_vertex: SN, uv2_vertex: AN, worldpos_vertex: _N, background_vert: EN, background_frag: MN, backgroundCube_vert: TN, backgroundCube_frag: CN, cube_vert: PN, cube_frag: IN, depth_vert: DN, depth_frag: ON, distanceRGBA_vert: RN, distanceRGBA_frag: LN, equirect_vert: NN, equirect_frag: BN, linedashed_vert: FN, linedashed_frag: kN, meshbasic_vert: UN, meshbasic_frag: zN, meshlambert_vert: GN, meshlambert_frag: VN, meshmatcap_vert: HN, meshmatcap_frag: jN, meshnormal_vert: WN, meshnormal_frag: qN, meshphong_vert: YN, meshphong_frag: XN, meshphysical_vert: QN, meshphysical_frag: KN, meshtoon_vert: ZN, meshtoon_frag: JN, points_vert: $N, points_frag: eB, shadow_vert: tB, shadow_frag: nB, sprite_vert: rB, sprite_frag: iB }, xe = { common: { diffuse: { value: new Le(16777215) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new Xt }, uv2Transform: { value: new Xt }, alphaMap: { value: null }, alphaTest: { value: 0 } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, ior: { value: 1.5 }, refractionRatio: { value: .98 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new B(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new Le(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {} } }, directionalLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {} } }, spotLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotLightMap: { value: [] }, spotShadowMap: { value: [] }, spotLightMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {} } }, pointLightShadows: { value: [], properties: { shadowBias: {}, shadowNormalBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } }, ltc_1: { value: null }, ltc_2: { value: null } }, points: { diffuse: { value: new Le(16777215) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Xt } }, sprite: { diffuse: { value: new Le(16777215) }, opacity: { value: 1 }, center: { value: new B(.5, .5) }, rotation: { value: 0 }, map: { value: null }, alphaMap: { value: null }, alphaTest: { value: 0 }, uvTransform: { value: new Xt } } }, ys = { basic: { uniforms: Lr([xe.common, xe.specularmap, xe.envmap, xe.aomap, xe.lightmap, xe.fog]), vertexShader: ot.meshbasic_vert, fragmentShader: ot.meshbasic_frag }, lambert: { uniforms: Lr([xe.common, xe.specularmap, xe.envmap, xe.aomap, xe.lightmap, xe.emissivemap, xe.bumpmap, xe.normalmap, xe.displacementmap, xe.fog, xe.lights, { emissive: { value: new Le(0) } }]), vertexShader: ot.meshlambert_vert, fragmentShader: ot.meshlambert_frag }, phong: { uniforms: Lr([xe.common, xe.specularmap, xe.envmap, xe.aomap, xe.lightmap, xe.emissivemap, xe.bumpmap, xe.normalmap, xe.displacementmap, xe.fog, xe.lights, { emissive: { value: new Le(0) }, specular: { value: new Le(1118481) }, shininess: { value: 30 } }]), vertexShader: ot.meshphong_vert, fragmentShader: ot.meshphong_frag }, standard: { uniforms: Lr([xe.common, xe.envmap, xe.aomap, xe.lightmap, xe.emissivemap, xe.bumpmap, xe.normalmap, xe.displacementmap, xe.roughnessmap, xe.metalnessmap, xe.fog, xe.lights, { emissive: { value: new Le(0) }, roughness: { value: 1 }, metalness: { value: 0 }, envMapIntensity: { value: 1 } }]), vertexShader: ot.meshphysical_vert, fragmentShader: ot.meshphysical_frag }, toon: { uniforms: Lr([xe.common, xe.aomap, xe.lightmap, xe.emissivemap, xe.bumpmap, xe.normalmap, xe.displacementmap, xe.gradientmap, xe.fog, xe.lights, { emissive: { value: new Le(0) } }]), vertexShader: ot.meshtoon_vert, fragmentShader: ot.meshtoon_frag }, matcap: { uniforms: Lr([xe.common, xe.bumpmap, xe.normalmap, xe.displacementmap, xe.fog, { matcap: { value: null } }]), vertexShader: ot.meshmatcap_vert, fragmentShader: ot.meshmatcap_frag }, points: { uniforms: Lr([xe.points, xe.fog]), vertexShader: ot.points_vert, fragmentShader: ot.points_frag }, dashed: { uniforms: Lr([xe.common, xe.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: ot.linedashed_vert, fragmentShader: ot.linedashed_frag }, depth: { uniforms: Lr([xe.common, xe.displacementmap]), vertexShader: ot.depth_vert, fragmentShader: ot.depth_frag }, normal: { uniforms: Lr([xe.common, xe.bumpmap, xe.normalmap, xe.displacementmap, { opacity: { value: 1 } }]), vertexShader: ot.meshnormal_vert, fragmentShader: ot.meshnormal_frag }, sprite: { uniforms: Lr([xe.sprite, xe.fog]), vertexShader: ot.sprite_vert, fragmentShader: ot.sprite_frag }, background: { uniforms: { uvTransform: { value: new Xt }, t2D: { value: null }, backgroundIntensity: { value: 1 } }, vertexShader: ot.background_vert, fragmentShader: ot.background_frag }, backgroundCube: { uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 }, backgroundBlurriness: { value: 0 }, backgroundIntensity: { value: 1 } }, vertexShader: ot.backgroundCube_vert, fragmentShader: ot.backgroundCube_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: ot.cube_vert, fragmentShader: ot.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: ot.equirect_vert, fragmentShader: ot.equirect_frag }, distanceRGBA: { uniforms: Lr([xe.common, xe.displacementmap, { referencePosition: { value: new A }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: ot.distanceRGBA_vert, fragmentShader: ot.distanceRGBA_frag }, shadow: { uniforms: Lr([xe.lights, xe.fog, { color: { value: new Le(0) }, opacity: { value: 1 } }]), vertexShader: ot.shadow_vert, fragmentShader: ot.shadow_frag } }; ys.physical = { uniforms: Lr([ys.standard.uniforms, { clearcoat: { value: 0 }, clearcoatMap: { value: null }, clearcoatRoughness: { value: 0 }, clearcoatRoughnessMap: { value: null }, clearcoatNormalScale: { value: new B(1, 1) }, clearcoatNormalMap: { value: null }, iridescence: { value: 0 }, iridescenceMap: { value: null }, iridescenceIOR: { value: 1.3 }, iridescenceThicknessMinimum: { value: 100 }, iridescenceThicknessMaximum: { value: 400 }, iridescenceThicknessMap: { value: null }, sheen: { value: 0 }, sheenColor: { value: new Le(0) }, sheenColorMap: { value: null }, sheenRoughness: { value: 1 }, sheenRoughnessMap: { value: null }, transmission: { value: 0 }, transmissionMap: { value: null }, transmissionSamplerSize: { value: new B }, transmissionSamplerMap: { value: null }, thickness: { value: 0 }, thicknessMap: { value: null }, attenuationDistance: { value: 0 }, attenuationColor: { value: new Le(0) }, specularIntensity: { value: 1 }, specularIntensityMap: { value: null }, specularColor: { value: new Le(1, 1, 1) }, specularColorMap: { value: null } }]), vertexShader: ot.meshphysical_vert, fragmentShader: ot.meshphysical_frag }; var Jp = { r: 0, b: 0, g: 0 }; function sB (i, t, e, n, r, s, o) { let a = new Le(0), l = s === !0 ? 0 : 1, u, c, h = null, d = 0, f = null; function p (g, y) { let v = !1, x = y.isScene === !0 ? y.background : null; x && x.isTexture && (x = (y.backgroundBlurriness > 0 ? e : t).get(x)); let b = i.xr, S = b.getSession && b.getSession(); S && S.environmentBlendMode === "additive" && (x = null), x === null ? m(a, l) : x && x.isColor && (m(x, 1), v = !0), (i.autoClear || v) && i.clear(i.autoClearColor, i.autoClearDepth, i.autoClearStencil), x && (x.isCubeTexture || x.mapping === Yc) ? (c === void 0 && (c = new Rn(new er(1, 1, 1), new it({ name: "BackgroundCubeMaterial", uniforms: Tc(ys.backgroundCube.uniforms), vertexShader: ys.backgroundCube.vertexShader, fragmentShader: ys.backgroundCube.fragmentShader, side: Ln, depthTest: !1, depthWrite: !1, fog: !1 })), c.geometry.deleteAttribute("normal"), c.geometry.deleteAttribute("uv"), c.onBeforeRender = function (_, E, w) { this.matrixWorld.copyPosition(w.matrixWorld) }, Object.defineProperty(c.material, "envMap", { get: function () { return this.uniforms.envMap.value } }), r.update(c)), c.material.uniforms.envMap.value = x, c.material.uniforms.flipEnvMap.value = x.isCubeTexture && x.isRenderTargetTexture === !1 ? -1 : 1, c.material.uniforms.backgroundBlurriness.value = y.backgroundBlurriness, c.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, c.material.toneMapped = x.encoding !== Je, (h !== x || d !== x.version || f !== i.toneMapping) && (c.material.needsUpdate = !0, h = x, d = x.version, f = i.toneMapping), c.layers.enableAll(), g.unshift(c, c.geometry, c.material, 0, 0, null)) : x && x.isTexture && (u === void 0 && (u = new Rn(new mo(2, 2), new it({ name: "BackgroundMaterial", uniforms: Tc(ys.background.uniforms), vertexShader: ys.background.vertexShader, fragmentShader: ys.background.fragmentShader, side: ai, depthTest: !1, depthWrite: !1, fog: !1 })), u.geometry.deleteAttribute("normal"), Object.defineProperty(u.material, "map", { get: function () { return this.uniforms.t2D.value } }), r.update(u)), u.material.uniforms.t2D.value = x, u.material.uniforms.backgroundIntensity.value = y.backgroundIntensity, u.material.toneMapped = x.encoding !== Je, x.matrixAutoUpdate === !0 && x.updateMatrix(), u.material.uniforms.uvTransform.value.copy(x.matrix), (h !== x || d !== x.version || f !== i.toneMapping) && (u.material.needsUpdate = !0, h = x, d = x.version, f = i.toneMapping), u.layers.enableAll(), g.unshift(u, u.geometry, u.material, 0, 0, null)) } function m (g, y) { g.getRGB(Jp, R_(i)), n.buffers.color.setClear(Jp.r, Jp.g, Jp.b, y, o) } return { getClearColor: function () { return a }, setClearColor: function (g, y = 1) { a.set(g), l = y, m(a, l) }, getClearAlpha: function () { return l }, setClearAlpha: function (g) { l = g, m(a, l) }, render: p } } function oB (i, t, e, n) { let r = i.getParameter(34921), s = n.isWebGL2 ? null : t.get("OES_vertex_array_object"), o = n.isWebGL2 || s !== null, a = {}, l = g(null), u = l, c = !1; function h (D, L, H, U, V) { let G = !1; if (o) { let z = m(U, H, L); u !== z && (u = z, f(u.object)), G = y(D, U, H, V), G && v(D, U, H, V) } else { let z = L.wireframe === !0; (u.geometry !== U.id || u.program !== H.id || u.wireframe !== z) && (u.geometry = U.id, u.program = H.id, u.wireframe = z, G = !0) } V !== null && e.update(V, 34963), (G || c) && (c = !1, w(D, L, H, U), V !== null && i.bindBuffer(34963, e.get(V).buffer)) } function d () { return n.isWebGL2 ? i.createVertexArray() : s.createVertexArrayOES() } function f (D) { return n.isWebGL2 ? i.bindVertexArray(D) : s.bindVertexArrayOES(D) } function p (D) { return n.isWebGL2 ? i.deleteVertexArray(D) : s.deleteVertexArrayOES(D) } function m (D, L, H) { let U = H.wireframe === !0, V = a[D.id]; V === void 0 && (V = {}, a[D.id] = V); let G = V[L.id]; G === void 0 && (G = {}, V[L.id] = G); let z = G[U]; return z === void 0 && (z = g(d()), G[U] = z), z } function g (D) { let L = [], H = [], U = []; for (let V = 0; V < r; V++)L[V] = 0, H[V] = 0, U[V] = 0; return { geometry: null, program: null, wireframe: !1, newAttributes: L, enabledAttributes: H, attributeDivisors: U, object: D, attributes: {}, index: null } } function y (D, L, H, U) { let V = u.attributes, G = L.attributes, z = 0, $ = H.getAttributes(); for (let F in $) if ($[F].location >= 0) { let X = V[F], q = G[F]; if (q === void 0 && (F === "instanceMatrix" && D.instanceMatrix && (q = D.instanceMatrix), F === "instanceColor" && D.instanceColor && (q = D.instanceColor)), X === void 0 || X.attribute !== q || q && X.data !== q.data) return !0; z++ } return u.attributesNum !== z || u.index !== U } function v (D, L, H, U) { let V = {}, G = L.attributes, z = 0, $ = H.getAttributes(); for (let F in $) if ($[F].location >= 0) { let X = G[F]; X === void 0 && (F === "instanceMatrix" && D.instanceMatrix && (X = D.instanceMatrix), F === "instanceColor" && D.instanceColor && (X = D.instanceColor)); let q = {}; q.attribute = X, X && X.data && (q.data = X.data), V[F] = q, z++ } u.attributes = V, u.attributesNum = z, u.index = U } function x () { let D = u.newAttributes; for (let L = 0, H = D.length; L < H; L++)D[L] = 0 } function b (D) { S(D, 0) } function S (D, L) { let H = u.newAttributes, U = u.enabledAttributes, V = u.attributeDivisors; H[D] = 1, U[D] === 0 && (i.enableVertexAttribArray(D), U[D] = 1), V[D] !== L && ((n.isWebGL2 ? i : t.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](D, L), V[D] = L) } function _ () { let D = u.newAttributes, L = u.enabledAttributes; for (let H = 0, U = L.length; H < U; H++)L[H] !== D[H] && (i.disableVertexAttribArray(H), L[H] = 0) } function E (D, L, H, U, V, G) { n.isWebGL2 === !0 && (H === 5124 || H === 5125) ? i.vertexAttribIPointer(D, L, H, V, G) : i.vertexAttribPointer(D, L, H, U, V, G) } function w (D, L, H, U) { if (n.isWebGL2 === !1 && (D.isInstancedMesh || U.isInstancedBufferGeometry) && t.get("ANGLE_instanced_arrays") === null) return; x(); let V = U.attributes, G = H.getAttributes(), z = L.defaultAttributeValues; for (let $ in G) { let F = G[$]; if (F.location >= 0) { let j = V[$]; if (j === void 0 && ($ === "instanceMatrix" && D.instanceMatrix && (j = D.instanceMatrix), $ === "instanceColor" && D.instanceColor && (j = D.instanceColor)), j !== void 0) { let X = j.normalized, q = j.itemSize, k = e.get(j); if (k === void 0) continue; let Z = k.buffer, K = k.type, Q = k.bytesPerElement; if (j.isInterleavedBufferAttribute) { let W = j.data, ge = W.stride, de = j.offset; if (W.isInstancedInterleavedBuffer) { for (let ie = 0; ie < F.locationSize; ie++)S(F.location + ie, W.meshPerAttribute); D.isInstancedMesh !== !0 && U._maxInstanceCount === void 0 && (U._maxInstanceCount = W.meshPerAttribute * W.count) } else for (let ie = 0; ie < F.locationSize; ie++)b(F.location + ie); i.bindBuffer(34962, Z); for (let ie = 0; ie < F.locationSize; ie++)E(F.location + ie, q / F.locationSize, K, X, ge * Q, (de + q / F.locationSize * ie) * Q) } else { if (j.isInstancedBufferAttribute) { for (let W = 0; W < F.locationSize; W++)S(F.location + W, j.meshPerAttribute); D.isInstancedMesh !== !0 && U._maxInstanceCount === void 0 && (U._maxInstanceCount = j.meshPerAttribute * j.count) } else for (let W = 0; W < F.locationSize; W++)b(F.location + W); i.bindBuffer(34962, Z); for (let W = 0; W < F.locationSize; W++)E(F.location + W, q / F.locationSize, K, X, q * Q, q / F.locationSize * W * Q) } } else if (z !== void 0) { let X = z[$]; if (X !== void 0) switch (X.length) { case 2: i.vertexAttrib2fv(F.location, X); break; case 3: i.vertexAttrib3fv(F.location, X); break; case 4: i.vertexAttrib4fv(F.location, X); break; default: i.vertexAttrib1fv(F.location, X) } } } } _() } function M () { C(); for (let D in a) { let L = a[D]; for (let H in L) { let U = L[H]; for (let V in U) p(U[V].object), delete U[V]; delete L[H] } delete a[D] } } function T (D) { if (a[D.id] === void 0) return; let L = a[D.id]; for (let H in L) { let U = L[H]; for (let V in U) p(U[V].object), delete U[V]; delete L[H] } delete a[D.id] } function I (D) { for (let L in a) { let H = a[L]; if (H[D.id] === void 0) continue; let U = H[D.id]; for (let V in U) p(U[V].object), delete U[V]; delete H[D.id] } } function C () { P(), c = !0, u !== l && (u = l, f(u.object)) } function P () { l.geometry = null, l.program = null, l.wireframe = !1 } return { setup: h, reset: C, resetDefaultState: P, dispose: M, releaseStatesOfGeometry: T, releaseStatesOfProgram: I, initAttributes: x, enableAttribute: b, disableUnusedAttributes: _ } } function aB (i, t, e, n) { let r = n.isWebGL2, s; function o (u) { s = u } function a (u, c) { i.drawArrays(s, u, c), e.update(c, s, 1) } function l (u, c, h) { if (h === 0) return; let d, f; if (r) d = i, f = "drawArraysInstanced"; else if (d = t.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", d === null) { console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } d[f](s, u, c, h), e.update(c, s, h) } this.setMode = o, this.render = a, this.renderInstances = l } function lB (i, t, e) { let n; function r () { if (n !== void 0) return n; if (t.has("EXT_texture_filter_anisotropic") === !0) { let E = t.get("EXT_texture_filter_anisotropic"); n = i.getParameter(E.MAX_TEXTURE_MAX_ANISOTROPY_EXT) } else n = 0; return n } function s (E) { if (E === "highp") { if (i.getShaderPrecisionFormat(35633, 36338).precision > 0 && i.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp"; E = "mediump" } return E === "mediump" && i.getShaderPrecisionFormat(35633, 36337).precision > 0 && i.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp" } let o = typeof WebGL2RenderingContext < "u" && i instanceof WebGL2RenderingContext, a = e.precision !== void 0 ? e.precision : "highp", l = s(a); l !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", l, "instead."), a = l); let u = o || t.has("WEBGL_draw_buffers"), c = e.logarithmicDepthBuffer === !0, h = i.getParameter(34930), d = i.getParameter(35660), f = i.getParameter(3379), p = i.getParameter(34076), m = i.getParameter(34921), g = i.getParameter(36347), y = i.getParameter(36348), v = i.getParameter(36349), x = d > 0, b = o || t.has("OES_texture_float"), S = x && b, _ = o ? i.getParameter(36183) : 0; return { isWebGL2: o, drawBuffers: u, getMaxAnisotropy: r, getMaxPrecision: s, precision: a, logarithmicDepthBuffer: c, maxTextures: h, maxVertexTextures: d, maxTextureSize: f, maxCubemapSize: p, maxAttributes: m, maxVertexUniforms: g, maxVaryings: y, maxFragmentUniforms: v, vertexTextures: x, floatFragmentTextures: b, floatVertexTextures: S, maxSamples: _ } } function cB (i) { let t = this, e = null, n = 0, r = !1, s = !1, o = new bn, a = new Xt, l = { value: null, needsUpdate: !1 }; this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function (h, d) { let f = h.length !== 0 || d || n !== 0 || r; return r = d, n = h.length, f }, this.beginShadows = function () { s = !0, c(null) }, this.endShadows = function () { s = !1 }, this.setGlobalState = function (h, d) { e = c(h, d, 0) }, this.setState = function (h, d, f) { let p = h.clippingPlanes, m = h.clipIntersection, g = h.clipShadows, y = i.get(h); if (!r || p === null || p.length === 0 || s && !g) s ? c(null) : u(); else { let v = s ? 0 : n, x = v * 4, b = y.clippingState || null; l.value = b, b = c(p, d, x, f); for (let S = 0; S !== x; ++S)b[S] = e[S]; y.clippingState = b, this.numIntersection = m ? this.numPlanes : 0, this.numPlanes += v } }; function u () { l.value !== e && (l.value = e, l.needsUpdate = n > 0), t.numPlanes = n, t.numIntersection = 0 } function c (h, d, f, p) { let m = h !== null ? h.length : 0, g = null; if (m !== 0) { if (g = l.value, p !== !0 || g === null) { let y = f + m * 4, v = d.matrixWorldInverse; a.getNormalMatrix(v), (g === null || g.length < y) && (g = new Float32Array(y)); for (let x = 0, b = f; x !== m; ++x, b += 4)o.copy(h[x]).applyMatrix4(v, a), o.normal.toArray(g, b), g[b + 3] = o.constant } l.value = g, l.needsUpdate = !0 } return t.numPlanes = m, t.numIntersection = 0, g } } function uB (i) { let t = new WeakMap; function e (o, a) { return a === lx ? o.mapping = ta : a === cx && (o.mapping = na), o } function n (o) { if (o && o.isTexture && o.isRenderTargetTexture === !1) { let a = o.mapping; if (a === lx || a === cx) if (t.has(o)) { let l = t.get(o).texture; return e(l, o.mapping) } else { let l = o.image; if (l && l.height > 0) { let u = new mx(l.height / 2); return u.fromEquirectangularTexture(i, o), t.set(o, u), o.addEventListener("dispose", r), e(u.texture, o.mapping) } else return null } } return o } function r (o) { let a = o.target; a.removeEventListener("dispose", r); let l = t.get(a); l !== void 0 && (t.delete(a), l.dispose()) } function s () { t = new WeakMap } return { get: n, dispose: s } } var Pc = class extends qi { constructor(t = -1, e = 1, n = 1, r = -1, s = .1, o = 2e3) { super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = s, this.far = o, this.updateProjectionMatrix() } copy (t, e) { return super.copy(t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = t.view === null ? null : Object.assign({}, t.view), this } setViewOffset (t, e, n, r, s, o) { this.view === null && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = s, this.view.height = o, this.updateProjectionMatrix() } clearViewOffset () { this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix() } updateProjectionMatrix () { let t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), n = (this.right + this.left) / 2, r = (this.top + this.bottom) / 2, s = n - t, o = n + t, a = r + e, l = r - e; if (this.view !== null && this.view.enabled) { let u = (this.right - this.left) / this.view.fullWidth / this.zoom, c = (this.top - this.bottom) / this.view.fullHeight / this.zoom; s += u * this.view.offsetX, o = s + u * this.view.width, a -= c * this.view.offsetY, l = a - c * this.view.height } this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert() } toJSON (t) { let e = super.toJSON(t); return e.object.zoom = this.zoom, e.object.left = this.left, e.object.right = this.right, e.object.top = this.top, e.object.bottom = this.bottom, e.object.near = this.near, e.object.far = this.far, this.view !== null && (e.object.view = Object.assign({}, this.view)), e } }, Ac = 4, BA = [.125, .215, .35, .446, .526, .582], sl = 20, J0 = new Pc, FA = new Le, $0 = null, il = (1 + Math.sqrt(5)) / 2, xc = 1 / il, kA = [new A(1, 1, 1), new A(-1, 1, 1), new A(1, 1, -1), new A(-1, 1, -1), new A(0, il, xc), new A(0, il, -xc), new A(xc, 0, il), new A(-xc, 0, il), new A(il, xc, 0), new A(-il, xc, 0)], bm = class { constructor(t) { this._renderer = t, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial) } fromScene (t, e = 0, n = .1, r = 100) { $0 = this._renderer.getRenderTarget(), this._setSize(256); let s = this._allocateTargets(); return s.depthBuffer = !0, this._sceneToCubeUV(t, n, r, s), e > 0 && this._blur(s, 0, 0, e), this._applyPMREM(s), this._cleanup(s), s } fromEquirectangular (t, e = null) { return this._fromTexture(t, e) } fromCubemap (t, e = null) { return this._fromTexture(t, e) } compileCubemapShader () { this._cubemapMaterial === null && (this._cubemapMaterial = GA(), this._compileMaterial(this._cubemapMaterial)) } compileEquirectangularShader () { this._equirectMaterial === null && (this._equirectMaterial = zA(), this._compileMaterial(this._equirectMaterial)) } dispose () { this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose() } _setSize (t) { this._lodMax = Math.floor(Math.log2(t)), this._cubeSize = Math.pow(2, this._lodMax) } _dispose () { this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose(); for (let t = 0; t < this._lodPlanes.length; t++)this._lodPlanes[t].dispose() } _cleanup (t) { this._renderer.setRenderTarget($0), t.scissorTest = !1, $p(t, 0, 0, t.width, t.height) } _fromTexture (t, e) { t.mapping === ta || t.mapping === na ? this._setSize(t.image.length === 0 ? 16 : t.image[0].width || t.image[0].image.width) : this._setSize(t.image.width / 4), $0 = this._renderer.getRenderTarget(); let n = e || this._allocateTargets(); return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n } _allocateTargets () { let t = 3 * Math.max(this._cubeSize, 112), e = 4 * this._cubeSize, n = { magFilter: Ke, minFilter: Ke, generateMipmaps: !1, type: cl, format: oi, encoding: li, depthBuffer: !1 }, r = UA(t, e, n); if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== t || this._pingPongRenderTarget.height !== e) { this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = UA(t, e, n); let { _lodMax: s } = this; ({ sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas } = hB(s)), this._blurMaterial = dB(s, t, e) } return r } _compileMaterial (t) { let e = new Rn(this._lodPlanes[0], t); this._renderer.compile(e, J0) } _sceneToCubeUV (t, e, n, r) { let a = new xn(90, 1, e, n), l = [1, -1, 1, 1, 1, 1], u = [1, 1, 1, -1, -1, -1], c = this._renderer, h = c.autoClear, d = c.toneMapping; c.getClearColor(FA), c.toneMapping = fo, c.autoClear = !1; let f = new po({ name: "PMREM.Background", side: Ln, depthWrite: !1, depthTest: !1 }), p = new Rn(new er, f), m = !1, g = t.background; g ? g.isColor && (f.color.copy(g), t.background = null, m = !0) : (f.color.copy(FA), m = !0); for (let y = 0; y < 6; y++) { let v = y % 3; v === 0 ? (a.up.set(0, l[y], 0), a.lookAt(u[y], 0, 0)) : v === 1 ? (a.up.set(0, 0, l[y]), a.lookAt(0, u[y], 0)) : (a.up.set(0, l[y], 0), a.lookAt(0, 0, u[y])); let x = this._cubeSize; $p(r, v * x, y > 2 ? x : 0, x, x), c.setRenderTarget(r), m && c.render(p, a), c.render(t, a) } p.geometry.dispose(), p.material.dispose(), c.toneMapping = d, c.autoClear = h, t.background = g } _textureToCubeUV (t, e) { let n = this._renderer, r = t.mapping === ta || t.mapping === na; r ? (this._cubemapMaterial === null && (this._cubemapMaterial = GA()), this._cubemapMaterial.uniforms.flipEnvMap.value = t.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = zA()); let s = r ? this._cubemapMaterial : this._equirectMaterial, o = new Rn(this._lodPlanes[0], s), a = s.uniforms; a.envMap.value = t; let l = this._cubeSize; $p(e, 0, 0, 3 * l, 2 * l), n.setRenderTarget(e), n.render(o, J0) } _applyPMREM (t) { let e = this._renderer, n = e.autoClear; e.autoClear = !1; for (let r = 1; r < this._lodPlanes.length; r++) { let s = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]), o = kA[(r - 1) % kA.length]; this._blur(t, r - 1, r, s, o) } e.autoClear = n } _blur (t, e, n, r, s) { let o = this._pingPongRenderTarget; this._halfBlur(t, o, e, n, r, "latitudinal", s), this._halfBlur(o, t, n, n, r, "longitudinal", s) } _halfBlur (t, e, n, r, s, o, a) { let l = this._renderer, u = this._blurMaterial; o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!"); let c = 3, h = new Rn(this._lodPlanes[r], u), d = u.uniforms, f = this._sizeLods[n] - 1, p = isFinite(s) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * sl - 1), m = s / p, g = isFinite(s) ? 1 + Math.floor(c * m) : sl; g > sl && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${g} samples when the maximum is set to ${sl}`); let y = [], v = 0; for (let E = 0; E < sl; ++E) { let w = E / m, M = Math.exp(-w * w / 2); y.push(M), E === 0 ? v += M : E < g && (v += 2 * M) } for (let E = 0; E < y.length; E++)y[E] = y[E] / v; d.envMap.value = t.texture, d.samples.value = g, d.weights.value = y, d.latitudinal.value = o === "latitudinal", a && (d.poleAxis.value = a); let { _lodMax: x } = this; d.dTheta.value = p, d.mipInt.value = x - n; let b = this._sizeLods[r], S = 3 * b * (r > x - Ac ? r - x + Ac : 0), _ = 4 * (this._cubeSize - b); $p(e, S, _, 3 * b, 2 * b), l.setRenderTarget(e), l.render(h, J0) } }; function hB (i) { let t = [], e = [], n = [], r = i, s = i - Ac + 1 + BA.length; for (let o = 0; o < s; o++) { let a = Math.pow(2, r); e.push(a); let l = 1 / a; o > i - Ac ? l = BA[o - i + Ac - 1] : o === 0 && (l = 0), n.push(l); let u = 1 / (a - 2), c = -u, h = 1 + u, d = [c, c, h, c, h, h, c, c, h, h, c, h], f = 6, p = 6, m = 3, g = 2, y = 1, v = new Float32Array(m * p * f), x = new Float32Array(g * p * f), b = new Float32Array(y * p * f); for (let _ = 0; _ < f; _++) { let E = _ % 3 * 2 / 3 - 1, w = _ > 2 ? 0 : -1, M = [E, w, 0, E + 2 / 3, w, 0, E + 2 / 3, w + 1, 0, E, w, 0, E + 2 / 3, w + 1, 0, E, w + 1, 0]; v.set(M, m * p * _), x.set(d, g * p * _); let T = [_, _, _, _, _, _]; b.set(T, y * p * _) } let S = new Ce; S.setAttribute("position", new ze(v, m)), S.setAttribute("uv", new ze(x, g)), S.setAttribute("faceIndex", new ze(b, y)), t.push(S), r > Ac && r-- } return { lodPlanes: t, sizeLods: e, sigmas: n } } function UA (i, t, e) { let n = new at(i, t, e); return n.texture.mapping = Yc, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n } function $p (i, t, e, n, r) { i.viewport.set(t, e, n, r), i.scissor.set(t, e, n, r) } function dB (i, t, e) {
	let n = new Float32Array(sl), r = new A(0, 1, 0); return new it({
		name: "SphericalGaussianBlur", defines: { n: sl, CUBEUV_TEXEL_WIDTH: 1 / t, CUBEUV_TEXEL_HEIGHT: 1 / e, CUBEUV_MAX_MIP: `${i}.0` }, uniforms: { envMap: { value: null }, samples: { value: 1 }, weights: { value: n }, latitudinal: { value: !1 }, dTheta: { value: 0 }, mipInt: { value: 0 }, poleAxis: { value: r } }, vertexShader: Qx(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`, blending: Ot, depthTest: !1, depthWrite: !1
	})
} function zA () {
	return new it({
		name: "EquirectangularToCubeUV", uniforms: { envMap: { value: null } }, vertexShader: Qx(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`, blending: Ot, depthTest: !1, depthWrite: !1
	})
} function GA () {
	return new it({
		name: "CubemapToCubeUV", uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } }, vertexShader: Qx(), fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`, blending: Ot, depthTest: !1, depthWrite: !1
	})
} function Qx () {
	return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`} function fB (i) { let t = new WeakMap, e = null; function n (a) { if (a && a.isTexture) { let l = a.mapping, u = l === lx || l === cx, c = l === ta || l === na; if (u || c) if (a.isRenderTargetTexture && a.needsPMREMUpdate === !0) { a.needsPMREMUpdate = !1; let h = t.get(a); return e === null && (e = new bm(i)), h = u ? e.fromEquirectangular(a, h) : e.fromCubemap(a, h), t.set(a, h), h.texture } else { if (t.has(a)) return t.get(a).texture; { let h = a.image; if (u && h && h.height > 0 || c && h && r(h)) { e === null && (e = new bm(i)); let d = u ? e.fromEquirectangular(a) : e.fromCubemap(a); return t.set(a, d), a.addEventListener("dispose", s), d.texture } else return null } } } return a } function r (a) { let l = 0, u = 6; for (let c = 0; c < u; c++)a[c] !== void 0 && l++; return l === u } function s (a) { let l = a.target; l.removeEventListener("dispose", s); let u = t.get(l); u !== void 0 && (t.delete(l), u.dispose()) } function o () { t = new WeakMap, e !== null && (e.dispose(), e = null) } return { get: n, dispose: o } } function pB (i) { let t = {}; function e (n) { if (t[n] !== void 0) return t[n]; let r; switch (n) { case "WEBGL_depth_texture": r = i.getExtension("WEBGL_depth_texture") || i.getExtension("MOZ_WEBGL_depth_texture") || i.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": r = i.getExtension("EXT_texture_filter_anisotropic") || i.getExtension("MOZ_EXT_texture_filter_anisotropic") || i.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": r = i.getExtension("WEBGL_compressed_texture_s3tc") || i.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": r = i.getExtension("WEBGL_compressed_texture_pvrtc") || i.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: r = i.getExtension(n) }return t[n] = r, r } return { has: function (n) { return e(n) !== null }, init: function (n) { n.isWebGL2 ? e("EXT_color_buffer_float") : (e("WEBGL_depth_texture"), e("OES_texture_float"), e("OES_texture_half_float"), e("OES_texture_half_float_linear"), e("OES_standard_derivatives"), e("OES_element_index_uint"), e("OES_vertex_array_object"), e("ANGLE_instanced_arrays")), e("OES_texture_float_linear"), e("EXT_color_buffer_half_float"), e("WEBGL_multisampled_render_to_texture") }, get: function (n) { let r = e(n); return r === null && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."), r } } } function mB (i, t, e, n) { let r = {}, s = new WeakMap; function o (h) { let d = h.target; d.index !== null && t.remove(d.index); for (let p in d.attributes) t.remove(d.attributes[p]); d.removeEventListener("dispose", o), delete r[d.id]; let f = s.get(d); f && (t.remove(f), s.delete(d)), n.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, e.memory.geometries-- } function a (h, d) { return r[d.id] === !0 || (d.addEventListener("dispose", o), r[d.id] = !0, e.memory.geometries++), d } function l (h) { let d = h.attributes; for (let p in d) t.update(d[p], 34962); let f = h.morphAttributes; for (let p in f) { let m = f[p]; for (let g = 0, y = m.length; g < y; g++)t.update(m[g], 34962) } } function u (h) { let d = [], f = h.index, p = h.attributes.position, m = 0; if (f !== null) { let v = f.array; m = f.version; for (let x = 0, b = v.length; x < b; x += 3) { let S = v[x + 0], _ = v[x + 1], E = v[x + 2]; d.push(S, _, _, E, E, S) } } else { let v = p.array; m = p.version; for (let x = 0, b = v.length / 3 - 1; x < b; x += 3) { let S = x + 0, _ = x + 1, E = x + 2; d.push(S, _, _, E, E, S) } } let g = new (D_(d) ? xs : xm)(d, 1); g.version = m; let y = s.get(h); y && t.remove(y), s.set(h, g) } function c (h) { let d = s.get(h); if (d) { let f = h.index; f !== null && d.version < f.version && u(h) } else u(h); return s.get(h) } return { get: a, update: l, getWireframeAttribute: c } } function gB (i, t, e, n) { let r = n.isWebGL2, s; function o (d) { s = d } let a, l; function u (d) { a = d.type, l = d.bytesPerElement } function c (d, f) { i.drawElements(s, f, a, d * l), e.update(f, s, 1) } function h (d, f, p) { if (p === 0) return; let m, g; if (r) m = i, g = "drawElementsInstanced"; else if (m = t.get("ANGLE_instanced_arrays"), g = "drawElementsInstancedANGLE", m === null) { console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); return } m[g](s, f, a, d * l, p), e.update(f, s, p) } this.setMode = o, this.setIndex = u, this.render = c, this.renderInstances = h } function yB (i) { let t = { geometries: 0, textures: 0 }, e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; function n (s, o, a) { switch (e.calls++, o) { case 4: e.triangles += a * (s / 3); break; case 1: e.lines += a * (s / 2); break; case 3: e.lines += a * (s - 1); break; case 2: e.lines += a * s; break; case 0: e.points += a * s; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", o); break } } function r () { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 } return { memory: t, render: e, programs: null, autoReset: !0, reset: r, update: n } } function vB (i, t) { return i[0] - t[0] } function xB (i, t) { return Math.abs(t[1]) - Math.abs(i[1]) } function bB (i, t, e) { let n = {}, r = new Float32Array(8), s = new WeakMap, o = new qe, a = []; for (let u = 0; u < 8; u++)a[u] = [u, 0]; function l (u, c, h, d) { let f = u.morphTargetInfluences; if (t.isWebGL2 === !0) { let p = c.morphAttributes.position || c.morphAttributes.normal || c.morphAttributes.color, m = p !== void 0 ? p.length : 0, g = s.get(c); if (g === void 0 || g.count !== m) { let L = function () { P.dispose(), s.delete(c), c.removeEventListener("dispose", L) }; g !== void 0 && g.texture.dispose(); let x = c.morphAttributes.position !== void 0, b = c.morphAttributes.normal !== void 0, S = c.morphAttributes.color !== void 0, _ = c.morphAttributes.position || [], E = c.morphAttributes.normal || [], w = c.morphAttributes.color || [], M = 0; x === !0 && (M = 1), b === !0 && (M = 2), S === !0 && (M = 3); let T = c.attributes.position.count * M, I = 1; T > t.maxTextureSize && (I = Math.ceil(T / t.maxTextureSize), T = t.maxTextureSize); let C = new Float32Array(T * I * 4 * m), P = new gm(C, T, I, m); P.type = gr, P.needsUpdate = !0; let D = M * 4; for (let H = 0; H < m; H++) { let U = _[H], V = E[H], G = w[H], z = T * I * 4 * H; for (let $ = 0; $ < U.count; $++) { let F = $ * D; x === !0 && (o.fromBufferAttribute(U, $), C[z + F + 0] = o.x, C[z + F + 1] = o.y, C[z + F + 2] = o.z, C[z + F + 3] = 0), b === !0 && (o.fromBufferAttribute(V, $), C[z + F + 4] = o.x, C[z + F + 5] = o.y, C[z + F + 6] = o.z, C[z + F + 7] = 0), S === !0 && (o.fromBufferAttribute(G, $), C[z + F + 8] = o.x, C[z + F + 9] = o.y, C[z + F + 10] = o.z, C[z + F + 11] = G.itemSize === 4 ? o.w : 1) } } g = { count: m, texture: P, size: new B(T, I) }, s.set(c, g), c.addEventListener("dispose", L) } let y = 0; for (let x = 0; x < f.length; x++)y += f[x]; let v = c.morphTargetsRelative ? 1 : 1 - y; d.getUniforms().setValue(i, "morphTargetBaseInfluence", v), d.getUniforms().setValue(i, "morphTargetInfluences", f), d.getUniforms().setValue(i, "morphTargetsTexture", g.texture, e), d.getUniforms().setValue(i, "morphTargetsTextureSize", g.size) } else { let p = f === void 0 ? 0 : f.length, m = n[c.id]; if (m === void 0 || m.length !== p) { m = []; for (let b = 0; b < p; b++)m[b] = [b, 0]; n[c.id] = m } for (let b = 0; b < p; b++) { let S = m[b]; S[0] = b, S[1] = f[b] } m.sort(xB); for (let b = 0; b < 8; b++)b < p && m[b][1] ? (a[b][0] = m[b][0], a[b][1] = m[b][1]) : (a[b][0] = Number.MAX_SAFE_INTEGER, a[b][1] = 0); a.sort(vB); let g = c.morphAttributes.position, y = c.morphAttributes.normal, v = 0; for (let b = 0; b < 8; b++) { let S = a[b], _ = S[0], E = S[1]; _ !== Number.MAX_SAFE_INTEGER && E ? (g && c.getAttribute("morphTarget" + b) !== g[_] && c.setAttribute("morphTarget" + b, g[_]), y && c.getAttribute("morphNormal" + b) !== y[_] && c.setAttribute("morphNormal" + b, y[_]), r[b] = E, v += E) : (g && c.hasAttribute("morphTarget" + b) === !0 && c.deleteAttribute("morphTarget" + b), y && c.hasAttribute("morphNormal" + b) === !0 && c.deleteAttribute("morphNormal" + b), r[b] = 0) } let x = c.morphTargetsRelative ? 1 : 1 - v; d.getUniforms().setValue(i, "morphTargetBaseInfluence", x), d.getUniforms().setValue(i, "morphTargetInfluences", r) } } return { update: l } } function wB (i, t, e, n) { let r = new WeakMap; function s (l) { let u = n.render.frame, c = l.geometry, h = t.get(l, c); return r.get(h) !== u && (t.update(h), r.set(h, u)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), e.update(l.instanceMatrix, 34962), l.instanceColor !== null && e.update(l.instanceColor, 34962)), h } function o () { r = new WeakMap } function a (l) { let u = l.target; u.removeEventListener("dispose", a), e.remove(u.instanceMatrix), u.instanceColor !== null && e.remove(u.instanceColor) } return { update: s, dispose: o } } var N_ = new Qt, B_ = new gm, F_ = new ym, k_ = new Cc, VA = [], HA = [], jA = new Float32Array(16), WA = new Float32Array(9), qA = new Float32Array(4); function Xc (i, t, e) { let n = i[0]; if (n <= 0 || n > 0) return i; let r = t * e, s = VA[r]; if (s === void 0 && (s = new Float32Array(r), VA[r] = s), t !== 0) { n.toArray(s, 0); for (let o = 1, a = 0; o !== t; ++o)a += e, i[o].toArray(s, a) } return s } function Gn (i, t) { if (i.length !== t.length) return !1; for (let e = 0, n = i.length; e < n; e++)if (i[e] !== t[e]) return !1; return !0 } function Vn (i, t) { for (let e = 0, n = t.length; e < n; e++)i[e] = t[e] } function km (i, t) { let e = HA[t]; e === void 0 && (e = new Int32Array(t), HA[t] = e); for (let n = 0; n !== t; ++n)e[n] = i.allocateTextureUnit(); return e } function SB (i, t) { let e = this.cache; e[0] !== t && (i.uniform1f(this.addr, t), e[0] = t) } function AB (i, t) { let e = this.cache; if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (i.uniform2f(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y); else { if (Gn(e, t)) return; i.uniform2fv(this.addr, t), Vn(e, t) } } function _B (i, t) { let e = this.cache; if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3f(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z); else if (t.r !== void 0) (e[0] !== t.r || e[1] !== t.g || e[2] !== t.b) && (i.uniform3f(this.addr, t.r, t.g, t.b), e[0] = t.r, e[1] = t.g, e[2] = t.b); else { if (Gn(e, t)) return; i.uniform3fv(this.addr, t), Vn(e, t) } } function EB (i, t) { let e = this.cache; if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4f(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w); else { if (Gn(e, t)) return; i.uniform4fv(this.addr, t), Vn(e, t) } } function MB (i, t) { let e = this.cache, n = t.elements; if (n === void 0) { if (Gn(e, t)) return; i.uniformMatrix2fv(this.addr, !1, t), Vn(e, t) } else { if (Gn(e, n)) return; qA.set(n), i.uniformMatrix2fv(this.addr, !1, qA), Vn(e, n) } } function TB (i, t) { let e = this.cache, n = t.elements; if (n === void 0) { if (Gn(e, t)) return; i.uniformMatrix3fv(this.addr, !1, t), Vn(e, t) } else { if (Gn(e, n)) return; WA.set(n), i.uniformMatrix3fv(this.addr, !1, WA), Vn(e, n) } } function CB (i, t) { let e = this.cache, n = t.elements; if (n === void 0) { if (Gn(e, t)) return; i.uniformMatrix4fv(this.addr, !1, t), Vn(e, t) } else { if (Gn(e, n)) return; jA.set(n), i.uniformMatrix4fv(this.addr, !1, jA), Vn(e, n) } } function PB (i, t) { let e = this.cache; e[0] !== t && (i.uniform1i(this.addr, t), e[0] = t) } function IB (i, t) { let e = this.cache; if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (i.uniform2i(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y); else { if (Gn(e, t)) return; i.uniform2iv(this.addr, t), Vn(e, t) } } function DB (i, t) { let e = this.cache; if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3i(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z); else { if (Gn(e, t)) return; i.uniform3iv(this.addr, t), Vn(e, t) } } function OB (i, t) { let e = this.cache; if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4i(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w); else { if (Gn(e, t)) return; i.uniform4iv(this.addr, t), Vn(e, t) } } function RB (i, t) { let e = this.cache; e[0] !== t && (i.uniform1ui(this.addr, t), e[0] = t) } function LB (i, t) { let e = this.cache; if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y) && (i.uniform2ui(this.addr, t.x, t.y), e[0] = t.x, e[1] = t.y); else { if (Gn(e, t)) return; i.uniform2uiv(this.addr, t), Vn(e, t) } } function NB (i, t) { let e = this.cache; if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z) && (i.uniform3ui(this.addr, t.x, t.y, t.z), e[0] = t.x, e[1] = t.y, e[2] = t.z); else { if (Gn(e, t)) return; i.uniform3uiv(this.addr, t), Vn(e, t) } } function BB (i, t) { let e = this.cache; if (t.x !== void 0) (e[0] !== t.x || e[1] !== t.y || e[2] !== t.z || e[3] !== t.w) && (i.uniform4ui(this.addr, t.x, t.y, t.z, t.w), e[0] = t.x, e[1] = t.y, e[2] = t.z, e[3] = t.w); else { if (Gn(e, t)) return; i.uniform4uiv(this.addr, t), Vn(e, t) } } function FB (i, t, e) { let n = this.cache, r = e.allocateTextureUnit(); n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTexture2D(t || N_, r) } function kB (i, t, e) { let n = this.cache, r = e.allocateTextureUnit(); n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTexture3D(t || F_, r) } function UB (i, t, e) { let n = this.cache, r = e.allocateTextureUnit(); n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTextureCube(t || k_, r) } function zB (i, t, e) { let n = this.cache, r = e.allocateTextureUnit(); n[0] !== r && (i.uniform1i(this.addr, r), n[0] = r), e.setTexture2DArray(t || B_, r) } function GB (i) { switch (i) { case 5126: return SB; case 35664: return AB; case 35665: return _B; case 35666: return EB; case 35674: return MB; case 35675: return TB; case 35676: return CB; case 5124: case 35670: return PB; case 35667: case 35671: return IB; case 35668: case 35672: return DB; case 35669: case 35673: return OB; case 5125: return RB; case 36294: return LB; case 36295: return NB; case 36296: return BB; case 35678: case 36198: case 36298: case 36306: case 35682: return FB; case 35679: case 36299: case 36307: return kB; case 35680: case 36300: case 36308: case 36293: return UB; case 36289: case 36303: case 36311: case 36292: return zB } } function VB (i, t) { i.uniform1fv(this.addr, t) } function HB (i, t) { let e = Xc(t, this.size, 2); i.uniform2fv(this.addr, e) } function jB (i, t) { let e = Xc(t, this.size, 3); i.uniform3fv(this.addr, e) } function WB (i, t) { let e = Xc(t, this.size, 4); i.uniform4fv(this.addr, e) } function qB (i, t) { let e = Xc(t, this.size, 4); i.uniformMatrix2fv(this.addr, !1, e) } function YB (i, t) { let e = Xc(t, this.size, 9); i.uniformMatrix3fv(this.addr, !1, e) } function XB (i, t) { let e = Xc(t, this.size, 16); i.uniformMatrix4fv(this.addr, !1, e) } function QB (i, t) { i.uniform1iv(this.addr, t) } function KB (i, t) { i.uniform2iv(this.addr, t) } function ZB (i, t) { i.uniform3iv(this.addr, t) } function JB (i, t) { i.uniform4iv(this.addr, t) } function $B (i, t) { i.uniform1uiv(this.addr, t) } function eF (i, t) { i.uniform2uiv(this.addr, t) } function tF (i, t) { i.uniform3uiv(this.addr, t) } function nF (i, t) { i.uniform4uiv(this.addr, t) } function rF (i, t, e) { let n = this.cache, r = t.length, s = km(e, r); Gn(n, s) || (i.uniform1iv(this.addr, s), Vn(n, s)); for (let o = 0; o !== r; ++o)e.setTexture2D(t[o] || N_, s[o]) } function iF (i, t, e) { let n = this.cache, r = t.length, s = km(e, r); Gn(n, s) || (i.uniform1iv(this.addr, s), Vn(n, s)); for (let o = 0; o !== r; ++o)e.setTexture3D(t[o] || F_, s[o]) } function sF (i, t, e) { let n = this.cache, r = t.length, s = km(e, r); Gn(n, s) || (i.uniform1iv(this.addr, s), Vn(n, s)); for (let o = 0; o !== r; ++o)e.setTextureCube(t[o] || k_, s[o]) } function oF (i, t, e) { let n = this.cache, r = t.length, s = km(e, r); Gn(n, s) || (i.uniform1iv(this.addr, s), Vn(n, s)); for (let o = 0; o !== r; ++o)e.setTexture2DArray(t[o] || B_, s[o]) } function aF (i) { switch (i) { case 5126: return VB; case 35664: return HB; case 35665: return jB; case 35666: return WB; case 35674: return qB; case 35675: return YB; case 35676: return XB; case 5124: case 35670: return QB; case 35667: case 35671: return KB; case 35668: case 35672: return ZB; case 35669: case 35673: return JB; case 5125: return $B; case 36294: return eF; case 36295: return tF; case 36296: return nF; case 35678: case 36198: case 36298: case 36306: case 35682: return rF; case 35679: case 36299: case 36307: return iF; case 35680: case 36300: case 36308: case 36293: return sF; case 36289: case 36303: case 36311: case 36292: return oF } } var gx = class { constructor(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.setValue = GB(e.type) } }, yx = class { constructor(t, e, n) { this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = aF(e.type) } }, vx = class { constructor(t) { this.id = t, this.seq = [], this.map = {} } setValue (t, e, n) { let r = this.seq; for (let s = 0, o = r.length; s !== o; ++s) { let a = r[s]; a.setValue(t, e[a.id], n) } } }, ex = /(\w+)(\])?(\[|\.)?/g; function YA (i, t) { i.seq.push(t), i.map[t.id] = t } function lF (i, t, e) { let n = i.name, r = n.length; for (ex.lastIndex = 0; ;) { let s = ex.exec(n), o = ex.lastIndex, a = s[1], l = s[2] === "]", u = s[3]; if (l && (a = a | 0), u === void 0 || u === "[" && o + 2 === r) { YA(e, u === void 0 ? new gx(a, i, t) : new yx(a, i, t)); break } else { let h = e.map[a]; h === void 0 && (h = new vx(a), YA(e, h)), e = h } } } var Mc = class { constructor(t, e) { this.seq = [], this.map = {}; let n = t.getProgramParameter(e, 35718); for (let r = 0; r < n; ++r) { let s = t.getActiveUniform(e, r), o = t.getUniformLocation(e, s.name); lF(s, o, this) } } setValue (t, e, n, r) { let s = this.map[e]; s !== void 0 && s.setValue(t, n, r) } setOptional (t, e, n) { let r = e[n]; r !== void 0 && this.setValue(t, n, r) } static upload (t, e, n, r) { for (let s = 0, o = e.length; s !== o; ++s) { let a = e[s], l = n[a.id]; l.needsUpdate !== !1 && a.setValue(t, l.value, r) } } static seqWithValue (t, e) { let n = []; for (let r = 0, s = t.length; r !== s; ++r) { let o = t[r]; o.id in e && n.push(o) } return n } }; function XA (i, t, e) { let n = i.createShader(t); return i.shaderSource(n, e), i.compileShader(n), n } var cF = 0; function uF (i, t) {
	let e = i.split(`
`), n = [], r = Math.max(t - 6, 0), s = Math.min(t + 6, e.length); for (let o = r; o < s; o++) { let a = o + 1; n.push(`${a === t ? ">" : " "} ${a}: ${e[o]}`) } return n.join(`
`)
} function hF (i) { switch (i) { case li: return ["Linear", "( value )"]; case Je: return ["sRGB", "( value )"]; default: return console.warn("THREE.WebGLProgram: Unsupported encoding:", i), ["Linear", "( value )"] } } function QA (i, t, e) {
	let n = i.getShaderParameter(t, 35713), r = i.getShaderInfoLog(t).trim(); if (n && r === "") return ""; let s = /ERROR: 0:(\d+)/.exec(r); if (s) {
		let o = parseInt(s[1]); return e.toUpperCase() + `

`+ r + `

`+ uF(i.getShaderSource(t), o)
	} else return r
} function dF (i, t) { let e = hF(t); return "vec4 " + i + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }" } function fF (i, t) { let e; switch (t) { case MR: e = "Linear"; break; case TR: e = "Reinhard"; break; case CR: e = "OptimizedCineon"; break; case PR: e = "ACESFilmic"; break; case IR: e = "Custom"; break; default: console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t), e = "Linear" }return "vec3 " + i + "( vec3 color ) { return " + e + "ToneMapping( color ); }" } function pF (i) {
	return [i.extensionDerivatives || !!i.envMapCubeUVHeight || i.bumpMap || i.tangentSpaceNormalMap || i.clearcoatNormalMap || i.flatShading || i.shaderID === "physical" ? "#extension GL_OES_standard_derivatives : enable" : "", (i.extensionFragDepth || i.logarithmicDepthBuffer) && i.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", i.extensionDrawBuffers && i.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (i.extensionShaderTextureLOD || i.envMap || i.transmission) && i.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Nd).join(`
`)
} function mF (i) {
	let t = []; for (let e in i) { let n = i[e]; n !== !1 && t.push("#define " + e + " " + n) } return t.join(`
`)
} function gF (i, t) { let e = {}, n = i.getProgramParameter(t, 35721); for (let r = 0; r < n; r++) { let s = i.getActiveAttrib(t, r), o = s.name, a = 1; s.type === 35674 && (a = 2), s.type === 35675 && (a = 3), s.type === 35676 && (a = 4), e[o] = { type: s.type, location: i.getAttribLocation(t, o), locationSize: a } } return e } function Nd (i) { return i !== "" } function KA (i, t) { let e = t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps; return i.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, e).replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows) } function ZA (i, t) { return i.replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, t.numClippingPlanes - t.numClipIntersection) } var yF = /^[ \t]*#include +<([\w\d./]+)>/gm; function xx (i) { return i.replace(yF, vF) } function vF (i, t) { let e = ot[t]; if (e === void 0) throw new Error("Can not resolve #include <" + t + ">"); return xx(e) } var xF = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g; function JA (i) { return i.replace(xF, bF) } function bF (i, t, e, n) { let r = ""; for (let s = parseInt(t); s < parseInt(e); s++)r += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s); return r } function $A (i) {
	let t = "precision " + i.precision + ` float;
precision `+ i.precision + " int;"; return i.precision === "highp" ? t += `
#define HIGH_PRECISION`: i.precision === "mediump" ? t += `
#define MEDIUM_PRECISION`: i.precision === "lowp" && (t += `
#define LOW_PRECISION`), t
} function wF (i) { let t = "SHADOWMAP_TYPE_BASIC"; return i.shadowMapType === Fm ? t = "SHADOWMAP_TYPE_PCF" : i.shadowMapType === iR ? t = "SHADOWMAP_TYPE_PCF_SOFT" : i.shadowMapType === Ld && (t = "SHADOWMAP_TYPE_VSM"), t } function SF (i) { let t = "ENVMAP_TYPE_CUBE"; if (i.envMap) switch (i.envMapMode) { case ta: case na: t = "ENVMAP_TYPE_CUBE"; break; case Yc: t = "ENVMAP_TYPE_CUBE_UV"; break }return t } function AF (i) { let t = "ENVMAP_MODE_REFLECTION"; if (i.envMap) switch (i.envMapMode) { case na: t = "ENVMAP_MODE_REFRACTION"; break }return t } function _F (i) { let t = "ENVMAP_BLENDING_NONE"; if (i.envMap) switch (i.combine) { case T_: t = "ENVMAP_BLENDING_MULTIPLY"; break; case _R: t = "ENVMAP_BLENDING_MIX"; break; case ER: t = "ENVMAP_BLENDING_ADD"; break }return t } function EF (i) { let t = i.envMapCubeUVHeight; if (t === null) return null; let e = Math.log2(t) - 2, n = 1 / t; return { texelWidth: 1 / (3 * Math.max(Math.pow(2, e), 7 * 16)), texelHeight: n, maxMip: e } } function MF (i, t, e, n) {
	let r = i.getContext(), s = e.defines, o = e.vertexShader, a = e.fragmentShader, l = wF(e), u = SF(e), c = AF(e), h = _F(e), d = EF(e), f = e.isWebGL2 ? "" : pF(e), p = mF(s), m = r.createProgram(), g, y, v = e.glslVersion ? "#version " + e.glslVersion + `
`: ""; e.isRawShaderMaterial ? (g = [p].filter(Nd).join(`
`), g.length > 0 && (g += `
`), y = [f, p].filter(Nd).join(`
`), y.length > 0 && (y += `
`)) : (g = [$A(e), "#define SHADER_NAME " + e.shaderName, p, e.instancing ? "#define USE_INSTANCING" : "", e.instancingColor ? "#define USE_INSTANCING_COLOR" : "", e.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + c : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.displacementMap && e.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", e.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", e.vertexTangents ? "#define USE_TANGENT" : "", e.vertexColors ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUvs ? "#define USE_UV" : "", e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.skinning ? "#define USE_SKINNING" : "", e.morphTargets ? "#define USE_MORPHTARGETS" : "", e.morphNormals && e.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", e.morphColors && e.isWebGL2 ? "#define USE_MORPHCOLORS" : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + e.morphTextureStride : "", e.morphTargetsCount > 0 && e.isWebGL2 ? "#define MORPHTARGETS_COUNT " + e.morphTargetsCount : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Nd).join(`
`), y = [f, $A(e), "#define SHADER_NAME " + e.shaderName, p, e.useFog && e.fog ? "#define USE_FOG" : "", e.useFog && e.fogExp2 ? "#define FOG_EXP2" : "", e.map ? "#define USE_MAP" : "", e.matcap ? "#define USE_MATCAP" : "", e.envMap ? "#define USE_ENVMAP" : "", e.envMap ? "#define " + u : "", e.envMap ? "#define " + c : "", e.envMap ? "#define " + h : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", e.lightMap ? "#define USE_LIGHTMAP" : "", e.aoMap ? "#define USE_AOMAP" : "", e.emissiveMap ? "#define USE_EMISSIVEMAP" : "", e.bumpMap ? "#define USE_BUMPMAP" : "", e.normalMap ? "#define USE_NORMALMAP" : "", e.normalMap && e.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", e.normalMap && e.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", e.clearcoat ? "#define USE_CLEARCOAT" : "", e.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", e.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", e.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", e.iridescence ? "#define USE_IRIDESCENCE" : "", e.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", e.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", e.specularMap ? "#define USE_SPECULARMAP" : "", e.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", e.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", e.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", e.metalnessMap ? "#define USE_METALNESSMAP" : "", e.alphaMap ? "#define USE_ALPHAMAP" : "", e.alphaTest ? "#define USE_ALPHATEST" : "", e.sheen ? "#define USE_SHEEN" : "", e.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", e.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", e.transmission ? "#define USE_TRANSMISSION" : "", e.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", e.thicknessMap ? "#define USE_THICKNESSMAP" : "", e.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", e.vertexTangents ? "#define USE_TANGENT" : "", e.vertexColors || e.instancingColor ? "#define USE_COLOR" : "", e.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", e.vertexUvs ? "#define USE_UV" : "", e.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", e.gradientMap ? "#define USE_GRADIENTMAP" : "", e.flatShading ? "#define FLAT_SHADED" : "", e.doubleSided ? "#define DOUBLE_SIDED" : "", e.flipSided ? "#define FLIP_SIDED" : "", e.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", e.shadowMapEnabled ? "#define " + l : "", e.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", e.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", e.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", e.logarithmicDepthBuffer && e.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", e.toneMapping !== fo ? "#define TONE_MAPPING" : "", e.toneMapping !== fo ? ot.tonemapping_pars_fragment : "", e.toneMapping !== fo ? fF("toneMapping", e.toneMapping) : "", e.dithering ? "#define DITHERING" : "", e.opaque ? "#define OPAQUE" : "", ot.encodings_pars_fragment, dF("linearToOutputTexel", e.outputEncoding), e.useDepthPacking ? "#define DEPTH_PACKING " + e.depthPacking : "", `
`].filter(Nd).join(`
`)), o = xx(o), o = KA(o, e), o = ZA(o, e), a = xx(a), a = KA(a, e), a = ZA(a, e), o = JA(o), a = JA(a), e.isWebGL2 && e.isRawShaderMaterial !== !0 && (v = `#version 300 es
`, g = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
`+ g, y = ["#define varying in", e.glslVersion === _A ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", e.glslVersion === _A ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
`+ y); let x = v + g + o, b = v + y + a, S = XA(r, 35633, x), _ = XA(r, 35632, b); if (r.attachShader(m, S), r.attachShader(m, _), e.index0AttributeName !== void 0 ? r.bindAttribLocation(m, 0, e.index0AttributeName) : e.morphTargets === !0 && r.bindAttribLocation(m, 0, "position"), r.linkProgram(m), i.debug.checkShaderErrors) {
		let M = r.getProgramInfoLog(m).trim(), T = r.getShaderInfoLog(S).trim(), I = r.getShaderInfoLog(_).trim(), C = !0, P = !0; if (r.getProgramParameter(m, 35714) === !1) {
			C = !1; let D = QA(r, S, "vertex"), L = QA(r, _, "fragment"); console.error("THREE.WebGLProgram: Shader Error " + r.getError() + " - VALIDATE_STATUS " + r.getProgramParameter(m, 35715) + `

Program Info Log: `+ M + `
`+ D + `
`+ L)
		} else M !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", M) : (T === "" || I === "") && (P = !1); P && (this.diagnostics = { runnable: C, programLog: M, vertexShader: { log: T, prefix: g }, fragmentShader: { log: I, prefix: y } })
	} r.deleteShader(S), r.deleteShader(_); let E; this.getUniforms = function () { return E === void 0 && (E = new Mc(r, m)), E }; let w; return this.getAttributes = function () { return w === void 0 && (w = gF(r, m)), w }, this.destroy = function () { n.releaseStatesOfProgram(this), r.deleteProgram(m), this.program = void 0 }, this.name = e.shaderName, this.id = cF++, this.cacheKey = t, this.usedTimes = 1, this.program = m, this.vertexShader = S, this.fragmentShader = _, this
} var TF = 0, bx = class { constructor() { this.shaderCache = new Map, this.materialCache = new Map } update (t) { let e = t.vertexShader, n = t.fragmentShader, r = this._getShaderStage(e), s = this._getShaderStage(n), o = this._getShaderCacheForMaterial(t); return o.has(r) === !1 && (o.add(r), r.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this } remove (t) { let e = this.materialCache.get(t); for (let n of e) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code); return this.materialCache.delete(t), this } getVertexShaderID (t) { return this._getShaderStage(t.vertexShader).id } getFragmentShaderID (t) { return this._getShaderStage(t.fragmentShader).id } dispose () { this.shaderCache.clear(), this.materialCache.clear() } _getShaderCacheForMaterial (t) { let e = this.materialCache, n = e.get(t); return n === void 0 && (n = new Set, e.set(t, n)), n } _getShaderStage (t) { let e = this.shaderCache, n = e.get(t); return n === void 0 && (n = new wx(t), e.set(t, n)), n } }, wx = class { constructor(t) { this.id = TF++, this.code = t, this.usedTimes = 0 } }; function CF (i, t, e, n, r, s, o) { let a = new Hd, l = new bx, u = [], c = r.isWebGL2, h = r.logarithmicDepthBuffer, d = r.vertexTextures, f = r.precision, p = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "toon", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }; function m (w, M, T, I, C) { let P = I.fog, D = C.geometry, L = w.isMeshStandardMaterial ? I.environment : null, H = (w.isMeshStandardMaterial ? e : t).get(w.envMap || L), U = !!H && H.mapping === Yc ? H.image.height : null, V = p[w.type]; w.precision !== null && (f = r.getMaxPrecision(w.precision), f !== w.precision && console.warn("THREE.WebGLProgram.getParameters:", w.precision, "not supported, using", f, "instead.")); let G = D.morphAttributes.position || D.morphAttributes.normal || D.morphAttributes.color, z = G !== void 0 ? G.length : 0, $ = 0; D.morphAttributes.position !== void 0 && ($ = 1), D.morphAttributes.normal !== void 0 && ($ = 2), D.morphAttributes.color !== void 0 && ($ = 3); let F, j, X, q; if (V) { let ge = ys[V]; F = ge.vertexShader, j = ge.fragmentShader } else F = w.vertexShader, j = w.fragmentShader, l.update(w), X = l.getVertexShaderID(w), q = l.getFragmentShaderID(w); let k = i.getRenderTarget(), Z = w.alphaTest > 0, K = w.clearcoat > 0, Q = w.iridescence > 0; return { isWebGL2: c, shaderID: V, shaderName: w.type, vertexShader: F, fragmentShader: j, defines: w.defines, customVertexShaderID: X, customFragmentShaderID: q, isRawShaderMaterial: w.isRawShaderMaterial === !0, glslVersion: w.glslVersion, precision: f, instancing: C.isInstancedMesh === !0, instancingColor: C.isInstancedMesh === !0 && C.instanceColor !== null, supportsVertexTextures: d, outputEncoding: k === null ? i.outputEncoding : k.isXRRenderTarget === !0 ? k.texture.encoding : li, map: !!w.map, matcap: !!w.matcap, envMap: !!H, envMapMode: H && H.mapping, envMapCubeUVHeight: U, lightMap: !!w.lightMap, aoMap: !!w.aoMap, emissiveMap: !!w.emissiveMap, bumpMap: !!w.bumpMap, normalMap: !!w.normalMap, objectSpaceNormalMap: w.normalMapType === XR, tangentSpaceNormalMap: w.normalMapType === YR, decodeVideoTexture: !!w.map && w.map.isVideoTexture === !0 && w.map.encoding === Je, clearcoat: K, clearcoatMap: K && !!w.clearcoatMap, clearcoatRoughnessMap: K && !!w.clearcoatRoughnessMap, clearcoatNormalMap: K && !!w.clearcoatNormalMap, iridescence: Q, iridescenceMap: Q && !!w.iridescenceMap, iridescenceThicknessMap: Q && !!w.iridescenceThicknessMap, displacementMap: !!w.displacementMap, roughnessMap: !!w.roughnessMap, metalnessMap: !!w.metalnessMap, specularMap: !!w.specularMap, specularIntensityMap: !!w.specularIntensityMap, specularColorMap: !!w.specularColorMap, opaque: w.transparent === !1 && w.blending === Ec, alphaMap: !!w.alphaMap, alphaTest: Z, gradientMap: !!w.gradientMap, sheen: w.sheen > 0, sheenColorMap: !!w.sheenColorMap, sheenRoughnessMap: !!w.sheenRoughnessMap, transmission: w.transmission > 0, transmissionMap: !!w.transmissionMap, thicknessMap: !!w.thicknessMap, combine: w.combine, vertexTangents: !!w.normalMap && !!D.attributes.tangent, vertexColors: w.vertexColors, vertexAlphas: w.vertexColors === !0 && !!D.attributes.color && D.attributes.color.itemSize === 4, vertexUvs: !!w.map || !!w.bumpMap || !!w.normalMap || !!w.specularMap || !!w.alphaMap || !!w.emissiveMap || !!w.roughnessMap || !!w.metalnessMap || !!w.clearcoatMap || !!w.clearcoatRoughnessMap || !!w.clearcoatNormalMap || !!w.iridescenceMap || !!w.iridescenceThicknessMap || !!w.displacementMap || !!w.transmissionMap || !!w.thicknessMap || !!w.specularIntensityMap || !!w.specularColorMap || !!w.sheenColorMap || !!w.sheenRoughnessMap, uvsVertexOnly: !(!!w.map || !!w.bumpMap || !!w.normalMap || !!w.specularMap || !!w.alphaMap || !!w.emissiveMap || !!w.roughnessMap || !!w.metalnessMap || !!w.clearcoatNormalMap || !!w.iridescenceMap || !!w.iridescenceThicknessMap || w.transmission > 0 || !!w.transmissionMap || !!w.thicknessMap || !!w.specularIntensityMap || !!w.specularColorMap || w.sheen > 0 || !!w.sheenColorMap || !!w.sheenRoughnessMap) && !!w.displacementMap, fog: !!P, useFog: w.fog === !0, fogExp2: P && P.isFogExp2, flatShading: !!w.flatShading, sizeAttenuation: w.sizeAttenuation, logarithmicDepthBuffer: h, skinning: C.isSkinnedMesh === !0, morphTargets: D.morphAttributes.position !== void 0, morphNormals: D.morphAttributes.normal !== void 0, morphColors: D.morphAttributes.color !== void 0, morphTargetsCount: z, morphTextureStride: $, numDirLights: M.directional.length, numPointLights: M.point.length, numSpotLights: M.spot.length, numSpotLightMaps: M.spotLightMap.length, numRectAreaLights: M.rectArea.length, numHemiLights: M.hemi.length, numDirLightShadows: M.directionalShadowMap.length, numPointLightShadows: M.pointShadowMap.length, numSpotLightShadows: M.spotShadowMap.length, numSpotLightShadowsWithMaps: M.numSpotLightShadowsWithMaps, numClippingPlanes: o.numPlanes, numClipIntersection: o.numIntersection, dithering: w.dithering, shadowMapEnabled: i.shadowMap.enabled && T.length > 0, shadowMapType: i.shadowMap.type, toneMapping: w.toneMapped ? i.toneMapping : fo, physicallyCorrectLights: i.physicallyCorrectLights, premultipliedAlpha: w.premultipliedAlpha, doubleSided: w.side === Nr, flipSided: w.side === Ln, useDepthPacking: !!w.depthPacking, depthPacking: w.depthPacking || 0, index0AttributeName: w.index0AttributeName, extensionDerivatives: w.extensions && w.extensions.derivatives, extensionFragDepth: w.extensions && w.extensions.fragDepth, extensionDrawBuffers: w.extensions && w.extensions.drawBuffers, extensionShaderTextureLOD: w.extensions && w.extensions.shaderTextureLOD, rendererExtensionFragDepth: c || n.has("EXT_frag_depth"), rendererExtensionDrawBuffers: c || n.has("WEBGL_draw_buffers"), rendererExtensionShaderTextureLod: c || n.has("EXT_shader_texture_lod"), customProgramCacheKey: w.customProgramCacheKey() } } function g (w) { let M = []; if (w.shaderID ? M.push(w.shaderID) : (M.push(w.customVertexShaderID), M.push(w.customFragmentShaderID)), w.defines !== void 0) for (let T in w.defines) M.push(T), M.push(w.defines[T]); return w.isRawShaderMaterial === !1 && (y(M, w), v(M, w), M.push(i.outputEncoding)), M.push(w.customProgramCacheKey), M.join() } function y (w, M) { w.push(M.precision), w.push(M.outputEncoding), w.push(M.envMapMode), w.push(M.envMapCubeUVHeight), w.push(M.combine), w.push(M.vertexUvs), w.push(M.fogExp2), w.push(M.sizeAttenuation), w.push(M.morphTargetsCount), w.push(M.morphAttributeCount), w.push(M.numDirLights), w.push(M.numPointLights), w.push(M.numSpotLights), w.push(M.numSpotLightMaps), w.push(M.numHemiLights), w.push(M.numRectAreaLights), w.push(M.numDirLightShadows), w.push(M.numPointLightShadows), w.push(M.numSpotLightShadows), w.push(M.numSpotLightShadowsWithMaps), w.push(M.shadowMapType), w.push(M.toneMapping), w.push(M.numClippingPlanes), w.push(M.numClipIntersection), w.push(M.depthPacking) } function v (w, M) { a.disableAll(), M.isWebGL2 && a.enable(0), M.supportsVertexTextures && a.enable(1), M.instancing && a.enable(2), M.instancingColor && a.enable(3), M.map && a.enable(4), M.matcap && a.enable(5), M.envMap && a.enable(6), M.lightMap && a.enable(7), M.aoMap && a.enable(8), M.emissiveMap && a.enable(9), M.bumpMap && a.enable(10), M.normalMap && a.enable(11), M.objectSpaceNormalMap && a.enable(12), M.tangentSpaceNormalMap && a.enable(13), M.clearcoat && a.enable(14), M.clearcoatMap && a.enable(15), M.clearcoatRoughnessMap && a.enable(16), M.clearcoatNormalMap && a.enable(17), M.iridescence && a.enable(18), M.iridescenceMap && a.enable(19), M.iridescenceThicknessMap && a.enable(20), M.displacementMap && a.enable(21), M.specularMap && a.enable(22), M.roughnessMap && a.enable(23), M.metalnessMap && a.enable(24), M.gradientMap && a.enable(25), M.alphaMap && a.enable(26), M.alphaTest && a.enable(27), M.vertexColors && a.enable(28), M.vertexAlphas && a.enable(29), M.vertexUvs && a.enable(30), M.vertexTangents && a.enable(31), M.uvsVertexOnly && a.enable(32), w.push(a.mask), a.disableAll(), M.fog && a.enable(0), M.useFog && a.enable(1), M.flatShading && a.enable(2), M.logarithmicDepthBuffer && a.enable(3), M.skinning && a.enable(4), M.morphTargets && a.enable(5), M.morphNormals && a.enable(6), M.morphColors && a.enable(7), M.premultipliedAlpha && a.enable(8), M.shadowMapEnabled && a.enable(9), M.physicallyCorrectLights && a.enable(10), M.doubleSided && a.enable(11), M.flipSided && a.enable(12), M.useDepthPacking && a.enable(13), M.dithering && a.enable(14), M.specularIntensityMap && a.enable(15), M.specularColorMap && a.enable(16), M.transmission && a.enable(17), M.transmissionMap && a.enable(18), M.thicknessMap && a.enable(19), M.sheen && a.enable(20), M.sheenColorMap && a.enable(21), M.sheenRoughnessMap && a.enable(22), M.decodeVideoTexture && a.enable(23), M.opaque && a.enable(24), w.push(a.mask) } function x (w) { let M = p[w.type], T; if (M) { let I = ys[M]; T = Yi.clone(I.uniforms) } else T = w.uniforms; return T } function b (w, M) { let T; for (let I = 0, C = u.length; I < C; I++) { let P = u[I]; if (P.cacheKey === M) { T = P, ++T.usedTimes; break } } return T === void 0 && (T = new MF(i, M, w, s), u.push(T)), T } function S (w) { if (--w.usedTimes === 0) { let M = u.indexOf(w); u[M] = u[u.length - 1], u.pop(), w.destroy() } } function _ (w) { l.remove(w) } function E () { l.dispose() } return { getParameters: m, getProgramCacheKey: g, getUniforms: x, acquireProgram: b, releaseProgram: S, releaseShaderCache: _, programs: u, dispose: E } } function PF () { let i = new WeakMap; function t (s) { let o = i.get(s); return o === void 0 && (o = {}, i.set(s, o)), o } function e (s) { i.delete(s) } function n (s, o, a) { i.get(s)[o] = a } function r () { i = new WeakMap } return { get: t, remove: e, update: n, dispose: r } } function IF (i, t) { return i.groupOrder !== t.groupOrder ? i.groupOrder - t.groupOrder : i.renderOrder !== t.renderOrder ? i.renderOrder - t.renderOrder : i.material.id !== t.material.id ? i.material.id - t.material.id : i.z !== t.z ? i.z - t.z : i.id - t.id } function e_ (i, t) { return i.groupOrder !== t.groupOrder ? i.groupOrder - t.groupOrder : i.renderOrder !== t.renderOrder ? i.renderOrder - t.renderOrder : i.z !== t.z ? t.z - i.z : i.id - t.id } function t_ () { let i = [], t = 0, e = [], n = [], r = []; function s () { t = 0, e.length = 0, n.length = 0, r.length = 0 } function o (h, d, f, p, m, g) { let y = i[t]; return y === void 0 ? (y = { id: h.id, object: h, geometry: d, material: f, groupOrder: p, renderOrder: h.renderOrder, z: m, group: g }, i[t] = y) : (y.id = h.id, y.object = h, y.geometry = d, y.material = f, y.groupOrder = p, y.renderOrder = h.renderOrder, y.z = m, y.group = g), t++, y } function a (h, d, f, p, m, g) { let y = o(h, d, f, p, m, g); f.transmission > 0 ? n.push(y) : f.transparent === !0 ? r.push(y) : e.push(y) } function l (h, d, f, p, m, g) { let y = o(h, d, f, p, m, g); f.transmission > 0 ? n.unshift(y) : f.transparent === !0 ? r.unshift(y) : e.unshift(y) } function u (h, d) { e.length > 1 && e.sort(h || IF), n.length > 1 && n.sort(d || e_), r.length > 1 && r.sort(d || e_) } function c () { for (let h = t, d = i.length; h < d; h++) { let f = i[h]; if (f.id === null) break; f.id = null, f.object = null, f.geometry = null, f.material = null, f.group = null } } return { opaque: e, transmissive: n, transparent: r, init: s, push: a, unshift: l, finish: c, sort: u } } function DF () { let i = new WeakMap; function t (n, r) { let s = i.get(n), o; return s === void 0 ? (o = new t_, i.set(n, [o])) : r >= s.length ? (o = new t_, s.push(o)) : o = s[r], o } function e () { i = new WeakMap } return { get: t, dispose: e } } function OF () { let i = {}; return { get: function (t) { if (i[t.id] !== void 0) return i[t.id]; let e; switch (t.type) { case "DirectionalLight": e = { direction: new A, color: new Le }; break; case "SpotLight": e = { position: new A, direction: new A, color: new Le, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0 }; break; case "PointLight": e = { position: new A, color: new Le, distance: 0, decay: 0 }; break; case "HemisphereLight": e = { direction: new A, skyColor: new Le, groundColor: new Le }; break; case "RectAreaLight": e = { color: new Le, position: new A, halfWidth: new A, halfHeight: new A }; break }return i[t.id] = e, e } } } function RF () { let i = {}; return { get: function (t) { if (i[t.id] !== void 0) return i[t.id]; let e; switch (t.type) { case "DirectionalLight": e = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new B }; break; case "SpotLight": e = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new B }; break; case "PointLight": e = { shadowBias: 0, shadowNormalBias: 0, shadowRadius: 1, shadowMapSize: new B, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break }return i[t.id] = e, e } } } var LF = 0; function NF (i, t) { return (t.castShadow ? 2 : 0) - (i.castShadow ? 2 : 0) + (t.map ? 1 : 0) - (i.map ? 1 : 0) } function BF (i, t) { let e = new OF, n = RF(), r = { version: 0, hash: { directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, numDirectionalShadows: -1, numPointShadows: -1, numSpotShadows: -1, numSpotMaps: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadow: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotLightMap: [], spotShadow: [], spotShadowMap: [], spotLightMatrix: [], rectArea: [], rectAreaLTC1: null, rectAreaLTC2: null, point: [], pointShadow: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [], numSpotLightShadowsWithMaps: 0 }; for (let c = 0; c < 9; c++)r.probe.push(new A); let s = new A, o = new se, a = new se; function l (c, h) { let d = 0, f = 0, p = 0; for (let I = 0; I < 9; I++)r.probe[I].set(0, 0, 0); let m = 0, g = 0, y = 0, v = 0, x = 0, b = 0, S = 0, _ = 0, E = 0, w = 0; c.sort(NF); let M = h !== !0 ? Math.PI : 1; for (let I = 0, C = c.length; I < C; I++) { let P = c[I], D = P.color, L = P.intensity, H = P.distance, U = P.shadow && P.shadow.map ? P.shadow.map.texture : null; if (P.isAmbientLight) d += D.r * L * M, f += D.g * L * M, p += D.b * L * M; else if (P.isLightProbe) for (let V = 0; V < 9; V++)r.probe[V].addScaledVector(P.sh.coefficients[V], L); else if (P.isDirectionalLight) { let V = e.get(P); if (V.color.copy(P.color).multiplyScalar(P.intensity * M), P.castShadow) { let G = P.shadow, z = n.get(P); z.shadowBias = G.bias, z.shadowNormalBias = G.normalBias, z.shadowRadius = G.radius, z.shadowMapSize = G.mapSize, r.directionalShadow[m] = z, r.directionalShadowMap[m] = U, r.directionalShadowMatrix[m] = P.shadow.matrix, b++ } r.directional[m] = V, m++ } else if (P.isSpotLight) { let V = e.get(P); V.position.setFromMatrixPosition(P.matrixWorld), V.color.copy(D).multiplyScalar(L * M), V.distance = H, V.coneCos = Math.cos(P.angle), V.penumbraCos = Math.cos(P.angle * (1 - P.penumbra)), V.decay = P.decay, r.spot[y] = V; let G = P.shadow; if (P.map && (r.spotLightMap[E] = P.map, E++, G.updateMatrices(P), P.castShadow && w++), r.spotLightMatrix[y] = G.matrix, P.castShadow) { let z = n.get(P); z.shadowBias = G.bias, z.shadowNormalBias = G.normalBias, z.shadowRadius = G.radius, z.shadowMapSize = G.mapSize, r.spotShadow[y] = z, r.spotShadowMap[y] = U, _++ } y++ } else if (P.isRectAreaLight) { let V = e.get(P); V.color.copy(D).multiplyScalar(L), V.halfWidth.set(P.width * .5, 0, 0), V.halfHeight.set(0, P.height * .5, 0), r.rectArea[v] = V, v++ } else if (P.isPointLight) { let V = e.get(P); if (V.color.copy(P.color).multiplyScalar(P.intensity * M), V.distance = P.distance, V.decay = P.decay, P.castShadow) { let G = P.shadow, z = n.get(P); z.shadowBias = G.bias, z.shadowNormalBias = G.normalBias, z.shadowRadius = G.radius, z.shadowMapSize = G.mapSize, z.shadowCameraNear = G.camera.near, z.shadowCameraFar = G.camera.far, r.pointShadow[g] = z, r.pointShadowMap[g] = U, r.pointShadowMatrix[g] = P.shadow.matrix, S++ } r.point[g] = V, g++ } else if (P.isHemisphereLight) { let V = e.get(P); V.skyColor.copy(P.color).multiplyScalar(L * M), V.groundColor.copy(P.groundColor).multiplyScalar(L * M), r.hemi[x] = V, x++ } } v > 0 && (t.isWebGL2 || i.has("OES_texture_float_linear") === !0 ? (r.rectAreaLTC1 = xe.LTC_FLOAT_1, r.rectAreaLTC2 = xe.LTC_FLOAT_2) : i.has("OES_texture_half_float_linear") === !0 ? (r.rectAreaLTC1 = xe.LTC_HALF_1, r.rectAreaLTC2 = xe.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), r.ambient[0] = d, r.ambient[1] = f, r.ambient[2] = p; let T = r.hash; (T.directionalLength !== m || T.pointLength !== g || T.spotLength !== y || T.rectAreaLength !== v || T.hemiLength !== x || T.numDirectionalShadows !== b || T.numPointShadows !== S || T.numSpotShadows !== _ || T.numSpotMaps !== E) && (r.directional.length = m, r.spot.length = y, r.rectArea.length = v, r.point.length = g, r.hemi.length = x, r.directionalShadow.length = b, r.directionalShadowMap.length = b, r.pointShadow.length = S, r.pointShadowMap.length = S, r.spotShadow.length = _, r.spotShadowMap.length = _, r.directionalShadowMatrix.length = b, r.pointShadowMatrix.length = S, r.spotLightMatrix.length = _ + E - w, r.spotLightMap.length = E, r.numSpotLightShadowsWithMaps = w, T.directionalLength = m, T.pointLength = g, T.spotLength = y, T.rectAreaLength = v, T.hemiLength = x, T.numDirectionalShadows = b, T.numPointShadows = S, T.numSpotShadows = _, T.numSpotMaps = E, r.version = LF++) } function u (c, h) { let d = 0, f = 0, p = 0, m = 0, g = 0, y = h.matrixWorldInverse; for (let v = 0, x = c.length; v < x; v++) { let b = c[v]; if (b.isDirectionalLight) { let S = r.directional[d]; S.direction.setFromMatrixPosition(b.matrixWorld), s.setFromMatrixPosition(b.target.matrixWorld), S.direction.sub(s), S.direction.transformDirection(y), d++ } else if (b.isSpotLight) { let S = r.spot[p]; S.position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(y), S.direction.setFromMatrixPosition(b.matrixWorld), s.setFromMatrixPosition(b.target.matrixWorld), S.direction.sub(s), S.direction.transformDirection(y), p++ } else if (b.isRectAreaLight) { let S = r.rectArea[m]; S.position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(y), a.identity(), o.copy(b.matrixWorld), o.premultiply(y), a.extractRotation(o), S.halfWidth.set(b.width * .5, 0, 0), S.halfHeight.set(0, b.height * .5, 0), S.halfWidth.applyMatrix4(a), S.halfHeight.applyMatrix4(a), m++ } else if (b.isPointLight) { let S = r.point[f]; S.position.setFromMatrixPosition(b.matrixWorld), S.position.applyMatrix4(y), f++ } else if (b.isHemisphereLight) { let S = r.hemi[g]; S.direction.setFromMatrixPosition(b.matrixWorld), S.direction.transformDirection(y), g++ } } } return { setup: l, setupView: u, state: r } } function n_ (i, t) { let e = new BF(i, t), n = [], r = []; function s () { n.length = 0, r.length = 0 } function o (h) { n.push(h) } function a (h) { r.push(h) } function l (h) { e.setup(n, h) } function u (h) { e.setupView(n, h) } return { init: s, state: { lightsArray: n, shadowsArray: r, lights: e }, setupLights: l, setupLightsView: u, pushLight: o, pushShadow: a } } function FF (i, t) { let e = new WeakMap; function n (s, o = 0) { let a = e.get(s), l; return a === void 0 ? (l = new n_(i, t), e.set(s, [l])) : o >= a.length ? (l = new n_(i, t), a.push(l)) : l = a[o], l } function r () { e = new WeakMap } return { get: n, dispose: r } } var Wd = class extends ul { constructor(t) { super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = tr, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(t) } copy (t) { return super.copy(t), this.depthPacking = t.depthPacking, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this } }, Sx = class extends ul { constructor(t) { super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.referencePosition = new A, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(t) } copy (t) { return super.copy(t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this } }, kF = `void main() {
	gl_Position = vec4( position, 1.0 );
}`, UF = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`; function zF (i, t, e) { let n = new jd, r = new B, s = new B, o = new qe, a = new Wd({ depthPacking: Yx }), l = new Sx, u = {}, c = e.maxTextureSize, h = { [ai]: Ln, [Ln]: ai, [Nr]: Nr }, d = new it({ defines: { VSM_SAMPLES: 8 }, uniforms: { shadow_pass: { value: null }, resolution: { value: new B }, radius: { value: 4 } }, vertexShader: kF, fragmentShader: UF }), f = d.clone(); f.defines.HORIZONTAL_PASS = 1; let p = new Ce; p.setAttribute("position", new ze(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3)); let m = new Rn(p, d), g = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = Fm, this.render = function (b, S, _) { if (g.enabled === !1 || g.autoUpdate === !1 && g.needsUpdate === !1 || b.length === 0) return; let E = i.getRenderTarget(), w = i.getActiveCubeFace(), M = i.getActiveMipmapLevel(), T = i.state; T.setBlending(Ot), T.buffers.color.setClear(1, 1, 1, 1), T.buffers.depth.setTest(!0), T.setScissorTest(!1); for (let I = 0, C = b.length; I < C; I++) { let P = b[I], D = P.shadow; if (D === void 0) { console.warn("THREE.WebGLShadowMap:", P, "has no shadow."); continue } if (D.autoUpdate === !1 && D.needsUpdate === !1) continue; r.copy(D.mapSize); let L = D.getFrameExtents(); if (r.multiply(L), s.copy(D.mapSize), (r.x > c || r.y > c) && (r.x > c && (s.x = Math.floor(c / L.x), r.x = s.x * L.x, D.mapSize.x = s.x), r.y > c && (s.y = Math.floor(c / L.y), r.y = s.y * L.y, D.mapSize.y = s.y)), D.map === null) { let U = this.type !== Ld ? { minFilter: Dt, magFilter: Dt } : {}; D.map = new at(r.x, r.y, U), D.map.texture.name = P.name + ".shadowMap", D.camera.updateProjectionMatrix() } i.setRenderTarget(D.map), i.clear(); let H = D.getViewportCount(); for (let U = 0; U < H; U++) { let V = D.getViewport(U); o.set(s.x * V.x, s.y * V.y, s.x * V.z, s.y * V.w), T.viewport(o), D.updateMatrices(P, U), n = D.getFrustum(), x(S, _, D.camera, P, this.type) } D.isPointLightShadow !== !0 && this.type === Ld && y(D, _), D.needsUpdate = !1 } g.needsUpdate = !1, i.setRenderTarget(E, w, M) }; function y (b, S) { let _ = t.update(m); d.defines.VSM_SAMPLES !== b.blurSamples && (d.defines.VSM_SAMPLES = b.blurSamples, f.defines.VSM_SAMPLES = b.blurSamples, d.needsUpdate = !0, f.needsUpdate = !0), b.mapPass === null && (b.mapPass = new at(r.x, r.y)), d.uniforms.shadow_pass.value = b.map.texture, d.uniforms.resolution.value = b.mapSize, d.uniforms.radius.value = b.radius, i.setRenderTarget(b.mapPass), i.clear(), i.renderBufferDirect(S, null, _, d, m, null), f.uniforms.shadow_pass.value = b.mapPass.texture, f.uniforms.resolution.value = b.mapSize, f.uniforms.radius.value = b.radius, i.setRenderTarget(b.map), i.clear(), i.renderBufferDirect(S, null, _, f, m, null) } function v (b, S, _, E, w, M) { let T = null, I = _.isPointLight === !0 ? b.customDistanceMaterial : b.customDepthMaterial; if (I !== void 0) T = I; else if (T = _.isPointLight === !0 ? l : a, i.localClippingEnabled && S.clipShadows === !0 && Array.isArray(S.clippingPlanes) && S.clippingPlanes.length !== 0 || S.displacementMap && S.displacementScale !== 0 || S.alphaMap && S.alphaTest > 0 || S.map && S.alphaTest > 0) { let C = T.uuid, P = S.uuid, D = u[C]; D === void 0 && (D = {}, u[C] = D); let L = D[P]; L === void 0 && (L = T.clone(), D[P] = L), T = L } return T.visible = S.visible, T.wireframe = S.wireframe, M === Ld ? T.side = S.shadowSide !== null ? S.shadowSide : S.side : T.side = S.shadowSide !== null ? S.shadowSide : h[S.side], T.alphaMap = S.alphaMap, T.alphaTest = S.alphaTest, T.map = S.map, T.clipShadows = S.clipShadows, T.clippingPlanes = S.clippingPlanes, T.clipIntersection = S.clipIntersection, T.displacementMap = S.displacementMap, T.displacementScale = S.displacementScale, T.displacementBias = S.displacementBias, T.wireframeLinewidth = S.wireframeLinewidth, T.linewidth = S.linewidth, _.isPointLight === !0 && T.isMeshDistanceMaterial === !0 && (T.referencePosition.setFromMatrixPosition(_.matrixWorld), T.nearDistance = E, T.farDistance = w), T } function x (b, S, _, E, w) { if (b.visible === !1) return; if (b.layers.test(S.layers) && (b.isMesh || b.isLine || b.isPoints) && (b.castShadow || b.receiveShadow && w === Ld) && (!b.frustumCulled || n.intersectsObject(b))) { b.modelViewMatrix.multiplyMatrices(_.matrixWorldInverse, b.matrixWorld); let I = t.update(b), C = b.material; if (Array.isArray(C)) { let P = I.groups; for (let D = 0, L = P.length; D < L; D++) { let H = P[D], U = C[H.materialIndex]; if (U && U.visible) { let V = v(b, U, E, _.near, _.far, w); i.renderBufferDirect(_, null, I, V, b, H) } } } else if (C.visible) { let P = v(b, C, E, _.near, _.far, w); i.renderBufferDirect(_, null, I, P, b, null) } } let T = b.children; for (let I = 0, C = T.length; I < C; I++)x(T[I], S, _, E, w) } } function GF (i, t, e) { let n = e.isWebGL2; function r () { let Y = !1, le = new qe, ye = null, Be = new qe(0, 0, 0, 0); return { setMask: function (Re) { ye !== Re && !Y && (i.colorMask(Re, Re, Re, Re), ye = Re) }, setLocked: function (Re) { Y = Re }, setClear: function (Re, bt, Pn, yn, Za) { Za === !0 && (Re *= yn, bt *= yn, Pn *= yn), le.set(Re, bt, Pn, yn), Be.equals(le) === !1 && (i.clearColor(Re, bt, Pn, yn), Be.copy(le)) }, reset: function () { Y = !1, ye = null, Be.set(-1, 0, 0, 0) } } } function s () { let Y = !1, le = null, ye = null, Be = null; return { setTest: function (Re) { Re ? Z(2929) : K(2929) }, setMask: function (Re) { le !== Re && !Y && (i.depthMask(Re), le = Re) }, setFunc: function (Re) { if (ye !== Re) { switch (Re) { case yR: i.depthFunc(512); break; case vR: i.depthFunc(519); break; case xR: i.depthFunc(513); break; case ax: i.depthFunc(515); break; case bR: i.depthFunc(514); break; case wR: i.depthFunc(518); break; case SR: i.depthFunc(516); break; case AR: i.depthFunc(517); break; default: i.depthFunc(515) }ye = Re } }, setLocked: function (Re) { Y = Re }, setClear: function (Re) { Be !== Re && (i.clearDepth(Re), Be = Re) }, reset: function () { Y = !1, le = null, ye = null, Be = null } } } function o () { let Y = !1, le = null, ye = null, Be = null, Re = null, bt = null, Pn = null, yn = null, Za = null; return { setTest: function (tn) { Y || (tn ? Z(2960) : K(2960)) }, setMask: function (tn) { le !== tn && !Y && (i.stencilMask(tn), le = tn) }, setFunc: function (tn, no, vi) { (ye !== tn || Be !== no || Re !== vi) && (i.stencilFunc(tn, no, vi), ye = tn, Be = no, Re = vi) }, setOp: function (tn, no, vi) { (bt !== tn || Pn !== no || yn !== vi) && (i.stencilOp(tn, no, vi), bt = tn, Pn = no, yn = vi) }, setLocked: function (tn) { Y = tn }, setClear: function (tn) { Za !== tn && (i.clearStencil(tn), Za = tn) }, reset: function () { Y = !1, le = null, ye = null, Be = null, Re = null, bt = null, Pn = null, yn = null, Za = null } } } let a = new r, l = new s, u = new o, c = new WeakMap, h = new WeakMap, d = {}, f = {}, p = new WeakMap, m = [], g = null, y = !1, v = null, x = null, b = null, S = null, _ = null, E = null, w = null, M = !1, T = null, I = null, C = null, P = null, D = null, L = i.getParameter(35661), H = !1, U = 0, V = i.getParameter(7938); V.indexOf("WebGL") !== -1 ? (U = parseFloat(/^WebGL (\d)/.exec(V)[1]), H = U >= 1) : V.indexOf("OpenGL ES") !== -1 && (U = parseFloat(/^OpenGL ES (\d)/.exec(V)[1]), H = U >= 2); let G = null, z = {}, $ = i.getParameter(3088), F = i.getParameter(2978), j = new qe().fromArray($), X = new qe().fromArray(F); function q (Y, le, ye) { let Be = new Uint8Array(4), Re = i.createTexture(); i.bindTexture(Y, Re), i.texParameteri(Y, 10241, 9728), i.texParameteri(Y, 10240, 9728); for (let bt = 0; bt < ye; bt++)i.texImage2D(le + bt, 0, 6408, 1, 1, 0, 6408, 5121, Be); return Re } let k = {}; k[3553] = q(3553, 3553, 1), k[34067] = q(34067, 34069, 6), a.setClear(0, 0, 0, 1), l.setClear(1), u.setClear(0), Z(2929), l.setFunc(ax), Ie(!1), Pe(X1), Z(2884), be(Ot); function Z (Y) { d[Y] !== !0 && (i.enable(Y), d[Y] = !0) } function K (Y) { d[Y] !== !1 && (i.disable(Y), d[Y] = !1) } function Q (Y, le) { return f[Y] !== le ? (i.bindFramebuffer(Y, le), f[Y] = le, n && (Y === 36009 && (f[36160] = le), Y === 36160 && (f[36009] = le)), !0) : !1 } function W (Y, le) { let ye = m, Be = !1; if (Y) if (ye = p.get(le), ye === void 0 && (ye = [], p.set(le, ye)), Y.isWebGLMultipleRenderTargets) { let Re = Y.texture; if (ye.length !== Re.length || ye[0] !== 36064) { for (let bt = 0, Pn = Re.length; bt < Pn; bt++)ye[bt] = 36064 + bt; ye.length = Re.length, Be = !0 } } else ye[0] !== 36064 && (ye[0] = 36064, Be = !0); else ye[0] !== 1029 && (ye[0] = 1029, Be = !0); Be && (e.isWebGL2 ? i.drawBuffers(ye) : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(ye)) } function ge (Y) { return g !== Y ? (i.useProgram(Y), g = Y, !0) : !1 } let de = { [bc]: 32774, [oR]: 32778, [aR]: 32779 }; if (n) de[J1] = 32775, de[$1] = 32776; else { let Y = t.get("EXT_blend_minmax"); Y !== null && (de[J1] = Y.MIN_EXT, de[$1] = Y.MAX_EXT) } let ie = { [lR]: 0, [cR]: 1, [uR]: 768, [E_]: 770, [gR]: 776, [pR]: 774, [dR]: 772, [hR]: 769, [M_]: 771, [mR]: 775, [fR]: 773 }; function be (Y, le, ye, Be, Re, bt, Pn, yn) { if (Y === Ot) { y === !0 && (K(3042), y = !1); return } if (y === !1 && (Z(3042), y = !0), Y !== sR) { if (Y !== v || yn !== M) { if ((x !== bc || _ !== bc) && (i.blendEquation(32774), x = bc, _ = bc), yn) switch (Y) { case Ec: i.blendFuncSeparate(1, 771, 1, 771); break; case Q1: i.blendFunc(1, 1); break; case K1: i.blendFuncSeparate(0, 769, 0, 1); break; case Z1: i.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", Y); break } else switch (Y) { case Ec: i.blendFuncSeparate(770, 771, 1, 771); break; case Q1: i.blendFunc(770, 1); break; case K1: i.blendFuncSeparate(0, 769, 0, 1); break; case Z1: i.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", Y); break }b = null, S = null, E = null, w = null, v = Y, M = yn } return } Re = Re || le, bt = bt || ye, Pn = Pn || Be, (le !== x || Re !== _) && (i.blendEquationSeparate(de[le], de[Re]), x = le, _ = Re), (ye !== b || Be !== S || bt !== E || Pn !== w) && (i.blendFuncSeparate(ie[ye], ie[Be], ie[bt], ie[Pn]), b = ye, S = Be, E = bt, w = Pn), v = Y, M = !1 } function ve (Y, le) { Y.side === Nr ? K(2884) : Z(2884); let ye = Y.side === Ln; le && (ye = !ye), Ie(ye), Y.blending === Ec && Y.transparent === !1 ? be(Ot) : be(Y.blending, Y.blendEquation, Y.blendSrc, Y.blendDst, Y.blendEquationAlpha, Y.blendSrcAlpha, Y.blendDstAlpha, Y.premultipliedAlpha), l.setFunc(Y.depthFunc), l.setTest(Y.depthTest), l.setMask(Y.depthWrite), a.setMask(Y.colorWrite); let Be = Y.stencilWrite; u.setTest(Be), Be && (u.setMask(Y.stencilWriteMask), u.setFunc(Y.stencilFunc, Y.stencilRef, Y.stencilFuncMask), u.setOp(Y.stencilFail, Y.stencilZFail, Y.stencilZPass)), Se(Y.polygonOffset, Y.polygonOffsetFactor, Y.polygonOffsetUnits), Y.alphaToCoverage === !0 ? Z(32926) : K(32926) } function Ie (Y) { T !== Y && (Y ? i.frontFace(2304) : i.frontFace(2305), T = Y) } function Pe (Y) { Y !== nR ? (Z(2884), Y !== I && (Y === X1 ? i.cullFace(1029) : Y === rR ? i.cullFace(1028) : i.cullFace(1032))) : K(2884), I = Y } function Me (Y) { Y !== C && (H && i.lineWidth(Y), C = Y) } function Se (Y, le, ye) { Y ? (Z(32823), (P !== le || D !== ye) && (i.polygonOffset(le, ye), P = le, D = ye)) : K(32823) } function Fe (Y) { Y ? Z(3089) : K(3089) } function ke (Y) { Y === void 0 && (Y = 33984 + L - 1), G !== Y && (i.activeTexture(Y), G = Y) } function R (Y, le, ye) { ye === void 0 && (G === null ? ye = 33984 + L - 1 : ye = G); let Be = z[ye]; Be === void 0 && (Be = { type: void 0, texture: void 0 }, z[ye] = Be), (Be.type !== Y || Be.texture !== le) && (G !== ye && (i.activeTexture(ye), G = ye), i.bindTexture(Y, le || k[Y]), Be.type = Y, Be.texture = le) } function O () { let Y = z[G]; Y !== void 0 && Y.type !== void 0 && (i.bindTexture(Y.type, null), Y.type = void 0, Y.texture = void 0) } function ne () { try { i.compressedTexImage2D.apply(i, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function ce () { try { i.compressedTexImage3D.apply(i, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function pe () { try { i.texSubImage2D.apply(i, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function Te () { try { i.texSubImage3D.apply(i, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function Ae () { try { i.compressedTexSubImage2D.apply(i, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function we () { try { i.compressedTexSubImage3D.apply(i, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function ae () { try { i.texStorage2D.apply(i, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function Xe () { try { i.texStorage3D.apply(i, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function Ne () { try { i.texImage2D.apply(i, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function De () { try { i.texImage3D.apply(i, arguments) } catch (Y) { console.error("THREE.WebGLState:", Y) } } function He (Y) { j.equals(Y) === !1 && (i.scissor(Y.x, Y.y, Y.z, Y.w), j.copy(Y)) } function Ze (Y) { X.equals(Y) === !1 && (i.viewport(Y.x, Y.y, Y.z, Y.w), X.copy(Y)) } function xt (Y, le) { let ye = h.get(le); ye === void 0 && (ye = new WeakMap, h.set(le, ye)); let Be = ye.get(Y); Be === void 0 && (Be = i.getUniformBlockIndex(le, Y.name), ye.set(Y, Be)) } function qt (Y, le) { let Be = h.get(le).get(Y); c.get(le) !== Be && (i.uniformBlockBinding(le, Be, Y.__bindingPointIndex), c.set(le, Be)) } function Cn () { i.disable(3042), i.disable(2884), i.disable(2929), i.disable(32823), i.disable(3089), i.disable(2960), i.disable(32926), i.blendEquation(32774), i.blendFunc(1, 0), i.blendFuncSeparate(1, 0, 1, 0), i.colorMask(!0, !0, !0, !0), i.clearColor(0, 0, 0, 0), i.depthMask(!0), i.depthFunc(513), i.clearDepth(1), i.stencilMask(4294967295), i.stencilFunc(519, 0, 4294967295), i.stencilOp(7680, 7680, 7680), i.clearStencil(0), i.cullFace(1029), i.frontFace(2305), i.polygonOffset(0, 0), i.activeTexture(33984), i.bindFramebuffer(36160, null), n === !0 && (i.bindFramebuffer(36009, null), i.bindFramebuffer(36008, null)), i.useProgram(null), i.lineWidth(1), i.scissor(0, 0, i.canvas.width, i.canvas.height), i.viewport(0, 0, i.canvas.width, i.canvas.height), d = {}, G = null, z = {}, f = {}, p = new WeakMap, m = [], g = null, y = !1, v = null, x = null, b = null, S = null, _ = null, E = null, w = null, M = !1, T = null, I = null, C = null, P = null, D = null, j.set(0, 0, i.canvas.width, i.canvas.height), X.set(0, 0, i.canvas.width, i.canvas.height), a.reset(), l.reset(), u.reset() } return { buffers: { color: a, depth: l, stencil: u }, enable: Z, disable: K, bindFramebuffer: Q, drawBuffers: W, useProgram: ge, setBlending: be, setMaterial: ve, setFlipSided: Ie, setCullFace: Pe, setLineWidth: Me, setPolygonOffset: Se, setScissorTest: Fe, activeTexture: ke, bindTexture: R, unbindTexture: O, compressedTexImage2D: ne, compressedTexImage3D: ce, texImage2D: Ne, texImage3D: De, updateUBOMapping: xt, uniformBlockBinding: qt, texStorage2D: ae, texStorage3D: Xe, texSubImage2D: pe, texSubImage3D: Te, compressedTexSubImage2D: Ae, compressedTexSubImage3D: we, scissor: He, viewport: Ze, reset: Cn } } function VF (i, t, e, n, r, s, o) { let a = r.isWebGL2, l = r.maxTextures, u = r.maxCubemapSize, c = r.maxTextureSize, h = r.maxSamples, d = t.has("WEBGL_multisampled_render_to_texture") ? t.get("WEBGL_multisampled_render_to_texture") : null, f = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent), p = new WeakMap, m, g = new WeakMap, y = !1; try { y = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null } catch { } function v (R, O) { return y ? new OffscreenCanvas(R, O) : fm("canvas") } function x (R, O, ne, ce) { let pe = 1; if ((R.width > ce || R.height > ce) && (pe = ce / Math.max(R.width, R.height)), pe < 1 || O === !0) if (typeof HTMLImageElement < "u" && R instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && R instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && R instanceof ImageBitmap) { let Te = O ? dm : Math.floor, Ae = Te(pe * R.width), we = Te(pe * R.height); m === void 0 && (m = v(Ae, we)); let ae = ne ? v(Ae, we) : m; return ae.width = Ae, ae.height = we, ae.getContext("2d").drawImage(R, 0, 0, Ae, we), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + R.width + "x" + R.height + ") to (" + Ae + "x" + we + ")."), ae } else return "data" in R && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + R.width + "x" + R.height + ")."), R; return R } function b (R) { return fx(R.width) && fx(R.height) } function S (R) { return a ? !1 : R.wrapS !== Yt || R.wrapT !== Yt || R.minFilter !== Dt && R.minFilter !== Ke } function _ (R, O) { return R.generateMipmaps && O && R.minFilter !== Dt && R.minFilter !== Ke } function E (R) { i.generateMipmap(R) } function w (R, O, ne, ce, pe = !1) { if (a === !1) return O; if (R !== null) { if (i[R] !== void 0) return i[R]; console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + R + "'") } let Te = O; return O === 6403 && (ne === 5126 && (Te = 33326), ne === 5131 && (Te = 33325), ne === 5121 && (Te = 33321)), O === 33319 && (ne === 5126 && (Te = 33328), ne === 5131 && (Te = 33327), ne === 5121 && (Te = 33323)), O === 6408 && (ne === 5126 && (Te = 34836), ne === 5131 && (Te = 34842), ne === 5121 && (Te = ce === Je && pe === !1 ? 35907 : 32856), ne === 32819 && (Te = 32854), ne === 32820 && (Te = 32855)), (Te === 33325 || Te === 33326 || Te === 33327 || Te === 33328 || Te === 34842 || Te === 34836) && t.get("EXT_color_buffer_float"), Te } function M (R, O, ne) { return _(R, ne) === !0 || R.isFramebufferTexture && R.minFilter !== Dt && R.minFilter !== Ke ? Math.log2(Math.max(O.width, O.height)) + 1 : R.mipmaps !== void 0 && R.mipmaps.length > 0 ? R.mipmaps.length : R.isCompressedTexture && Array.isArray(R.image) ? O.mipmaps.length : 1 } function T (R) { return R === Dt || R === eA || R === _0 ? 9728 : 9729 } function I (R) { let O = R.target; O.removeEventListener("dispose", I), P(O), O.isVideoTexture && p.delete(O) } function C (R) { let O = R.target; O.removeEventListener("dispose", C), L(O) } function P (R) { let O = n.get(R); if (O.__webglInit === void 0) return; let ne = R.source, ce = g.get(ne); if (ce) { let pe = ce[O.__cacheKey]; pe.usedTimes--, pe.usedTimes === 0 && D(R), Object.keys(ce).length === 0 && g.delete(ne) } n.remove(R) } function D (R) { let O = n.get(R); i.deleteTexture(O.__webglTexture); let ne = R.source, ce = g.get(ne); delete ce[O.__cacheKey], o.memory.textures-- } function L (R) { let O = R.texture, ne = n.get(R), ce = n.get(O); if (ce.__webglTexture !== void 0 && (i.deleteTexture(ce.__webglTexture), o.memory.textures--), R.depthTexture && R.depthTexture.dispose(), R.isWebGLCubeRenderTarget) for (let pe = 0; pe < 6; pe++)i.deleteFramebuffer(ne.__webglFramebuffer[pe]), ne.__webglDepthbuffer && i.deleteRenderbuffer(ne.__webglDepthbuffer[pe]); else { if (i.deleteFramebuffer(ne.__webglFramebuffer), ne.__webglDepthbuffer && i.deleteRenderbuffer(ne.__webglDepthbuffer), ne.__webglMultisampledFramebuffer && i.deleteFramebuffer(ne.__webglMultisampledFramebuffer), ne.__webglColorRenderbuffer) for (let pe = 0; pe < ne.__webglColorRenderbuffer.length; pe++)ne.__webglColorRenderbuffer[pe] && i.deleteRenderbuffer(ne.__webglColorRenderbuffer[pe]); ne.__webglDepthRenderbuffer && i.deleteRenderbuffer(ne.__webglDepthRenderbuffer) } if (R.isWebGLMultipleRenderTargets) for (let pe = 0, Te = O.length; pe < Te; pe++) { let Ae = n.get(O[pe]); Ae.__webglTexture && (i.deleteTexture(Ae.__webglTexture), o.memory.textures--), n.remove(O[pe]) } n.remove(O), n.remove(R) } let H = 0; function U () { H = 0 } function V () { let R = H; return R >= l && console.warn("THREE.WebGLTextures: Trying to use " + R + " texture units while this GPU supports only " + l), H += 1, R } function G (R) { let O = []; return O.push(R.wrapS), O.push(R.wrapT), O.push(R.wrapR || 0), O.push(R.magFilter), O.push(R.minFilter), O.push(R.anisotropy), O.push(R.internalFormat), O.push(R.format), O.push(R.type), O.push(R.generateMipmaps), O.push(R.premultiplyAlpha), O.push(R.flipY), O.push(R.unpackAlignment), O.push(R.encoding), O.join() } function z (R, O) { let ne = n.get(R); if (R.isVideoTexture && Fe(R), R.isRenderTargetTexture === !1 && R.version > 0 && ne.__version !== R.version) { let ce = R.image; if (ce === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found."); else if (ce.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete"); else { K(ne, R, O); return } } e.bindTexture(3553, ne.__webglTexture, 33984 + O) } function $ (R, O) { let ne = n.get(R); if (R.version > 0 && ne.__version !== R.version) { K(ne, R, O); return } e.bindTexture(35866, ne.__webglTexture, 33984 + O) } function F (R, O) { let ne = n.get(R); if (R.version > 0 && ne.__version !== R.version) { K(ne, R, O); return } e.bindTexture(32879, ne.__webglTexture, 33984 + O) } function j (R, O) { let ne = n.get(R); if (R.version > 0 && ne.__version !== R.version) { Q(ne, R, O); return } e.bindTexture(34067, ne.__webglTexture, 33984 + O) } let X = { [ji]: 10497, [Yt]: 33071, [ux]: 33648 }, q = { [Dt]: 9728, [eA]: 9984, [_0]: 9986, [Ke]: 9729, [DR]: 9985, [ll]: 9987 }; function k (R, O, ne) { if (ne ? (i.texParameteri(R, 10242, X[O.wrapS]), i.texParameteri(R, 10243, X[O.wrapT]), (R === 32879 || R === 35866) && i.texParameteri(R, 32882, X[O.wrapR]), i.texParameteri(R, 10240, q[O.magFilter]), i.texParameteri(R, 10241, q[O.minFilter])) : (i.texParameteri(R, 10242, 33071), i.texParameteri(R, 10243, 33071), (R === 32879 || R === 35866) && i.texParameteri(R, 32882, 33071), (O.wrapS !== Yt || O.wrapT !== Yt) && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), i.texParameteri(R, 10240, T(O.magFilter)), i.texParameteri(R, 10241, T(O.minFilter)), O.minFilter !== Dt && O.minFilter !== Ke && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), t.has("EXT_texture_filter_anisotropic") === !0) { let ce = t.get("EXT_texture_filter_anisotropic"); if (O.magFilter === Dt || O.minFilter !== _0 && O.minFilter !== ll || O.type === gr && t.has("OES_texture_float_linear") === !1 || a === !1 && O.type === cl && t.has("OES_texture_half_float_linear") === !1) return; (O.anisotropy > 1 || n.get(O).__currentAnisotropy) && (i.texParameterf(R, ce.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(O.anisotropy, r.getMaxAnisotropy())), n.get(O).__currentAnisotropy = O.anisotropy) } } function Z (R, O) { let ne = !1; R.__webglInit === void 0 && (R.__webglInit = !0, O.addEventListener("dispose", I)); let ce = O.source, pe = g.get(ce); pe === void 0 && (pe = {}, g.set(ce, pe)); let Te = G(O); if (Te !== R.__cacheKey) { pe[Te] === void 0 && (pe[Te] = { texture: i.createTexture(), usedTimes: 0 }, o.memory.textures++, ne = !0), pe[Te].usedTimes++; let Ae = pe[R.__cacheKey]; Ae !== void 0 && (pe[R.__cacheKey].usedTimes--, Ae.usedTimes === 0 && D(O)), R.__cacheKey = Te, R.__webglTexture = pe[Te].texture } return ne } function K (R, O, ne) { let ce = 3553; (O.isDataArrayTexture || O.isCompressedArrayTexture) && (ce = 35866), O.isData3DTexture && (ce = 32879); let pe = Z(R, O), Te = O.source; e.bindTexture(ce, R.__webglTexture, 33984 + ne); let Ae = n.get(Te); if (Te.version !== Ae.__version || pe === !0) { e.activeTexture(33984 + ne), i.pixelStorei(37440, O.flipY), i.pixelStorei(37441, O.premultiplyAlpha), i.pixelStorei(3317, O.unpackAlignment), i.pixelStorei(37443, 0); let we = S(O) && b(O.image) === !1, ae = x(O.image, we, !1, c); ae = ke(O, ae); let Xe = b(ae) || a, Ne = s.convert(O.format, O.encoding), De = s.convert(O.type), He = w(O.internalFormat, Ne, De, O.encoding, O.isVideoTexture); k(ce, O, Xe); let Ze, xt = O.mipmaps, qt = a && O.isVideoTexture !== !0, Cn = Ae.__version === void 0 || pe === !0, Y = M(O, ae, Xe); if (O.isDepthTexture) He = 6402, a ? O.type === gr ? He = 36012 : O.type === uo ? He = 33190 : O.type === ea ? He = 35056 : He = 33189 : O.type === gr && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), O.format === ol && He === 6402 && O.type !== P_ && O.type !== uo && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), O.type = uo, De = s.convert(O.type)), O.format === ra && He === 6402 && (He = 34041, O.type !== ea && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), O.type = ea, De = s.convert(O.type))), Cn && (qt ? e.texStorage2D(3553, 1, He, ae.width, ae.height) : e.texImage2D(3553, 0, He, ae.width, ae.height, 0, Ne, De, null)); else if (O.isDataTexture) if (xt.length > 0 && Xe) { qt && Cn && e.texStorage2D(3553, Y, He, xt[0].width, xt[0].height); for (let le = 0, ye = xt.length; le < ye; le++)Ze = xt[le], qt ? e.texSubImage2D(3553, le, 0, 0, Ze.width, Ze.height, Ne, De, Ze.data) : e.texImage2D(3553, le, He, Ze.width, Ze.height, 0, Ne, De, Ze.data); O.generateMipmaps = !1 } else qt ? (Cn && e.texStorage2D(3553, Y, He, ae.width, ae.height), e.texSubImage2D(3553, 0, 0, 0, ae.width, ae.height, Ne, De, ae.data)) : e.texImage2D(3553, 0, He, ae.width, ae.height, 0, Ne, De, ae.data); else if (O.isCompressedTexture) if (O.isCompressedArrayTexture) { qt && Cn && e.texStorage3D(35866, Y, He, xt[0].width, xt[0].height, ae.depth); for (let le = 0, ye = xt.length; le < ye; le++)Ze = xt[le], O.format !== oi ? Ne !== null ? qt ? e.compressedTexSubImage3D(35866, le, 0, 0, 0, Ze.width, Ze.height, ae.depth, Ne, Ze.data, 0, 0) : e.compressedTexImage3D(35866, le, He, Ze.width, Ze.height, ae.depth, 0, Ze.data, 0, 0) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : qt ? e.texSubImage3D(35866, le, 0, 0, 0, Ze.width, Ze.height, ae.depth, Ne, De, Ze.data) : e.texImage3D(35866, le, He, Ze.width, Ze.height, ae.depth, 0, Ne, De, Ze.data) } else { qt && Cn && e.texStorage2D(3553, Y, He, xt[0].width, xt[0].height); for (let le = 0, ye = xt.length; le < ye; le++)Ze = xt[le], O.format !== oi ? Ne !== null ? qt ? e.compressedTexSubImage2D(3553, le, 0, 0, Ze.width, Ze.height, Ne, Ze.data) : e.compressedTexImage2D(3553, le, He, Ze.width, Ze.height, 0, Ze.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : qt ? e.texSubImage2D(3553, le, 0, 0, Ze.width, Ze.height, Ne, De, Ze.data) : e.texImage2D(3553, le, He, Ze.width, Ze.height, 0, Ne, De, Ze.data) } else if (O.isDataArrayTexture) qt ? (Cn && e.texStorage3D(35866, Y, He, ae.width, ae.height, ae.depth), e.texSubImage3D(35866, 0, 0, 0, 0, ae.width, ae.height, ae.depth, Ne, De, ae.data)) : e.texImage3D(35866, 0, He, ae.width, ae.height, ae.depth, 0, Ne, De, ae.data); else if (O.isData3DTexture) qt ? (Cn && e.texStorage3D(32879, Y, He, ae.width, ae.height, ae.depth), e.texSubImage3D(32879, 0, 0, 0, 0, ae.width, ae.height, ae.depth, Ne, De, ae.data)) : e.texImage3D(32879, 0, He, ae.width, ae.height, ae.depth, 0, Ne, De, ae.data); else if (O.isFramebufferTexture) { if (Cn) if (qt) e.texStorage2D(3553, Y, He, ae.width, ae.height); else { let le = ae.width, ye = ae.height; for (let Be = 0; Be < Y; Be++)e.texImage2D(3553, Be, He, le, ye, 0, Ne, De, null), le >>= 1, ye >>= 1 } } else if (xt.length > 0 && Xe) { qt && Cn && e.texStorage2D(3553, Y, He, xt[0].width, xt[0].height); for (let le = 0, ye = xt.length; le < ye; le++)Ze = xt[le], qt ? e.texSubImage2D(3553, le, 0, 0, Ne, De, Ze) : e.texImage2D(3553, le, He, Ne, De, Ze); O.generateMipmaps = !1 } else qt ? (Cn && e.texStorage2D(3553, Y, He, ae.width, ae.height), e.texSubImage2D(3553, 0, 0, 0, Ne, De, ae)) : e.texImage2D(3553, 0, He, Ne, De, ae); _(O, Xe) && E(ce), Ae.__version = Te.version, O.onUpdate && O.onUpdate(O) } R.__version = O.version } function Q (R, O, ne) { if (O.image.length !== 6) return; let ce = Z(R, O), pe = O.source; e.bindTexture(34067, R.__webglTexture, 33984 + ne); let Te = n.get(pe); if (pe.version !== Te.__version || ce === !0) { e.activeTexture(33984 + ne), i.pixelStorei(37440, O.flipY), i.pixelStorei(37441, O.premultiplyAlpha), i.pixelStorei(3317, O.unpackAlignment), i.pixelStorei(37443, 0); let Ae = O.isCompressedTexture || O.image[0].isCompressedTexture, we = O.image[0] && O.image[0].isDataTexture, ae = []; for (let le = 0; le < 6; le++)!Ae && !we ? ae[le] = x(O.image[le], !1, !0, u) : ae[le] = we ? O.image[le].image : O.image[le], ae[le] = ke(O, ae[le]); let Xe = ae[0], Ne = b(Xe) || a, De = s.convert(O.format, O.encoding), He = s.convert(O.type), Ze = w(O.internalFormat, De, He, O.encoding), xt = a && O.isVideoTexture !== !0, qt = Te.__version === void 0 || ce === !0, Cn = M(O, Xe, Ne); k(34067, O, Ne); let Y; if (Ae) { xt && qt && e.texStorage2D(34067, Cn, Ze, Xe.width, Xe.height); for (let le = 0; le < 6; le++) { Y = ae[le].mipmaps; for (let ye = 0; ye < Y.length; ye++) { let Be = Y[ye]; O.format !== oi ? De !== null ? xt ? e.compressedTexSubImage2D(34069 + le, ye, 0, 0, Be.width, Be.height, De, Be.data) : e.compressedTexImage2D(34069 + le, ye, Ze, Be.width, Be.height, 0, Be.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : xt ? e.texSubImage2D(34069 + le, ye, 0, 0, Be.width, Be.height, De, He, Be.data) : e.texImage2D(34069 + le, ye, Ze, Be.width, Be.height, 0, De, He, Be.data) } } } else { Y = O.mipmaps, xt && qt && (Y.length > 0 && Cn++, e.texStorage2D(34067, Cn, Ze, ae[0].width, ae[0].height)); for (let le = 0; le < 6; le++)if (we) { xt ? e.texSubImage2D(34069 + le, 0, 0, 0, ae[le].width, ae[le].height, De, He, ae[le].data) : e.texImage2D(34069 + le, 0, Ze, ae[le].width, ae[le].height, 0, De, He, ae[le].data); for (let ye = 0; ye < Y.length; ye++) { let Re = Y[ye].image[le].image; xt ? e.texSubImage2D(34069 + le, ye + 1, 0, 0, Re.width, Re.height, De, He, Re.data) : e.texImage2D(34069 + le, ye + 1, Ze, Re.width, Re.height, 0, De, He, Re.data) } } else { xt ? e.texSubImage2D(34069 + le, 0, 0, 0, De, He, ae[le]) : e.texImage2D(34069 + le, 0, Ze, De, He, ae[le]); for (let ye = 0; ye < Y.length; ye++) { let Be = Y[ye]; xt ? e.texSubImage2D(34069 + le, ye + 1, 0, 0, De, He, Be.image[le]) : e.texImage2D(34069 + le, ye + 1, Ze, De, He, Be.image[le]) } } } _(O, Ne) && E(34067), Te.__version = pe.version, O.onUpdate && O.onUpdate(O) } R.__version = O.version } function W (R, O, ne, ce, pe) { let Te = s.convert(ne.format, ne.encoding), Ae = s.convert(ne.type), we = w(ne.internalFormat, Te, Ae, ne.encoding); n.get(O).__hasExternalTextures || (pe === 32879 || pe === 35866 ? e.texImage3D(pe, 0, we, O.width, O.height, O.depth, 0, Te, Ae, null) : e.texImage2D(pe, 0, we, O.width, O.height, 0, Te, Ae, null)), e.bindFramebuffer(36160, R), Se(O) ? d.framebufferTexture2DMultisampleEXT(36160, ce, pe, n.get(ne).__webglTexture, 0, Me(O)) : (pe === 3553 || pe >= 34069 && pe <= 34074) && i.framebufferTexture2D(36160, ce, pe, n.get(ne).__webglTexture, 0), e.bindFramebuffer(36160, null) } function ge (R, O, ne) { if (i.bindRenderbuffer(36161, R), O.depthBuffer && !O.stencilBuffer) { let ce = 33189; if (ne || Se(O)) { let pe = O.depthTexture; pe && pe.isDepthTexture && (pe.type === gr ? ce = 36012 : pe.type === uo && (ce = 33190)); let Te = Me(O); Se(O) ? d.renderbufferStorageMultisampleEXT(36161, Te, ce, O.width, O.height) : i.renderbufferStorageMultisample(36161, Te, ce, O.width, O.height) } else i.renderbufferStorage(36161, ce, O.width, O.height); i.framebufferRenderbuffer(36160, 36096, 36161, R) } else if (O.depthBuffer && O.stencilBuffer) { let ce = Me(O); ne && Se(O) === !1 ? i.renderbufferStorageMultisample(36161, ce, 35056, O.width, O.height) : Se(O) ? d.renderbufferStorageMultisampleEXT(36161, ce, 35056, O.width, O.height) : i.renderbufferStorage(36161, 34041, O.width, O.height), i.framebufferRenderbuffer(36160, 33306, 36161, R) } else { let ce = O.isWebGLMultipleRenderTargets === !0 ? O.texture : [O.texture]; for (let pe = 0; pe < ce.length; pe++) { let Te = ce[pe], Ae = s.convert(Te.format, Te.encoding), we = s.convert(Te.type), ae = w(Te.internalFormat, Ae, we, Te.encoding), Xe = Me(O); ne && Se(O) === !1 ? i.renderbufferStorageMultisample(36161, Xe, ae, O.width, O.height) : Se(O) ? d.renderbufferStorageMultisampleEXT(36161, Xe, ae, O.width, O.height) : i.renderbufferStorage(36161, ae, O.width, O.height) } } i.bindRenderbuffer(36161, null) } function de (R, O) { if (O && O.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported"); if (e.bindFramebuffer(36160, R), !(O.depthTexture && O.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); (!n.get(O.depthTexture).__webglTexture || O.depthTexture.image.width !== O.width || O.depthTexture.image.height !== O.height) && (O.depthTexture.image.width = O.width, O.depthTexture.image.height = O.height, O.depthTexture.needsUpdate = !0), z(O.depthTexture, 0); let ce = n.get(O.depthTexture).__webglTexture, pe = Me(O); if (O.depthTexture.format === ol) Se(O) ? d.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, ce, 0, pe) : i.framebufferTexture2D(36160, 36096, 3553, ce, 0); else if (O.depthTexture.format === ra) Se(O) ? d.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, ce, 0, pe) : i.framebufferTexture2D(36160, 33306, 3553, ce, 0); else throw new Error("Unknown depthTexture format") } function ie (R) { let O = n.get(R), ne = R.isWebGLCubeRenderTarget === !0; if (R.depthTexture && !O.__autoAllocateDepthBuffer) { if (ne) throw new Error("target.depthTexture not supported in Cube render targets"); de(O.__webglFramebuffer, R) } else if (ne) { O.__webglDepthbuffer = []; for (let ce = 0; ce < 6; ce++)e.bindFramebuffer(36160, O.__webglFramebuffer[ce]), O.__webglDepthbuffer[ce] = i.createRenderbuffer(), ge(O.__webglDepthbuffer[ce], R, !1) } else e.bindFramebuffer(36160, O.__webglFramebuffer), O.__webglDepthbuffer = i.createRenderbuffer(), ge(O.__webglDepthbuffer, R, !1); e.bindFramebuffer(36160, null) } function be (R, O, ne) { let ce = n.get(R); O !== void 0 && W(ce.__webglFramebuffer, R, R.texture, 36064, 3553), ne !== void 0 && ie(R) } function ve (R) { let O = R.texture, ne = n.get(R), ce = n.get(O); R.addEventListener("dispose", C), R.isWebGLMultipleRenderTargets !== !0 && (ce.__webglTexture === void 0 && (ce.__webglTexture = i.createTexture()), ce.__version = O.version, o.memory.textures++); let pe = R.isWebGLCubeRenderTarget === !0, Te = R.isWebGLMultipleRenderTargets === !0, Ae = b(R) || a; if (pe) { ne.__webglFramebuffer = []; for (let we = 0; we < 6; we++)ne.__webglFramebuffer[we] = i.createFramebuffer() } else { if (ne.__webglFramebuffer = i.createFramebuffer(), Te) if (r.drawBuffers) { let we = R.texture; for (let ae = 0, Xe = we.length; ae < Xe; ae++) { let Ne = n.get(we[ae]); Ne.__webglTexture === void 0 && (Ne.__webglTexture = i.createTexture(), o.memory.textures++) } } else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."); if (a && R.samples > 0 && Se(R) === !1) { let we = Te ? O : [O]; ne.__webglMultisampledFramebuffer = i.createFramebuffer(), ne.__webglColorRenderbuffer = [], e.bindFramebuffer(36160, ne.__webglMultisampledFramebuffer); for (let ae = 0; ae < we.length; ae++) { let Xe = we[ae]; ne.__webglColorRenderbuffer[ae] = i.createRenderbuffer(), i.bindRenderbuffer(36161, ne.__webglColorRenderbuffer[ae]); let Ne = s.convert(Xe.format, Xe.encoding), De = s.convert(Xe.type), He = w(Xe.internalFormat, Ne, De, Xe.encoding, R.isXRRenderTarget === !0), Ze = Me(R); i.renderbufferStorageMultisample(36161, Ze, He, R.width, R.height), i.framebufferRenderbuffer(36160, 36064 + ae, 36161, ne.__webglColorRenderbuffer[ae]) } i.bindRenderbuffer(36161, null), R.depthBuffer && (ne.__webglDepthRenderbuffer = i.createRenderbuffer(), ge(ne.__webglDepthRenderbuffer, R, !0)), e.bindFramebuffer(36160, null) } } if (pe) { e.bindTexture(34067, ce.__webglTexture), k(34067, O, Ae); for (let we = 0; we < 6; we++)W(ne.__webglFramebuffer[we], R, O, 36064, 34069 + we); _(O, Ae) && E(34067), e.unbindTexture() } else if (Te) { let we = R.texture; for (let ae = 0, Xe = we.length; ae < Xe; ae++) { let Ne = we[ae], De = n.get(Ne); e.bindTexture(3553, De.__webglTexture), k(3553, Ne, Ae), W(ne.__webglFramebuffer, R, Ne, 36064 + ae, 3553), _(Ne, Ae) && E(3553) } e.unbindTexture() } else { let we = 3553; (R.isWebGL3DRenderTarget || R.isWebGLArrayRenderTarget) && (a ? we = R.isWebGL3DRenderTarget ? 32879 : 35866 : console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")), e.bindTexture(we, ce.__webglTexture), k(we, O, Ae), W(ne.__webglFramebuffer, R, O, 36064, we), _(O, Ae) && E(we), e.unbindTexture() } R.depthBuffer && ie(R) } function Ie (R) { let O = b(R) || a, ne = R.isWebGLMultipleRenderTargets === !0 ? R.texture : [R.texture]; for (let ce = 0, pe = ne.length; ce < pe; ce++) { let Te = ne[ce]; if (_(Te, O)) { let Ae = R.isWebGLCubeRenderTarget ? 34067 : 3553, we = n.get(Te).__webglTexture; e.bindTexture(Ae, we), E(Ae), e.unbindTexture() } } } function Pe (R) { if (a && R.samples > 0 && Se(R) === !1) { let O = R.isWebGLMultipleRenderTargets ? R.texture : [R.texture], ne = R.width, ce = R.height, pe = 16384, Te = [], Ae = R.stencilBuffer ? 33306 : 36096, we = n.get(R), ae = R.isWebGLMultipleRenderTargets === !0; if (ae) for (let Xe = 0; Xe < O.length; Xe++)e.bindFramebuffer(36160, we.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(36160, 36064 + Xe, 36161, null), e.bindFramebuffer(36160, we.__webglFramebuffer), i.framebufferTexture2D(36009, 36064 + Xe, 3553, null, 0); e.bindFramebuffer(36008, we.__webglMultisampledFramebuffer), e.bindFramebuffer(36009, we.__webglFramebuffer); for (let Xe = 0; Xe < O.length; Xe++) { Te.push(36064 + Xe), R.depthBuffer && Te.push(Ae); let Ne = we.__ignoreDepthValues !== void 0 ? we.__ignoreDepthValues : !1; if (Ne === !1 && (R.depthBuffer && (pe |= 256), R.stencilBuffer && (pe |= 1024)), ae && i.framebufferRenderbuffer(36008, 36064, 36161, we.__webglColorRenderbuffer[Xe]), Ne === !0 && (i.invalidateFramebuffer(36008, [Ae]), i.invalidateFramebuffer(36009, [Ae])), ae) { let De = n.get(O[Xe]).__webglTexture; i.framebufferTexture2D(36009, 36064, 3553, De, 0) } i.blitFramebuffer(0, 0, ne, ce, 0, 0, ne, ce, pe, 9728), f && i.invalidateFramebuffer(36008, Te) } if (e.bindFramebuffer(36008, null), e.bindFramebuffer(36009, null), ae) for (let Xe = 0; Xe < O.length; Xe++) { e.bindFramebuffer(36160, we.__webglMultisampledFramebuffer), i.framebufferRenderbuffer(36160, 36064 + Xe, 36161, we.__webglColorRenderbuffer[Xe]); let Ne = n.get(O[Xe]).__webglTexture; e.bindFramebuffer(36160, we.__webglFramebuffer), i.framebufferTexture2D(36009, 36064 + Xe, 3553, Ne, 0) } e.bindFramebuffer(36009, we.__webglMultisampledFramebuffer) } } function Me (R) { return Math.min(h, R.samples) } function Se (R) { let O = n.get(R); return a && R.samples > 0 && t.has("WEBGL_multisampled_render_to_texture") === !0 && O.__useRenderToTexture !== !1 } function Fe (R) { let O = o.render.frame; p.get(R) !== O && (p.set(R, O), R.update()) } function ke (R, O) { let ne = R.encoding, ce = R.format, pe = R.type; return R.isCompressedTexture === !0 || R.isVideoTexture === !0 || R.format === dx || ne !== li && (ne === Je ? a === !1 ? t.has("EXT_sRGB") === !0 && ce === oi ? (R.format = dx, R.minFilter = Ke, R.generateMipmaps = !1) : O = pm.sRGBToLinear(O) : (ce !== oi || pe !== Zt) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", ne)), O } this.allocateTextureUnit = V, this.resetTextureUnits = U, this.setTexture2D = z, this.setTexture2DArray = $, this.setTexture3D = F, this.setTextureCube = j, this.rebindTextures = be, this.setupRenderTarget = ve, this.updateRenderTargetMipmap = Ie, this.updateMultisampleRenderTarget = Pe, this.setupDepthRenderbuffer = ie, this.setupFrameBufferTexture = W, this.useMultisampledRTT = Se } function HF (i, t, e) { let n = e.isWebGL2; function r (s, o = null) { let a; if (s === Zt) return 5121; if (s === NR) return 32819; if (s === BR) return 32820; if (s === OR) return 5120; if (s === RR) return 5122; if (s === P_) return 5123; if (s === LR) return 5124; if (s === uo) return 5125; if (s === gr) return 5126; if (s === cl) return n ? 5131 : (a = t.get("OES_texture_half_float"), a !== null ? a.HALF_FLOAT_OES : null); if (s === FR) return 6406; if (s === oi) return 6408; if (s === kR) return 6409; if (s === UR) return 6410; if (s === ol) return 6402; if (s === ra) return 34041; if (s === dx) return a = t.get("EXT_sRGB"), a !== null ? a.SRGB_ALPHA_EXT : null; if (s === zR) return 6403; if (s === GR) return 36244; if (s === Hx) return 33319; if (s === VR) return 33320; if (s === HR) return 36249; if (s === E0 || s === M0 || s === T0 || s === C0) if (o === Je) if (a = t.get("WEBGL_compressed_texture_s3tc_srgb"), a !== null) { if (s === E0) return a.COMPRESSED_SRGB_S3TC_DXT1_EXT; if (s === M0) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT; if (s === T0) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT; if (s === C0) return a.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT } else return null; else if (a = t.get("WEBGL_compressed_texture_s3tc"), a !== null) { if (s === E0) return a.COMPRESSED_RGB_S3TC_DXT1_EXT; if (s === M0) return a.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (s === T0) return a.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (s === C0) return a.COMPRESSED_RGBA_S3TC_DXT5_EXT } else return null; if (s === tA || s === nA || s === rA || s === iA) if (a = t.get("WEBGL_compressed_texture_pvrtc"), a !== null) { if (s === tA) return a.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (s === nA) return a.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (s === rA) return a.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (s === iA) return a.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } else return null; if (s === jR) return a = t.get("WEBGL_compressed_texture_etc1"), a !== null ? a.COMPRESSED_RGB_ETC1_WEBGL : null; if (s === sA || s === oA) if (a = t.get("WEBGL_compressed_texture_etc"), a !== null) { if (s === sA) return o === Je ? a.COMPRESSED_SRGB8_ETC2 : a.COMPRESSED_RGB8_ETC2; if (s === oA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : a.COMPRESSED_RGBA8_ETC2_EAC } else return null; if (s === aA || s === lA || s === cA || s === uA || s === hA || s === dA || s === fA || s === pA || s === mA || s === gA || s === yA || s === vA || s === xA || s === bA) if (a = t.get("WEBGL_compressed_texture_astc"), a !== null) { if (s === aA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : a.COMPRESSED_RGBA_ASTC_4x4_KHR; if (s === lA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : a.COMPRESSED_RGBA_ASTC_5x4_KHR; if (s === cA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : a.COMPRESSED_RGBA_ASTC_5x5_KHR; if (s === uA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : a.COMPRESSED_RGBA_ASTC_6x5_KHR; if (s === hA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : a.COMPRESSED_RGBA_ASTC_6x6_KHR; if (s === dA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : a.COMPRESSED_RGBA_ASTC_8x5_KHR; if (s === fA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : a.COMPRESSED_RGBA_ASTC_8x6_KHR; if (s === pA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : a.COMPRESSED_RGBA_ASTC_8x8_KHR; if (s === mA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : a.COMPRESSED_RGBA_ASTC_10x5_KHR; if (s === gA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : a.COMPRESSED_RGBA_ASTC_10x6_KHR; if (s === yA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : a.COMPRESSED_RGBA_ASTC_10x8_KHR; if (s === vA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : a.COMPRESSED_RGBA_ASTC_10x10_KHR; if (s === xA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : a.COMPRESSED_RGBA_ASTC_12x10_KHR; if (s === bA) return o === Je ? a.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : a.COMPRESSED_RGBA_ASTC_12x12_KHR } else return null; if (s === P0) if (a = t.get("EXT_texture_compression_bptc"), a !== null) { if (s === P0) return o === Je ? a.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : a.COMPRESSED_RGBA_BPTC_UNORM_EXT } else return null; if (s === WR || s === wA || s === SA || s === AA) if (a = t.get("EXT_texture_compression_rgtc"), a !== null) { if (s === P0) return a.COMPRESSED_RED_RGTC1_EXT; if (s === wA) return a.COMPRESSED_SIGNED_RED_RGTC1_EXT; if (s === SA) return a.COMPRESSED_RED_GREEN_RGTC2_EXT; if (s === AA) return a.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT } else return null; return s === ea ? n ? 34042 : (a = t.get("WEBGL_depth_texture"), a !== null ? a.UNSIGNED_INT_24_8_WEBGL : null) : i[s] !== void 0 ? i[s] : null } return { convert: r } } var Ax = class extends xn { constructor(t = []) { super(), this.isArrayCamera = !0, this.cameras = t } }, vs = class extends ft { constructor() { super(), this.isGroup = !0, this.type = "Group" } }, jF = { type: "move" }, kd = class { constructor() { this._targetRay = null, this._grip = null, this._hand = null } getHandSpace () { return this._hand === null && (this._hand = new vs, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = { pinching: !1 }), this._hand } getTargetRaySpace () { return this._targetRay === null && (this._targetRay = new vs, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new A, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new A), this._targetRay } getGripSpace () { return this._grip === null && (this._grip = new vs, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new A, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new A), this._grip } dispatchEvent (t) { return this._targetRay !== null && this._targetRay.dispatchEvent(t), this._grip !== null && this._grip.dispatchEvent(t), this._hand !== null && this._hand.dispatchEvent(t), this } connect (t) { if (t && t.hand) { let e = this._hand; if (e) for (let n of t.hand.values()) this._getHandJoint(e, n) } return this.dispatchEvent({ type: "connected", data: t }), this } disconnect (t) { return this.dispatchEvent({ type: "disconnected", data: t }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this } update (t, e, n) { let r = null, s = null, o = null, a = this._targetRay, l = this._grip, u = this._hand; if (t && e.session.visibilityState !== "visible-blurred") { if (u && t.hand) { o = !0; for (let m of t.hand.values()) { let g = e.getJointPose(m, n), y = this._getHandJoint(u, m); g !== null && (y.matrix.fromArray(g.transform.matrix), y.matrix.decompose(y.position, y.rotation, y.scale), y.jointRadius = g.radius), y.visible = g !== null } let c = u.joints["index-finger-tip"], h = u.joints["thumb-tip"], d = c.position.distanceTo(h.position), f = .02, p = .005; u.inputState.pinching && d > f + p ? (u.inputState.pinching = !1, this.dispatchEvent({ type: "pinchend", handedness: t.handedness, target: this })) : !u.inputState.pinching && d <= f - p && (u.inputState.pinching = !0, this.dispatchEvent({ type: "pinchstart", handedness: t.handedness, target: this })) } else l !== null && t.gripSpace && (s = e.getPose(t.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1)); a !== null && (r = e.getPose(t.targetRaySpace, n), r === null && s !== null && (r = s), r !== null && (a.matrix.fromArray(r.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), r.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(r.linearVelocity)) : a.hasLinearVelocity = !1, r.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(r.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(jF))) } return a !== null && (a.visible = r !== null), l !== null && (l.visible = s !== null), u !== null && (u.visible = o !== null), this } _getHandJoint (t, e) { if (t.joints[e.jointName] === void 0) { let n = new vs; n.matrixAutoUpdate = !1, n.visible = !1, t.joints[e.jointName] = n, t.add(n) } return t.joints[e.jointName] } }, wi = class extends Qt { constructor(t, e, n, r, s, o, a, l, u, c) { if (c = c !== void 0 ? c : ol, c !== ol && c !== ra) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); n === void 0 && c === ol && (n = uo), n === void 0 && c === ra && (n = ea), super(null, r, s, o, a, l, c, n, u), this.isDepthTexture = !0, this.image = { width: t, height: e }, this.magFilter = a !== void 0 ? a : Dt, this.minFilter = l !== void 0 ? l : Dt, this.flipY = !1, this.generateMipmaps = !1 } }, _x = class extends kt { constructor(t, e) { super(); let n = this, r = null, s = 1, o = null, a = "local-floor", l = 1, u = null, c = null, h = null, d = null, f = null, p = null, m = e.getContextAttributes(), g = null, y = null, v = [], x = [], b = new Set, S = new Map, _ = new xn; _.layers.enable(1), _.viewport = new qe; let E = new xn; E.layers.enable(2), E.viewport = new qe; let w = [_, E], M = new Ax; M.layers.enable(1), M.layers.enable(2); let T = null, I = null; this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (F) { let j = v[F]; return j === void 0 && (j = new kd, v[F] = j), j.getTargetRaySpace() }, this.getControllerGrip = function (F) { let j = v[F]; return j === void 0 && (j = new kd, v[F] = j), j.getGripSpace() }, this.getHand = function (F) { let j = v[F]; return j === void 0 && (j = new kd, v[F] = j), j.getHandSpace() }; function C (F) { let j = x.indexOf(F.inputSource); if (j === -1) return; let X = v[j]; X !== void 0 && X.dispatchEvent({ type: F.type, data: F.inputSource }) } function P () { r.removeEventListener("select", C), r.removeEventListener("selectstart", C), r.removeEventListener("selectend", C), r.removeEventListener("squeeze", C), r.removeEventListener("squeezestart", C), r.removeEventListener("squeezeend", C), r.removeEventListener("end", P), r.removeEventListener("inputsourceschange", D); for (let F = 0; F < v.length; F++) { let j = x[F]; j !== null && (x[F] = null, v[F].disconnect(j)) } T = null, I = null, t.setRenderTarget(g), f = null, d = null, h = null, r = null, y = null, $.stop(), n.isPresenting = !1, n.dispatchEvent({ type: "sessionend" }) } this.setFramebufferScaleFactor = function (F) { s = F, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.") }, this.setReferenceSpaceType = function (F) { a = F, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.") }, this.getReferenceSpace = function () { return u || o }, this.setReferenceSpace = function (F) { u = F }, this.getBaseLayer = function () { return d !== null ? d : f }, this.getBinding = function () { return h }, this.getFrame = function () { return p }, this.getSession = function () { return r }, this.setSession = async function (F) { if (r = F, r !== null) { if (g = t.getRenderTarget(), r.addEventListener("select", C), r.addEventListener("selectstart", C), r.addEventListener("selectend", C), r.addEventListener("squeeze", C), r.addEventListener("squeezestart", C), r.addEventListener("squeezeend", C), r.addEventListener("end", P), r.addEventListener("inputsourceschange", D), m.xrCompatible !== !0 && await e.makeXRCompatible(), r.renderState.layers === void 0 || t.capabilities.isWebGL2 === !1) { let j = { antialias: r.renderState.layers === void 0 ? m.antialias : !0, alpha: m.alpha, depth: m.depth, stencil: m.stencil, framebufferScaleFactor: s }; f = new XRWebGLLayer(r, e, j), r.updateRenderState({ baseLayer: f }), y = new at(f.framebufferWidth, f.framebufferHeight, { format: oi, type: Zt, encoding: t.outputEncoding, stencilBuffer: m.stencil }) } else { let j = null, X = null, q = null; m.depth && (q = m.stencil ? 35056 : 33190, j = m.stencil ? ra : ol, X = m.stencil ? ea : uo); let k = { colorFormat: 32856, depthFormat: q, scaleFactor: s }; h = new XRWebGLBinding(r, e), d = h.createProjectionLayer(k), r.updateRenderState({ layers: [d] }), y = new at(d.textureWidth, d.textureHeight, { format: oi, type: Zt, depthTexture: new wi(d.textureWidth, d.textureHeight, X, void 0, void 0, void 0, void 0, void 0, void 0, j), stencilBuffer: m.stencil, encoding: t.outputEncoding, samples: m.antialias ? 4 : 0 }); let Z = t.properties.get(y); Z.__ignoreDepthValues = d.ignoreDepthValues } y.isXRRenderTarget = !0, this.setFoveation(l), u = null, o = await r.requestReferenceSpace(a), $.setContext(r), $.start(), n.isPresenting = !0, n.dispatchEvent({ type: "sessionstart" }) } }; function D (F) { for (let j = 0; j < F.removed.length; j++) { let X = F.removed[j], q = x.indexOf(X); q >= 0 && (x[q] = null, v[q].disconnect(X)) } for (let j = 0; j < F.added.length; j++) { let X = F.added[j], q = x.indexOf(X); if (q === -1) { for (let Z = 0; Z < v.length; Z++)if (Z >= x.length) { x.push(X), q = Z; break } else if (x[Z] === null) { x[Z] = X, q = Z; break } if (q === -1) break } let k = v[q]; k && k.connect(X) } } let L = new A, H = new A; function U (F, j, X) { L.setFromMatrixPosition(j.matrixWorld), H.setFromMatrixPosition(X.matrixWorld); let q = L.distanceTo(H), k = j.projectionMatrix.elements, Z = X.projectionMatrix.elements, K = k[14] / (k[10] - 1), Q = k[14] / (k[10] + 1), W = (k[9] + 1) / k[5], ge = (k[9] - 1) / k[5], de = (k[8] - 1) / k[0], ie = (Z[8] + 1) / Z[0], be = K * de, ve = K * ie, Ie = q / (-de + ie), Pe = Ie * -de; j.matrixWorld.decompose(F.position, F.quaternion, F.scale), F.translateX(Pe), F.translateZ(Ie), F.matrixWorld.compose(F.position, F.quaternion, F.scale), F.matrixWorldInverse.copy(F.matrixWorld).invert(); let Me = K + Ie, Se = Q + Ie, Fe = be - Pe, ke = ve + (q - Pe), R = W * Q / Se * Me, O = ge * Q / Se * Me; F.projectionMatrix.makePerspective(Fe, ke, R, O, Me, Se) } function V (F, j) { j === null ? F.matrixWorld.copy(F.matrix) : F.matrixWorld.multiplyMatrices(j.matrixWorld, F.matrix), F.matrixWorldInverse.copy(F.matrixWorld).invert() } this.updateCamera = function (F) { if (r === null) return; M.near = E.near = _.near = F.near, M.far = E.far = _.far = F.far, (T !== M.near || I !== M.far) && (r.updateRenderState({ depthNear: M.near, depthFar: M.far }), T = M.near, I = M.far); let j = F.parent, X = M.cameras; V(M, j); for (let k = 0; k < X.length; k++)V(X[k], j); M.matrixWorld.decompose(M.position, M.quaternion, M.scale), F.matrix.copy(M.matrix), F.matrix.decompose(F.position, F.quaternion, F.scale); let q = F.children; for (let k = 0, Z = q.length; k < Z; k++)q[k].updateMatrixWorld(!0); X.length === 2 ? U(M, _, E) : M.projectionMatrix.copy(_.projectionMatrix) }, this.getCamera = function () { return M }, this.getFoveation = function () { if (!(d === null && f === null)) return l }, this.setFoveation = function (F) { l = F, d !== null && (d.fixedFoveation = F), f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = F) }, this.getPlanes = function () { return b }; let G = null; function z (F, j) { if (c = j.getViewerPose(u || o), p = j, c !== null) { let X = c.views; f !== null && (t.setRenderTargetFramebuffer(y, f.framebuffer), t.setRenderTarget(y)); let q = !1; X.length !== M.cameras.length && (M.cameras.length = 0, q = !0); for (let k = 0; k < X.length; k++) { let Z = X[k], K = null; if (f !== null) K = f.getViewport(Z); else { let W = h.getViewSubImage(d, Z); K = W.viewport, k === 0 && (t.setRenderTargetTextures(y, W.colorTexture, d.ignoreDepthValues ? void 0 : W.depthStencilTexture), t.setRenderTarget(y)) } let Q = w[k]; Q === void 0 && (Q = new xn, Q.layers.enable(k), Q.viewport = new qe, w[k] = Q), Q.matrix.fromArray(Z.transform.matrix), Q.projectionMatrix.fromArray(Z.projectionMatrix), Q.viewport.set(K.x, K.y, K.width, K.height), k === 0 && M.matrix.copy(Q.matrix), q === !0 && M.cameras.push(Q) } } for (let X = 0; X < v.length; X++) { let q = x[X], k = v[X]; q !== null && k !== void 0 && k.update(q, j, u || o) } if (G && G(F, j), j.detectedPlanes) { n.dispatchEvent({ type: "planesdetected", data: j.detectedPlanes }); let X = null; for (let q of b) j.detectedPlanes.has(q) || (X === null && (X = []), X.push(q)); if (X !== null) for (let q of X) b.delete(q), S.delete(q), n.dispatchEvent({ type: "planeremoved", data: q }); for (let q of j.detectedPlanes) if (!b.has(q)) b.add(q), S.set(q, j.lastChangedTime), n.dispatchEvent({ type: "planeadded", data: q }); else { let k = S.get(q); q.lastChangedTime > k && (S.set(q, q.lastChangedTime), n.dispatchEvent({ type: "planechanged", data: q })) } } p = null } let $ = new L_; $.setAnimationLoop(z), this.setAnimationLoop = function (F) { G = F }, this.dispose = function () { } } }; function WF (i, t) { function e (m, g) { g.color.getRGB(m.fogColor.value, R_(i)), g.isFog ? (m.fogNear.value = g.near, m.fogFar.value = g.far) : g.isFogExp2 && (m.fogDensity.value = g.density) } function n (m, g, y, v, x) { g.isMeshBasicMaterial || g.isMeshLambertMaterial ? r(m, g) : g.isMeshToonMaterial ? (r(m, g), c(m, g)) : g.isMeshPhongMaterial ? (r(m, g), u(m, g)) : g.isMeshStandardMaterial ? (r(m, g), h(m, g), g.isMeshPhysicalMaterial && d(m, g, x)) : g.isMeshMatcapMaterial ? (r(m, g), f(m, g)) : g.isMeshDepthMaterial ? r(m, g) : g.isMeshDistanceMaterial ? (r(m, g), p(m, g)) : g.isMeshNormalMaterial ? r(m, g) : g.isLineBasicMaterial ? (s(m, g), g.isLineDashedMaterial && o(m, g)) : g.isPointsMaterial ? a(m, g, y, v) : g.isSpriteMaterial ? l(m, g) : g.isShadowMaterial ? (m.color.value.copy(g.color), m.opacity.value = g.opacity) : g.isShaderMaterial && (g.uniformsNeedUpdate = !1) } function r (m, g) { m.opacity.value = g.opacity, g.color && m.diffuse.value.copy(g.color), g.emissive && m.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity), g.map && (m.map.value = g.map), g.alphaMap && (m.alphaMap.value = g.alphaMap), g.bumpMap && (m.bumpMap.value = g.bumpMap, m.bumpScale.value = g.bumpScale, g.side === Ln && (m.bumpScale.value *= -1)), g.displacementMap && (m.displacementMap.value = g.displacementMap, m.displacementScale.value = g.displacementScale, m.displacementBias.value = g.displacementBias), g.emissiveMap && (m.emissiveMap.value = g.emissiveMap), g.normalMap && (m.normalMap.value = g.normalMap, m.normalScale.value.copy(g.normalScale), g.side === Ln && m.normalScale.value.negate()), g.specularMap && (m.specularMap.value = g.specularMap), g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest); let y = t.get(g).envMap; if (y && (m.envMap.value = y, m.flipEnvMap.value = y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1, m.reflectivity.value = g.reflectivity, m.ior.value = g.ior, m.refractionRatio.value = g.refractionRatio), g.lightMap) { m.lightMap.value = g.lightMap; let b = i.physicallyCorrectLights !== !0 ? Math.PI : 1; m.lightMapIntensity.value = g.lightMapIntensity * b } g.aoMap && (m.aoMap.value = g.aoMap, m.aoMapIntensity.value = g.aoMapIntensity); let v; g.map ? v = g.map : g.specularMap ? v = g.specularMap : g.displacementMap ? v = g.displacementMap : g.normalMap ? v = g.normalMap : g.bumpMap ? v = g.bumpMap : g.roughnessMap ? v = g.roughnessMap : g.metalnessMap ? v = g.metalnessMap : g.alphaMap ? v = g.alphaMap : g.emissiveMap ? v = g.emissiveMap : g.clearcoatMap ? v = g.clearcoatMap : g.clearcoatNormalMap ? v = g.clearcoatNormalMap : g.clearcoatRoughnessMap ? v = g.clearcoatRoughnessMap : g.iridescenceMap ? v = g.iridescenceMap : g.iridescenceThicknessMap ? v = g.iridescenceThicknessMap : g.specularIntensityMap ? v = g.specularIntensityMap : g.specularColorMap ? v = g.specularColorMap : g.transmissionMap ? v = g.transmissionMap : g.thicknessMap ? v = g.thicknessMap : g.sheenColorMap ? v = g.sheenColorMap : g.sheenRoughnessMap && (v = g.sheenRoughnessMap), v !== void 0 && (v.isWebGLRenderTarget && (v = v.texture), v.matrixAutoUpdate === !0 && v.updateMatrix(), m.uvTransform.value.copy(v.matrix)); let x; g.aoMap ? x = g.aoMap : g.lightMap && (x = g.lightMap), x !== void 0 && (x.isWebGLRenderTarget && (x = x.texture), x.matrixAutoUpdate === !0 && x.updateMatrix(), m.uv2Transform.value.copy(x.matrix)) } function s (m, g) { m.diffuse.value.copy(g.color), m.opacity.value = g.opacity } function o (m, g) { m.dashSize.value = g.dashSize, m.totalSize.value = g.dashSize + g.gapSize, m.scale.value = g.scale } function a (m, g, y, v) { m.diffuse.value.copy(g.color), m.opacity.value = g.opacity, m.size.value = g.size * y, m.scale.value = v * .5, g.map && (m.map.value = g.map), g.alphaMap && (m.alphaMap.value = g.alphaMap), g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest); let x; g.map ? x = g.map : g.alphaMap && (x = g.alphaMap), x !== void 0 && (x.matrixAutoUpdate === !0 && x.updateMatrix(), m.uvTransform.value.copy(x.matrix)) } function l (m, g) { m.diffuse.value.copy(g.color), m.opacity.value = g.opacity, m.rotation.value = g.rotation, g.map && (m.map.value = g.map), g.alphaMap && (m.alphaMap.value = g.alphaMap), g.alphaTest > 0 && (m.alphaTest.value = g.alphaTest); let y; g.map ? y = g.map : g.alphaMap && (y = g.alphaMap), y !== void 0 && (y.matrixAutoUpdate === !0 && y.updateMatrix(), m.uvTransform.value.copy(y.matrix)) } function u (m, g) { m.specular.value.copy(g.specular), m.shininess.value = Math.max(g.shininess, 1e-4) } function c (m, g) { g.gradientMap && (m.gradientMap.value = g.gradientMap) } function h (m, g) { m.roughness.value = g.roughness, m.metalness.value = g.metalness, g.roughnessMap && (m.roughnessMap.value = g.roughnessMap), g.metalnessMap && (m.metalnessMap.value = g.metalnessMap), t.get(g).envMap && (m.envMapIntensity.value = g.envMapIntensity) } function d (m, g, y) { m.ior.value = g.ior, g.sheen > 0 && (m.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen), m.sheenRoughness.value = g.sheenRoughness, g.sheenColorMap && (m.sheenColorMap.value = g.sheenColorMap), g.sheenRoughnessMap && (m.sheenRoughnessMap.value = g.sheenRoughnessMap)), g.clearcoat > 0 && (m.clearcoat.value = g.clearcoat, m.clearcoatRoughness.value = g.clearcoatRoughness, g.clearcoatMap && (m.clearcoatMap.value = g.clearcoatMap), g.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = g.clearcoatRoughnessMap), g.clearcoatNormalMap && (m.clearcoatNormalScale.value.copy(g.clearcoatNormalScale), m.clearcoatNormalMap.value = g.clearcoatNormalMap, g.side === Ln && m.clearcoatNormalScale.value.negate())), g.iridescence > 0 && (m.iridescence.value = g.iridescence, m.iridescenceIOR.value = g.iridescenceIOR, m.iridescenceThicknessMinimum.value = g.iridescenceThicknessRange[0], m.iridescenceThicknessMaximum.value = g.iridescenceThicknessRange[1], g.iridescenceMap && (m.iridescenceMap.value = g.iridescenceMap), g.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = g.iridescenceThicknessMap)), g.transmission > 0 && (m.transmission.value = g.transmission, m.transmissionSamplerMap.value = y.texture, m.transmissionSamplerSize.value.set(y.width, y.height), g.transmissionMap && (m.transmissionMap.value = g.transmissionMap), m.thickness.value = g.thickness, g.thicknessMap && (m.thicknessMap.value = g.thicknessMap), m.attenuationDistance.value = g.attenuationDistance, m.attenuationColor.value.copy(g.attenuationColor)), m.specularIntensity.value = g.specularIntensity, m.specularColor.value.copy(g.specularColor), g.specularIntensityMap && (m.specularIntensityMap.value = g.specularIntensityMap), g.specularColorMap && (m.specularColorMap.value = g.specularColorMap) } function f (m, g) { g.matcap && (m.matcap.value = g.matcap) } function p (m, g) { m.referencePosition.value.copy(g.referencePosition), m.nearDistance.value = g.nearDistance, m.farDistance.value = g.farDistance } return { refreshFogUniforms: e, refreshMaterialUniforms: n } } function qF (i, t, e, n) { let r = {}, s = {}, o = [], a = e.isWebGL2 ? i.getParameter(35375) : 0; function l (v, x) { let b = x.program; n.uniformBlockBinding(v, b) } function u (v, x) { let b = r[v.id]; b === void 0 && (p(v), b = c(v), r[v.id] = b, v.addEventListener("dispose", g)); let S = x.program; n.updateUBOMapping(v, S); let _ = t.render.frame; s[v.id] !== _ && (d(v), s[v.id] = _) } function c (v) { let x = h(); v.__bindingPointIndex = x; let b = i.createBuffer(), S = v.__size, _ = v.usage; return i.bindBuffer(35345, b), i.bufferData(35345, S, _), i.bindBuffer(35345, null), i.bindBufferBase(35345, x, b), b } function h () { for (let v = 0; v < a; v++)if (o.indexOf(v) === -1) return o.push(v), v; return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0 } function d (v) { let x = r[v.id], b = v.uniforms, S = v.__cache; i.bindBuffer(35345, x); for (let _ = 0, E = b.length; _ < E; _++) { let w = b[_]; if (f(w, _, S) === !0) { let M = w.__offset, T = Array.isArray(w.value) ? w.value : [w.value], I = 0; for (let C = 0; C < T.length; C++) { let P = T[C], D = m(P); typeof P == "number" ? (w.__data[0] = P, i.bufferSubData(35345, M + I, w.__data)) : P.isMatrix3 ? (w.__data[0] = P.elements[0], w.__data[1] = P.elements[1], w.__data[2] = P.elements[2], w.__data[3] = P.elements[0], w.__data[4] = P.elements[3], w.__data[5] = P.elements[4], w.__data[6] = P.elements[5], w.__data[7] = P.elements[0], w.__data[8] = P.elements[6], w.__data[9] = P.elements[7], w.__data[10] = P.elements[8], w.__data[11] = P.elements[0]) : (P.toArray(w.__data, I), I += D.storage / Float32Array.BYTES_PER_ELEMENT) } i.bufferSubData(35345, M, w.__data) } } i.bindBuffer(35345, null) } function f (v, x, b) { let S = v.value; if (b[x] === void 0) { if (typeof S == "number") b[x] = S; else { let _ = Array.isArray(S) ? S : [S], E = []; for (let w = 0; w < _.length; w++)E.push(_[w].clone()); b[x] = E } return !0 } else if (typeof S == "number") { if (b[x] !== S) return b[x] = S, !0 } else { let _ = Array.isArray(b[x]) ? b[x] : [b[x]], E = Array.isArray(S) ? S : [S]; for (let w = 0; w < _.length; w++) { let M = _[w]; if (M.equals(E[w]) === !1) return M.copy(E[w]), !0 } } return !1 } function p (v) { let x = v.uniforms, b = 0, S = 16, _ = 0; for (let E = 0, w = x.length; E < w; E++) { let M = x[E], T = { boundary: 0, storage: 0 }, I = Array.isArray(M.value) ? M.value : [M.value]; for (let C = 0, P = I.length; C < P; C++) { let D = I[C], L = m(D); T.boundary += L.boundary, T.storage += L.storage } if (M.__data = new Float32Array(T.storage / Float32Array.BYTES_PER_ELEMENT), M.__offset = b, E > 0) { _ = b % S; let C = S - _; _ !== 0 && C - T.boundary < 0 && (b += S - _, M.__offset = b) } b += T.storage } return _ = b % S, _ > 0 && (b += S - _), v.__size = b, v.__cache = {}, this } function m (v) { let x = { boundary: 0, storage: 0 }; return typeof v == "number" ? (x.boundary = 4, x.storage = 4) : v.isVector2 ? (x.boundary = 8, x.storage = 8) : v.isVector3 || v.isColor ? (x.boundary = 16, x.storage = 12) : v.isVector4 ? (x.boundary = 16, x.storage = 16) : v.isMatrix3 ? (x.boundary = 48, x.storage = 48) : v.isMatrix4 ? (x.boundary = 64, x.storage = 64) : v.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", v), x } function g (v) { let x = v.target; x.removeEventListener("dispose", g); let b = o.indexOf(x.__bindingPointIndex); o.splice(b, 1), i.deleteBuffer(r[x.id]), delete r[x.id], delete s[x.id] } function y () { for (let v in r) i.deleteBuffer(r[v]); o = [], r = {}, s = {} } return { bind: l, update: u, dispose: y } } function YF () { let i = fm("canvas"); return i.style.display = "block", i } function Kx (i = {}) { this.isWebGLRenderer = !0; let t = i.canvas !== void 0 ? i.canvas : YF(), e = i.context !== void 0 ? i.context : null, n = i.depth !== void 0 ? i.depth : !0, r = i.stencil !== void 0 ? i.stencil : !0, s = i.antialias !== void 0 ? i.antialias : !1, o = i.premultipliedAlpha !== void 0 ? i.premultipliedAlpha : !0, a = i.preserveDrawingBuffer !== void 0 ? i.preserveDrawingBuffer : !1, l = i.powerPreference !== void 0 ? i.powerPreference : "default", u = i.failIfMajorPerformanceCaveat !== void 0 ? i.failIfMajorPerformanceCaveat : !1, c; e !== null ? c = e.getContextAttributes().alpha : c = i.alpha !== void 0 ? i.alpha : !1; let h = null, d = null, f = [], p = []; this.domElement = t, this.debug = { checkShaderErrors: !0 }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = li, this.physicallyCorrectLights = !1, this.toneMapping = fo, this.toneMappingExposure = 1; let m = this, g = !1, y = 0, v = 0, x = null, b = -1, S = null, _ = new qe, E = new qe, w = null, M = t.width, T = t.height, I = 1, C = null, P = null, D = new qe(0, 0, M, T), L = new qe(0, 0, M, T), H = !1, U = new jd, V = !1, G = !1, z = null, $ = new se, F = new B, j = new A, X = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: !0 }; function q () { return x === null ? I : 1 } let k = e; function Z (N, te) { for (let ue = 0; ue < N.length; ue++) { let ee = N[ue], fe = t.getContext(ee, te); if (fe !== null) return fe } return null } try { let N = { alpha: !0, depth: n, stencil: r, antialias: s, premultipliedAlpha: o, preserveDrawingBuffer: a, powerPreference: l, failIfMajorPerformanceCaveat: u }; if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${vo}`), t.addEventListener("webglcontextlost", He, !1), t.addEventListener("webglcontextrestored", Ze, !1), t.addEventListener("webglcontextcreationerror", xt, !1), k === null) { let te = ["webgl2", "webgl", "experimental-webgl"]; if (m.isWebGL1Renderer === !0 && te.shift(), k = Z(te, N), k === null) throw Z(te) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.") } k.getShaderPrecisionFormat === void 0 && (k.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (N) { throw console.error("THREE.WebGLRenderer: " + N.message), N } let K, Q, W, ge, de, ie, be, ve, Ie, Pe, Me, Se, Fe, ke, R, O, ne, ce, pe, Te, Ae, we, ae, Xe; function Ne () { K = new pB(k), Q = new lB(k, K, i), K.init(Q), we = new HF(k, K, Q), W = new GF(k, K, Q), ge = new yB, de = new PF, ie = new VF(k, K, W, de, Q, we, ge), be = new uB(m), ve = new fB(m), Ie = new ML(k, Q), ae = new oB(k, K, Ie, Q), Pe = new mB(k, Ie, ge, ae), Me = new wB(k, Pe, Ie, ge), pe = new bB(k, Q, ie), O = new cB(de), Se = new CF(m, be, ve, K, Q, ae, O), Fe = new WF(m, de), ke = new DF, R = new FF(K, Q), ce = new sB(m, be, ve, W, Me, c, o), ne = new zF(m, Me, Q), Xe = new qF(k, ge, Q, W), Te = new aB(k, K, ge, Q), Ae = new gB(k, K, ge, Q), ge.programs = Se.programs, m.capabilities = Q, m.extensions = K, m.properties = de, m.renderLists = ke, m.shadowMap = ne, m.state = W, m.info = ge } Ne(); let De = new _x(m, k); this.xr = De, this.getContext = function () { return k }, this.getContextAttributes = function () { return k.getContextAttributes() }, this.forceContextLoss = function () { let N = K.get("WEBGL_lose_context"); N && N.loseContext() }, this.forceContextRestore = function () { let N = K.get("WEBGL_lose_context"); N && N.restoreContext() }, this.getPixelRatio = function () { return I }, this.setPixelRatio = function (N) { N !== void 0 && (I = N, this.setSize(M, T, !1)) }, this.getSize = function (N) { return N.set(M, T) }, this.setSize = function (N, te, ue) { if (De.isPresenting) { console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."); return } M = N, T = te, t.width = Math.floor(N * I), t.height = Math.floor(te * I), ue !== !1 && (t.style.width = N + "px", t.style.height = te + "px"), this.setViewport(0, 0, N, te) }, this.getDrawingBufferSize = function (N) { return N.set(M * I, T * I).floor() }, this.setDrawingBufferSize = function (N, te, ue) { M = N, T = te, I = ue, t.width = Math.floor(N * ue), t.height = Math.floor(te * ue), this.setViewport(0, 0, N, te) }, this.getCurrentViewport = function (N) { return N.copy(_) }, this.getViewport = function (N) { return N.copy(D) }, this.setViewport = function (N, te, ue, ee) { N.isVector4 ? D.set(N.x, N.y, N.z, N.w) : D.set(N, te, ue, ee), W.viewport(_.copy(D).multiplyScalar(I).floor()) }, this.getScissor = function (N) { return N.copy(L) }, this.setScissor = function (N, te, ue, ee) { N.isVector4 ? L.set(N.x, N.y, N.z, N.w) : L.set(N, te, ue, ee), W.scissor(E.copy(L).multiplyScalar(I).floor()) }, this.getScissorTest = function () { return H }, this.setScissorTest = function (N) { W.setScissorTest(H = N) }, this.setOpaqueSort = function (N) { C = N }, this.setTransparentSort = function (N) { P = N }, this.getClearColor = function (N) { return N.copy(ce.getClearColor()) }, this.setClearColor = function () { ce.setClearColor.apply(ce, arguments) }, this.getClearAlpha = function () { return ce.getClearAlpha() }, this.setClearAlpha = function () { ce.setClearAlpha.apply(ce, arguments) }, this.clear = function (N = !0, te = !0, ue = !0) { let ee = 0; N && (ee |= 16384), te && (ee |= 256), ue && (ee |= 1024), k.clear(ee) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { t.removeEventListener("webglcontextlost", He, !1), t.removeEventListener("webglcontextrestored", Ze, !1), t.removeEventListener("webglcontextcreationerror", xt, !1), ke.dispose(), R.dispose(), de.dispose(), be.dispose(), ve.dispose(), Me.dispose(), ae.dispose(), Xe.dispose(), Se.dispose(), De.dispose(), De.removeEventListener("sessionstart", Be), De.removeEventListener("sessionend", Re), z && (z.dispose(), z = null), bt.stop() }; function He (N) { N.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), g = !0 } function Ze () { console.log("THREE.WebGLRenderer: Context Restored."), g = !1; let N = ge.autoReset, te = ne.enabled, ue = ne.autoUpdate, ee = ne.needsUpdate, fe = ne.type; Ne(), ge.autoReset = N, ne.enabled = te, ne.autoUpdate = ue, ne.needsUpdate = ee, ne.type = fe } function xt (N) { console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", N.statusMessage) } function qt (N) { let te = N.target; te.removeEventListener("dispose", qt), Cn(te) } function Cn (N) { Y(N), de.remove(N) } function Y (N) { let te = de.get(N).programs; te !== void 0 && (te.forEach(function (ue) { Se.releaseProgram(ue) }), N.isShaderMaterial && Se.releaseShaderCache(N)) } this.renderBufferDirect = function (N, te, ue, ee, fe, nt) { te === null && (te = X); let lt = fe.isMesh && fe.matrixWorld.determinant() < 0, dt = WO(N, te, ue, ee, fe); W.setMaterial(ee, lt); let gt = ue.index, Ct = 1; ee.wireframe === !0 && (gt = Pe.getWireframeAttribute(ue), Ct = 2); let wt = ue.drawRange, St = ue.attributes.position, In = wt.start * Ct, ni = (wt.start + wt.count) * Ct; nt !== null && (In = Math.max(In, nt.start * Ct), ni = Math.min(ni, (nt.start + nt.count) * Ct)), gt !== null ? (In = Math.max(In, 0), ni = Math.min(ni, gt.count)) : St != null && (In = Math.max(In, 0), ni = Math.min(ni, St.count)); let ro = ni - In; if (ro < 0 || ro === 1 / 0) return; ae.setup(fe, ee, dt, ue, gt); let Ja, Dn = Te; if (gt !== null && (Ja = Ie.get(gt), Dn = Ae, Dn.setIndex(Ja)), fe.isMesh) ee.wireframe === !0 ? (W.setLineWidth(ee.wireframeLinewidth * q()), Dn.setMode(1)) : Dn.setMode(4); else if (fe.isLine) { let At = ee.linewidth; At === void 0 && (At = 1), W.setLineWidth(At * q()), fe.isLineSegments ? Dn.setMode(1) : fe.isLineLoop ? Dn.setMode(2) : Dn.setMode(3) } else fe.isPoints ? Dn.setMode(0) : fe.isSprite && Dn.setMode(4); if (fe.isInstancedMesh) Dn.renderInstances(In, ro, fe.count); else if (ue.isInstancedBufferGeometry) { let At = ue._maxInstanceCount !== void 0 ? ue._maxInstanceCount : 1 / 0, x0 = Math.min(ue.instanceCount, At); Dn.renderInstances(In, ro, x0) } else Dn.render(In, ro) }, this.compile = function (N, te) { function ue (ee, fe, nt) { ee.transparent === !0 && ee.side === Nr && ee.forceSinglePass === !1 ? (ee.side = Ln, ee.needsUpdate = !0, vi(ee, fe, nt), ee.side = ai, ee.needsUpdate = !0, vi(ee, fe, nt), ee.side = Nr) : vi(ee, fe, nt) } d = R.get(N), d.init(), p.push(d), N.traverseVisible(function (ee) { ee.isLight && ee.layers.test(te.layers) && (d.pushLight(ee), ee.castShadow && d.pushShadow(ee)) }), d.setupLights(m.physicallyCorrectLights), N.traverse(function (ee) { let fe = ee.material; if (fe) if (Array.isArray(fe)) for (let nt = 0; nt < fe.length; nt++) { let lt = fe[nt]; ue(lt, N, ee) } else ue(fe, N, ee) }), p.pop(), d = null }; let le = null; function ye (N) { le && le(N) } function Be () { bt.stop() } function Re () { bt.start() } let bt = new L_; bt.setAnimationLoop(ye), typeof self < "u" && bt.setContext(self), this.setAnimationLoop = function (N) { le = N, De.setAnimationLoop(N), N === null ? bt.stop() : bt.start() }, De.addEventListener("sessionstart", Be), De.addEventListener("sessionend", Re), this.render = function (N, te) { if (te !== void 0 && te.isCamera !== !0) { console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."); return } if (g === !0) return; N.matrixWorldAutoUpdate === !0 && N.updateMatrixWorld(), te.parent === null && te.matrixWorldAutoUpdate === !0 && te.updateMatrixWorld(), De.enabled === !0 && De.isPresenting === !0 && (De.cameraAutoUpdate === !0 && De.updateCamera(te), te = De.getCamera()), N.isScene === !0 && N.onBeforeRender(m, N, te, x), d = R.get(N, p.length), d.init(), p.push(d), $.multiplyMatrices(te.projectionMatrix, te.matrixWorldInverse), U.setFromProjectionMatrix($), G = this.localClippingEnabled, V = O.init(this.clippingPlanes, G), h = ke.get(N, f.length), h.init(), f.push(h), Pn(N, te, 0, m.sortObjects), h.finish(), m.sortObjects === !0 && h.sort(C, P), V === !0 && O.beginShadows(); let ue = d.state.shadowsArray; if (ne.render(ue, N, te), V === !0 && O.endShadows(), this.info.autoReset === !0 && this.info.reset(), ce.render(h, N), d.setupLights(m.physicallyCorrectLights), te.isArrayCamera) { let ee = te.cameras; for (let fe = 0, nt = ee.length; fe < nt; fe++) { let lt = ee[fe]; yn(h, N, lt, lt.viewport) } } else yn(h, N, te); x !== null && (ie.updateMultisampleRenderTarget(x), ie.updateRenderTargetMipmap(x)), N.isScene === !0 && N.onAfterRender(m, N, te), ae.resetDefaultState(), b = -1, S = null, p.pop(), p.length > 0 ? d = p[p.length - 1] : d = null, f.pop(), f.length > 0 ? h = f[f.length - 1] : h = null }; function Pn (N, te, ue, ee) { if (N.visible === !1) return; if (N.layers.test(te.layers)) { if (N.isGroup) ue = N.renderOrder; else if (N.isLOD) N.autoUpdate === !0 && N.update(te); else if (N.isLight) d.pushLight(N), N.castShadow && d.pushShadow(N); else if (N.isSprite) { if (!N.frustumCulled || U.intersectsSprite(N)) { ee && j.setFromMatrixPosition(N.matrixWorld).applyMatrix4($); let lt = Me.update(N), dt = N.material; dt.visible && h.push(N, lt, dt, ue, j.z, null) } } else if ((N.isMesh || N.isLine || N.isPoints) && (N.isSkinnedMesh && N.skeleton.frame !== ge.render.frame && (N.skeleton.update(), N.skeleton.frame = ge.render.frame), !N.frustumCulled || U.intersectsObject(N))) { ee && j.setFromMatrixPosition(N.matrixWorld).applyMatrix4($); let lt = Me.update(N), dt = N.material; if (Array.isArray(dt)) { let gt = lt.groups; for (let Ct = 0, wt = gt.length; Ct < wt; Ct++) { let St = gt[Ct], In = dt[St.materialIndex]; In && In.visible && h.push(N, lt, In, ue, j.z, St) } } else dt.visible && h.push(N, lt, dt, ue, j.z, null) } } let nt = N.children; for (let lt = 0, dt = nt.length; lt < dt; lt++)Pn(nt[lt], te, ue, ee) } function yn (N, te, ue, ee) { let fe = N.opaque, nt = N.transmissive, lt = N.transparent; d.setupLightsView(ue), V === !0 && O.setGlobalState(m.clippingPlanes, ue), nt.length > 0 && Za(fe, te, ue), ee && W.viewport(_.copy(ee)), fe.length > 0 && tn(fe, te, ue), nt.length > 0 && tn(nt, te, ue), lt.length > 0 && tn(lt, te, ue), W.buffers.depth.setTest(!0), W.buffers.depth.setMask(!0), W.buffers.color.setMask(!0), W.setPolygonOffset(!1) } function Za (N, te, ue) { let ee = Q.isWebGL2; z === null && (z = new at(1, 1, { generateMipmaps: !0, type: K.has("EXT_color_buffer_half_float") ? cl : Zt, minFilter: ll, samples: ee && s === !0 ? 4 : 0 })), m.getDrawingBufferSize(F), ee ? z.setSize(F.x, F.y) : z.setSize(dm(F.x), dm(F.y)); let fe = m.getRenderTarget(); m.setRenderTarget(z), m.clear(); let nt = m.toneMapping; m.toneMapping = fo, tn(N, te, ue), m.toneMapping = nt, ie.updateMultisampleRenderTarget(z), ie.updateRenderTargetMipmap(z), m.setRenderTarget(fe) } function tn (N, te, ue) { let ee = te.isScene === !0 ? te.overrideMaterial : null; for (let fe = 0, nt = N.length; fe < nt; fe++) { let lt = N[fe], dt = lt.object, gt = lt.geometry, Ct = ee === null ? lt.material : ee, wt = lt.group; dt.layers.test(ue.layers) && no(dt, te, ue, gt, Ct, wt) } } function no (N, te, ue, ee, fe, nt) { N.onBeforeRender(m, te, ue, ee, fe, nt), N.modelViewMatrix.multiplyMatrices(ue.matrixWorldInverse, N.matrixWorld), N.normalMatrix.getNormalMatrix(N.modelViewMatrix), fe.onBeforeRender(m, te, ue, ee, N, nt), fe.transparent === !0 && fe.side === Nr && fe.forceSinglePass === !1 ? (fe.side = Ln, fe.needsUpdate = !0, m.renderBufferDirect(ue, te, ee, fe, N, nt), fe.side = ai, fe.needsUpdate = !0, m.renderBufferDirect(ue, te, ee, fe, N, nt), fe.side = Nr) : m.renderBufferDirect(ue, te, ee, fe, N, nt), N.onAfterRender(m, te, ue, ee, fe, nt) } function vi (N, te, ue) { te.isScene !== !0 && (te = X); let ee = de.get(N), fe = d.state.lights, nt = d.state.shadowsArray, lt = fe.state.version, dt = Se.getParameters(N, fe.state, nt, te, ue), gt = Se.getProgramCacheKey(dt), Ct = ee.programs; ee.environment = N.isMeshStandardMaterial ? te.environment : null, ee.fog = te.fog, ee.envMap = (N.isMeshStandardMaterial ? ve : be).get(N.envMap || ee.environment), Ct === void 0 && (N.addEventListener("dispose", qt), Ct = new Map, ee.programs = Ct); let wt = Ct.get(gt); if (wt !== void 0) { if (ee.currentProgram === wt && ee.lightsStateVersion === lt) return W1(N, dt), wt } else dt.uniforms = Se.getUniforms(N), N.onBuild(ue, dt, m), N.onBeforeCompile(dt, m), wt = Se.acquireProgram(dt, gt), Ct.set(gt, wt), ee.uniforms = dt.uniforms; let St = ee.uniforms; (!N.isShaderMaterial && !N.isRawShaderMaterial || N.clipping === !0) && (St.clippingPlanes = O.uniform), W1(N, dt), ee.needsLights = YO(N), ee.lightsStateVersion = lt, ee.needsLights && (St.ambientLightColor.value = fe.state.ambient, St.lightProbe.value = fe.state.probe, St.directionalLights.value = fe.state.directional, St.directionalLightShadows.value = fe.state.directionalShadow, St.spotLights.value = fe.state.spot, St.spotLightShadows.value = fe.state.spotShadow, St.rectAreaLights.value = fe.state.rectArea, St.ltc_1.value = fe.state.rectAreaLTC1, St.ltc_2.value = fe.state.rectAreaLTC2, St.pointLights.value = fe.state.point, St.pointLightShadows.value = fe.state.pointShadow, St.hemisphereLights.value = fe.state.hemi, St.directionalShadowMap.value = fe.state.directionalShadowMap, St.directionalShadowMatrix.value = fe.state.directionalShadowMatrix, St.spotShadowMap.value = fe.state.spotShadowMap, St.spotLightMatrix.value = fe.state.spotLightMatrix, St.spotLightMap.value = fe.state.spotLightMap, St.pointShadowMap.value = fe.state.pointShadowMap, St.pointShadowMatrix.value = fe.state.pointShadowMatrix); let In = wt.getUniforms(), ni = Mc.seqWithValue(In.seq, St); return ee.currentProgram = wt, ee.uniformsList = ni, wt } function W1 (N, te) { let ue = de.get(N); ue.outputEncoding = te.outputEncoding, ue.instancing = te.instancing, ue.skinning = te.skinning, ue.morphTargets = te.morphTargets, ue.morphNormals = te.morphNormals, ue.morphColors = te.morphColors, ue.morphTargetsCount = te.morphTargetsCount, ue.numClippingPlanes = te.numClippingPlanes, ue.numIntersection = te.numClipIntersection, ue.vertexAlphas = te.vertexAlphas, ue.vertexTangents = te.vertexTangents, ue.toneMapping = te.toneMapping } function WO (N, te, ue, ee, fe) { te.isScene !== !0 && (te = X), ie.resetTextureUnits(); let nt = te.fog, lt = ee.isMeshStandardMaterial ? te.environment : null, dt = x === null ? m.outputEncoding : x.isXRRenderTarget === !0 ? x.texture.encoding : li, gt = (ee.isMeshStandardMaterial ? ve : be).get(ee.envMap || lt), Ct = ee.vertexColors === !0 && !!ue.attributes.color && ue.attributes.color.itemSize === 4, wt = !!ee.normalMap && !!ue.attributes.tangent, St = !!ue.morphAttributes.position, In = !!ue.morphAttributes.normal, ni = !!ue.morphAttributes.color, ro = ee.toneMapped ? m.toneMapping : fo, Ja = ue.morphAttributes.position || ue.morphAttributes.normal || ue.morphAttributes.color, Dn = Ja !== void 0 ? Ja.length : 0, At = de.get(ee), x0 = d.state.lights; if (V === !0 && (G === !0 || N !== S)) { let ri = N === S && ee.id === b; O.setState(ee, N, ri) } let Jn = !1; ee.version === At.__version ? (At.needsLights && At.lightsStateVersion !== x0.state.version || At.outputEncoding !== dt || fe.isInstancedMesh && At.instancing === !1 || !fe.isInstancedMesh && At.instancing === !0 || fe.isSkinnedMesh && At.skinning === !1 || !fe.isSkinnedMesh && At.skinning === !0 || At.envMap !== gt || ee.fog === !0 && At.fog !== nt || At.numClippingPlanes !== void 0 && (At.numClippingPlanes !== O.numPlanes || At.numIntersection !== O.numIntersection) || At.vertexAlphas !== Ct || At.vertexTangents !== wt || At.morphTargets !== St || At.morphNormals !== In || At.morphColors !== ni || At.toneMapping !== ro || Q.isWebGL2 === !0 && At.morphTargetsCount !== Dn) && (Jn = !0) : (Jn = !0, At.__version = ee.version); let $a = At.currentProgram; Jn === !0 && ($a = vi(ee, te, fe)); let q1 = !1, Ed = !1, b0 = !1, mr = $a.getUniforms(), el = At.uniforms; if (W.useProgram($a.program) && (q1 = !0, Ed = !0, b0 = !0), ee.id !== b && (b = ee.id, Ed = !0), q1 || S !== N) { if (mr.setValue(k, "projectionMatrix", N.projectionMatrix), Q.logarithmicDepthBuffer && mr.setValue(k, "logDepthBufFC", 2 / (Math.log(N.far + 1) / Math.LN2)), S !== N && (S = N, Ed = !0, b0 = !0), ee.isShaderMaterial || ee.isMeshPhongMaterial || ee.isMeshToonMaterial || ee.isMeshStandardMaterial || ee.envMap) { let ri = mr.map.cameraPosition; ri !== void 0 && ri.setValue(k, j.setFromMatrixPosition(N.matrixWorld)) } (ee.isMeshPhongMaterial || ee.isMeshToonMaterial || ee.isMeshLambertMaterial || ee.isMeshBasicMaterial || ee.isMeshStandardMaterial || ee.isShaderMaterial) && mr.setValue(k, "isOrthographic", N.isOrthographicCamera === !0), (ee.isMeshPhongMaterial || ee.isMeshToonMaterial || ee.isMeshLambertMaterial || ee.isMeshBasicMaterial || ee.isMeshStandardMaterial || ee.isShaderMaterial || ee.isShadowMaterial || fe.isSkinnedMesh) && mr.setValue(k, "viewMatrix", N.matrixWorldInverse) } if (fe.isSkinnedMesh) { mr.setOptional(k, fe, "bindMatrix"), mr.setOptional(k, fe, "bindMatrixInverse"); let ri = fe.skeleton; ri && (Q.floatVertexTextures ? (ri.boneTexture === null && ri.computeBoneTexture(), mr.setValue(k, "boneTexture", ri.boneTexture, ie), mr.setValue(k, "boneTextureSize", ri.boneTextureSize)) : console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.")) } let w0 = ue.morphAttributes; if ((w0.position !== void 0 || w0.normal !== void 0 || w0.color !== void 0 && Q.isWebGL2 === !0) && pe.update(fe, ue, ee, $a), (Ed || At.receiveShadow !== fe.receiveShadow) && (At.receiveShadow = fe.receiveShadow, mr.setValue(k, "receiveShadow", fe.receiveShadow)), ee.isMeshGouraudMaterial && ee.envMap !== null && (el.envMap.value = gt, el.flipEnvMap.value = gt.isCubeTexture && gt.isRenderTargetTexture === !1 ? -1 : 1), Ed && (mr.setValue(k, "toneMappingExposure", m.toneMappingExposure), At.needsLights && qO(el, b0), nt && ee.fog === !0 && Fe.refreshFogUniforms(el, nt), Fe.refreshMaterialUniforms(el, ee, I, T, z), Mc.upload(k, At.uniformsList, el, ie)), ee.isShaderMaterial && ee.uniformsNeedUpdate === !0 && (Mc.upload(k, At.uniformsList, el, ie), ee.uniformsNeedUpdate = !1), ee.isSpriteMaterial && mr.setValue(k, "center", fe.center), mr.setValue(k, "modelViewMatrix", fe.modelViewMatrix), mr.setValue(k, "normalMatrix", fe.normalMatrix), mr.setValue(k, "modelMatrix", fe.matrixWorld), fe.previousModelViewMatrix && mr.setValue(k, "previousModelViewMatrix", fe.previousModelViewMatrix), N.previousProjectionMatrix && mr.setValue(k, "previousProjectionMatrix", N.previousProjectionMatrix), ee.isShaderMaterial || ee.isRawShaderMaterial) { let ri = ee.uniformsGroups; for (let S0 = 0, XO = ri.length; S0 < XO; S0++)if (Q.isWebGL2) { let Y1 = ri[S0]; Xe.update(Y1, $a), Xe.bind(Y1, $a) } else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.") } return $a } function qO (N, te) { N.ambientLightColor.needsUpdate = te, N.lightProbe.needsUpdate = te, N.directionalLights.needsUpdate = te, N.directionalLightShadows.needsUpdate = te, N.pointLights.needsUpdate = te, N.pointLightShadows.needsUpdate = te, N.spotLights.needsUpdate = te, N.spotLightShadows.needsUpdate = te, N.rectAreaLights.needsUpdate = te, N.hemisphereLights.needsUpdate = te } function YO (N) { return N.isMeshLambertMaterial || N.isMeshToonMaterial || N.isMeshPhongMaterial || N.isMeshStandardMaterial || N.isShadowMaterial || N.isShaderMaterial && N.lights === !0 } this.getActiveCubeFace = function () { return y }, this.getActiveMipmapLevel = function () { return v }, this.getRenderTarget = function () { return x }, this.setRenderTargetTextures = function (N, te, ue) { de.get(N.texture).__webglTexture = te, de.get(N.depthTexture).__webglTexture = ue; let ee = de.get(N); ee.__hasExternalTextures = !0, ee.__hasExternalTextures && (ee.__autoAllocateDepthBuffer = ue === void 0, ee.__autoAllocateDepthBuffer || K.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), ee.__useRenderToTexture = !1)) }, this.setRenderTargetFramebuffer = function (N, te) { let ue = de.get(N); ue.__webglFramebuffer = te, ue.__useDefaultFramebuffer = te === void 0 }, this.setRenderTarget = function (N, te = 0, ue = 0) { x = N, y = te, v = ue; let ee = !0, fe = null, nt = !1, lt = !1; if (N) { let gt = de.get(N); gt.__useDefaultFramebuffer !== void 0 ? (W.bindFramebuffer(36160, null), ee = !1) : gt.__webglFramebuffer === void 0 ? ie.setupRenderTarget(N) : gt.__hasExternalTextures && ie.rebindTextures(N, de.get(N.texture).__webglTexture, de.get(N.depthTexture).__webglTexture); let Ct = N.texture; (Ct.isData3DTexture || Ct.isDataArrayTexture || Ct.isCompressedArrayTexture) && (lt = !0); let wt = de.get(N).__webglFramebuffer; N.isWebGLCubeRenderTarget ? (fe = wt[te], nt = !0) : Q.isWebGL2 && N.samples > 0 && ie.useMultisampledRTT(N) === !1 ? fe = de.get(N).__webglMultisampledFramebuffer : fe = wt, _.copy(N.viewport), E.copy(N.scissor), w = N.scissorTest } else _.copy(D).multiplyScalar(I).floor(), E.copy(L).multiplyScalar(I).floor(), w = H; if (W.bindFramebuffer(36160, fe) && Q.drawBuffers && ee && W.drawBuffers(N, fe), W.viewport(_), W.scissor(E), W.setScissorTest(w), nt) { let gt = de.get(N.texture); k.framebufferTexture2D(36160, 36064, 34069 + te, gt.__webglTexture, ue) } else if (lt) { let gt = de.get(N.texture), Ct = te || 0; k.framebufferTextureLayer(36160, 36064, gt.__webglTexture, ue || 0, Ct) } b = -1 }, this.readRenderTargetPixels = function (N, te, ue, ee, fe, nt, lt) { if (!(N && N.isWebGLRenderTarget)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."); return } let dt = de.get(N).__webglFramebuffer; if (N.isWebGLCubeRenderTarget && lt !== void 0 && (dt = dt[lt]), dt) { W.bindFramebuffer(36160, dt); try { let gt = N.texture, Ct = gt.format, wt = gt.type; if (Ct !== oi && we.convert(Ct) !== k.getParameter(35739)) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."); return } let St = wt === cl && (K.has("EXT_color_buffer_half_float") || Q.isWebGL2 && K.has("EXT_color_buffer_float")); if (wt !== Zt && we.convert(wt) !== k.getParameter(35738) && !(wt === gr && (Q.isWebGL2 || K.has("OES_texture_float") || K.has("WEBGL_color_buffer_float"))) && !St) { console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."); return } te >= 0 && te <= N.width - ee && ue >= 0 && ue <= N.height - fe && k.readPixels(te, ue, ee, fe, we.convert(Ct), we.convert(wt), nt) } finally { let gt = x !== null ? de.get(x).__webglFramebuffer : null; W.bindFramebuffer(36160, gt) } } }, this.copyFramebufferToTexture = function (N, te, ue = 0) { let ee = Math.pow(2, -ue), fe = Math.floor(te.image.width * ee), nt = Math.floor(te.image.height * ee); ie.setTexture2D(te, 0), k.copyTexSubImage2D(3553, ue, 0, 0, N.x, N.y, fe, nt), W.unbindTexture() }, this.copyTextureToTexture = function (N, te, ue, ee = 0) { let fe = te.image.width, nt = te.image.height, lt = we.convert(ue.format), dt = we.convert(ue.type); ie.setTexture2D(ue, 0), k.pixelStorei(37440, ue.flipY), k.pixelStorei(37441, ue.premultiplyAlpha), k.pixelStorei(3317, ue.unpackAlignment), te.isDataTexture ? k.texSubImage2D(3553, ee, N.x, N.y, fe, nt, lt, dt, te.image.data) : te.isCompressedTexture ? k.compressedTexSubImage2D(3553, ee, N.x, N.y, te.mipmaps[0].width, te.mipmaps[0].height, lt, te.mipmaps[0].data) : k.texSubImage2D(3553, ee, N.x, N.y, lt, dt, te.image), ee === 0 && ue.generateMipmaps && k.generateMipmap(3553), W.unbindTexture() }, this.copyTextureToTexture3D = function (N, te, ue, ee, fe = 0) { if (m.isWebGL1Renderer) { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."); return } let nt = N.max.x - N.min.x + 1, lt = N.max.y - N.min.y + 1, dt = N.max.z - N.min.z + 1, gt = we.convert(ee.format), Ct = we.convert(ee.type), wt; if (ee.isData3DTexture) ie.setTexture3D(ee, 0), wt = 32879; else if (ee.isDataArrayTexture) ie.setTexture2DArray(ee, 0), wt = 35866; else { console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."); return } k.pixelStorei(37440, ee.flipY), k.pixelStorei(37441, ee.premultiplyAlpha), k.pixelStorei(3317, ee.unpackAlignment); let St = k.getParameter(3314), In = k.getParameter(32878), ni = k.getParameter(3316), ro = k.getParameter(3315), Ja = k.getParameter(32877), Dn = ue.isCompressedTexture ? ue.mipmaps[0] : ue.image; k.pixelStorei(3314, Dn.width), k.pixelStorei(32878, Dn.height), k.pixelStorei(3316, N.min.x), k.pixelStorei(3315, N.min.y), k.pixelStorei(32877, N.min.z), ue.isDataTexture || ue.isData3DTexture ? k.texSubImage3D(wt, fe, te.x, te.y, te.z, nt, lt, dt, gt, Ct, Dn.data) : ue.isCompressedArrayTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), k.compressedTexSubImage3D(wt, fe, te.x, te.y, te.z, nt, lt, dt, gt, Dn.data)) : k.texSubImage3D(wt, fe, te.x, te.y, te.z, nt, lt, dt, gt, Ct, Dn), k.pixelStorei(3314, St), k.pixelStorei(32878, In), k.pixelStorei(3316, ni), k.pixelStorei(3315, ro), k.pixelStorei(32877, Ja), fe === 0 && ee.generateMipmaps && k.generateMipmap(wt), W.unbindTexture() }, this.initTexture = function (N) { N.isCubeTexture ? ie.setTextureCube(N, 0) : N.isData3DTexture ? ie.setTexture3D(N, 0) : N.isDataArrayTexture || N.isCompressedArrayTexture ? ie.setTexture2DArray(N, 0) : ie.setTexture2D(N, 0), W.unbindTexture() }, this.resetState = function () { y = 0, v = 0, x = null, W.reset(), ae.reset() }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } var Ex = class extends Kx { }; Ex.prototype.isWebGL1Renderer = !0; var Ic = class { constructor(t, e = 1, n = 1e3) { this.isFog = !0, this.name = "", this.color = new Le(t), this.near = e, this.far = n } clone () { return new Ic(this.color, this.near, this.far) } toJSON () { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } }, yr = class extends ft { constructor() { super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this })) } copy (t, e) { return super.copy(t, e), t.background !== null && (this.background = t.background.clone()), t.environment !== null && (this.environment = t.environment.clone()), t.fog !== null && (this.fog = t.fog.clone()), this.backgroundBlurriness = t.backgroundBlurriness, this.backgroundIntensity = t.backgroundIntensity, t.overrideMaterial !== null && (this.overrideMaterial = t.overrideMaterial.clone()), this.matrixAutoUpdate = t.matrixAutoUpdate, this } toJSON (t) { let e = super.toJSON(t); return this.fog !== null && (e.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (e.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (e.object.backgroundIntensity = this.backgroundIntensity), e } get autoUpdate () { return console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate } set autoUpdate (t) { console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."), this.matrixWorldAutoUpdate = t } }, wm = class { constructor(t, e) { this.isInterleavedBuffer = !0, this.array = t, this.stride = e, this.count = t !== void 0 ? t.length / e : 0, this.usage = hx, this.updateRange = { offset: 0, count: -1 }, this.version = 0, this.uuid = bi() } onUploadCallback () { } set needsUpdate (t) { t === !0 && this.version++ } setUsage (t) { return this.usage = t, this } copy (t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.usage = t.usage, this } copyAt (t, e, n) { t *= this.stride, n *= e.stride; for (let r = 0, s = this.stride; r < s; r++)this.array[t + r] = e.array[n + r]; return this } set (t, e = 0) { return this.array.set(t, e), this } clone (t) { t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = bi()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer); let e = new this.array.constructor(t.arrayBuffers[this.array.buffer._uuid]), n = new this.constructor(e, this.stride); return n.setUsage(this.usage), n } onUpload (t) { return this.onUploadCallback = t, this } toJSON (t) { return t.arrayBuffers === void 0 && (t.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = bi()), t.arrayBuffers[this.array.buffer._uuid] === void 0 && (t.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), { uuid: this.uuid, buffer: this.array.buffer._uuid, type: this.array.constructor.name, stride: this.stride } } }, Rr = new A, hl = class { constructor(t, e, n, r = !1) { this.isInterleavedBufferAttribute = !0, this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = r } get count () { return this.data.count } get array () { return this.data.array } set needsUpdate (t) { this.data.needsUpdate = t } applyMatrix4 (t) { for (let e = 0, n = this.data.count; e < n; e++)Rr.fromBufferAttribute(this, e), Rr.applyMatrix4(t), this.setXYZ(e, Rr.x, Rr.y, Rr.z); return this } applyNormalMatrix (t) { for (let e = 0, n = this.count; e < n; e++)Rr.fromBufferAttribute(this, e), Rr.applyNormalMatrix(t), this.setXYZ(e, Rr.x, Rr.y, Rr.z); return this } transformDirection (t) { for (let e = 0, n = this.count; e < n; e++)Rr.fromBufferAttribute(this, e), Rr.transformDirection(t), this.setXYZ(e, Rr.x, Rr.y, Rr.z); return this } setX (t, e) { return this.normalized && (e = zt(e, this.array)), this.data.array[t * this.data.stride + this.offset] = e, this } setY (t, e) { return this.normalized && (e = zt(e, this.array)), this.data.array[t * this.data.stride + this.offset + 1] = e, this } setZ (t, e) { return this.normalized && (e = zt(e, this.array)), this.data.array[t * this.data.stride + this.offset + 2] = e, this } setW (t, e) { return this.normalized && (e = zt(e, this.array)), this.data.array[t * this.data.stride + this.offset + 3] = e, this } getX (t) { let e = this.data.array[t * this.data.stride + this.offset]; return this.normalized && (e = ho(e, this.array)), e } getY (t) { let e = this.data.array[t * this.data.stride + this.offset + 1]; return this.normalized && (e = ho(e, this.array)), e } getZ (t) { let e = this.data.array[t * this.data.stride + this.offset + 2]; return this.normalized && (e = ho(e, this.array)), e } getW (t) { let e = this.data.array[t * this.data.stride + this.offset + 3]; return this.normalized && (e = ho(e, this.array)), e } setXY (t, e, n) { return t = t * this.data.stride + this.offset, this.normalized && (e = zt(e, this.array), n = zt(n, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this } setXYZ (t, e, n, r) { return t = t * this.data.stride + this.offset, this.normalized && (e = zt(e, this.array), n = zt(n, this.array), r = zt(r, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this } setXYZW (t, e, n, r, s) { return t = t * this.data.stride + this.offset, this.normalized && (e = zt(e, this.array), n = zt(n, this.array), r = zt(r, this.array), s = zt(s, this.array)), this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = s, this } clone (t) { if (t === void 0) { console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."); let e = []; for (let n = 0; n < this.count; n++) { let r = n * this.data.stride + this.offset; for (let s = 0; s < this.itemSize; s++)e.push(this.data.array[r + s]) } return new ze(new this.array.constructor(e), this.itemSize, this.normalized) } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.clone(t)), new hl(t.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized) } toJSON (t) { if (t === void 0) { console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."); let e = []; for (let n = 0; n < this.count; n++) { let r = n * this.data.stride + this.offset; for (let s = 0; s < this.itemSize; s++)e.push(this.data.array[r + s]) } return { itemSize: this.itemSize, type: this.array.constructor.name, array: e, normalized: this.normalized } } else return t.interleavedBuffers === void 0 && (t.interleavedBuffers = {}), t.interleavedBuffers[this.data.uuid] === void 0 && (t.interleavedBuffers[this.data.uuid] = this.data.toJSON(t)), { isInterleavedBufferAttribute: !0, itemSize: this.itemSize, data: this.data.uuid, offset: this.offset, normalized: this.normalized } } }; var qd = class extends ft { constructor() { super(), this.isBone = !0, this.type = "Bone" } }, go = class extends Qt { constructor(t = null, e = 1, n = 1, r, s, o, a, l, u = Dt, c = Dt, h, d) { super(null, o, a, l, u, c, r, s, h, d), this.isDataTexture = !0, this.image = { data: t, width: e, height: n }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1 } }, r_ = new se, XF = new se, ia = class { constructor(t = [], e = []) { this.uuid = bi(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init() } init () { let t = this.bones, e = this.boneInverses; if (this.boneMatrices = new Float32Array(t.length * 16), e.length === 0) this.calculateInverses(); else if (t.length !== e.length) { console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = []; for (let n = 0, r = this.bones.length; n < r; n++)this.boneInverses.push(new se) } } calculateInverses () { this.boneInverses.length = 0; for (let t = 0, e = this.bones.length; t < e; t++) { let n = new se; this.bones[t] && n.copy(this.bones[t].matrixWorld).invert(), this.boneInverses.push(n) } } pose () { for (let t = 0, e = this.bones.length; t < e; t++) { let n = this.bones[t]; n && n.matrixWorld.copy(this.boneInverses[t]).invert() } for (let t = 0, e = this.bones.length; t < e; t++) { let n = this.bones[t]; n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale)) } } update () { let t = this.bones, e = this.boneInverses, n = this.boneMatrices, r = this.boneTexture; for (let s = 0, o = t.length; s < o; s++) { let a = t[s] ? t[s].matrixWorld : XF; r_.multiplyMatrices(a, e[s]), r_.toArray(n, s * 16) } r !== null && (r.needsUpdate = !0) } clone () { return new ia(this.bones, this.boneInverses) } computeBoneTexture () { let t = Math.sqrt(this.bones.length * 4); t = I_(t), t = Math.max(t, 4); let e = new Float32Array(t * t * 4); e.set(this.boneMatrices); let n = new go(e, t, t, oi, gr); return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this } getBoneByName (t) { for (let e = 0, n = this.bones.length; e < n; e++) { let r = this.bones[e]; if (r.name === t) return r } } dispose () { this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null) } fromJSON (t, e) { this.uuid = t.uuid; for (let n = 0, r = t.bones.length; n < r; n++) { let s = t.bones[n], o = e[s]; o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new qd), this.bones.push(o), this.boneInverses.push(new se().fromArray(t.boneInverses[n])) } return this.init(), this } toJSON () { let t = { metadata: { version: 4.5, type: "Skeleton", generator: "Skeleton.toJSON" }, bones: [], boneInverses: [] }; t.uuid = this.uuid; let e = this.bones, n = this.boneInverses; for (let r = 0, s = e.length; r < s; r++) { let o = e[r]; t.bones.push(o.uuid); let a = n[r]; t.boneInverses.push(a.toArray()) } return t } }, Sm = class extends ze { constructor(t, e, n, r = 1) { super(t, e, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = r } copy (t) { return super.copy(t), this.meshPerAttribute = t.meshPerAttribute, this } toJSON () { let t = super.toJSON(); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t } }; var Si = class extends ul { constructor(t) { super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new Le(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(t) } copy (t) { return super.copy(t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this.fog = t.fog, this } }, i_ = new A, s_ = new A, o_ = new se, tx = new Wi, em = new dn, dl = class extends ft { constructor(t = new Ce, e = new Si) { super(), this.isLine = !0, this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets() } copy (t, e) { return super.copy(t, e), this.material = t.material, this.geometry = t.geometry, this } computeLineDistances () { let t = this.geometry; if (t.index === null) { let e = t.attributes.position, n = [0]; for (let r = 1, s = e.count; r < s; r++)i_.fromBufferAttribute(e, r - 1), s_.fromBufferAttribute(e, r), n[r] = n[r - 1], n[r] += i_.distanceTo(s_); t.setAttribute("lineDistance", new _e(n, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } raycast (t, e) { let n = this.geometry, r = this.matrixWorld, s = t.params.Line.threshold, o = n.drawRange; if (n.boundingSphere === null && n.computeBoundingSphere(), em.copy(n.boundingSphere), em.applyMatrix4(r), em.radius += s, t.ray.intersectsSphere(em) === !1) return; o_.copy(r).invert(), tx.copy(t.ray).applyMatrix4(o_); let a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3), l = a * a, u = new A, c = new A, h = new A, d = new A, f = this.isLineSegments ? 2 : 1, p = n.index, g = n.attributes.position; if (p !== null) { let y = Math.max(0, o.start), v = Math.min(p.count, o.start + o.count); for (let x = y, b = v - 1; x < b; x += f) { let S = p.getX(x), _ = p.getX(x + 1); if (u.fromBufferAttribute(g, S), c.fromBufferAttribute(g, _), tx.distanceSqToSegment(u, c, d, h) > l) continue; d.applyMatrix4(this.matrixWorld); let w = t.ray.origin.distanceTo(d); w < t.near || w > t.far || e.push({ distance: w, point: h.clone().applyMatrix4(this.matrixWorld), index: x, face: null, faceIndex: null, object: this }) } } else { let y = Math.max(0, o.start), v = Math.min(g.count, o.start + o.count); for (let x = y, b = v - 1; x < b; x += f) { if (u.fromBufferAttribute(g, x), c.fromBufferAttribute(g, x + 1), tx.distanceSqToSegment(u, c, d, h) > l) continue; d.applyMatrix4(this.matrixWorld); let _ = t.ray.origin.distanceTo(d); _ < t.near || _ > t.far || e.push({ distance: _, point: h.clone().applyMatrix4(this.matrixWorld), index: x, face: null, faceIndex: null, object: this }) } } } updateMorphTargets () { let e = this.geometry.morphAttributes, n = Object.keys(e); if (n.length > 0) { let r = e[n[0]]; if (r !== void 0) { this.morphTargetInfluences = [], this.morphTargetDictionary = {}; for (let s = 0, o = r.length; s < o; s++) { let a = r[s].name || String(s); this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s } } } } }, a_ = new A, l_ = new A, sa = class extends dl { constructor(t, e) { super(t, e), this.isLineSegments = !0, this.type = "LineSegments" } computeLineDistances () { let t = this.geometry; if (t.index === null) { let e = t.attributes.position, n = []; for (let r = 0, s = e.count; r < s; r += 2)a_.fromBufferAttribute(e, r), l_.fromBufferAttribute(e, r + 1), n[r] = r === 0 ? 0 : n[r - 1], n[r + 1] = n[r] + a_.distanceTo(l_); t.setAttribute("lineDistance", new _e(n, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); return this } }; var Am = class extends Qt { constructor(t, e, n, r, s, o, a, l, u) { super(t, e, n, r, s, o, a, l, u), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : Ke, this.magFilter = s !== void 0 ? s : Ke, this.generateMipmaps = !1; let c = this; function h () { c.needsUpdate = !0, t.requestVideoFrameCallback(h) } "requestVideoFrameCallback" in t && t.requestVideoFrameCallback(h) } clone () { return new this.constructor(this.image).copy(this) } update () { let t = this.image; "requestVideoFrameCallback" in t === !1 && t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }; var Ai = class { constructor() { this.type = "Curve", this.arcLengthDivisions = 200 } getPoint () { return console.warn("THREE.Curve: .getPoint() not implemented."), null } getPointAt (t, e) { let n = this.getUtoTmapping(t); return this.getPoint(n, e) } getPoints (t = 5) { let e = []; for (let n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return e } getSpacedPoints (t = 5) { let e = []; for (let n = 0; n <= t; n++)e.push(this.getPointAt(n / t)); return e } getLength () { let t = this.getLengths(); return t[t.length - 1] } getLengths (t = this.arcLengthDivisions) { if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; let e = [], n, r = this.getPoint(0), s = 0; e.push(0); for (let o = 1; o <= t; o++)n = this.getPoint(o / t), s += n.distanceTo(r), e.push(s), r = n; return this.cacheArcLengths = e, e } updateArcLengths () { this.needsUpdate = !0, this.getLengths() } getUtoTmapping (t, e) { let n = this.getLengths(), r = 0, s = n.length, o; e ? o = e : o = t * n[s - 1]; let a = 0, l = s - 1, u; for (; a <= l;)if (r = Math.floor(a + (l - a) / 2), u = n[r] - o, u < 0) a = r + 1; else if (u > 0) l = r - 1; else { l = r; break } if (r = l, n[r] === o) return r / (s - 1); let c = n[r], d = n[r + 1] - c, f = (o - c) / d; return (r + f) / (s - 1) } getTangent (t, e) { let r = t - 1e-4, s = t + 1e-4; r < 0 && (r = 0), s > 1 && (s = 1); let o = this.getPoint(r), a = this.getPoint(s), l = e || (o.isVector2 ? new B : new A); return l.copy(a).sub(o).normalize(), l } getTangentAt (t, e) { let n = this.getUtoTmapping(t); return this.getTangent(n, e) } computeFrenetFrames (t, e) { let n = new A, r = [], s = [], o = [], a = new A, l = new se; for (let f = 0; f <= t; f++) { let p = f / t; r[f] = this.getTangentAt(p, new A) } s[0] = new A, o[0] = new A; let u = Number.MAX_VALUE, c = Math.abs(r[0].x), h = Math.abs(r[0].y), d = Math.abs(r[0].z); c <= u && (u = c, n.set(1, 0, 0)), h <= u && (u = h, n.set(0, 1, 0)), d <= u && n.set(0, 0, 1), a.crossVectors(r[0], n).normalize(), s[0].crossVectors(r[0], a), o[0].crossVectors(r[0], s[0]); for (let f = 1; f <= t; f++) { if (s[f] = s[f - 1].clone(), o[f] = o[f - 1].clone(), a.crossVectors(r[f - 1], r[f]), a.length() > Number.EPSILON) { a.normalize(); let p = Math.acos(zn(r[f - 1].dot(r[f]), -1, 1)); s[f].applyMatrix4(l.makeRotationAxis(a, p)) } o[f].crossVectors(r[f], s[f]) } if (e === !0) { let f = Math.acos(zn(s[0].dot(s[t]), -1, 1)); f /= t, r[0].dot(a.crossVectors(s[0], s[t])) > 0 && (f = -f); for (let p = 1; p <= t; p++)s[p].applyMatrix4(l.makeRotationAxis(r[p], f * p)), o[p].crossVectors(r[p], s[p]) } return { tangents: r, normals: s, binormals: o } } clone () { return new this.constructor().copy(this) } copy (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } toJSON () { let t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t } fromJSON (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } }, fl = class extends Ai { constructor(t = 0, e = 0, n = 1, r = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) { super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l } getPoint (t, e) { let n = e || new B, r = Math.PI * 2, s = this.aEndAngle - this.aStartAngle, o = Math.abs(s) < Number.EPSILON; for (; s < 0;)s += r; for (; s > r;)s -= r; s < Number.EPSILON && (o ? s = 0 : s = r), this.aClockwise === !0 && !o && (s === r ? s = -r : s = s - r); let a = this.aStartAngle + t * s, l = this.aX + this.xRadius * Math.cos(a), u = this.aY + this.yRadius * Math.sin(a); if (this.aRotation !== 0) { let c = Math.cos(this.aRotation), h = Math.sin(this.aRotation), d = l - this.aX, f = u - this.aY; l = d * c - f * h + this.aX, u = d * h + f * c + this.aY } return n.set(l, u) } copy (t) { return super.copy(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this } toJSON () { let t = super.toJSON(); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t } fromJSON (t) { return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this } }, Mx = class extends fl { constructor(t, e, n, r, s, o) { super(t, e, n, n, r, s, o), this.isArcCurve = !0, this.type = "ArcCurve" } }; function Zx () { let i = 0, t = 0, e = 0, n = 0; function r (s, o, a, l) { i = s, t = a, e = -3 * s + 3 * o - 2 * a - l, n = 2 * s - 2 * o + a + l } return { initCatmullRom: function (s, o, a, l, u) { r(o, a, u * (a - s), u * (l - o)) }, initNonuniformCatmullRom: function (s, o, a, l, u, c, h) { let d = (o - s) / u - (a - s) / (u + c) + (a - o) / c, f = (a - o) / c - (l - o) / (c + h) + (l - a) / h; d *= c, f *= c, r(o, a, d, f) }, calc: function (s) { let o = s * s, a = o * s; return i + t * s + e * o + n * a } } } var tm = new A, nx = new Zx, rx = new Zx, ix = new Zx, Tx = class extends Ai { constructor(t = [], e = !1, n = "centripetal", r = .5) { super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r } getPoint (t, e = new A) { let n = e, r = this.points, s = r.length, o = (s - (this.closed ? 0 : 1)) * t, a = Math.floor(o), l = o - a; this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1); let u, c; this.closed || a > 0 ? u = r[(a - 1) % s] : (tm.subVectors(r[0], r[1]).add(r[0]), u = tm); let h = r[a % s], d = r[(a + 1) % s]; if (this.closed || a + 2 < s ? c = r[(a + 2) % s] : (tm.subVectors(r[s - 1], r[s - 2]).add(r[s - 1]), c = tm), this.curveType === "centripetal" || this.curveType === "chordal") { let f = this.curveType === "chordal" ? .5 : .25, p = Math.pow(u.distanceToSquared(h), f), m = Math.pow(h.distanceToSquared(d), f), g = Math.pow(d.distanceToSquared(c), f); m < 1e-4 && (m = 1), p < 1e-4 && (p = m), g < 1e-4 && (g = m), nx.initNonuniformCatmullRom(u.x, h.x, d.x, c.x, p, m, g), rx.initNonuniformCatmullRom(u.y, h.y, d.y, c.y, p, m, g), ix.initNonuniformCatmullRom(u.z, h.z, d.z, c.z, p, m, g) } else this.curveType === "catmullrom" && (nx.initCatmullRom(u.x, h.x, d.x, c.x, this.tension), rx.initCatmullRom(u.y, h.y, d.y, c.y, this.tension), ix.initCatmullRom(u.z, h.z, d.z, c.z, this.tension)); return n.set(nx.calc(l), rx.calc(l), ix.calc(l)), n } copy (t) { super.copy(t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { let r = t.points[e]; this.points.push(r.clone()) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this } toJSON () { let t = super.toJSON(); t.points = []; for (let e = 0, n = this.points.length; e < n; e++) { let r = this.points[e]; t.points.push(r.toArray()) } return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t } fromJSON (t) { super.fromJSON(t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { let r = t.points[e]; this.points.push(new A().fromArray(r)) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this } }; function c_ (i, t, e, n, r) { let s = (n - t) * .5, o = (r - e) * .5, a = i * i, l = i * a; return (2 * e - 2 * n + s + o) * l + (-3 * e + 3 * n - 2 * s - o) * a + s * i + e } function QF (i, t) { let e = 1 - i; return e * e * t } function KF (i, t) { return 2 * (1 - i) * i * t } function ZF (i, t) { return i * i * t } function Ud (i, t, e, n) { return QF(i, t) + KF(i, e) + ZF(i, n) } function JF (i, t) { let e = 1 - i; return e * e * e * t } function $F (i, t) { let e = 1 - i; return 3 * e * e * i * t } function ek (i, t) { return 3 * (1 - i) * i * i * t } function tk (i, t) { return i * i * i * t } function zd (i, t, e, n, r) { return JF(i, t) + $F(i, e) + ek(i, n) + tk(i, r) } var Tr = class extends Ai { constructor(t = new B, e = new B, n = new B, r = new B) { super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r } getPoint (t, e = new B) { let n = e, r = this.v0, s = this.v1, o = this.v2, a = this.v3; return n.set(zd(t, r.x, s.x, o.x, a.x), zd(t, r.y, s.y, o.y, a.y)), n } copy (t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this } toJSON () { let t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t } fromJSON (t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this } }, pl = class extends Ai { constructor(t = new A, e = new A, n = new A, r = new A) { super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r } getPoint (t, e = new A) { let n = e, r = this.v0, s = this.v1, o = this.v2, a = this.v3; return n.set(zd(t, r.x, s.x, o.x, a.x), zd(t, r.y, s.y, o.y, a.y), zd(t, r.z, s.z, o.z, a.z)), n } copy (t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this } toJSON () { let t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t } fromJSON (t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this } }, Cr = class extends Ai { constructor(t = new B, e = new B) { super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = t, this.v2 = e } getPoint (t, e = new B) { let n = e; return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n } getPointAt (t, e) { return this.getPoint(t, e) } getTangent (t, e) { let n = e || new B; return n.copy(this.v2).sub(this.v1).normalize(), n } copy (t) { return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this } toJSON () { let t = super.toJSON(); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t } fromJSON (t) { return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this } }, Yd = class extends Ai { constructor(t = new A, e = new A) { super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = t, this.v2 = e } getPoint (t, e = new A) { let n = e; return t === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n } getPointAt (t, e) { return this.getPoint(t, e) } copy (t) { return super.copy(t), this.v1.copy(t.v1), this.v2.copy(t.v2), this } toJSON () { let t = super.toJSON(); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t } fromJSON (t) { return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this } }, ci = class extends Ai { constructor(t = new B, e = new B, n = new B) { super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n } getPoint (t, e = new B) { let n = e, r = this.v0, s = this.v1, o = this.v2; return n.set(Ud(t, r.x, s.x, o.x), Ud(t, r.y, s.y, o.y)), n } copy (t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this } toJSON () { let t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t } fromJSON (t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this } }, Cx = class extends Ai { constructor(t = new A, e = new A, n = new A) { super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n } getPoint (t, e = new A) { let n = e, r = this.v0, s = this.v1, o = this.v2; return n.set(Ud(t, r.x, s.x, o.x), Ud(t, r.y, s.y, o.y), Ud(t, r.z, s.z, o.z)), n } copy (t) { return super.copy(t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this } toJSON () { let t = super.toJSON(); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t } fromJSON (t) { return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this } }, Dc = class extends Ai { constructor(t = []) { super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = t } getPoint (t, e = new B) { let n = e, r = this.points, s = (r.length - 1) * t, o = Math.floor(s), a = s - o, l = r[o === 0 ? o : o - 1], u = r[o], c = r[o > r.length - 2 ? r.length - 1 : o + 1], h = r[o > r.length - 3 ? r.length - 1 : o + 2]; return n.set(c_(a, l.x, u.x, c.x, h.x), c_(a, l.y, u.y, c.y, h.y)), n } copy (t) { super.copy(t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { let r = t.points[e]; this.points.push(r.clone()) } return this } toJSON () { let t = super.toJSON(); t.points = []; for (let e = 0, n = this.points.length; e < n; e++) { let r = this.points[e]; t.points.push(r.toArray()) } return t } fromJSON (t) { super.fromJSON(t), this.points = []; for (let e = 0, n = t.points.length; e < n; e++) { let r = t.points[e]; this.points.push(new B().fromArray(r)) } return this } }, nk = Object.freeze({ __proto__: null, ArcCurve: Mx, CatmullRomCurve3: Tx, CubicBezierCurve: Tr, CubicBezierCurve3: pl, EllipseCurve: fl, LineCurve: Cr, LineCurve3: Yd, QuadraticBezierCurve: ci, QuadraticBezierCurve3: Cx, SplineCurve: Dc }), Xd = class extends Ai { constructor() { super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } add (t) { this.curves.push(t) } closePath () { let t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1); t.equals(e) || this.curves.push(new Cr(e, t)) } getPoint (t, e) { let n = t * this.getLength(), r = this.getCurveLengths(), s = 0; for (; s < r.length;) { if (r[s] >= n) { let o = r[s] - n, a = this.curves[s], l = a.getLength(), u = l === 0 ? 0 : 1 - o / l; return a.getPointAt(u, e) } s++ } return null } getLength () { let t = this.getCurveLengths(); return t[t.length - 1] } updateArcLengths () { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() } getCurveLengths () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; let t = [], e = 0; for (let n = 0, r = this.curves.length; n < r; n++)e += this.curves[n].getLength(), t.push(e); return this.cacheLengths = t, t } getSpacedPoints (t = 40) { let e = []; for (let n = 0; n <= t; n++)e.push(this.getPoint(n / t)); return this.autoClose && e.push(e[0]), e } getPoints (t = 12) { let e = [], n; for (let r = 0, s = this.curves; r < s.length; r++) { let o = s[r], a = o.isEllipseCurve ? t * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? t * o.points.length : t, l = o.getPoints(a); for (let u = 0; u < l.length; u++) { let c = l[u]; n && n.equals(c) || (e.push(c), n = c) } } return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e } copy (t) { super.copy(t), this.curves = []; for (let e = 0, n = t.curves.length; e < n; e++) { let r = t.curves[e]; this.curves.push(r.clone()) } return this.autoClose = t.autoClose, this } toJSON () { let t = super.toJSON(); t.autoClose = this.autoClose, t.curves = []; for (let e = 0, n = this.curves.length; e < n; e++) { let r = this.curves[e]; t.curves.push(r.toJSON()) } return t } fromJSON (t) { super.fromJSON(t), this.autoClose = t.autoClose, this.curves = []; for (let e = 0, n = t.curves.length; e < n; e++) { let r = t.curves[e]; this.curves.push(new nk[r.type]().fromJSON(r)) } return this } }, ml = class extends Xd { constructor(t) { super(), this.type = "Path", this.currentPoint = new B, t && this.setFromPoints(t) } setFromPoints (t) { this.moveTo(t[0].x, t[0].y); for (let e = 1, n = t.length; e < n; e++)this.lineTo(t[e].x, t[e].y); return this } moveTo (t, e) { return this.currentPoint.set(t, e), this } lineTo (t, e) { let n = new Cr(this.currentPoint.clone(), new B(t, e)); return this.curves.push(n), this.currentPoint.set(t, e), this } quadraticCurveTo (t, e, n, r) { let s = new ci(this.currentPoint.clone(), new B(t, e), new B(n, r)); return this.curves.push(s), this.currentPoint.set(n, r), this } bezierCurveTo (t, e, n, r, s, o) { let a = new Tr(this.currentPoint.clone(), new B(t, e), new B(n, r), new B(s, o)); return this.curves.push(a), this.currentPoint.set(s, o), this } splineThru (t) { let e = [this.currentPoint.clone()].concat(t), n = new Dc(e); return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this } arc (t, e, n, r, s, o) { let a = this.currentPoint.x, l = this.currentPoint.y; return this.absarc(t + a, e + l, n, r, s, o), this } absarc (t, e, n, r, s, o) { return this.absellipse(t, e, n, n, r, s, o), this } ellipse (t, e, n, r, s, o, a, l) { let u = this.currentPoint.x, c = this.currentPoint.y; return this.absellipse(t + u, e + c, n, r, s, o, a, l), this } absellipse (t, e, n, r, s, o, a, l) { let u = new fl(t, e, n, r, s, o, a, l); if (this.curves.length > 0) { let h = u.getPoint(0); h.equals(this.currentPoint) || this.lineTo(h.x, h.y) } this.curves.push(u); let c = u.getPoint(1); return this.currentPoint.copy(c), this } copy (t) { return super.copy(t), this.currentPoint.copy(t.currentPoint), this } toJSON () { let t = super.toJSON(); return t.currentPoint = this.currentPoint.toArray(), t } fromJSON (t) { return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this } }, Oc = class extends Ce { constructor(t = [new B(0, -.5), new B(.5, 0), new B(0, .5)], e = 12, n = 0, r = Math.PI * 2) { super(), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: r }, e = Math.floor(e), r = zn(r, 0, Math.PI * 2); let s = [], o = [], a = [], l = [], u = [], c = 1 / e, h = new A, d = new B, f = new A, p = new A, m = new A, g = 0, y = 0; for (let v = 0; v <= t.length - 1; v++)switch (v) { case 0: g = t[v + 1].x - t[v].x, y = t[v + 1].y - t[v].y, f.x = y * 1, f.y = -g, f.z = y * 0, m.copy(f), f.normalize(), l.push(f.x, f.y, f.z); break; case t.length - 1: l.push(m.x, m.y, m.z); break; default: g = t[v + 1].x - t[v].x, y = t[v + 1].y - t[v].y, f.x = y * 1, f.y = -g, f.z = y * 0, p.copy(f), f.x += m.x, f.y += m.y, f.z += m.z, f.normalize(), l.push(f.x, f.y, f.z), m.copy(p) }for (let v = 0; v <= e; v++) { let x = n + v * c * r, b = Math.sin(x), S = Math.cos(x); for (let _ = 0; _ <= t.length - 1; _++) { h.x = t[_].x * b, h.y = t[_].y, h.z = t[_].x * S, o.push(h.x, h.y, h.z), d.x = v / e, d.y = _ / (t.length - 1), a.push(d.x, d.y); let E = l[3 * _ + 0] * b, w = l[3 * _ + 1], M = l[3 * _ + 0] * S; u.push(E, w, M) } } for (let v = 0; v < e; v++)for (let x = 0; x < t.length - 1; x++) { let b = x + v * t.length, S = b, _ = b + t.length, E = b + t.length + 1, w = b + 1; s.push(S, _, w), s.push(E, w, _) } this.setIndex(s), this.setAttribute("position", new _e(o, 3)), this.setAttribute("uv", new _e(a, 2)), this.setAttribute("normal", new _e(u, 3)) } static fromJSON (t) { return new Oc(t.points, t.segments, t.phiStart, t.phiLength) } }; var gl = class extends Ce { constructor(t = 1, e = 1, n = 1, r = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) { super(), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: r, heightSegments: s, openEnded: o, thetaStart: a, thetaLength: l }; let u = this; r = Math.floor(r), s = Math.floor(s); let c = [], h = [], d = [], f = [], p = 0, m = [], g = n / 2, y = 0; v(), o === !1 && (t > 0 && x(!0), e > 0 && x(!1)), this.setIndex(c), this.setAttribute("position", new _e(h, 3)), this.setAttribute("normal", new _e(d, 3)), this.setAttribute("uv", new _e(f, 2)); function v () { let b = new A, S = new A, _ = 0, E = (e - t) / n; for (let w = 0; w <= s; w++) { let M = [], T = w / s, I = T * (e - t) + t; for (let C = 0; C <= r; C++) { let P = C / r, D = P * l + a, L = Math.sin(D), H = Math.cos(D); S.x = I * L, S.y = -T * n + g, S.z = I * H, h.push(S.x, S.y, S.z), b.set(L, E, H).normalize(), d.push(b.x, b.y, b.z), f.push(P, 1 - T), M.push(p++) } m.push(M) } for (let w = 0; w < r; w++)for (let M = 0; M < s; M++) { let T = m[M][w], I = m[M + 1][w], C = m[M + 1][w + 1], P = m[M][w + 1]; c.push(T, I, P), c.push(I, C, P), _ += 6 } u.addGroup(y, _, 0), y += _ } function x (b) { let S = p, _ = new B, E = new A, w = 0, M = b === !0 ? t : e, T = b === !0 ? 1 : -1; for (let C = 1; C <= r; C++)h.push(0, g * T, 0), d.push(0, T, 0), f.push(.5, .5), p++; let I = p; for (let C = 0; C <= r; C++) { let D = C / r * l + a, L = Math.cos(D), H = Math.sin(D); E.x = M * H, E.y = g * T, E.z = M * L, h.push(E.x, E.y, E.z), d.push(0, T, 0), _.x = L * .5 + .5, _.y = H * .5 * T + .5, f.push(_.x, _.y), p++ } for (let C = 0; C < r; C++) { let P = S + C, D = I + C; b === !0 ? c.push(D, D + 1, P) : c.push(D + 1, D, P), w += 3 } u.addGroup(y, w, b === !0 ? 1 : 2), y += w } } static fromJSON (t) { return new gl(t.radiusTop, t.radiusBottom, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength) } }, Rc = class extends gl { constructor(t = 1, e = 1, n = 32, r = 1, s = !1, o = 0, a = Math.PI * 2) { super(0, t, e, n, r, s, o, a), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: n, heightSegments: r, openEnded: s, thetaStart: o, thetaLength: a } } static fromJSON (t) { return new Rc(t.radius, t.height, t.radialSegments, t.heightSegments, t.openEnded, t.thetaStart, t.thetaLength) } }, Lc = class extends Ce { constructor(t = [], e = [], n = 1, r = 0) { super(), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: r }; let s = [], o = []; a(r), u(n), c(), this.setAttribute("position", new _e(s, 3)), this.setAttribute("normal", new _e(s.slice(), 3)), this.setAttribute("uv", new _e(o, 2)), r === 0 ? this.computeVertexNormals() : this.normalizeNormals(); function a (v) { let x = new A, b = new A, S = new A; for (let _ = 0; _ < e.length; _ += 3)f(e[_ + 0], x), f(e[_ + 1], b), f(e[_ + 2], S), l(x, b, S, v) } function l (v, x, b, S) { let _ = S + 1, E = []; for (let w = 0; w <= _; w++) { E[w] = []; let M = v.clone().lerp(b, w / _), T = x.clone().lerp(b, w / _), I = _ - w; for (let C = 0; C <= I; C++)C === 0 && w === _ ? E[w][C] = M : E[w][C] = M.clone().lerp(T, C / I) } for (let w = 0; w < _; w++)for (let M = 0; M < 2 * (_ - w) - 1; M++) { let T = Math.floor(M / 2); M % 2 === 0 ? (d(E[w][T + 1]), d(E[w + 1][T]), d(E[w][T])) : (d(E[w][T + 1]), d(E[w + 1][T + 1]), d(E[w + 1][T])) } } function u (v) { let x = new A; for (let b = 0; b < s.length; b += 3)x.x = s[b + 0], x.y = s[b + 1], x.z = s[b + 2], x.normalize().multiplyScalar(v), s[b + 0] = x.x, s[b + 1] = x.y, s[b + 2] = x.z } function c () { let v = new A; for (let x = 0; x < s.length; x += 3) { v.x = s[x + 0], v.y = s[x + 1], v.z = s[x + 2]; let b = g(v) / 2 / Math.PI + .5, S = y(v) / Math.PI + .5; o.push(b, 1 - S) } p(), h() } function h () { for (let v = 0; v < o.length; v += 6) { let x = o[v + 0], b = o[v + 2], S = o[v + 4], _ = Math.max(x, b, S), E = Math.min(x, b, S); _ > .9 && E < .1 && (x < .2 && (o[v + 0] += 1), b < .2 && (o[v + 2] += 1), S < .2 && (o[v + 4] += 1)) } } function d (v) { s.push(v.x, v.y, v.z) } function f (v, x) { let b = v * 3; x.x = t[b + 0], x.y = t[b + 1], x.z = t[b + 2] } function p () { let v = new A, x = new A, b = new A, S = new A, _ = new B, E = new B, w = new B; for (let M = 0, T = 0; M < s.length; M += 9, T += 6) { v.set(s[M + 0], s[M + 1], s[M + 2]), x.set(s[M + 3], s[M + 4], s[M + 5]), b.set(s[M + 6], s[M + 7], s[M + 8]), _.set(o[T + 0], o[T + 1]), E.set(o[T + 2], o[T + 3]), w.set(o[T + 4], o[T + 5]), S.copy(v).add(x).add(b).divideScalar(3); let I = g(S); m(_, T + 0, v, I), m(E, T + 2, x, I), m(w, T + 4, b, I) } } function m (v, x, b, S) { S < 0 && v.x === 1 && (o[x] = v.x - 1), b.x === 0 && b.z === 0 && (o[x] = S / 2 / Math.PI + .5) } function g (v) { return Math.atan2(v.z, -v.x) } function y (v) { return Math.atan2(-v.y, Math.sqrt(v.x * v.x + v.z * v.z)) } } static fromJSON (t) { return new Lc(t.vertices, t.indices, t.radius, t.details) } }, Nc = class extends Lc { constructor(t = 1, e = 0) { let n = (1 + Math.sqrt(5)) / 2, r = 1 / n, s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9]; super(s, o, t, e), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e } } static fromJSON (t) { return new Nc(t.radius, t.detail) } }; var yo = class extends ml { constructor(t) { super(t), this.uuid = bi(), this.type = "Shape", this.holes = [] } getPointsHoles (t) { let e = []; for (let n = 0, r = this.holes.length; n < r; n++)e[n] = this.holes[n].getPoints(t); return e } extractPoints (t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } } copy (t) { super.copy(t), this.holes = []; for (let e = 0, n = t.holes.length; e < n; e++) { let r = t.holes[e]; this.holes.push(r.clone()) } return this } toJSON () { let t = super.toJSON(); t.uuid = this.uuid, t.holes = []; for (let e = 0, n = this.holes.length; e < n; e++) { let r = this.holes[e]; t.holes.push(r.toJSON()) } return t } fromJSON (t) { super.fromJSON(t), this.uuid = t.uuid, this.holes = []; for (let e = 0, n = t.holes.length; e < n; e++) { let r = t.holes[e]; this.holes.push(new ml().fromJSON(r)) } return this } }, rk = { triangulate: function (i, t, e = 2) { let n = t && t.length, r = n ? t[0] * e : i.length, s = U_(i, 0, r, e, !0), o = []; if (!s || s.next === s.prev) return o; let a, l, u, c, h, d, f; if (n && (s = lk(i, t, s, e)), i.length > 80 * e) { a = u = i[0], l = c = i[1]; for (let p = e; p < r; p += e)h = i[p], d = i[p + 1], h < a && (a = h), d < l && (l = d), h > u && (u = h), d > c && (c = d); f = Math.max(u - a, c - l), f = f !== 0 ? 32767 / f : 0 } return Qd(s, o, e, a, l, f, 0), o } }; function U_ (i, t, e, n, r) { let s, o; if (r === xk(i, t, e, n) > 0) for (s = t; s < e; s += n)o = u_(s, i[s], i[s + 1], o); else for (s = e - n; s >= t; s -= n)o = u_(s, i[s], i[s + 1], o); return o && Um(o, o.next) && (Zd(o), o = o.next), o } function yl (i, t) { if (!i) return i; t || (t = i); let e = i, n; do if (n = !1, !e.steiner && (Um(e, e.next) || an(e.prev, e, e.next) === 0)) { if (Zd(e), e = t = e.prev, e === e.next) break; n = !0 } else e = e.next; while (n || e !== t); return t } function Qd (i, t, e, n, r, s, o) { if (!i) return; !o && s && fk(i, n, r, s); let a = i, l, u; for (; i.prev !== i.next;) { if (l = i.prev, u = i.next, s ? sk(i, n, r, s) : ik(i)) { t.push(l.i / e | 0), t.push(i.i / e | 0), t.push(u.i / e | 0), Zd(i), i = u.next, a = u.next; continue } if (i = u, i === a) { o ? o === 1 ? (i = ok(yl(i), t, e), Qd(i, t, e, n, r, s, 2)) : o === 2 && ak(i, t, e, n, r, s) : Qd(yl(i), t, e, n, r, s, 1); break } } } function ik (i) { let t = i.prev, e = i, n = i.next; if (an(t, e, n) >= 0) return !1; let r = t.x, s = e.x, o = n.x, a = t.y, l = e.y, u = n.y, c = r < s ? r < o ? r : o : s < o ? s : o, h = a < l ? a < u ? a : u : l < u ? l : u, d = r > s ? r > o ? r : o : s > o ? s : o, f = a > l ? a > u ? a : u : l > u ? l : u, p = n.next; for (; p !== t;) { if (p.x >= c && p.x <= d && p.y >= h && p.y <= f && _c(r, a, s, l, o, u, p.x, p.y) && an(p.prev, p, p.next) >= 0) return !1; p = p.next } return !0 } function sk (i, t, e, n) { let r = i.prev, s = i, o = i.next; if (an(r, s, o) >= 0) return !1; let a = r.x, l = s.x, u = o.x, c = r.y, h = s.y, d = o.y, f = a < l ? a < u ? a : u : l < u ? l : u, p = c < h ? c < d ? c : d : h < d ? h : d, m = a > l ? a > u ? a : u : l > u ? l : u, g = c > h ? c > d ? c : d : h > d ? h : d, y = Px(f, p, t, e, n), v = Px(m, g, t, e, n), x = i.prevZ, b = i.nextZ; for (; x && x.z >= y && b && b.z <= v;) { if (x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== r && x !== o && _c(a, c, l, h, u, d, x.x, x.y) && an(x.prev, x, x.next) >= 0 || (x = x.prevZ, b.x >= f && b.x <= m && b.y >= p && b.y <= g && b !== r && b !== o && _c(a, c, l, h, u, d, b.x, b.y) && an(b.prev, b, b.next) >= 0)) return !1; b = b.nextZ } for (; x && x.z >= y;) { if (x.x >= f && x.x <= m && x.y >= p && x.y <= g && x !== r && x !== o && _c(a, c, l, h, u, d, x.x, x.y) && an(x.prev, x, x.next) >= 0) return !1; x = x.prevZ } for (; b && b.z <= v;) { if (b.x >= f && b.x <= m && b.y >= p && b.y <= g && b !== r && b !== o && _c(a, c, l, h, u, d, b.x, b.y) && an(b.prev, b, b.next) >= 0) return !1; b = b.nextZ } return !0 } function ok (i, t, e) { let n = i; do { let r = n.prev, s = n.next.next; !Um(r, s) && z_(r, n, n.next, s) && Kd(r, s) && Kd(s, r) && (t.push(r.i / e | 0), t.push(n.i / e | 0), t.push(s.i / e | 0), Zd(n), Zd(n.next), n = i = s), n = n.next } while (n !== i); return yl(n) } function ak (i, t, e, n, r, s) { let o = i; do { let a = o.next.next; for (; a !== o.prev;) { if (o.i !== a.i && gk(o, a)) { let l = G_(o, a); o = yl(o, o.next), l = yl(l, l.next), Qd(o, t, e, n, r, s, 0), Qd(l, t, e, n, r, s, 0); return } a = a.next } o = o.next } while (o !== i) } function lk (i, t, e, n) { let r = [], s, o, a, l, u; for (s = 0, o = t.length; s < o; s++)a = t[s] * n, l = s < o - 1 ? t[s + 1] * n : i.length, u = U_(i, a, l, n, !1), u === u.next && (u.steiner = !0), r.push(mk(u)); for (r.sort(ck), s = 0; s < r.length; s++)e = uk(r[s], e); return e } function ck (i, t) { return i.x - t.x } function uk (i, t) { let e = hk(i, t); if (!e) return t; let n = G_(e, i); return yl(n, n.next), yl(e, e.next) } function hk (i, t) { let e = t, n = -1 / 0, r, s = i.x, o = i.y; do { if (o <= e.y && o >= e.next.y && e.next.y !== e.y) { let d = e.x + (o - e.y) * (e.next.x - e.x) / (e.next.y - e.y); if (d <= s && d > n && (n = d, r = e.x < e.next.x ? e : e.next, d === s)) return r } e = e.next } while (e !== t); if (!r) return null; let a = r, l = r.x, u = r.y, c = 1 / 0, h; e = r; do s >= e.x && e.x >= l && s !== e.x && _c(o < u ? s : n, o, l, u, o < u ? n : s, o, e.x, e.y) && (h = Math.abs(o - e.y) / (s - e.x), Kd(e, i) && (h < c || h === c && (e.x > r.x || e.x === r.x && dk(r, e))) && (r = e, c = h)), e = e.next; while (e !== a); return r } function dk (i, t) { return an(i.prev, i, t.prev) < 0 && an(t.next, i, i.next) < 0 } function fk (i, t, e, n) { let r = i; do r.z === 0 && (r.z = Px(r.x, r.y, t, e, n)), r.prevZ = r.prev, r.nextZ = r.next, r = r.next; while (r !== i); r.prevZ.nextZ = null, r.prevZ = null, pk(r) } function pk (i) { let t, e, n, r, s, o, a, l, u = 1; do { for (e = i, i = null, s = null, o = 0; e;) { for (o++, n = e, a = 0, t = 0; t < u && (a++, n = n.nextZ, !!n); t++); for (l = u; a > 0 || l > 0 && n;)a !== 0 && (l === 0 || !n || e.z <= n.z) ? (r = e, e = e.nextZ, a--) : (r = n, n = n.nextZ, l--), s ? s.nextZ = r : i = r, r.prevZ = s, s = r; e = n } s.nextZ = null, u *= 2 } while (o > 1); return i } function Px (i, t, e, n, r) { return i = (i - e) * r | 0, t = (t - n) * r | 0, i = (i | i << 8) & 16711935, i = (i | i << 4) & 252645135, i = (i | i << 2) & 858993459, i = (i | i << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, i | t << 1 } function mk (i) { let t = i, e = i; do (t.x < e.x || t.x === e.x && t.y < e.y) && (e = t), t = t.next; while (t !== i); return e } function _c (i, t, e, n, r, s, o, a) { return (r - o) * (t - a) >= (i - o) * (s - a) && (i - o) * (n - a) >= (e - o) * (t - a) && (e - o) * (s - a) >= (r - o) * (n - a) } function gk (i, t) { return i.next.i !== t.i && i.prev.i !== t.i && !yk(i, t) && (Kd(i, t) && Kd(t, i) && vk(i, t) && (an(i.prev, i, t.prev) || an(i, t.prev, t)) || Um(i, t) && an(i.prev, i, i.next) > 0 && an(t.prev, t, t.next) > 0) } function an (i, t, e) { return (t.y - i.y) * (e.x - t.x) - (t.x - i.x) * (e.y - t.y) } function Um (i, t) { return i.x === t.x && i.y === t.y } function z_ (i, t, e, n) { let r = rm(an(i, t, e)), s = rm(an(i, t, n)), o = rm(an(e, n, i)), a = rm(an(e, n, t)); return !!(r !== s && o !== a || r === 0 && nm(i, e, t) || s === 0 && nm(i, n, t) || o === 0 && nm(e, i, n) || a === 0 && nm(e, t, n)) } function nm (i, t, e) { return t.x <= Math.max(i.x, e.x) && t.x >= Math.min(i.x, e.x) && t.y <= Math.max(i.y, e.y) && t.y >= Math.min(i.y, e.y) } function rm (i) { return i > 0 ? 1 : i < 0 ? -1 : 0 } function yk (i, t) { let e = i; do { if (e.i !== i.i && e.next.i !== i.i && e.i !== t.i && e.next.i !== t.i && z_(e, e.next, i, t)) return !0; e = e.next } while (e !== i); return !1 } function Kd (i, t) { return an(i.prev, i, i.next) < 0 ? an(i, t, i.next) >= 0 && an(i, i.prev, t) >= 0 : an(i, t, i.prev) < 0 || an(i, i.next, t) < 0 } function vk (i, t) { let e = i, n = !1, r = (i.x + t.x) / 2, s = (i.y + t.y) / 2; do e.y > s != e.next.y > s && e.next.y !== e.y && r < (e.next.x - e.x) * (s - e.y) / (e.next.y - e.y) + e.x && (n = !n), e = e.next; while (e !== i); return n } function G_ (i, t) { let e = new Ix(i.i, i.x, i.y), n = new Ix(t.i, t.x, t.y), r = i.next, s = t.prev; return i.next = t, t.prev = i, e.next = r, r.prev = e, n.next = e, e.prev = n, s.next = n, n.prev = s, n } function u_ (i, t, e, n) { let r = new Ix(i, t, e); return n ? (r.next = n.next, r.prev = n, n.next.prev = r, n.next = r) : (r.prev = r, r.next = r), r } function Zd (i) { i.next.prev = i.prev, i.prev.next = i.next, i.prevZ && (i.prevZ.nextZ = i.nextZ), i.nextZ && (i.nextZ.prevZ = i.prevZ) } function Ix (i, t, e) { this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1 } function xk (i, t, e, n) { let r = 0; for (let s = t, o = e - n; s < e; s += n)r += (i[o] - i[s]) * (i[s + 1] + i[o + 1]), o = s; return r } var Bc = class { static area (t) { let e = t.length, n = 0; for (let r = e - 1, s = 0; s < e; r = s++)n += t[r].x * t[s].y - t[s].x * t[r].y; return n * .5 } static isClockWise (t) { return Bc.area(t) < 0 } static triangulateShape (t, e) { let n = [], r = [], s = []; h_(t), d_(n, t); let o = t.length; e.forEach(h_); for (let l = 0; l < e.length; l++)r.push(o), o += e[l].length, d_(n, e[l]); let a = rk.triangulate(n, r); for (let l = 0; l < a.length; l += 3)s.push(a.slice(l, l + 3)); return s } }; function h_ (i) { let t = i.length; t > 2 && i[t - 1].equals(i[0]) && i.pop() } function d_ (i, t) { for (let e = 0; e < t.length; e++)i.push(t[e].x), i.push(t[e].y) } var Fc = class extends Lc { constructor(t = 1, e = 0) { let n = (1 + Math.sqrt(5)) / 2, r = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1]; super(r, s, t, e), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e } } static fromJSON (t) { return new Fc(t.radius, t.detail) } }; var vl = class extends Ce { constructor(t = 1, e = 32, n = 16, r = 0, s = Math.PI * 2, o = 0, a = Math.PI) { super(), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: n, phiStart: r, phiLength: s, thetaStart: o, thetaLength: a }, e = Math.max(3, Math.floor(e)), n = Math.max(2, Math.floor(n)); let l = Math.min(o + a, Math.PI), u = 0, c = [], h = new A, d = new A, f = [], p = [], m = [], g = []; for (let y = 0; y <= n; y++) { let v = [], x = y / n, b = 0; y == 0 && o == 0 ? b = .5 / e : y == n && l == Math.PI && (b = -.5 / e); for (let S = 0; S <= e; S++) { let _ = S / e; h.x = -t * Math.cos(r + _ * s) * Math.sin(o + x * a), h.y = t * Math.cos(o + x * a), h.z = t * Math.sin(r + _ * s) * Math.sin(o + x * a), p.push(h.x, h.y, h.z), d.copy(h).normalize(), m.push(d.x, d.y, d.z), g.push(_ + b, 1 - x), v.push(u++) } c.push(v) } for (let y = 0; y < n; y++)for (let v = 0; v < e; v++) { let x = c[y][v + 1], b = c[y][v], S = c[y + 1][v], _ = c[y + 1][v + 1]; (y !== 0 || o > 0) && f.push(x, b, _), (y !== n - 1 || l < Math.PI) && f.push(b, S, _) } this.setIndex(f), this.setAttribute("position", new _e(p, 3)), this.setAttribute("normal", new _e(m, 3)), this.setAttribute("uv", new _e(g, 2)) } static fromJSON (t) { return new vl(t.radius, t.widthSegments, t.heightSegments, t.phiStart, t.phiLength, t.thetaStart, t.thetaLength) } }; var kc = class extends Ce { constructor(t = 1, e = .4, n = 64, r = 8, s = 2, o = 3) { super(), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: n, radialSegments: r, p: s, q: o }, n = Math.floor(n), r = Math.floor(r); let a = [], l = [], u = [], c = [], h = new A, d = new A, f = new A, p = new A, m = new A, g = new A, y = new A; for (let x = 0; x <= n; ++x) { let b = x / n * s * Math.PI * 2; v(b, s, o, t, f), v(b + .01, s, o, t, p), g.subVectors(p, f), y.addVectors(p, f), m.crossVectors(g, y), y.crossVectors(m, g), m.normalize(), y.normalize(); for (let S = 0; S <= r; ++S) { let _ = S / r * Math.PI * 2, E = -e * Math.cos(_), w = e * Math.sin(_); h.x = f.x + (E * y.x + w * m.x), h.y = f.y + (E * y.y + w * m.y), h.z = f.z + (E * y.z + w * m.z), l.push(h.x, h.y, h.z), d.subVectors(h, f).normalize(), u.push(d.x, d.y, d.z), c.push(x / n), c.push(S / r) } } for (let x = 1; x <= n; x++)for (let b = 1; b <= r; b++) { let S = (r + 1) * (x - 1) + (b - 1), _ = (r + 1) * x + (b - 1), E = (r + 1) * x + b, w = (r + 1) * (x - 1) + b; a.push(S, _, w), a.push(_, E, w) } this.setIndex(a), this.setAttribute("position", new _e(l, 3)), this.setAttribute("normal", new _e(u, 3)), this.setAttribute("uv", new _e(c, 2)); function v (x, b, S, _, E) { let w = Math.cos(x), M = Math.sin(x), T = S / b * x, I = Math.cos(T); E.x = _ * (2 + I) * .5 * w, E.y = _ * (2 + I) * M * .5, E.z = _ * Math.sin(T) * .5 } } static fromJSON (t) { return new kc(t.radius, t.tube, t.tubularSegments, t.radialSegments, t.p, t.q) } }; function $o (i, t, e) { return V_(i) ? new i.constructor(i.subarray(t, e !== void 0 ? e : i.length)) : i.slice(t, e) } function im (i, t, e) { return !i || !e && i.constructor === t ? i : typeof t.BYTES_PER_ELEMENT == "number" ? new t(i) : Array.prototype.slice.call(i) } function V_ (i) { return ArrayBuffer.isView(i) && !(i instanceof DataView) } function bk (i) { function t (r, s) { return i[r] - i[s] } let e = i.length, n = new Array(e); for (let r = 0; r !== e; ++r)n[r] = r; return n.sort(t), n } function f_ (i, t, e) { let n = i.length, r = new i.constructor(n); for (let s = 0, o = 0; o !== n; ++s) { let a = e[s] * t; for (let l = 0; l !== t; ++l)r[o++] = i[a + l] } return r } function H_ (i, t, e, n) { let r = 1, s = i[0]; for (; s !== void 0 && s[n] === void 0;)s = i[r++]; if (s === void 0) return; let o = s[n]; if (o !== void 0) if (Array.isArray(o)) do o = s[n], o !== void 0 && (t.push(s.time), e.push.apply(e, o)), s = i[r++]; while (s !== void 0); else if (o.toArray !== void 0) do o = s[n], o !== void 0 && (t.push(s.time), o.toArray(e, e.length)), s = i[r++]; while (s !== void 0); else do o = s[n], o !== void 0 && (t.push(s.time), e.push(o)), s = i[r++]; while (s !== void 0) } var Uc = class { constructor(t, e, n, r) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = r !== void 0 ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {} } evaluate (t) { let e = this.parameterPositions, n = this._cachedIndex, r = e[n], s = e[n - 1]; e: { t: { let o; n: { r: if (!(t < r)) { for (let a = n + 2; ;) { if (r === void 0) { if (t < s) break r; return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } if (n === a) break; if (s = r, r = e[++n], t < r) break t } o = e.length; break n } if (!(t >= s)) { let a = e[1]; t < a && (n = 2, s = a); for (let l = n - 2; ;) { if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (n === l) break; if (r = s, s = e[--n - 1], t >= s) break t } o = n, n = 0; break n } break e } for (; n < o;) { let a = n + o >>> 1; t < e[a] ? o = a : n = a + 1 } if (r = e[n], s = e[n - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0); if (r === void 0) return n = e.length, this._cachedIndex = n, this.copySampleValue_(n - 1) } this._cachedIndex = n, this.intervalChanged_(n, s, r) } return this.interpolate_(n, s, t, r) } getSettings_ () { return this.settings || this.DefaultSettings_ } copySampleValue_ (t) { let e = this.resultBuffer, n = this.sampleValues, r = this.valueSize, s = t * r; for (let o = 0; o !== r; ++o)e[o] = n[s + o]; return e } interpolate_ () { throw new Error("call to abstract method") } intervalChanged_ () { } }, Dx = class extends Uc { constructor(t, e, n, r) { super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = { endingStart: wc, endingEnd: wc } } intervalChanged_ (t, e, n) { let r = this.parameterPositions, s = t - 2, o = t + 1, a = r[s], l = r[o]; if (a === void 0) switch (this.getSettings_().endingStart) { case Sc: s = t, a = 2 * e - n; break; case hm: s = r.length - 2, a = e + r[s] - r[s + 1]; break; default: s = t, a = n }if (l === void 0) switch (this.getSettings_().endingEnd) { case Sc: o = t, l = 2 * n - e; break; case hm: o = 1, l = n + r[1] - r[0]; break; default: o = t - 1, l = e }let u = (n - e) * .5, c = this.valueSize; this._weightPrev = u / (e - a), this._weightNext = u / (l - n), this._offsetPrev = s * c, this._offsetNext = o * c } interpolate_ (t, e, n, r) { let s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = t * a, u = l - a, c = this._offsetPrev, h = this._offsetNext, d = this._weightPrev, f = this._weightNext, p = (n - e) / (r - e), m = p * p, g = m * p, y = -d * g + 2 * d * m - d * p, v = (1 + d) * g + (-1.5 - 2 * d) * m + (-.5 + d) * p + 1, x = (-1 - f) * g + (1.5 + f) * m + .5 * p, b = f * g - f * m; for (let S = 0; S !== a; ++S)s[S] = y * o[c + S] + v * o[u + S] + x * o[l + S] + b * o[h + S]; return s } }, _m = class extends Uc { constructor(t, e, n, r) { super(t, e, n, r) } interpolate_ (t, e, n, r) { let s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = t * a, u = l - a, c = (n - e) / (r - e), h = 1 - c; for (let d = 0; d !== a; ++d)s[d] = o[u + d] * h + o[l + d] * c; return s } }, Ox = class extends Uc { constructor(t, e, n, r) { super(t, e, n, r) } interpolate_ (t) { return this.copySampleValue_(t - 1) } }, _i = class { constructor(t, e, n, r) { if (t === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined"); if (e === void 0 || e.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t); this.name = t, this.times = im(e, this.TimeBufferType), this.values = im(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation) } static toJSON (t) { let e = t.constructor, n; if (e.toJSON !== this.toJSON) n = e.toJSON(t); else { n = { name: t.name, times: im(t.times, Array), values: im(t.values, Array) }; let r = t.getInterpolation(); r !== t.DefaultInterpolation && (n.interpolation = r) } return n.type = t.ValueTypeName, n } InterpolantFactoryMethodDiscrete (t) { return new Ox(this.times, this.values, this.getValueSize(), t) } InterpolantFactoryMethodLinear (t) { return new _m(this.times, this.values, this.getValueSize(), t) } InterpolantFactoryMethodSmooth (t) { return new Dx(this.times, this.values, this.getValueSize(), t) } setInterpolation (t) { let e; switch (t) { case cm: e = this.InterpolantFactoryMethodDiscrete; break; case um: e = this.InterpolantFactoryMethodLinear; break; case I0: e = this.InterpolantFactoryMethodSmooth; break }if (e === void 0) { let n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name; if (this.createInterpolant === void 0) if (t !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation); else throw new Error(n); return console.warn("THREE.KeyframeTrack:", n), this } return this.createInterpolant = e, this } getInterpolation () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return cm; case this.InterpolantFactoryMethodLinear: return um; case this.InterpolantFactoryMethodSmooth: return I0 } } getValueSize () { return this.values.length / this.times.length } shift (t) { if (t !== 0) { let e = this.times; for (let n = 0, r = e.length; n !== r; ++n)e[n] += t } return this } scale (t) { if (t !== 1) { let e = this.times; for (let n = 0, r = e.length; n !== r; ++n)e[n] *= t } return this } trim (t, e) { let n = this.times, r = n.length, s = 0, o = r - 1; for (; s !== r && n[s] < t;)++s; for (; o !== -1 && n[o] > e;)--o; if (++o, s !== 0 || o !== r) { s >= o && (o = Math.max(o, 1), s = o - 1); let a = this.getValueSize(); this.times = $o(n, s, o), this.values = $o(this.values, s * a, o * a) } return this } validate () { let t = !0, e = this.getValueSize(); e - Math.floor(e) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1); let n = this.times, r = this.values, s = n.length; s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1); let o = null; for (let a = 0; a !== s; a++) { let l = n[a]; if (typeof l == "number" && isNaN(l)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), t = !1; break } if (o !== null && o > l) { console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), t = !1; break } o = l } if (r !== void 0 && V_(r)) for (let a = 0, l = r.length; a !== l; ++a) { let u = r[a]; if (isNaN(u)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, u), t = !1; break } } return t } optimize () { let t = $o(this.times), e = $o(this.values), n = this.getValueSize(), r = this.getInterpolation() === I0, s = t.length - 1, o = 1; for (let a = 1; a < s; ++a) { let l = !1, u = t[a], c = t[a + 1]; if (u !== c && (a !== 1 || u !== t[0])) if (r) l = !0; else { let h = a * n, d = h - n, f = h + n; for (let p = 0; p !== n; ++p) { let m = e[h + p]; if (m !== e[d + p] || m !== e[f + p]) { l = !0; break } } } if (l) { if (a !== o) { t[o] = t[a]; let h = a * n, d = o * n; for (let f = 0; f !== n; ++f)e[d + f] = e[h + f] } ++o } } if (s > 0) { t[o] = t[s]; for (let a = s * n, l = o * n, u = 0; u !== n; ++u)e[l + u] = e[a + u]; ++o } return o !== t.length ? (this.times = $o(t, 0, o), this.values = $o(e, 0, o * n)) : (this.times = t, this.values = e), this } clone () { let t = $o(this.times, 0), e = $o(this.values, 0), n = this.constructor, r = new n(this.name, t, e); return r.createInterpolant = this.createInterpolant, r } }; _i.prototype.TimeBufferType = Float32Array; _i.prototype.ValueBufferType = Float32Array; _i.prototype.DefaultInterpolation = um; var oa = class extends _i { }; oa.prototype.ValueTypeName = "bool"; oa.prototype.ValueBufferType = Array; oa.prototype.DefaultInterpolation = cm; oa.prototype.InterpolantFactoryMethodLinear = void 0; oa.prototype.InterpolantFactoryMethodSmooth = void 0; var Em = class extends _i { }; Em.prototype.ValueTypeName = "color"; var zc = class extends _i { }; zc.prototype.ValueTypeName = "number"; var Rx = class extends Uc { constructor(t, e, n, r) { super(t, e, n, r) } interpolate_ (t, e, n, r) { let s = this.resultBuffer, o = this.sampleValues, a = this.valueSize, l = (n - e) / (r - e), u = t * a; for (let c = u + a; u !== c; u += 4)Ye.slerpFlat(s, 0, o, u - a, o, u, l); return s } }, xl = class extends _i { InterpolantFactoryMethodLinear (t) { return new Rx(this.times, this.values, this.getValueSize(), t) } }; xl.prototype.ValueTypeName = "quaternion"; xl.prototype.DefaultInterpolation = um; xl.prototype.InterpolantFactoryMethodSmooth = void 0; var aa = class extends _i { }; aa.prototype.ValueTypeName = "string"; aa.prototype.ValueBufferType = Array; aa.prototype.DefaultInterpolation = cm; aa.prototype.InterpolantFactoryMethodLinear = void 0; aa.prototype.InterpolantFactoryMethodSmooth = void 0; var Gc = class extends _i { }; Gc.prototype.ValueTypeName = "vector"; var Vc = class { constructor(t, e = -1, n, r = qx) { this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = bi(), this.duration < 0 && this.resetDuration() } static parse (t) { let e = [], n = t.tracks, r = 1 / (t.fps || 1); for (let o = 0, a = n.length; o !== a; ++o)e.push(Sk(n[o]).scale(r)); let s = new this(t.name, t.duration, e, t.blendMode); return s.uuid = t.uuid, s } static toJSON (t) { let e = [], n = t.tracks, r = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid, blendMode: t.blendMode }; for (let s = 0, o = n.length; s !== o; ++s)e.push(_i.toJSON(n[s])); return r } static CreateFromMorphTargetSequence (t, e, n, r) { let s = e.length, o = []; for (let a = 0; a < s; a++) { let l = [], u = []; l.push((a + s - 1) % s, a, (a + 1) % s), u.push(0, 1, 0); let c = bk(l); l = f_(l, 1, c), u = f_(u, 1, c), !r && l[0] === 0 && (l.push(s), u.push(u[0])), o.push(new zc(".morphTargetInfluences[" + e[a].name + "]", l, u).scale(1 / n)) } return new this(t, -1, o) } static findByName (t, e) { let n = t; if (!Array.isArray(t)) { let r = t; n = r.geometry && r.geometry.animations || r.animations } for (let r = 0; r < n.length; r++)if (n[r].name === e) return n[r]; return null } static CreateClipsFromMorphTargetSequences (t, e, n) { let r = {}, s = /^([\w-]*?)([\d]+)$/; for (let a = 0, l = t.length; a < l; a++) { let u = t[a], c = u.name.match(s); if (c && c.length > 1) { let h = c[1], d = r[h]; d || (r[h] = d = []), d.push(u) } } let o = []; for (let a in r) o.push(this.CreateFromMorphTargetSequence(a, r[a], e, n)); return o } static parseAnimation (t, e) { if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; let n = function (h, d, f, p, m) { if (f.length !== 0) { let g = [], y = []; H_(f, g, y, p), g.length !== 0 && m.push(new h(d, g, y)) } }, r = [], s = t.name || "default", o = t.fps || 30, a = t.blendMode, l = t.length || -1, u = t.hierarchy || []; for (let h = 0; h < u.length; h++) { let d = u[h].keys; if (!(!d || d.length === 0)) if (d[0].morphTargets) { let f = {}, p; for (p = 0; p < d.length; p++)if (d[p].morphTargets) for (let m = 0; m < d[p].morphTargets.length; m++)f[d[p].morphTargets[m]] = -1; for (let m in f) { let g = [], y = []; for (let v = 0; v !== d[p].morphTargets.length; ++v) { let x = d[p]; g.push(x.time), y.push(x.morphTarget === m ? 1 : 0) } r.push(new zc(".morphTargetInfluence[" + m + "]", g, y)) } l = f.length * o } else { let f = ".bones[" + e[h].name + "]"; n(Gc, f + ".position", d, "pos", r), n(xl, f + ".quaternion", d, "rot", r), n(Gc, f + ".scale", d, "scl", r) } } return r.length === 0 ? null : new this(s, l, r, a) } resetDuration () { let t = this.tracks, e = 0; for (let n = 0, r = t.length; n !== r; ++n) { let s = this.tracks[n]; e = Math.max(e, s.times[s.times.length - 1]) } return this.duration = e, this } trim () { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration); return this } validate () { let t = !0; for (let e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t } optimize () { for (let t = 0; t < this.tracks.length; t++)this.tracks[t].optimize(); return this } clone () { let t = []; for (let e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new this.constructor(this.name, this.duration, t, this.blendMode) } toJSON () { return this.constructor.toJSON(this) } }; function wk (i) { switch (i.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return zc; case "vector": case "vector2": case "vector3": case "vector4": return Gc; case "color": return Em; case "quaternion": return xl; case "bool": case "boolean": return oa; case "string": return aa }throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + i) } function Sk (i) { if (i.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse"); let t = wk(i.type); if (i.times === void 0) { let e = [], n = []; H_(i.keys, e, n, "value"), i.times = e, i.values = n } return t.parse !== void 0 ? t.parse(i) : new t(i.name, i.times, i.values, i.interpolation) } var p_ = { enabled: !1, files: {}, add: function (i, t) { this.enabled !== !1 && (this.files[i] = t) }, get: function (i) { if (this.enabled !== !1) return this.files[i] }, remove: function (i) { delete this.files[i] }, clear: function () { this.files = {} } }, Jd = class { constructor(t, e, n) { let r = this, s = !1, o = 0, a = 0, l, u = []; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function (c) { a++, s === !1 && r.onStart !== void 0 && r.onStart(c, o, a), s = !0 }, this.itemEnd = function (c) { o++, r.onProgress !== void 0 && r.onProgress(c, o, a), o === a && (s = !1, r.onLoad !== void 0 && r.onLoad()) }, this.itemError = function (c) { r.onError !== void 0 && r.onError(c) }, this.resolveURL = function (c) { return l ? l(c) : c }, this.setURLModifier = function (c) { return l = c, this }, this.addHandler = function (c, h) { return u.push(c, h), this }, this.removeHandler = function (c) { let h = u.indexOf(c); return h !== -1 && u.splice(h, 2), this }, this.getHandler = function (c) { for (let h = 0, d = u.length; h < d; h += 2) { let f = u[h], p = u[h + 1]; if (f.global && (f.lastIndex = 0), f.test(c)) return p } return null } } }, Ak = new Jd, Hc = class { constructor(t) { this.manager = t !== void 0 ? t : Ak, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {} } load () { } loadAsync (t, e) { let n = this; return new Promise(function (r, s) { n.load(t, r, e, s) }) } parse () { } setCrossOrigin (t) { return this.crossOrigin = t, this } setWithCredentials (t) { return this.withCredentials = t, this } setPath (t) { return this.path = t, this } setResourcePath (t) { return this.resourcePath = t, this } setRequestHeader (t) { return this.requestHeader = t, this } }, co = {}, Lx = class extends Error { constructor(t, e) { super(t), this.response = e } }, jc = class extends Hc { constructor(t) { super(t) } load (t, e, n, r) { t === void 0 && (t = ""), this.path !== void 0 && (t = this.path + t), t = this.manager.resolveURL(t); let s = p_.get(t); if (s !== void 0) return this.manager.itemStart(t), setTimeout(() => { e && e(s), this.manager.itemEnd(t) }, 0), s; if (co[t] !== void 0) { co[t].push({ onLoad: e, onProgress: n, onError: r }); return } co[t] = [], co[t].push({ onLoad: e, onProgress: n, onError: r }); let o = new Request(t, { headers: new Headers(this.requestHeader), credentials: this.withCredentials ? "include" : "same-origin" }), a = this.mimeType, l = this.responseType; fetch(o).then(u => { if (u.status === 200 || u.status === 0) { if (u.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || u.body === void 0 || u.body.getReader === void 0) return u; let c = co[t], h = u.body.getReader(), d = u.headers.get("Content-Length") || u.headers.get("X-File-Size"), f = d ? parseInt(d) : 0, p = f !== 0, m = 0, g = new ReadableStream({ start (y) { v(); function v () { h.read().then(({ done: x, value: b }) => { if (x) y.close(); else { m += b.byteLength; let S = new ProgressEvent("progress", { lengthComputable: p, loaded: m, total: f }); for (let _ = 0, E = c.length; _ < E; _++) { let w = c[_]; w.onProgress && w.onProgress(S) } y.enqueue(b), v() } }) } } }); return new Response(g) } else throw new Lx(`fetch for "${u.url}" responded with ${u.status}: ${u.statusText}`, u) }).then(u => { switch (l) { case "arraybuffer": return u.arrayBuffer(); case "blob": return u.blob(); case "document": return u.text().then(c => new DOMParser().parseFromString(c, a)); case "json": return u.json(); default: if (a === void 0) return u.text(); { let h = /charset="?([^;"\s]*)"?/i.exec(a), d = h && h[1] ? h[1].toLowerCase() : void 0, f = new TextDecoder(d); return u.arrayBuffer().then(p => f.decode(p)) } } }).then(u => { p_.add(t, u); let c = co[t]; delete co[t]; for (let h = 0, d = c.length; h < d; h++) { let f = c[h]; f.onLoad && f.onLoad(u) } }).catch(u => { let c = co[t]; if (c === void 0) throw this.manager.itemError(t), u; delete co[t]; for (let h = 0, d = c.length; h < d; h++) { let f = c[h]; f.onError && f.onError(u) } this.manager.itemError(t) }).finally(() => { this.manager.itemEnd(t) }), this.manager.itemStart(t) } setResponseType (t) { return this.responseType = t, this } setMimeType (t) { return this.mimeType = t, this } }; var la = class extends ft { constructor(t, e = 1) { super(), this.isLight = !0, this.type = "Light", this.color = new Le(t), this.intensity = e } dispose () { } copy (t, e) { return super.copy(t, e), this.color.copy(t.color), this.intensity = t.intensity, this } toJSON (t) { let e = super.toJSON(t); return e.object.color = this.color.getHex(), e.object.intensity = this.intensity, this.groundColor !== void 0 && (e.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (e.object.distance = this.distance), this.angle !== void 0 && (e.object.angle = this.angle), this.decay !== void 0 && (e.object.decay = this.decay), this.penumbra !== void 0 && (e.object.penumbra = this.penumbra), this.shadow !== void 0 && (e.object.shadow = this.shadow.toJSON()), e } }, Mm = class extends la { constructor(t, e, n) { super(t, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(ft.DEFAULT_UP), this.updateMatrix(), this.groundColor = new Le(e) } copy (t, e) { return super.copy(t, e), this.groundColor.copy(t.groundColor), this } }, sx = new se, m_ = new A, g_ = new A, $d = class { constructor(t) { this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new B(512, 512), this.map = null, this.mapPass = null, this.matrix = new se, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new jd, this._frameExtents = new B(1, 1), this._viewportCount = 1, this._viewports = [new qe(0, 0, 1, 1)] } getViewportCount () { return this._viewportCount } getFrustum () { return this._frustum } updateMatrices (t) { let e = this.camera, n = this.matrix; m_.setFromMatrixPosition(t.matrixWorld), e.position.copy(m_), g_.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(g_), e.updateMatrixWorld(), sx.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(sx), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(sx) } getViewport (t) { return this._viewports[t] } getFrameExtents () { return this._frameExtents } dispose () { this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose() } copy (t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this } clone () { return new this.constructor().copy(this) } toJSON () { let t = {}; return this.bias !== 0 && (t.bias = this.bias), this.normalBias !== 0 && (t.normalBias = this.normalBias), this.radius !== 1 && (t.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } }, Nx = class extends $d { constructor() { super(new xn(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1 } updateMatrices (t) { let e = this.camera, n = Vd * 2 * t.angle * this.focus, r = this.mapSize.width / this.mapSize.height, s = t.distance || e.far; (n !== e.fov || r !== e.aspect || s !== e.far) && (e.fov = n, e.aspect = r, e.far = s, e.updateProjectionMatrix()), super.updateMatrices(t) } copy (t) { return super.copy(t), this.focus = t.focus, this } }, Tm = class extends la { constructor(t, e, n = 0, r = Math.PI / 3, s = 0, o = 2) { super(t, e), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(ft.DEFAULT_UP), this.updateMatrix(), this.target = new ft, this.distance = n, this.angle = r, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new Nx } get power () { return this.intensity * Math.PI } set power (t) { this.intensity = t / Math.PI } dispose () { this.shadow.dispose() } copy (t, e) { return super.copy(t, e), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }, y_ = new se, Rd = new A, ox = new A, Bx = class extends $d { constructor() { super(new xn(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new B(4, 2), this._viewportCount = 6, this._viewports = [new qe(2, 1, 1, 1), new qe(0, 1, 1, 1), new qe(3, 1, 1, 1), new qe(1, 1, 1, 1), new qe(3, 0, 1, 1), new qe(1, 0, 1, 1)], this._cubeDirections = [new A(1, 0, 0), new A(-1, 0, 0), new A(0, 0, 1), new A(0, 0, -1), new A(0, 1, 0), new A(0, -1, 0)], this._cubeUps = [new A(0, 1, 0), new A(0, 1, 0), new A(0, 1, 0), new A(0, 1, 0), new A(0, 0, 1), new A(0, 0, -1)] } updateMatrices (t, e = 0) { let n = this.camera, r = this.matrix, s = t.distance || n.far; s !== n.far && (n.far = s, n.updateProjectionMatrix()), Rd.setFromMatrixPosition(t.matrixWorld), n.position.copy(Rd), ox.copy(n.position), ox.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(ox), n.updateMatrixWorld(), r.makeTranslation(-Rd.x, -Rd.y, -Rd.z), y_.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(y_) } }, Cm = class extends la { constructor(t, e, n = 0, r = 2) { super(t, e), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new Bx } get power () { return this.intensity * 4 * Math.PI } set power (t) { this.intensity = t / (4 * Math.PI) } dispose () { this.shadow.dispose() } copy (t, e) { return super.copy(t, e), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } }, Fx = class extends $d { constructor() { super(new Pc(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0 } }, Pm = class extends la { constructor(t, e) { super(t, e), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(ft.DEFAULT_UP), this.updateMatrix(), this.target = new ft, this.shadow = new Fx } dispose () { this.shadow.dispose() } copy (t) { return super.copy(t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }; var kx = class extends Ce { constructor() { super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0 } copy (t) { return super.copy(t), this.instanceCount = t.instanceCount, this } toJSON () { let t = super.toJSON(); return t.instanceCount = this.instanceCount, t.isInstancedBufferGeometry = !0, t } }, Wc = class extends Hc { constructor(t) { super(t) } load (t, e, n, r) { let s = this, o = new jc(s.manager); o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(t, function (a) { try { e(s.parse(JSON.parse(a))) } catch (l) { r ? r(l) : console.error(l), s.manager.itemError(t) } }, n, r) } parse (t) { let e = {}, n = {}; function r (f, p) { if (e[p] !== void 0) return e[p]; let g = f.interleavedBuffers[p], y = s(f, g.buffer), v = Np(g.type, y), x = new wm(v, g.stride); return x.uuid = g.uuid, e[p] = x, x } function s (f, p) { if (n[p] !== void 0) return n[p]; let g = f.arrayBuffers[p], y = new Uint32Array(g).buffer; return n[p] = y, y } let o = t.isInstancedBufferGeometry ? new kx : new Ce, a = t.data.index; if (a !== void 0) { let f = Np(a.type, a.array); o.setIndex(new ze(f, 1)) } let l = t.data.attributes; for (let f in l) { let p = l[f], m; if (p.isInterleavedBufferAttribute) { let g = r(t.data, p.data); m = new hl(g, p.itemSize, p.offset, p.normalized) } else { let g = Np(p.type, p.array), y = p.isInstancedBufferAttribute ? Sm : ze; m = new y(g, p.itemSize, p.normalized) } p.name !== void 0 && (m.name = p.name), p.usage !== void 0 && m.setUsage(p.usage), p.updateRange !== void 0 && (m.updateRange.offset = p.updateRange.offset, m.updateRange.count = p.updateRange.count), o.setAttribute(f, m) } let u = t.data.morphAttributes; if (u) for (let f in u) { let p = u[f], m = []; for (let g = 0, y = p.length; g < y; g++) { let v = p[g], x; if (v.isInterleavedBufferAttribute) { let b = r(t.data, v.data); x = new hl(b, v.itemSize, v.offset, v.normalized) } else { let b = Np(v.type, v.array); x = new ze(b, v.itemSize, v.normalized) } v.name !== void 0 && (x.name = v.name), m.push(x) } o.morphAttributes[f] = m } t.data.morphTargetsRelative && (o.morphTargetsRelative = !0); let h = t.data.groups || t.data.drawcalls || t.data.offsets; if (h !== void 0) for (let f = 0, p = h.length; f !== p; ++f) { let m = h[f]; o.addGroup(m.start, m.count, m.materialIndex) } let d = t.data.boundingSphere; if (d !== void 0) { let f = new A; d.center !== void 0 && f.fromArray(d.center), o.boundingSphere = new dn(f, d.radius) } return t.name && (o.name = t.name), t.userData && (o.userData = t.userData), o } }; var Im = class { constructor(t = !0) { this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1 } start () { this.startTime = v_(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0 } stop () { this.getElapsedTime(), this.running = !1, this.autoStart = !1 } getElapsedTime () { return this.getDelta(), this.elapsedTime } getDelta () { let t = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { let e = v_(); t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t } return t } }; function v_ () { return (typeof performance > "u" ? Date : performance).now() } var Ux = class { constructor(t, e, n) { this.binding = t, this.valueSize = n; let r, s, o; switch (e) { case "quaternion": r = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5; break; case "string": case "bool": r = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5); break; default: r = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5) }this._mixBufferRegion = r, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0 } accumulate (t, e) { let n = this.buffer, r = this.valueSize, s = t * r + r, o = this.cumulativeWeight; if (o === 0) { for (let a = 0; a !== r; ++a)n[s + a] = n[a]; o = e } else { o += e; let a = e / o; this._mixBufferRegion(n, s, 0, a, r) } this.cumulativeWeight = o } accumulateAdditive (t) { let e = this.buffer, n = this.valueSize, r = n * this._addIndex; this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t } apply (t) { let e = this.valueSize, n = this.buffer, r = t * e + e, s = this.cumulativeWeight, o = this.cumulativeWeightAdditive, a = this.binding; if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) { let l = e * this._origIndex; this._mixBufferRegion(n, r, l, 1 - s, e) } o > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e); for (let l = e, u = e + e; l !== u; ++l)if (n[l] !== n[l + e]) { a.setValue(n, r); break } } saveOriginalState () { let t = this.binding, e = this.buffer, n = this.valueSize, r = n * this._origIndex; t.getValue(e, r); for (let s = n, o = r; s !== o; ++s)e[s] = e[r + s % n]; this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0 } restoreOriginalState () { let t = this.valueSize * 3; this.binding.setValue(this.buffer, t) } _setAdditiveIdentityNumeric () { let t = this._addIndex * this.valueSize, e = t + this.valueSize; for (let n = t; n < e; n++)this.buffer[n] = 0 } _setAdditiveIdentityQuaternion () { this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1 } _setAdditiveIdentityOther () { let t = this._origIndex * this.valueSize, e = this._addIndex * this.valueSize; for (let n = 0; n < this.valueSize; n++)this.buffer[e + n] = this.buffer[t + n] } _select (t, e, n, r, s) { if (r >= .5) for (let o = 0; o !== s; ++o)t[e + o] = t[n + o] } _slerp (t, e, n, r) { Ye.slerpFlat(t, e, t, e, t, n, r) } _slerpAdditive (t, e, n, r, s) { let o = this._workIndex * s; Ye.multiplyQuaternionsFlat(t, o, t, e, t, n), Ye.slerpFlat(t, e, t, e, t, o, r) } _lerp (t, e, n, r, s) { let o = 1 - r; for (let a = 0; a !== s; ++a) { let l = e + a; t[l] = t[l] * o + t[n + a] * r } } _lerpAdditive (t, e, n, r, s) { for (let o = 0; o !== s; ++o) { let a = e + o; t[a] = t[a] + t[n + o] * r } } }, Jx = "\\[\\]\\.:\\/", _k = new RegExp("[" + Jx + "]", "g"), $x = "[^" + Jx + "]", Ek = "[^" + Jx.replace("\\.", "") + "]", Mk = /((?:WC+[\/:])*)/.source.replace("WC", $x), Tk = /(WCOD+)?/.source.replace("WCOD", Ek), Ck = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", $x), Pk = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", $x), Ik = new RegExp("^" + Mk + Tk + Ck + Pk + "$"), Dk = ["material", "materials", "bones", "map"], zx = class { constructor(t, e, n) { let r = n || It.parseTrackName(e); this._targetGroup = t, this._bindings = t.subscribe_(e, r) } getValue (t, e) { this.bind(); let n = this._targetGroup.nCachedObjects_, r = this._bindings[n]; r !== void 0 && r.getValue(t, e) } setValue (t, e) { let n = this._bindings; for (let r = this._targetGroup.nCachedObjects_, s = n.length; r !== s; ++r)n[r].setValue(t, e) } bind () { let t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].bind() } unbind () { let t = this._bindings; for (let e = this._targetGroup.nCachedObjects_, n = t.length; e !== n; ++e)t[e].unbind() } }, It = class { constructor(t, e, n) { this.path = e, this.parsedPath = n || It.parseTrackName(e), this.node = It.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } static create (t, e, n) { return t && t.isAnimationObjectGroup ? new It.Composite(t, e, n) : new It(t, e, n) } static sanitizeNodeName (t) { return t.replace(/\s/g, "_").replace(_k, "") } static parseTrackName (t) { let e = Ik.exec(t); if (e === null) throw new Error("PropertyBinding: Cannot parse trackName: " + t); let n = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }, r = n.nodeName && n.nodeName.lastIndexOf("."); if (r !== void 0 && r !== -1) { let s = n.nodeName.substring(r + 1); Dk.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, r), n.objectName = s) } if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t); return n } static findNode (t, e) { if (e === void 0 || e === "" || e === "." || e === -1 || e === t.name || e === t.uuid) return t; if (t.skeleton) { let n = t.skeleton.getBoneByName(e); if (n !== void 0) return n } if (t.children) { let n = function (s) { for (let o = 0; o < s.length; o++) { let a = s[o]; if (a.name === e || a.uuid === e) return a; let l = n(a.children); if (l) return l } return null }, r = n(t.children); if (r) return r } return null } _getValue_unavailable () { } _setValue_unavailable () { } _getValue_direct (t, e) { t[e] = this.targetObject[this.propertyName] } _getValue_array (t, e) { let n = this.resolvedProperty; for (let r = 0, s = n.length; r !== s; ++r)t[e++] = n[r] } _getValue_arrayElement (t, e) { t[e] = this.resolvedProperty[this.propertyIndex] } _getValue_toArray (t, e) { this.resolvedProperty.toArray(t, e) } _setValue_direct (t, e) { this.targetObject[this.propertyName] = t[e] } _setValue_direct_setNeedsUpdate (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 } _setValue_direct_setMatrixWorldNeedsUpdate (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_array (t, e) { let n = this.resolvedProperty; for (let r = 0, s = n.length; r !== s; ++r)n[r] = t[e++] } _setValue_array_setNeedsUpdate (t, e) { let n = this.resolvedProperty; for (let r = 0, s = n.length; r !== s; ++r)n[r] = t[e++]; this.targetObject.needsUpdate = !0 } _setValue_array_setMatrixWorldNeedsUpdate (t, e) { let n = this.resolvedProperty; for (let r = 0, s = n.length; r !== s; ++r)n[r] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_arrayElement (t, e) { this.resolvedProperty[this.propertyIndex] = t[e] } _setValue_arrayElement_setNeedsUpdate (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 } _setValue_arrayElement_setMatrixWorldNeedsUpdate (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 } _setValue_fromArray (t, e) { this.resolvedProperty.fromArray(t, e) } _setValue_fromArray_setNeedsUpdate (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 } _setValue_fromArray_setMatrixWorldNeedsUpdate (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 } _getValue_unbound (t, e) { this.bind(), this.getValue(t, e) } _setValue_unbound (t, e) { this.bind(), this.setValue(t, e) } bind () { let t = this.node, e = this.parsedPath, n = e.objectName, r = e.propertyName, s = e.propertyIndex; if (t || (t = It.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) { console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found."); return } if (n) { let u = e.objectIndex; switch (n) { case "materials": if (!t.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!t.material.materials) { console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); return } t = t.material.materials; break; case "bones": if (!t.skeleton) { console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); return } t = t.skeleton.bones; for (let c = 0; c < t.length; c++)if (t[c].name === u) { u = c; break } break; case "map": if ("map" in t) { t = t.map; break } if (!t.material) { console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); return } if (!t.material.map) { console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this); return } t = t.material.map; break; default: if (t[n] === void 0) { console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); return } t = t[n] }if (u !== void 0) { if (t[u] === void 0) { console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t); return } t = t[u] } } let o = t[r]; if (o === void 0) { let u = e.nodeName; console.error("THREE.PropertyBinding: Trying to update property for track: " + u + "." + r + " but it wasn't found.", t); return } let a = this.Versioning.None; this.targetObject = t, t.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : t.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate); let l = this.BindingType.Direct; if (s !== void 0) { if (r === "morphTargetInfluences") { if (!t.geometry) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); return } if (!t.geometry.morphAttributes) { console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); return } t.morphTargetDictionary[s] !== void 0 && (s = t.morphTargetDictionary[s]) } l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = r; this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a] } unbind () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }; It.Composite = zx; It.prototype.BindingType = { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }; It.prototype.Versioning = { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }; It.prototype.GetterByBindingType = [It.prototype._getValue_direct, It.prototype._getValue_array, It.prototype._getValue_arrayElement, It.prototype._getValue_toArray]; It.prototype.SetterByBindingTypeAndVersioning = [[It.prototype._setValue_direct, It.prototype._setValue_direct_setNeedsUpdate, It.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [It.prototype._setValue_array, It.prototype._setValue_array_setNeedsUpdate, It.prototype._setValue_array_setMatrixWorldNeedsUpdate], [It.prototype._setValue_arrayElement, It.prototype._setValue_arrayElement_setNeedsUpdate, It.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [It.prototype._setValue_fromArray, It.prototype._setValue_fromArray_setNeedsUpdate, It.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]]; var Gx = class { constructor(t, e, n = null, r = e.blendMode) { this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = r; let s = e.tracks, o = s.length, a = new Array(o), l = { endingStart: wc, endingEnd: wc }; for (let u = 0; u !== o; ++u) { let c = s[u].createInterpolant(null); a[u] = c, c.settings = l } this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = Wx, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0 } play () { return this._mixer._activateAction(this), this } stop () { return this._mixer._deactivateAction(this), this.reset() } reset () { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() } isRunning () { return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this) } isScheduled () { return this._mixer._isActiveAction(this) } startAt (t) { return this._startTime = t, this } setLoop (t, e) { return this.loop = t, this.repetitions = e, this } setEffectiveWeight (t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() } getEffectiveWeight () { return this._effectiveWeight } fadeIn (t) { return this._scheduleFading(t, 0, 1) } fadeOut (t) { return this._scheduleFading(t, 1, 0) } crossFadeFrom (t, e, n) { if (t.fadeOut(e), this.fadeIn(e), n) { let r = this._clip.duration, s = t._clip.duration, o = s / r, a = r / s; t.warp(1, o, e), this.warp(a, 1, e) } return this } crossFadeTo (t, e, n) { return t.crossFadeFrom(this, e, n) } stopFading () { let t = this._weightInterpolant; return t !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this } setEffectiveTimeScale (t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() } getEffectiveTimeScale () { return this._effectiveTimeScale } setDuration (t) { return this.timeScale = this._clip.duration / t, this.stopWarping() } syncWith (t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() } halt (t) { return this.warp(this._effectiveTimeScale, 0, t) } warp (t, e, n) { let r = this._mixer, s = r.time, o = this.timeScale, a = this._timeScaleInterpolant; a === null && (a = r._lendControlInterpolant(), this._timeScaleInterpolant = a); let l = a.parameterPositions, u = a.sampleValues; return l[0] = s, l[1] = s + n, u[0] = t / o, u[1] = e / o, this } stopWarping () { let t = this._timeScaleInterpolant; return t !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this } getMixer () { return this._mixer } getClip () { return this._clip } getRoot () { return this._localRoot || this._mixer._root } _update (t, e, n, r) { if (!this.enabled) { this._updateWeight(t); return } let s = this._startTime; if (s !== null) { let l = (t - s) * n; l < 0 || n === 0 ? e = 0 : (this._startTime = null, e = n * l) } e *= this._updateTimeScale(t); let o = this._updateTime(e), a = this._updateWeight(t); if (a > 0) { let l = this._interpolants, u = this._propertyBindings; switch (this.blendMode) { case qR: for (let c = 0, h = l.length; c !== h; ++c)l[c].evaluate(o), u[c].accumulateAdditive(a); break; case qx: default: for (let c = 0, h = l.length; c !== h; ++c)l[c].evaluate(o), u[c].accumulate(r, a) } } } _updateWeight (t) { let e = 0; if (this.enabled) { e = this.weight; let n = this._weightInterpolant; if (n !== null) { let r = n.evaluate(t)[0]; e *= r, t > n.parameterPositions[1] && (this.stopFading(), r === 0 && (this.enabled = !1)) } } return this._effectiveWeight = e, e } _updateTimeScale (t) { let e = 0; if (!this.paused) { e = this.timeScale; let n = this._timeScaleInterpolant; if (n !== null) { let r = n.evaluate(t)[0]; e *= r, t > n.parameterPositions[1] && (this.stopWarping(), e === 0 ? this.paused = !0 : this.timeScale = e) } } return this._effectiveTimeScale = e, e } _updateTime (t) { let e = this._clip.duration, n = this.loop, r = this.time + t, s = this._loopCount, o = n === tf; if (t === 0) return s === -1 ? r : o && (s & 1) === 1 ? e - r : r; if (n === jx) { s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= e) r = e; else if (r < 0) r = 0; else { this.time = r; break e } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t < 0 ? -1 : 1 }) } } else { if (s === -1 && (t >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), r >= e || r < 0) { let a = Math.floor(r / e); r -= e * a, s += Math.abs(a); let l = this.repetitions - s; if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, r = t > 0 ? e : 0, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: t > 0 ? 1 : -1 }); else { if (l === 1) { let u = t < 0; this._setEndings(u, !u, o) } else this._setEndings(!1, !1, o); this._loopCount = s, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a }) } } else this.time = r; if (o && (s & 1) === 1) return e - r } return r } _setEndings (t, e, n) { let r = this._interpolantSettings; n ? (r.endingStart = Sc, r.endingEnd = Sc) : (t ? r.endingStart = this.zeroSlopeAtStart ? Sc : wc : r.endingStart = hm, e ? r.endingEnd = this.zeroSlopeAtEnd ? Sc : wc : r.endingEnd = hm) } _scheduleFading (t, e, n) { let r = this._mixer, s = r.time, o = this._weightInterpolant; o === null && (o = r._lendControlInterpolant(), this._weightInterpolant = o); let a = o.parameterPositions, l = o.sampleValues; return a[0] = s, l[0] = e, a[1] = s + t, l[1] = n, this } }, Ok = new Float32Array(1), Dm = class extends kt { constructor(t) { super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1 } _bindAction (t, e) { let n = t._localRoot || this._root, r = t._clip.tracks, s = r.length, o = t._propertyBindings, a = t._interpolants, l = n.uuid, u = this._bindingsByRootAndName, c = u[l]; c === void 0 && (c = {}, u[l] = c); for (let h = 0; h !== s; ++h) { let d = r[h], f = d.name, p = c[f]; if (p !== void 0) ++p.referenceCount, o[h] = p; else { if (p = o[h], p !== void 0) { p._cacheIndex === null && (++p.referenceCount, this._addInactiveBinding(p, l, f)); continue } let m = e && e._propertyBindings[h].binding.parsedPath; p = new Ux(It.create(n, f, m), d.ValueTypeName, d.getValueSize()), ++p.referenceCount, this._addInactiveBinding(p, l, f), o[h] = p } a[h].resultBuffer = p.buffer } } _activateAction (t) { if (!this._isActiveAction(t)) { if (t._cacheIndex === null) { let n = (t._localRoot || this._root).uuid, r = t._clip.uuid, s = this._actionsByClip[r]; this._bindAction(t, s && s.knownActions[0]), this._addInactiveAction(t, r, n) } let e = t._propertyBindings; for (let n = 0, r = e.length; n !== r; ++n) { let s = e[n]; s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState()) } this._lendAction(t) } } _deactivateAction (t) { if (this._isActiveAction(t)) { let e = t._propertyBindings; for (let n = 0, r = e.length; n !== r; ++n) { let s = e[n]; --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s)) } this._takeBackAction(t) } } _initMemoryManager () { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; let t = this; this.stats = { actions: { get total () { return t._actions.length }, get inUse () { return t._nActiveActions } }, bindings: { get total () { return t._bindings.length }, get inUse () { return t._nActiveBindings } }, controlInterpolants: { get total () { return t._controlInterpolants.length }, get inUse () { return t._nActiveControlInterpolants } } } } _isActiveAction (t) { let e = t._cacheIndex; return e !== null && e < this._nActiveActions } _addInactiveAction (t, e, n) { let r = this._actions, s = this._actionsByClip, o = s[e]; if (o === void 0) o = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, s[e] = o; else { let a = o.knownActions; t._byClipCacheIndex = a.length, a.push(t) } t._cacheIndex = r.length, r.push(t), o.actionByRoot[n] = t } _removeInactiveAction (t) { let e = this._actions, n = e[e.length - 1], r = t._cacheIndex; n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null; let s = t._clip.uuid, o = this._actionsByClip, a = o[s], l = a.knownActions, u = l[l.length - 1], c = t._byClipCacheIndex; u._byClipCacheIndex = c, l[c] = u, l.pop(), t._byClipCacheIndex = null; let h = a.actionByRoot, d = (t._localRoot || this._root).uuid; delete h[d], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(t) } _removeInactiveBindingsForAction (t) { let e = t._propertyBindings; for (let n = 0, r = e.length; n !== r; ++n) { let s = e[n]; --s.referenceCount === 0 && this._removeInactiveBinding(s) } } _lendAction (t) { let e = this._actions, n = t._cacheIndex, r = this._nActiveActions++, s = e[r]; t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s } _takeBackAction (t) { let e = this._actions, n = t._cacheIndex, r = --this._nActiveActions, s = e[r]; t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s } _addInactiveBinding (t, e, n) { let r = this._bindingsByRootAndName, s = this._bindings, o = r[e]; o === void 0 && (o = {}, r[e] = o), o[n] = t, t._cacheIndex = s.length, s.push(t) } _removeInactiveBinding (t) { let e = this._bindings, n = t.binding, r = n.rootNode.uuid, s = n.path, o = this._bindingsByRootAndName, a = o[r], l = e[e.length - 1], u = t._cacheIndex; l._cacheIndex = u, e[u] = l, e.pop(), delete a[s], Object.keys(a).length === 0 && delete o[r] } _lendBinding (t) { let e = this._bindings, n = t._cacheIndex, r = this._nActiveBindings++, s = e[r]; t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s } _takeBackBinding (t) { let e = this._bindings, n = t._cacheIndex, r = --this._nActiveBindings, s = e[r]; t._cacheIndex = r, e[r] = t, s._cacheIndex = n, e[n] = s } _lendControlInterpolant () { let t = this._controlInterpolants, e = this._nActiveControlInterpolants++, n = t[e]; return n === void 0 && (n = new _m(new Float32Array(2), new Float32Array(2), 1, Ok), n.__cacheIndex = e, t[e] = n), n } _takeBackControlInterpolant (t) { let e = this._controlInterpolants, n = t.__cacheIndex, r = --this._nActiveControlInterpolants, s = e[r]; t.__cacheIndex = r, e[r] = t, s.__cacheIndex = n, e[n] = s } clipAction (t, e, n) { let r = e || this._root, s = r.uuid, o = typeof t == "string" ? Vc.findByName(r, t) : t, a = o !== null ? o.uuid : t, l = this._actionsByClip[a], u = null; if (n === void 0 && (o !== null ? n = o.blendMode : n = qx), l !== void 0) { let h = l.actionByRoot[s]; if (h !== void 0 && h.blendMode === n) return h; u = l.knownActions[0], o === null && (o = u._clip) } if (o === null) return null; let c = new Gx(this, o, e, n); return this._bindAction(c, u), this._addInactiveAction(c, a, s), c } existingAction (t, e) { let n = e || this._root, r = n.uuid, s = typeof t == "string" ? Vc.findByName(n, t) : t, o = s ? s.uuid : t, a = this._actionsByClip[o]; return a !== void 0 && a.actionByRoot[r] || null } stopAllAction () { let t = this._actions, e = this._nActiveActions; for (let n = e - 1; n >= 0; --n)t[n].stop(); return this } update (t) { t *= this.timeScale; let e = this._actions, n = this._nActiveActions, r = this.time += t, s = Math.sign(t), o = this._accuIndex ^= 1; for (let u = 0; u !== n; ++u)e[u]._update(r, t, s, o); let a = this._bindings, l = this._nActiveBindings; for (let u = 0; u !== l; ++u)a[u].apply(o); return this } setTime (t) { this.time = 0; for (let e = 0; e < this._actions.length; e++)this._actions[e].time = 0; return this.update(t) } getRoot () { return this._root } uncacheClip (t) { let e = this._actions, n = t.uuid, r = this._actionsByClip, s = r[n]; if (s !== void 0) { let o = s.knownActions; for (let a = 0, l = o.length; a !== l; ++a) { let u = o[a]; this._deactivateAction(u); let c = u._cacheIndex, h = e[e.length - 1]; u._cacheIndex = null, u._byClipCacheIndex = null, h._cacheIndex = c, e[c] = h, e.pop(), this._removeInactiveBindingsForAction(u) } delete r[n] } } uncacheRoot (t) { let e = t.uuid, n = this._actionsByClip; for (let o in n) { let a = n[o].actionByRoot, l = a[e]; l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l)) } let r = this._bindingsByRootAndName, s = r[e]; if (s !== void 0) for (let o in s) { let a = s[o]; a.restoreOriginalState(), this._removeInactiveBinding(a) } } uncacheAction (t, e) { let n = this.existingAction(t, e); n !== null && (this._deactivateAction(n), this._removeInactiveAction(n)) } }, oe = class { constructor(t) { this.value = t } clone () { return new oe(this.value.clone === void 0 ? this.value : this.value.clone()) } }; var qc = class { constructor(t, e, n = 0, r = 1 / 0) { this.ray = new Wi(t, e), this.near = n, this.far = r, this.camera = null, this.layers = new Hd, this.params = { Mesh: {}, Line: { threshold: 1 }, LOD: {}, Points: { threshold: 1 }, Sprite: {} } } set (t, e) { this.ray.set(t, e) } setFromCamera (t, e) { e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : console.error("THREE.Raycaster: Unsupported camera type: " + e.type) } intersectObject (t, e = !0, n = []) { return Vx(t, this, n, e), n.sort(x_), n } intersectObjects (t, e = !0, n = []) { for (let r = 0, s = t.length; r < s; r++)Vx(t[r], this, n, e); return n.sort(x_), n } }; function x_ (i, t) { return i.distance - t.distance } function Vx (i, t, e, n) { if (i.layers.test(t.layers) && i.raycast(t, e), n === !0) { let r = i.children; for (let s = 0, o = r.length; s < o; s++)Vx(r[s], t, e, !0) } } var ef = class { constructor(t = 1, e = 0, n = 0) { return this.radius = t, this.phi = e, this.theta = n, this } set (t, e, n) { return this.radius = t, this.phi = e, this.theta = n, this } copy (t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this } makeSafe () { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this } setFromVector3 (t) { return this.setFromCartesianCoords(t.x, t.y, t.z) } setFromCartesianCoords (t, e, n) { return this.radius = Math.sqrt(t * t + e * e + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(t, n), this.phi = Math.acos(zn(e / this.radius, -1, 1))), this } clone () { return new this.constructor().copy(this) } }; var b_ = new B, Om = class { constructor(t = new B(1 / 0, 1 / 0), e = new B(-1 / 0, -1 / 0)) { this.isBox2 = !0, this.min = t, this.max = e } set (t, e) { return this.min.copy(t), this.max.copy(e), this } setFromPoints (t) { this.makeEmpty(); for (let e = 0, n = t.length; e < n; e++)this.expandByPoint(t[e]); return this } setFromCenterAndSize (t, e) { let n = b_.copy(e).multiplyScalar(.5); return this.min.copy(t).sub(n), this.max.copy(t).add(n), this } clone () { return new this.constructor().copy(this) } copy (t) { return this.min.copy(t.min), this.max.copy(t.max), this } makeEmpty () { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this } isEmpty () { return this.max.x < this.min.x || this.max.y < this.min.y } getCenter (t) { return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) } getSize (t) { return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) } expandByPoint (t) { return this.min.min(t), this.max.max(t), this } expandByVector (t) { return this.min.sub(t), this.max.add(t), this } expandByScalar (t) { return this.min.addScalar(-t), this.max.addScalar(t), this } containsPoint (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) } containsBox (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y } getParameter (t, e) { return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) } intersectsBox (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) } clampPoint (t, e) { return e.copy(t).clamp(this.min, this.max) } distanceToPoint (t) { return b_.copy(t).clamp(this.min, this.max).sub(t).length() } intersect (t) { return this.min.max(t.min), this.max.min(t.max), this } union (t) { return this.min.min(t.min), this.max.max(t.max), this } translate (t) { return this.min.add(t), this.max.add(t), this } equals (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }, w_ = new A, sm = new A, Hn = class { constructor(t = new A, e = new A) { this.start = t, this.end = e } set (t, e) { return this.start.copy(t), this.end.copy(e), this } copy (t) { return this.start.copy(t.start), this.end.copy(t.end), this } getCenter (t) { return t.addVectors(this.start, this.end).multiplyScalar(.5) } delta (t) { return t.subVectors(this.end, this.start) } distanceSq () { return this.start.distanceToSquared(this.end) } distance () { return this.start.distanceTo(this.end) } at (t, e) { return this.delta(e).multiplyScalar(t).add(this.start) } closestPointToPointParameter (t, e) { w_.subVectors(t, this.start), sm.subVectors(this.end, this.start); let n = sm.dot(sm), s = sm.dot(w_) / n; return e && (s = zn(s, 0, 1)), s } closestPointToPoint (t, e, n) { let r = this.closestPointToPointParameter(t, e); return this.delta(n).multiplyScalar(r).add(this.start) } applyMatrix4 (t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this } equals (t) { return t.start.equals(this.start) && t.end.equals(this.end) } clone () { return new this.constructor().copy(this) } }, S_ = new A, Rm = class extends ft { constructor(t, e) { super(), this.light = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, this.type = "SpotLightHelper"; let n = new Ce, r = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (let o = 0, a = 1, l = 32; o < l; o++, a++) { let u = o / l * Math.PI * 2, c = a / l * Math.PI * 2; r.push(Math.cos(u), Math.sin(u), 1, Math.cos(c), Math.sin(c), 1) } n.setAttribute("position", new _e(r, 3)); let s = new Si({ fog: !1, toneMapped: !1 }); this.cone = new sa(n, s), this.add(this.cone), this.update() } dispose () { this.cone.geometry.dispose(), this.cone.material.dispose() } update () { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1); let t = this.light.distance ? this.light.distance : 1e3, e = t * Math.tan(this.light.angle); this.cone.scale.set(e, e, t), S_.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(S_), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } }; var Lm = class extends Rn { constructor(t, e, n) { let r = new vl(e, 4, 2), s = new po({ wireframe: !0, fog: !1, toneMapped: !1 }); super(r, s), this.light = t, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } dispose () { this.geometry.dispose(), this.material.dispose() } update () { this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) } }; var A_ = new A, om = new A, __ = new A, Nm = class extends ft { constructor(t, e, n) { super(), this.light = t, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", e === void 0 && (e = 1); let r = new Ce; r.setAttribute("position", new _e([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)); let s = new Si({ fog: !1, toneMapped: !1 }); this.lightPlane = new dl(r, s), this.add(this.lightPlane), r = new Ce, r.setAttribute("position", new _e([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new dl(r, s), this.add(this.targetLine), this.update() } dispose () { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() } update () { this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), A_.setFromMatrixPosition(this.light.matrixWorld), om.setFromMatrixPosition(this.light.target.matrixWorld), __.subVectors(om, A_), this.lightPlane.lookAt(om), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(om), this.targetLine.scale.z = __.length() } }, am = new A, hn = new qi, ca = class extends sa { constructor(t) { let e = new Ce, n = new Si({ color: 16777215, vertexColors: !0, toneMapped: !1 }), r = [], s = [], o = {}; a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4"); function a (p, m) { l(p), l(m) } function l (p) { r.push(0, 0, 0), s.push(0, 0, 0), o[p] === void 0 && (o[p] = []), o[p].push(r.length / 3 - 1) } e.setAttribute("position", new _e(r, 3)), e.setAttribute("color", new _e(s, 3)), super(e, n), this.type = "CameraHelper", this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update(); let u = new Le(16755200), c = new Le(16711680), h = new Le(43775), d = new Le(16777215), f = new Le(3355443); this.setColors(u, c, h, d, f) } setColors (t, e, n, r, s) { let a = this.geometry.getAttribute("color"); a.setXYZ(0, t.r, t.g, t.b), a.setXYZ(1, t.r, t.g, t.b), a.setXYZ(2, t.r, t.g, t.b), a.setXYZ(3, t.r, t.g, t.b), a.setXYZ(4, t.r, t.g, t.b), a.setXYZ(5, t.r, t.g, t.b), a.setXYZ(6, t.r, t.g, t.b), a.setXYZ(7, t.r, t.g, t.b), a.setXYZ(8, t.r, t.g, t.b), a.setXYZ(9, t.r, t.g, t.b), a.setXYZ(10, t.r, t.g, t.b), a.setXYZ(11, t.r, t.g, t.b), a.setXYZ(12, t.r, t.g, t.b), a.setXYZ(13, t.r, t.g, t.b), a.setXYZ(14, t.r, t.g, t.b), a.setXYZ(15, t.r, t.g, t.b), a.setXYZ(16, t.r, t.g, t.b), a.setXYZ(17, t.r, t.g, t.b), a.setXYZ(18, t.r, t.g, t.b), a.setXYZ(19, t.r, t.g, t.b), a.setXYZ(20, t.r, t.g, t.b), a.setXYZ(21, t.r, t.g, t.b), a.setXYZ(22, t.r, t.g, t.b), a.setXYZ(23, t.r, t.g, t.b), a.setXYZ(24, e.r, e.g, e.b), a.setXYZ(25, e.r, e.g, e.b), a.setXYZ(26, e.r, e.g, e.b), a.setXYZ(27, e.r, e.g, e.b), a.setXYZ(28, e.r, e.g, e.b), a.setXYZ(29, e.r, e.g, e.b), a.setXYZ(30, e.r, e.g, e.b), a.setXYZ(31, e.r, e.g, e.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, r.r, r.g, r.b), a.setXYZ(39, r.r, r.g, r.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = !0 } update () { let t = this.geometry, e = this.pointMap, n = 1, r = 1; hn.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), vn("c", e, t, hn, 0, 0, -1), vn("t", e, t, hn, 0, 0, 1), vn("n1", e, t, hn, -n, -r, -1), vn("n2", e, t, hn, n, -r, -1), vn("n3", e, t, hn, -n, r, -1), vn("n4", e, t, hn, n, r, -1), vn("f1", e, t, hn, -n, -r, 1), vn("f2", e, t, hn, n, -r, 1), vn("f3", e, t, hn, -n, r, 1), vn("f4", e, t, hn, n, r, 1), vn("u1", e, t, hn, n * .7, r * 1.1, -1), vn("u2", e, t, hn, -n * .7, r * 1.1, -1), vn("u3", e, t, hn, 0, r * 2, -1), vn("cf1", e, t, hn, -n, 0, 1), vn("cf2", e, t, hn, n, 0, 1), vn("cf3", e, t, hn, 0, -r, 1), vn("cf4", e, t, hn, 0, r, 1), vn("cn1", e, t, hn, -n, 0, -1), vn("cn2", e, t, hn, n, 0, -1), vn("cn3", e, t, hn, 0, -r, -1), vn("cn4", e, t, hn, 0, r, -1), t.getAttribute("position").needsUpdate = !0 } dispose () { this.geometry.dispose(), this.material.dispose() } }; function vn (i, t, e, n, r, s, o) { am.set(r, s, o).unproject(n); let a = t[i]; if (a !== void 0) { let l = e.getAttribute("position"); for (let u = 0, c = a.length; u < c; u++)l.setXYZ(a[u], am.x, am.y, am.z) } } var ua = class extends sa { constructor(t, e = 16776960) { let n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]), r = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], s = new Ce; s.setIndex(new ze(n, 1)), s.setAttribute("position", new _e(r, 3)), super(s, new Si({ color: e, toneMapped: !1 })), this.box = t, this.type = "Box3Helper", this.geometry.computeBoundingSphere() } updateMatrixWorld (t) { let e = this.box; e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(t)) } dispose () { this.geometry.dispose(), this.material.dispose() } }; var Bm = class extends sa { constructor(t = 1) { let e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t], n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], r = new Ce; r.setAttribute("position", new _e(e, 3)), r.setAttribute("color", new _e(n, 3)); let s = new Si({ vertexColors: !0, toneMapped: !1 }); super(r, s), this.type = "AxesHelper" } setColors (t, e, n) { let r = new Le, s = this.geometry.attributes.color.array; return r.set(t), r.toArray(s, 0), r.toArray(s, 3), r.set(e), r.toArray(s, 6), r.toArray(s, 9), r.set(n), r.toArray(s, 12), r.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this } dispose () { this.geometry.dispose(), this.material.dispose() } }; typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: { revision: vo } })); typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = vo); var Qc = ".", nf = Symbol("target"), eb = Symbol("unsubscribe"); function rf (i) { return i instanceof Date || i instanceof Set || i instanceof Map || i instanceof WeakSet || i instanceof WeakMap || ArrayBuffer.isView(i) } function j_ (i) { return (typeof i == "object" ? i === null : typeof i != "function") || i instanceof RegExp } var hi = Array.isArray; function bl (i) { return typeof i == "symbol" } var Rk = { after: (i, t) => hi(i) ? i.slice(t.length) : t === "" ? i : i.slice(t.length + 1), concat: (i, t) => hi(i) ? (i = [...i], t && i.push(t), i) : t && t.toString !== void 0 ? (i !== "" && (i += Qc), bl(t) ? i + t.toString() : i + t) : i, initial: i => { if (hi(i)) return i.slice(0, -1); if (i === "") return i; let t = i.lastIndexOf(Qc); return t === -1 ? "" : i.slice(0, t) }, last: i => { if (hi(i)) return i[i.length - 1] || ""; if (i === "") return i; let t = i.lastIndexOf(Qc); return t === -1 ? i : i.slice(t + 1) }, walk: (i, t) => { if (hi(i)) for (let e of i) t(e); else if (i !== "") { let e = 0, n = i.indexOf(Qc); if (n === -1) t(i); else for (; e < i.length;)n === -1 && (n = i.length), t(i.slice(e, n)), e = n + 1, n = i.indexOf(Qc, e) } }, get (i, t) { return this.walk(t, e => { i && (i = i[e]) }), i } }, Br = Rk; function tb (i) { return typeof i == "object" && typeof i.next == "function" } function nb (i, t, e, n, r) { let s = i.next; if (t.name === "entries") i.next = function () { let o = s.call(this); return o.done === !1 && (o.value[0] = r(o.value[0], t, o.value[0], n), o.value[1] = r(o.value[1], t, o.value[0], n)), o }; else if (t.name === "values") { let o = e[nf].keys(); i.next = function () { let a = s.call(this); return a.done === !1 && (a.value = r(a.value, t, o.next().value, n)), a } } else i.next = function () { let o = s.call(this); return o.done === !1 && (o.value = r(o.value, t, o.value, n)), o }; return i } function zm (i, t, e) { return i.isUnsubscribed || t.ignoreSymbols && bl(e) || t.ignoreUnderscores && e.charAt(0) === "_" || "ignoreKeys" in t && t.ignoreKeys.includes(e) } var sf = class { constructor(t) { this._equals = t, this._proxyCache = new WeakMap, this._pathCache = new WeakMap, this.isUnsubscribed = !1 } _getDescriptorCache () { return this._descriptorCache === void 0 && (this._descriptorCache = new WeakMap), this._descriptorCache } _getProperties (t) { let e = this._getDescriptorCache(), n = e.get(t); return n === void 0 && (n = {}, e.set(t, n)), n } _getOwnPropertyDescriptor (t, e) { if (this.isUnsubscribed) return Reflect.getOwnPropertyDescriptor(t, e); let n = this._getProperties(t), r = n[e]; return r === void 0 && (r = Reflect.getOwnPropertyDescriptor(t, e), n[e] = r), r } getProxy (t, e, n, r) { if (this.isUnsubscribed) return t; let s = t[r], o = s || t; this._pathCache.set(o, e); let a = this._proxyCache.get(o); return a === void 0 && (a = s === void 0 ? new Proxy(t, n) : t, this._proxyCache.set(o, a)), a } getPath (t) { return this.isUnsubscribed ? void 0 : this._pathCache.get(t) } isDetached (t, e) { return !Object.is(t, Br.get(e, this.getPath(t))) } defineProperty (t, e, n) { return Reflect.defineProperty(t, e, n) ? (this.isUnsubscribed || (this._getProperties(t)[e] = n), !0) : !1 } setProperty (t, e, n, r, s) { if (!this._equals(s, n) || !(e in t)) { let o = this._getOwnPropertyDescriptor(t, e); return o !== void 0 && "set" in o ? Reflect.set(t, e, n, r) : Reflect.set(t, e, n) } return !0 } deleteProperty (t, e, n) { if (Reflect.deleteProperty(t, e)) { if (!this.isUnsubscribed) { let r = this._getDescriptorCache().get(t); r && (delete r[e], this._pathCache.delete(n)) } return !0 } return !1 } isSameDescriptor (t, e, n) { let r = this._getOwnPropertyDescriptor(e, n); return t !== void 0 && r !== void 0 && Object.is(t.value, r.value) && (t.writable || !1) === (r.writable || !1) && (t.enumerable || !1) === (r.enumerable || !1) && (t.configurable || !1) === (r.configurable || !1) && t.get === r.get && t.set === r.set } isGetInvariant (t, e) { let n = this._getOwnPropertyDescriptor(t, e); return n !== void 0 && n.configurable !== !0 && n.writable !== !0 } unsubscribe () { this._descriptorCache = null, this._pathCache = null, this._proxyCache = null, this.isUnsubscribed = !0 } }; function Kc (i) { return toString.call(i) === "[object Object]" } function Zc () { return !0 } function ha (i, t) { return i.length !== t.length || i.some((e, n) => t[n] !== e) } var Gm = new Set(["hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]); var Lk = new Set(["concat", "includes", "indexOf", "join", "keys", "lastIndexOf"]), rb = { push: Zc, pop: Zc, shift: Zc, unshift: Zc, copyWithin: ha, reverse: ha, sort: ha, splice: ha, flat: ha, fill: ha }, W_ = new Set([...Gm, ...Lk, ...Object.keys(rb)]); function Jc (i, t) { if (i.size !== t.size) return !0; for (let e of i) if (!t.has(e)) return !0; return !1 } var ib = ["keys", "values", "entries"], sb = new Set(["has", "toString"]), ob = { add: Jc, clear: Jc, delete: Jc, forEach: Jc }, q_ = new Set([...sb, ...Object.keys(ob), ...ib]); function $c (i, t) { if (i.size !== t.size) return !0; let e; for (let [n, r] of i) if (e = t.get(n), e !== r || e === void 0 && !t.has(n)) return !0; return !1 } var Nk = new Set([...sb, "get"]), ab = { set: $c, clear: $c, delete: $c, forEach: $c }, Y_ = new Set([...Nk, ...Object.keys(ab), ...ib]); var nr = class { constructor(t, e, n, r) { this._path = e, this._isChanged = !1, this._clonedCache = new Set, this._hasOnValidate = r, this._changes = r ? [] : null, this.clone = e === void 0 ? t : this._shallowClone(t) } static isHandledMethod (t) { return Gm.has(t) } _shallowClone (t) { let e = t; if (Kc(t)) e = { ...t }; else if (hi(t)) e = [...t]; else if (t instanceof Date) e = new Date(t); else if (t instanceof Set) e = new Set([...t].map(n => this._shallowClone(n))); else if (t instanceof Map) { e = new Map; for (let [n, r] of t.entries()) e.set(n, this._shallowClone(r)) } return this._clonedCache.add(e), e } preferredThisArg (t, e, n, r) { return t ? (hi(r) ? this._onIsChanged = rb[e] : r instanceof Set ? this._onIsChanged = ob[e] : r instanceof Map && (this._onIsChanged = ab[e]), r) : n } update (t, e, n) { let r = Br.after(t, this._path); if (e !== "length") { let s = this.clone; Br.walk(r, o => { s && s[o] && (this._clonedCache.has(s[o]) || (s[o] = this._shallowClone(s[o])), s = s[o]) }), this._hasOnValidate && this._changes.push({ path: r, property: e, previous: n }), s && s[e] && (s[e] = n) } this._isChanged = !0 } undo (t) { let e; for (let n = this._changes.length - 1; n !== -1; n--)e = this._changes[n], Br.get(t, e.path)[e.property] = e.previous } isChanged (t) { return this._onIsChanged === void 0 ? this._isChanged : this._onIsChanged(this.clone, t) } }; var eu = class extends nr { static isHandledMethod (t) { return W_.has(t) } }; var of = class extends nr { undo (t) { t.setTime(this.clone.getTime()) } isChanged (t, e) { return !e(this.clone.valueOf(), t.valueOf()) } }; var tu = class extends nr { static isHandledMethod (t) { return q_.has(t) } undo (t) { for (let e of this.clone) t.add(e); for (let e of t) this.clone.has(e) || t.delete(e) } }; var nu = class extends nr { static isHandledMethod (t) { return Y_.has(t) } undo (t) { for (let [e, n] of this.clone.entries()) t.set(e, n); for (let e of t.keys()) this.clone.has(e) || t.delete(e) } }; var af = class extends nr { constructor(t, e, n, r) { super(void 0, e, n, r), this._arg1 = n[0], this._weakValue = t.has(this._arg1) } isChanged (t) { return this._weakValue !== t.has(this._arg1) } undo (t) { this._weakValue && !t.has(this._arg1) ? t.add(this._arg1) : t.delete(this._arg1) } }; var lf = class extends nr { constructor(t, e, n, r) { super(void 0, e, n, r), this._weakKey = n[0], this._weakHas = t.has(this._weakKey), this._weakValue = t.get(this._weakKey) } isChanged (t) { return this._weakValue !== t.get(this._weakKey) } undo (t) { let e = t.has(this._weakKey); this._weakHas && !e ? t.set(this._weakKey, this._weakValue) : !this._weakHas && e ? t.delete(this._weakKey) : this._weakValue !== t.get(this._weakKey) && t.set(this._weakKey, this._weakValue) } }; var Xi = class { constructor(t) { this._stack = [], this._hasOnValidate = t } static isHandledType (t) { return Kc(t) || hi(t) || rf(t) } static isHandledMethod (t, e) { return Kc(t) ? nr.isHandledMethod(e) : hi(t) ? eu.isHandledMethod(e) : t instanceof Set ? tu.isHandledMethod(e) : t instanceof Map ? nu.isHandledMethod(e) : rf(t) } get isCloning () { return this._stack.length > 0 } start (t, e, n) { let r = nr; hi(t) ? r = eu : t instanceof Date ? r = of : t instanceof Set ? r = tu : t instanceof Map ? r = nu : t instanceof WeakSet ? r = af : t instanceof WeakMap && (r = lf), this._stack.push(new r(t, e, n, this._hasOnValidate)) } update (t, e, n) { this._stack[this._stack.length - 1].update(t, e, n) } preferredThisArg (t, e, n) { let { name: r } = t, s = Xi.isHandledMethod(n, r); return this._stack[this._stack.length - 1].preferredThisArg(s, r, e, n) } isChanged (t, e, n) { return this._stack[this._stack.length - 1].isChanged(t, e, n) } undo (t) { this._previousClone !== void 0 && this._previousClone.undo(t) } stop () { return this._previousClone = this._stack.pop(), this._previousClone.clone } }; var Bk = { equals: Object.is, isShallow: !1, pathAsArray: !1, ignoreSymbols: !1, ignoreUnderscores: !1, ignoreDetached: !1, details: !1 }, lb = (i, t, e = {}) => { e = { ...Bk, ...e }; let n = Symbol("ProxyTarget"), { equals: r, isShallow: s, ignoreDetached: o, details: a } = e, l = new sf(r), u = typeof e.onValidate == "function", c = new Xi(u), h = (v, x, b, S, _) => !u || c.isCloning || e.onValidate(Br.concat(l.getPath(v), x), b, S, _) === !0, d = (v, x, b, S) => { !zm(l, e, x) && !(o && l.isDetached(v, i)) && f(l.getPath(v), x, b, S) }, f = (v, x, b, S, _) => { c.isCloning ? c.update(v, x, S) : t(Br.concat(v, x), b, S, _) }, p = v => v && (v[n] || v), m = (v, x, b, S) => j_(v) || b === "constructor" || s && !Xi.isHandledMethod(x, b) || zm(l, e, b) || l.isGetInvariant(x, b) || o && l.isDetached(x, i) ? v : (S === void 0 && (S = l.getPath(x)), l.getProxy(v, Br.concat(S, b), g, n)), g = { get (v, x, b) { if (bl(x)) { if (x === n || x === nf) return v; if (x === eb && !l.isUnsubscribed && l.getPath(v).length === 0) return l.unsubscribe(), v } let S = rf(v) ? Reflect.get(v, x) : Reflect.get(v, x, b); return m(S, v, x) }, set (v, x, b, S) { b = p(b); let _ = v[n] || v, E = _[x]; if (r(E, b) && x in v) return !0; let w = h(v, x, b, E); return w && l.setProperty(_, x, b, S, E) ? (d(v, x, v[x], E), !0) : !w }, defineProperty (v, x, b) { if (!l.isSameDescriptor(b, v, x)) { let S = v[x]; h(v, x, b.value, S) && l.defineProperty(v, x, b, S) && d(v, x, b.value, S) } return !0 }, deleteProperty (v, x) { if (!Reflect.has(v, x)) return !0; let b = Reflect.get(v, x), S = h(v, x, void 0, b); return S && l.deleteProperty(v, x, b) ? (d(v, x, void 0, b), !0) : !S }, apply (v, x, b) { let S = x[n] || x; if (l.isUnsubscribed) return Reflect.apply(v, S, b); if ((a === !1 || a !== !0 && !a.includes(v.name)) && Xi.isHandledType(S)) { let _ = Br.initial(l.getPath(v)), E = Xi.isHandledMethod(S, v.name); c.start(S, _, b); let w = Reflect.apply(v, c.preferredThisArg(v, x, S), E ? b.map(I => p(I)) : b), M = c.isChanged(S, r), T = c.stop(); if (Xi.isHandledType(w) && E && (x instanceof Map && v.name === "get" && (_ = Br.concat(_, b[0])), w = l.getProxy(w, _, g)), M) { let I = { name: v.name, args: b, result: w }, C = c.isCloning ? Br.initial(_) : _, P = c.isCloning ? Br.last(_) : ""; h(Br.get(i, C), P, S, T, I) ? f(C, P, S, T, I) : c.undo(S) } return (x instanceof Map || x instanceof Set) && tb(w) ? nb(w, v, x, _, m) : w } return Reflect.apply(v, x, b) } }, y = l.getProxy(i, e.pathAsArray ? [] : "", g); return t = t.bind(y), u && (e.onValidate = e.onValidate.bind(y)), y }; lb.target = i => i && i[nf] || i; lb.unsubscribe = i => i[eb] || i; var cb = lb; var Fk = typeof global == "object" && global && global.Object === Object && global, Vm = Fk; var kk = typeof self == "object" && self && self.Object === Object && self, Uk = Vm || kk || Function("return this")(), fn = Uk; var zk = fn.Symbol, rr = zk; var X_ = Object.prototype, Gk = X_.hasOwnProperty, Vk = X_.toString, cf = rr ? rr.toStringTag : void 0; function Hk (i) { var t = Gk.call(i, cf), e = i[cf]; try { i[cf] = void 0; var n = !0 } catch { } var r = Vk.call(i); return n && (t ? i[cf] = e : delete i[cf]), r } var Q_ = Hk; var jk = Object.prototype, Wk = jk.toString; function qk (i) { return Wk.call(i) } var K_ = qk; var Yk = "[object Null]", Xk = "[object Undefined]", Z_ = rr ? rr.toStringTag : void 0; function Qk (i) { return i == null ? i === void 0 ? Xk : Yk : Z_ && Z_ in Object(i) ? Q_(i) : K_(i) } var di = Qk; function Kk (i) { return i != null && typeof i == "object" } var vr = Kk; var Zk = "[object Symbol]"; function Jk (i) { return typeof i == "symbol" || vr(i) && di(i) == Zk } var da = Jk; function $k (i, t) { for (var e = -1, n = i == null ? 0 : i.length, r = Array(n); ++e < n;)r[e] = t(i[e], e, i); return r } var Hm = $k; var eU = Array.isArray, jn = eU; var tU = 1 / 0, J_ = rr ? rr.prototype : void 0, $_ = J_ ? J_.toString : void 0; function eE (i) { if (typeof i == "string") return i; if (jn(i)) return Hm(i, eE) + ""; if (da(i)) return $_ ? $_.call(i) : ""; var t = i + ""; return t == "0" && 1 / i == -tU ? "-0" : t } var tE = eE; var nU = /\s/; function rU (i) { for (var t = i.length; t-- && nU.test(i.charAt(t));); return t } var nE = rU; var iU = /^\s+/; function sU (i) { return i && i.slice(0, nE(i) + 1).replace(iU, "") } var rE = sU; function oU (i) { var t = typeof i; return i != null && (t == "object" || t == "function") } var Nn = oU; var iE = 0 / 0, aU = /^[-+]0x[0-9a-f]+$/i, lU = /^0b[01]+$/i, cU = /^0o[0-7]+$/i, uU = parseInt; function hU (i) { if (typeof i == "number") return i; if (da(i)) return iE; if (Nn(i)) { var t = typeof i.valueOf == "function" ? i.valueOf() : i; i = Nn(t) ? t + "" : t } if (typeof i != "string") return i === 0 ? i : +i; i = rE(i); var e = lU.test(i); return e || cU.test(i) ? uU(i.slice(2), e ? 2 : 8) : aU.test(i) ? iE : +i } var ub = hU; function dU (i) { return i } var sE = dU; var fU = "[object AsyncFunction]", pU = "[object Function]", mU = "[object GeneratorFunction]", gU = "[object Proxy]"; function yU (i) { if (!Nn(i)) return !1; var t = di(i); return t == pU || t == mU || t == fU || t == gU } var jm = yU; var vU = fn["__core-js_shared__"], Wm = vU; var oE = function () { var i = /[^.]+$/.exec(Wm && Wm.keys && Wm.keys.IE_PROTO || ""); return i ? "Symbol(src)_1." + i : "" }(); function xU (i) { return !!oE && oE in i } var aE = xU; var bU = Function.prototype, wU = bU.toString; function SU (i) { if (i != null) { try { return wU.call(i) } catch { } try { return i + "" } catch { } } return "" } var xo = SU; var AU = /[\\^$.*+?()[\]{}|]/g, _U = /^\[object .+?Constructor\]$/, EU = Function.prototype, MU = Object.prototype, TU = EU.toString, CU = MU.hasOwnProperty, PU = RegExp("^" + TU.call(CU).replace(AU, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"); function IU (i) { if (!Nn(i) || aE(i)) return !1; var t = jm(i) ? PU : _U; return t.test(xo(i)) } var lE = IU; function DU (i, t) { return i?.[t] } var cE = DU; function OU (i, t) { var e = cE(i, t); return lE(e) ? e : void 0 } var Wr = OU; var RU = Wr(fn, "WeakMap"), qm = RU; var uE = Object.create, LU = function () { function i () { } return function (t) { if (!Nn(t)) return {}; if (uE) return uE(t); i.prototype = t; var e = new i; return i.prototype = void 0, e } }(), hE = LU; function NU (i, t, e) { switch (e.length) { case 0: return i.call(t); case 1: return i.call(t, e[0]); case 2: return i.call(t, e[0], e[1]); case 3: return i.call(t, e[0], e[1], e[2]) }return i.apply(t, e) } var dE = NU; function BU (i, t) { var e = -1, n = i.length; for (t || (t = Array(n)); ++e < n;)t[e] = i[e]; return t } var fE = BU; var FU = 800, kU = 16, UU = Date.now; function zU (i) { var t = 0, e = 0; return function () { var n = UU(), r = kU - (n - e); if (e = n, r > 0) { if (++t >= FU) return arguments[0] } else t = 0; return i.apply(void 0, arguments) } } var pE = zU; function GU (i) { return function () { return i } } var mE = GU; var VU = function () { try { var i = Wr(Object, "defineProperty"); return i({}, "", {}), i } catch { } }(), ru = VU; var HU = ru ? function (i, t) { return ru(i, "toString", { configurable: !0, enumerable: !1, value: mE(t), writable: !0 }) } : sE, gE = HU; var jU = pE(gE), yE = jU; function WU (i, t) { for (var e = -1, n = i == null ? 0 : i.length; ++e < n && t(i[e], e, i) !== !1;); return i } var vE = WU; var qU = 9007199254740991, YU = /^(?:0|[1-9]\d*)$/; function XU (i, t) { var e = typeof i; return t = t ?? qU, !!t && (e == "number" || e != "symbol" && YU.test(i)) && i > -1 && i % 1 == 0 && i < t } var iu = XU; function QU (i, t, e) { t == "__proto__" && ru ? ru(i, t, { configurable: !0, enumerable: !0, value: e, writable: !0 }) : i[t] = e } var Ym = QU; function KU (i, t) { return i === t || i !== i && t !== t } var su = KU; var ZU = Object.prototype, JU = ZU.hasOwnProperty; function $U (i, t, e) { var n = i[t]; (!(JU.call(i, t) && su(n, e)) || e === void 0 && !(t in i)) && Ym(i, t, e) } var ou = $U; function ez (i, t, e, n) { var r = !e; e || (e = {}); for (var s = -1, o = t.length; ++s < o;) { var a = t[s], l = n ? n(e[a], i[a], a, e, i) : void 0; l === void 0 && (l = i[a]), r ? Ym(e, a, l) : ou(e, a, l) } return e } var bs = ez; var xE = Math.max; function tz (i, t, e) { return t = xE(t === void 0 ? i.length - 1 : t, 0), function () { for (var n = arguments, r = -1, s = xE(n.length - t, 0), o = Array(s); ++r < s;)o[r] = n[t + r]; r = -1; for (var a = Array(t + 1); ++r < t;)a[r] = n[r]; return a[t] = e(o), dE(i, this, a) } } var bE = tz; var nz = 9007199254740991; function rz (i) { return typeof i == "number" && i > -1 && i % 1 == 0 && i <= nz } var au = rz; function iz (i) { return i != null && au(i.length) && !jm(i) } var Xm = iz; var sz = Object.prototype; function oz (i) { var t = i && i.constructor, e = typeof t == "function" && t.prototype || sz; return i === e } var lu = oz; function az (i, t) { for (var e = -1, n = Array(i); ++e < i;)n[e] = t(e); return n } var wE = az; var lz = "[object Arguments]"; function cz (i) { return vr(i) && di(i) == lz } var hb = cz; var SE = Object.prototype, uz = SE.hasOwnProperty, hz = SE.propertyIsEnumerable, dz = hb(function () { return arguments }()) ? hb : function (i) { return vr(i) && uz.call(i, "callee") && !hz.call(i, "callee") }, cu = dz; function fz () { return !1 } var AE = fz; var ME = typeof exports == "object" && exports && !exports.nodeType && exports, _E = ME && typeof module == "object" && module && !module.nodeType && module, pz = _E && _E.exports === ME, EE = pz ? fn.Buffer : void 0, mz = EE ? EE.isBuffer : void 0, gz = mz || AE, wl = gz; var yz = "[object Arguments]", vz = "[object Array]", xz = "[object Boolean]", bz = "[object Date]", wz = "[object Error]", Sz = "[object Function]", Az = "[object Map]", _z = "[object Number]", Ez = "[object Object]", Mz = "[object RegExp]", Tz = "[object Set]", Cz = "[object String]", Pz = "[object WeakMap]", Iz = "[object ArrayBuffer]", Dz = "[object DataView]", Oz = "[object Float32Array]", Rz = "[object Float64Array]", Lz = "[object Int8Array]", Nz = "[object Int16Array]", Bz = "[object Int32Array]", Fz = "[object Uint8Array]", kz = "[object Uint8ClampedArray]", Uz = "[object Uint16Array]", zz = "[object Uint32Array]", Jt = {}; Jt[Oz] = Jt[Rz] = Jt[Lz] = Jt[Nz] = Jt[Bz] = Jt[Fz] = Jt[kz] = Jt[Uz] = Jt[zz] = !0; Jt[yz] = Jt[vz] = Jt[Iz] = Jt[xz] = Jt[Dz] = Jt[bz] = Jt[wz] = Jt[Sz] = Jt[Az] = Jt[_z] = Jt[Ez] = Jt[Mz] = Jt[Tz] = Jt[Cz] = Jt[Pz] = !1; function Gz (i) { return vr(i) && au(i.length) && !!Jt[di(i)] } var TE = Gz; function Vz (i) { return function (t) { return i(t) } } var uu = Vz; var CE = typeof exports == "object" && exports && !exports.nodeType && exports, uf = CE && typeof module == "object" && module && !module.nodeType && module, Hz = uf && uf.exports === CE, db = Hz && Vm.process, jz = function () { try { var i = uf && uf.require && uf.require("util").types; return i || db && db.binding && db.binding("util") } catch { } }(), bo = jz; var PE = bo && bo.isTypedArray, Wz = PE ? uu(PE) : TE, Qm = Wz; var qz = Object.prototype, Yz = qz.hasOwnProperty; function Xz (i, t) { var e = jn(i), n = !e && cu(i), r = !e && !n && wl(i), s = !e && !n && !r && Qm(i), o = e || n || r || s, a = o ? wE(i.length, String) : [], l = a.length; for (var u in i) (t || Yz.call(i, u)) && !(o && (u == "length" || r && (u == "offset" || u == "parent") || s && (u == "buffer" || u == "byteLength" || u == "byteOffset") || iu(u, l))) && a.push(u); return a } var Km = Xz; function Qz (i, t) { return function (e) { return i(t(e)) } } var Zm = Qz; var Kz = Zm(Object.keys, Object), IE = Kz; var Zz = Object.prototype, Jz = Zz.hasOwnProperty; function $z (i) { if (!lu(i)) return IE(i); var t = []; for (var e in Object(i)) Jz.call(i, e) && e != "constructor" && t.push(e); return t } var DE = $z; function eG (i) { return Xm(i) ? Km(i) : DE(i) } var hu = eG; function tG (i) { var t = []; if (i != null) for (var e in Object(i)) t.push(e); return t } var OE = tG; var nG = Object.prototype, rG = nG.hasOwnProperty; function iG (i) { if (!Nn(i)) return OE(i); var t = lu(i), e = []; for (var n in i) n == "constructor" && (t || !rG.call(i, n)) || e.push(n); return e } var RE = iG; function sG (i) { return Xm(i) ? Km(i, !0) : RE(i) } var du = sG; var oG = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, aG = /^\w*$/; function lG (i, t) { if (jn(i)) return !1; var e = typeof i; return e == "number" || e == "symbol" || e == "boolean" || i == null || da(i) ? !0 : aG.test(i) || !oG.test(i) || t != null && i in Object(t) } var LE = lG; var cG = Wr(Object, "create"), wo = cG; function uG () { this.__data__ = wo ? wo(null) : {}, this.size = 0 } var NE = uG; function hG (i) { var t = this.has(i) && delete this.__data__[i]; return this.size -= t ? 1 : 0, t } var BE = hG; var dG = "__lodash_hash_undefined__", fG = Object.prototype, pG = fG.hasOwnProperty; function mG (i) { var t = this.__data__; if (wo) { var e = t[i]; return e === dG ? void 0 : e } return pG.call(t, i) ? t[i] : void 0 } var FE = mG; var gG = Object.prototype, yG = gG.hasOwnProperty; function vG (i) { var t = this.__data__; return wo ? t[i] !== void 0 : yG.call(t, i) } var kE = vG; var xG = "__lodash_hash_undefined__"; function bG (i, t) { var e = this.__data__; return this.size += this.has(i) ? 0 : 1, e[i] = wo && t === void 0 ? xG : t, this } var UE = bG; function fu (i) { var t = -1, e = i == null ? 0 : i.length; for (this.clear(); ++t < e;) { var n = i[t]; this.set(n[0], n[1]) } } fu.prototype.clear = NE; fu.prototype.delete = BE; fu.prototype.get = FE; fu.prototype.has = kE; fu.prototype.set = UE; var fb = fu; function wG () { this.__data__ = [], this.size = 0 } var zE = wG; function SG (i, t) { for (var e = i.length; e--;)if (su(i[e][0], t)) return e; return -1 } var fa = SG; var AG = Array.prototype, _G = AG.splice; function EG (i) { var t = this.__data__, e = fa(t, i); if (e < 0) return !1; var n = t.length - 1; return e == n ? t.pop() : _G.call(t, e, 1), --this.size, !0 } var GE = EG; function MG (i) { var t = this.__data__, e = fa(t, i); return e < 0 ? void 0 : t[e][1] } var VE = MG; function TG (i) { return fa(this.__data__, i) > -1 } var HE = TG; function CG (i, t) { var e = this.__data__, n = fa(e, i); return n < 0 ? (++this.size, e.push([i, t])) : e[n][1] = t, this } var jE = CG; function pu (i) { var t = -1, e = i == null ? 0 : i.length; for (this.clear(); ++t < e;) { var n = i[t]; this.set(n[0], n[1]) } } pu.prototype.clear = zE; pu.prototype.delete = GE; pu.prototype.get = VE; pu.prototype.has = HE; pu.prototype.set = jE; var pa = pu; var PG = Wr(fn, "Map"), ma = PG; function IG () { this.size = 0, this.__data__ = { hash: new fb, map: new (ma || pa), string: new fb } } var WE = IG; function DG (i) { var t = typeof i; return t == "string" || t == "number" || t == "symbol" || t == "boolean" ? i !== "__proto__" : i === null } var qE = DG; function OG (i, t) { var e = i.__data__; return qE(t) ? e[typeof t == "string" ? "string" : "hash"] : e.map } var ga = OG; function RG (i) { var t = ga(this, i).delete(i); return this.size -= t ? 1 : 0, t } var YE = RG; function LG (i) { return ga(this, i).get(i) } var XE = LG; function NG (i) { return ga(this, i).has(i) } var QE = NG; function BG (i, t) { var e = ga(this, i), n = e.size; return e.set(i, t), this.size += e.size == n ? 0 : 1, this } var KE = BG; function mu (i) { var t = -1, e = i == null ? 0 : i.length; for (this.clear(); ++t < e;) { var n = i[t]; this.set(n[0], n[1]) } } mu.prototype.clear = WE; mu.prototype.delete = YE; mu.prototype.get = XE; mu.prototype.has = QE; mu.prototype.set = KE; var Sl = mu; var FG = "Expected a function"; function pb (i, t) { if (typeof i != "function" || t != null && typeof t != "function") throw new TypeError(FG); var e = function () { var n = arguments, r = t ? t.apply(this, n) : n[0], s = e.cache; if (s.has(r)) return s.get(r); var o = i.apply(this, n); return e.cache = s.set(r, o) || s, o }; return e.cache = new (pb.Cache || Sl), e } pb.Cache = Sl; var ZE = pb; var kG = 500; function UG (i) { var t = ZE(i, function (n) { return e.size === kG && e.clear(), n }), e = t.cache; return t } var JE = UG; var zG = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, GG = /\\(\\)?/g, VG = JE(function (i) { var t = []; return i.charCodeAt(0) === 46 && t.push(""), i.replace(zG, function (e, n, r, s) { t.push(r ? s.replace(GG, "$1") : n || e) }), t }), $E = VG; function HG (i) { return i == null ? "" : tE(i) } var eM = HG; function jG (i, t) { return jn(i) ? i : LE(i, t) ? [i] : $E(eM(i)) } var Ei = jG; var WG = 1 / 0; function qG (i) { if (typeof i == "string" || da(i)) return i; var t = i + ""; return t == "0" && 1 / i == -WG ? "-0" : t } var ya = qG; function YG (i, t) { t = Ei(t, i); for (var e = 0, n = t.length; i != null && e < n;)i = i[ya(t[e++])]; return e && e == n ? i : void 0 } var Jm = YG; function XG (i, t) { for (var e = -1, n = t.length, r = i.length; ++e < n;)i[r + e] = t[e]; return i } var gu = XG; var tM = rr ? rr.isConcatSpreadable : void 0; function QG (i) { return jn(i) || cu(i) || !!(tM && i && i[tM]) } var nM = QG; function rM (i, t, e, n, r) { var s = -1, o = i.length; for (e || (e = nM), r || (r = []); ++s < o;) { var a = i[s]; t > 0 && e(a) ? t > 1 ? rM(a, t - 1, e, n, r) : gu(r, a) : n || (r[r.length] = a) } return r } var iM = rM; function KG (i) { var t = i == null ? 0 : i.length; return t ? iM(i, 1) : [] } var sM = KG; function ZG (i) { return yE(bE(i, void 0, sM), i + "") } var $m = ZG; var JG = Zm(Object.getPrototypeOf, Object), yu = JG; var $G = "[object Object]", eV = Function.prototype, tV = Object.prototype, oM = eV.toString, nV = tV.hasOwnProperty, rV = oM.call(Object); function iV (i) { if (!vr(i) || di(i) != $G) return !1; var t = yu(i); if (t === null) return !0; var e = nV.call(t, "constructor") && t.constructor; return typeof e == "function" && e instanceof e && oM.call(e) == rV } var aM = iV; function sV (i, t, e) { var n = -1, r = i.length; t < 0 && (t = -t > r ? 0 : r + t), e = e > r ? r : e, e < 0 && (e += r), r = t > e ? 0 : e - t >>> 0, t >>>= 0; for (var s = Array(r); ++n < r;)s[n] = i[n + t]; return s } var lM = sV; function oV () { this.__data__ = new pa, this.size = 0 } var cM = oV; function aV (i) { var t = this.__data__, e = t.delete(i); return this.size = t.size, e } var uM = aV; function lV (i) { return this.__data__.get(i) } var hM = lV; function cV (i) { return this.__data__.has(i) } var dM = cV; var uV = 200; function hV (i, t) { var e = this.__data__; if (e instanceof pa) { var n = e.__data__; if (!ma || n.length < uV - 1) return n.push([i, t]), this.size = ++e.size, this; e = this.__data__ = new Sl(n) } return e.set(i, t), this.size = e.size, this } var fM = hV; function vu (i) { var t = this.__data__ = new pa(i); this.size = t.size } vu.prototype.clear = cM; vu.prototype.delete = uM; vu.prototype.get = hM; vu.prototype.has = dM; vu.prototype.set = fM; var xu = vu; function dV (i, t) { return i && bs(t, hu(t), i) } var pM = dV; function fV (i, t) { return i && bs(t, du(t), i) } var mM = fV; var xM = typeof exports == "object" && exports && !exports.nodeType && exports, gM = xM && typeof module == "object" && module && !module.nodeType && module, pV = gM && gM.exports === xM, yM = pV ? fn.Buffer : void 0, vM = yM ? yM.allocUnsafe : void 0; function mV (i, t) { if (t) return i.slice(); var e = i.length, n = vM ? vM(e) : new i.constructor(e); return i.copy(n), n } var bM = mV; function gV (i, t) { for (var e = -1, n = i == null ? 0 : i.length, r = 0, s = []; ++e < n;) { var o = i[e]; t(o, e, i) && (s[r++] = o) } return s } var wM = gV; function yV () { return [] } var eg = yV; var vV = Object.prototype, xV = vV.propertyIsEnumerable, SM = Object.getOwnPropertySymbols, bV = SM ? function (i) { return i == null ? [] : (i = Object(i), wM(SM(i), function (t) { return xV.call(i, t) })) } : eg, bu = bV; function wV (i, t) { return bs(i, bu(i), t) } var AM = wV; var SV = Object.getOwnPropertySymbols, AV = SV ? function (i) { for (var t = []; i;)gu(t, bu(i)), i = yu(i); return t } : eg, tg = AV; function _V (i, t) { return bs(i, tg(i), t) } var _M = _V; function EV (i, t, e) { var n = t(i); return jn(i) ? n : gu(n, e(i)) } var ng = EV; function MV (i) { return ng(i, hu, bu) } var hf = MV; function TV (i) { return ng(i, du, tg) } var rg = TV; var CV = Wr(fn, "DataView"), ig = CV; var PV = Wr(fn, "Promise"), sg = PV; var IV = Wr(fn, "Set"), og = IV; var EM = "[object Map]", DV = "[object Object]", MM = "[object Promise]", TM = "[object Set]", CM = "[object WeakMap]", PM = "[object DataView]", OV = xo(ig), RV = xo(ma), LV = xo(sg), NV = xo(og), BV = xo(qm), Al = di; (ig && Al(new ig(new ArrayBuffer(1))) != PM || ma && Al(new ma) != EM || sg && Al(sg.resolve()) != MM || og && Al(new og) != TM || qm && Al(new qm) != CM) && (Al = function (i) { var t = di(i), e = t == DV ? i.constructor : void 0, n = e ? xo(e) : ""; if (n) switch (n) { case OV: return PM; case RV: return EM; case LV: return MM; case NV: return TM; case BV: return CM }return t }); var So = Al; var FV = Object.prototype, kV = FV.hasOwnProperty; function UV (i) { var t = i.length, e = new i.constructor(t); return t && typeof i[0] == "string" && kV.call(i, "index") && (e.index = i.index, e.input = i.input), e } var IM = UV; var zV = fn.Uint8Array, wu = zV; function GV (i) { var t = new i.constructor(i.byteLength); return new wu(t).set(new wu(i)), t } var Su = GV; function VV (i, t) { var e = t ? Su(i.buffer) : i.buffer; return new i.constructor(e, i.byteOffset, i.byteLength) } var DM = VV; var HV = /\w*$/; function jV (i) { var t = new i.constructor(i.source, HV.exec(i)); return t.lastIndex = i.lastIndex, t } var OM = jV; var RM = rr ? rr.prototype : void 0, LM = RM ? RM.valueOf : void 0; function WV (i) { return LM ? Object(LM.call(i)) : {} } var NM = WV; function qV (i, t) { var e = t ? Su(i.buffer) : i.buffer; return new i.constructor(e, i.byteOffset, i.length) } var BM = qV; var YV = "[object Boolean]", XV = "[object Date]", QV = "[object Map]", KV = "[object Number]", ZV = "[object RegExp]", JV = "[object Set]", $V = "[object String]", e4 = "[object Symbol]", t4 = "[object ArrayBuffer]", n4 = "[object DataView]", r4 = "[object Float32Array]", i4 = "[object Float64Array]", s4 = "[object Int8Array]", o4 = "[object Int16Array]", a4 = "[object Int32Array]", l4 = "[object Uint8Array]", c4 = "[object Uint8ClampedArray]", u4 = "[object Uint16Array]", h4 = "[object Uint32Array]"; function d4 (i, t, e) { var n = i.constructor; switch (t) { case t4: return Su(i); case YV: case XV: return new n(+i); case n4: return DM(i, e); case r4: case i4: case s4: case o4: case a4: case l4: case c4: case u4: case h4: return BM(i, e); case QV: return new n; case KV: case $V: return new n(i); case ZV: return OM(i); case JV: return new n; case e4: return NM(i) } } var FM = d4; function f4 (i) { return typeof i.constructor == "function" && !lu(i) ? hE(yu(i)) : {} } var kM = f4; var p4 = "[object Map]"; function m4 (i) { return vr(i) && So(i) == p4 } var UM = m4; var zM = bo && bo.isMap, g4 = zM ? uu(zM) : UM, GM = g4; var y4 = "[object Set]"; function v4 (i) { return vr(i) && So(i) == y4 } var VM = v4; var HM = bo && bo.isSet, x4 = HM ? uu(HM) : VM, jM = x4; var b4 = 1, w4 = 2, S4 = 4, WM = "[object Arguments]", A4 = "[object Array]", _4 = "[object Boolean]", E4 = "[object Date]", M4 = "[object Error]", qM = "[object Function]", T4 = "[object GeneratorFunction]", C4 = "[object Map]", P4 = "[object Number]", YM = "[object Object]", I4 = "[object RegExp]", D4 = "[object Set]", O4 = "[object String]", R4 = "[object Symbol]", L4 = "[object WeakMap]", N4 = "[object ArrayBuffer]", B4 = "[object DataView]", F4 = "[object Float32Array]", k4 = "[object Float64Array]", U4 = "[object Int8Array]", z4 = "[object Int16Array]", G4 = "[object Int32Array]", V4 = "[object Uint8Array]", H4 = "[object Uint8ClampedArray]", j4 = "[object Uint16Array]", W4 = "[object Uint32Array]", Kt = {}; Kt[WM] = Kt[A4] = Kt[N4] = Kt[B4] = Kt[_4] = Kt[E4] = Kt[F4] = Kt[k4] = Kt[U4] = Kt[z4] = Kt[G4] = Kt[C4] = Kt[P4] = Kt[YM] = Kt[I4] = Kt[D4] = Kt[O4] = Kt[R4] = Kt[V4] = Kt[H4] = Kt[j4] = Kt[W4] = !0; Kt[M4] = Kt[qM] = Kt[L4] = !1; function ag (i, t, e, n, r, s) { var o, a = t & b4, l = t & w4, u = t & S4; if (e && (o = r ? e(i, n, r, s) : e(i)), o !== void 0) return o; if (!Nn(i)) return i; var c = jn(i); if (c) { if (o = IM(i), !a) return fE(i, o) } else { var h = So(i), d = h == qM || h == T4; if (wl(i)) return bM(i, a); if (h == YM || h == WM || d && !r) { if (o = l || d ? {} : kM(i), !a) return l ? _M(i, mM(o, i)) : AM(i, pM(o, i)) } else { if (!Kt[h]) return r ? i : {}; o = FM(i, h, a) } } s || (s = new xu); var f = s.get(i); if (f) return f; s.set(i, o), jM(i) ? i.forEach(function (g) { o.add(ag(g, t, e, g, i, s)) }) : GM(i) && i.forEach(function (g, y) { o.set(y, ag(g, t, e, y, i, s)) }); var p = u ? l ? rg : hf : l ? du : hu, m = c ? void 0 : p(i); return vE(m || i, function (g, y) { m && (y = g, g = i[y]), ou(o, y, ag(g, t, e, y, i, s)) }), o } var lg = ag; var q4 = 1, Y4 = 4; function X4 (i) { return lg(i, q4 | Y4) } var Ao = X4; var Q4 = "__lodash_hash_undefined__"; function K4 (i) { return this.__data__.set(i, Q4), this } var XM = K4; function Z4 (i) { return this.__data__.has(i) } var QM = Z4; function cg (i) { var t = -1, e = i == null ? 0 : i.length; for (this.__data__ = new Sl; ++t < e;)this.add(i[t]) } cg.prototype.add = cg.prototype.push = XM; cg.prototype.has = QM; var KM = cg; function J4 (i, t) { for (var e = -1, n = i == null ? 0 : i.length; ++e < n;)if (t(i[e], e, i)) return !0; return !1 } var ZM = J4; function $4 (i, t) { return i.has(t) } var JM = $4; var eH = 1, tH = 2; function nH (i, t, e, n, r, s) { var o = e & eH, a = i.length, l = t.length; if (a != l && !(o && l > a)) return !1; var u = s.get(i), c = s.get(t); if (u && c) return u == t && c == i; var h = -1, d = !0, f = e & tH ? new KM : void 0; for (s.set(i, t), s.set(t, i); ++h < a;) { var p = i[h], m = t[h]; if (n) var g = o ? n(m, p, h, t, i, s) : n(p, m, h, i, t, s); if (g !== void 0) { if (g) continue; d = !1; break } if (f) { if (!ZM(t, function (y, v) { if (!JM(f, v) && (p === y || r(p, y, e, n, s))) return f.push(v) })) { d = !1; break } } else if (!(p === m || r(p, m, e, n, s))) { d = !1; break } } return s.delete(i), s.delete(t), d } var ug = nH; function rH (i) { var t = -1, e = Array(i.size); return i.forEach(function (n, r) { e[++t] = [r, n] }), e } var $M = rH; function iH (i) { var t = -1, e = Array(i.size); return i.forEach(function (n) { e[++t] = n }), e } var eT = iH; var sH = 1, oH = 2, aH = "[object Boolean]", lH = "[object Date]", cH = "[object Error]", uH = "[object Map]", hH = "[object Number]", dH = "[object RegExp]", fH = "[object Set]", pH = "[object String]", mH = "[object Symbol]", gH = "[object ArrayBuffer]", yH = "[object DataView]", tT = rr ? rr.prototype : void 0, mb = tT ? tT.valueOf : void 0; function vH (i, t, e, n, r, s, o) { switch (e) { case yH: if (i.byteLength != t.byteLength || i.byteOffset != t.byteOffset) return !1; i = i.buffer, t = t.buffer; case gH: return !(i.byteLength != t.byteLength || !s(new wu(i), new wu(t))); case aH: case lH: case hH: return su(+i, +t); case cH: return i.name == t.name && i.message == t.message; case dH: case pH: return i == t + ""; case uH: var a = $M; case fH: var l = n & sH; if (a || (a = eT), i.size != t.size && !l) return !1; var u = o.get(i); if (u) return u == t; n |= oH, o.set(i, t); var c = ug(a(i), a(t), n, r, s, o); return o.delete(i), c; case mH: if (mb) return mb.call(i) == mb.call(t) }return !1 } var nT = vH; var xH = 1, bH = Object.prototype, wH = bH.hasOwnProperty; function SH (i, t, e, n, r, s) { var o = e & xH, a = hf(i), l = a.length, u = hf(t), c = u.length; if (l != c && !o) return !1; for (var h = l; h--;) { var d = a[h]; if (!(o ? d in t : wH.call(t, d))) return !1 } var f = s.get(i), p = s.get(t); if (f && p) return f == t && p == i; var m = !0; s.set(i, t), s.set(t, i); for (var g = o; ++h < l;) { d = a[h]; var y = i[d], v = t[d]; if (n) var x = o ? n(v, y, d, t, i, s) : n(y, v, d, i, t, s); if (!(x === void 0 ? y === v || r(y, v, e, n, s) : x)) { m = !1; break } g || (g = d == "constructor") } if (m && !g) { var b = i.constructor, S = t.constructor; b != S && "constructor" in i && "constructor" in t && !(typeof b == "function" && b instanceof b && typeof S == "function" && S instanceof S) && (m = !1) } return s.delete(i), s.delete(t), m } var rT = SH; var AH = 1, iT = "[object Arguments]", sT = "[object Array]", hg = "[object Object]", _H = Object.prototype, oT = _H.hasOwnProperty; function EH (i, t, e, n, r, s) { var o = jn(i), a = jn(t), l = o ? sT : So(i), u = a ? sT : So(t); l = l == iT ? hg : l, u = u == iT ? hg : u; var c = l == hg, h = u == hg, d = l == u; if (d && wl(i)) { if (!wl(t)) return !1; o = !0, c = !1 } if (d && !c) return s || (s = new xu), o || Qm(i) ? ug(i, t, e, n, r, s) : nT(i, t, l, e, n, r, s); if (!(e & AH)) { var f = c && oT.call(i, "__wrapped__"), p = h && oT.call(t, "__wrapped__"); if (f || p) { var m = f ? i.value() : i, g = p ? t.value() : t; return s || (s = new xu), r(m, g, e, n, s) } } return d ? (s || (s = new xu), rT(i, t, e, n, r, s)) : !1 } var aT = EH; function lT (i, t, e, n, r) { return i === t ? !0 : i == null || t == null || !vr(i) && !vr(t) ? i !== i && t !== t : aT(i, t, e, n, lT, r) } var cT = lT; function MH (i, t) { return i != null && t in Object(i) } var uT = MH; function TH (i, t, e) { t = Ei(t, i); for (var n = -1, r = t.length, s = !1; ++n < r;) { var o = ya(t[n]); if (!(s = i != null && e(i, o))) break; i = i[o] } return s || ++n != r ? s : (r = i == null ? 0 : i.length, !!r && au(r) && iu(o, r) && (jn(i) || cu(i))) } var hT = TH; function CH (i, t) { return i != null && hT(i, t, uT) } var dT = CH; var PH = function () { return fn.Date.now() }, dg = PH; var IH = "Expected a function", DH = Math.max, OH = Math.min; function RH (i, t, e) { var n, r, s, o, a, l, u = 0, c = !1, h = !1, d = !0; if (typeof i != "function") throw new TypeError(IH); t = ub(t) || 0, Nn(e) && (c = !!e.leading, h = "maxWait" in e, s = h ? DH(ub(e.maxWait) || 0, t) : s, d = "trailing" in e ? !!e.trailing : d); function f (_) { var E = n, w = r; return n = r = void 0, u = _, o = i.apply(w, E), o } function p (_) { return u = _, a = setTimeout(y, t), c ? f(_) : o } function m (_) { var E = _ - l, w = _ - u, M = t - E; return h ? OH(M, s - w) : M } function g (_) { var E = _ - l, w = _ - u; return l === void 0 || E >= t || E < 0 || h && w >= s } function y () { var _ = dg(); if (g(_)) return v(_); a = setTimeout(y, m(_)) } function v (_) { return a = void 0, d && n ? f(_) : (n = r = void 0, o) } function x () { a !== void 0 && clearTimeout(a), u = 0, n = l = r = a = void 0 } function b () { return a === void 0 ? o : v(dg()) } function S () { var _ = dg(), E = g(_); if (n = arguments, r = this, l = _, E) { if (a === void 0) return p(l); if (h) return clearTimeout(a), a = setTimeout(y, t), f(l) } return a === void 0 && (a = setTimeout(y, t)), o } return S.cancel = x, S.flush = b, S } var _l = RH; function LH (i) { var t = i == null ? 0 : i.length; return t ? i[t - 1] : void 0 } var fT = LH; function NH (i, t) { return t.length < 2 ? i : Jm(i, lM(t, 0, -1)) } var pT = NH; function BH (i, t) { return cT(i, t) } var El = BH; function FH (i, t) { return t = Ei(t, i), i = pT(i, t), i == null || delete i[ya(fT(t))] } var mT = FH; function kH (i) { return aM(i) ? void 0 : i } var gT = kH; var UH = 1, zH = 2, GH = 4, VH = $m(function (i, t) { var e = {}; if (i == null) return e; var n = !1; t = Hm(t, function (s) { return s = Ei(s, i), n || (n = s.length > 1), s }), bs(i, rg(i), e), n && (e = lg(e, UH | zH | GH, gT)); for (var r = t.length; r--;)mT(e, t[r]); return e }), Au = VH; function HH (i, t, e, n) { if (!Nn(i)) return i; t = Ei(t, i); for (var r = -1, s = t.length, o = s - 1, a = i; a != null && ++r < s;) { var l = ya(t[r]), u = e; if (l === "__proto__" || l === "constructor" || l === "prototype") return i; if (r != o) { var c = a[l]; u = n ? n(c, l, a) : void 0, u === void 0 && (u = Nn(c) ? c : iu(t[r + 1]) ? [] : {}) } ou(a, l, u), a = a[l] } return i } var yT = HH; function jH (i, t, e) { for (var n = -1, r = t.length, s = {}; ++n < r;) { var o = t[n], a = Jm(i, o); e(a, o) && yT(s, Ei(o, i), a) } return s } var vT = jH; function WH (i, t) { return vT(i, t, function (e, n) { return dT(i, n) }) } var xT = WH; var qH = $m(function (i, t) { return i == null ? {} : xT(i, t) }), fi = qH; var YH = "Expected a function"; function XH (i, t, e) { var n = !0, r = !0; if (typeof i != "function") throw new TypeError(YH); return Nn(e) && (n = "leading" in e ? !!e.leading : n, r = "trailing" in e ? !!e.trailing : r), _l(i, t, { leading: n, maxWait: t, trailing: r }) } var gb = XH; function bT (i) { for (let t of Object.keys(i)) i[t] === void 0 && delete i[t]; return i } function Qi (i, t) { return Object.setPrototypeOf(i, t), i } var QH = () => typeof window > "u" ? !1 : window.navigator.userAgent.toLowerCase().includes(" electron/"), KH = () => typeof window > "u" ? !1 : window.navigator.platform.toUpperCase().includes("MAC"), ZH = () => typeof window > "u" ? !1 : /iPad|iPhone|iPod/.test(window.navigator.userAgent) || Ml && "ontouchend" in document, JH = () => typeof window > "u" ? !1 : window.navigator.userAgent.toLowerCase().indexOf("firefox") > -1, $H = () => typeof window > "u" ? !1 : "ontouchstart" in window || navigator.maxTouchPoints > 0, e5 = () => { if (typeof window > "u") return !1; let i = navigator.userAgent, t = navigator.vendor; return /Safari/i.test(i) && /Apple Computer/.test(t) }, t5 = () => { if (typeof window > "u") return null; let t = navigator.userAgent.match(/Version\/(\d+\.\d)/); return t && t[1] }, n5 = () => { if (typeof window > "u") return; let t = new URLSearchParams(window.location.search).get("desktop-app-version"); return t ? (window.localStorage.setItem("desktop-app-version", t), t) : window.localStorage.getItem("desktop-app-version") ?? "0.0.6" }, r5 = QH(), hne = r5 ? n5() : void 0, Ml = KH(), fg = ZH(), wT = JH(), Wn = $H(), yb = e5(), vb = Number(t5()); function pg (i) { return Array.isArray(i) ? i : [i] } function ST (i, t) { let e = 0; for (; e < i.length && e < t.length;) { if (i[e] < t[e]) return -1; if (i[e] > t[e]) return 1; e += 1 } return e !== t.length ? -1 : e !== i.length ? 1 : 0 } function df (i) { return Ml ? i.metaKey : i.ctrlKey } var je = [], gg = {}, ff = {}, mg = {}; function AT (i) { je.includes(i) || je.push(i) } function _u (i) { delete gg[i.pointerId]; for (let t = 0; t < je.length; t++)if (je[t].pointerId === i.pointerId) { je.splice(t, 1); break } } function _T () { je.splice(0, je.length) } function yg (i) { if (i.pointerType !== "touch") return; let t = gg[i.pointerId]; t === void 0 && (t = { x: 0, y: 0 }, gg[i.pointerId] = t), t.x = i.pageX, t.y = i.pageY } function vg (i) { let t = i.pointerId === je[0].pointerId ? je[1] : je[0]; return gg[t.pointerId] } function ET (i) { ff[i.key] = !0, mg[i.key] = mg[i.key] === void 0 ? 1 : mg[i.key] + 1 } function MT (i) { if (Ml && ff.Meta) for (let t in ff) ff[t] = !1; else ff[i.key] = !1; mg = {} } function TT (i) { i.addEventListener("pointerdown", AT, !0), i.addEventListener("pointerdown", yg, !0), i.addEventListener("pointermove", yg, !0), i.addEventListener("pointerup", _u, !0), i.addEventListener("pointercancel", _u, !0), i.addEventListener("pointerleave", _u, !0), window.addEventListener("keydown", ET, !0), window.addEventListener("keyup", MT, !0) } function CT (i) { i.removeEventListener("pointerdown", AT, !0), i.removeEventListener("pointerdown", yg, !0), i.removeEventListener("pointermove", yg, !0), i.removeEventListener("pointerup", _u, !0), i.removeEventListener("pointercancel", _u, !0), i.removeEventListener("pointerleave", _u, !0), window.removeEventListener("keydown", ET, !0), window.removeEventListener("keyup", MT, !0) } var PT, IT = new Promise(i => { PT = i }); var xg; function DT () { if (xg) return xg; async function i () { let e = !1 ? "." : "https://unpkg.com/@splinetool/navmesh-wasm@0.9.437/build", r = import("./navmesh.js"), [s, o] = await Promise.all([r, fetch(`${e}/navmesh.wasm`).then(u => u.arrayBuffer())]), a = s.default, l = await a({ wasmBinary: o }); PT(l) } return xg = i(), xg } var OT, RT = new Promise(i => { OT = i }); var bg; function LT () { if (bg) return bg; async function i () { let e = await import("./physics.js"); await e.init(), OT(e) } return bg = i(), bg } var Ut = class { modifyById (t, e) { let n = this; if (n[t] === void 0) throw new Error("not expected"); { let s = { ...n, [t]: e }; return Object.setPrototypeOf(s, Ut.prototype), s } } add (t, e) { return this.runOp({ type: 1, id: t, data: e })?.data ?? this } runOp (t) { let e = this; if (t.type === 1) { let n = e[t.id], r; n === void 0 ? r = { type: 2, id: t.id } : r = { type: 1, id: t.id, data: n }; let { id: s, data: o } = t, a = { ...e, [s]: o }; return Object.setPrototypeOf(a, Ut.prototype), { data: a, actual: t, reverse: r } } else if (t.type === 2) { let { id: n } = t, r = e[n]; if (r === void 0) return null; { let s = { ...e }; return Object.setPrototypeOf(s, Ut.prototype), delete s[n], { data: s, actual: t, reverse: { type: 1, id: n, data: r } } } } return null } }; function pf (i) { if (i.deepFreeze !== void 0) { i.deepFreeze(i); return } let t = Object.getOwnPropertyNames(i); for (let e of t) { let n = i[e]; n && typeof n == "object" && pf(n) } return Object.freeze(i) } function NT (i, t) { let e = 0; for (; e < i.length && e < t.length;) { if (i[e] < t[e]) return -1; if (i[e] > t[e]) return 1; e += 1 } return e !== t.length ? -1 : e !== i.length ? 1 : 0 } var Eu = class extends Error { }; function wg (i) { let t = { ...i }; return Object.setPrototypeOf(t, Object.getPrototypeOf(i)), t } function ws (i, t, e) { if (i === void 0 ? t === void 0 ? (i = 0, t = 10) : i = t - 10 : t === void 0 && (t = i + 10), i > t) { let s = i; i = t, t = s } let n = [], r = 1 / (e + 1); for (let s = 0; s < e; s++) { let o = i + (t - i) * (s + .75 + Math.random() * .5) * r; n.push(o) } return n } function Mu (i) { return i instanceof Uint8Array || i instanceof Uint16Array || i instanceof Uint32Array || i instanceof Int8Array || i instanceof Int16Array || i instanceof Int32Array || i instanceof Float32Array || i instanceof Float64Array } function BT () { return typeof process < "u" } function FT (i, t) { for (let e of i) t(e.id, e.data) !== !0 && FT(e.children, t) } function kT (i, t) { if (t(i.id, i.data) !== !0) for (let e of i.children) kT(e, t) } var rn = class extends Array { constructor(...e) { super(...e); Object.setPrototypeOf(this, rn.prototype) } deepFreeze () { let e = 0; for (; e < this.length;)pf(this[e]), e++ } fillCaches0 (e, n) { this.objCaches.set(e.id, e), this.parentCaches.set(e.id, n); for (let r of e.children) this.fillCaches0(r, e.id) } fillCaches () { if (this.objCaches === void 0) { this.objCaches = new Map, this.parentCaches = new Map; for (let e of this) this.fillCaches0(e, null) } } randomId () { this.fillCaches(); let e = Array.from(this.objCaches.keys()); if (e.length !== 0) return e[Math.max(0, Math.floor(Math.random() * e.length) - 1)] } nonExistOrDescendantOf (e, n) { if (!this.has(e)) return !0; for (; e;) { let r = this.parent(e); if (r === n) return !0; e = r } return !1 } rootAcestor (e) { for (; e;) { let n = this.parent(e); if (n) e = n; else return e } return e } isDescendantOf (e, n) { for (; e;) { let r = this.parent(e); if (r === n) return !0; e = r } return !1 } data (e) { return this.get(e)?.data } has (e) { return this.childrenOf(e) !== void 0 } get (e) { return this.fillCaches(), this.objCaches.get(e) } childrenOf (e) { return e === null ? this : this.get(e)?.children } traverseFrom (e, n) { if (e === null) this.traverse(n); else { let r = this.get(e); r && kT(r, n) } } traverse (e) { FT(this, e) } totalSize () { return this.fillCaches(), this.objCaches.size } parent (e) { return this.fillCaches(), this.parentCaches.get(e) } childrenArray (e) { return e === null ? this : this.get(e).children } modifyById (e, n) { if (this.get(e) === void 0) throw new Error("not expected"); { let s = this.parent(e), o = this.childrenArray(s), a = o.findIndex(c => c.id === e); if (a < 0) throw new Error("not expected"); let l = o[a]; return o = [...o], o[a] = { ...l, data: n }, this.modifyArrayBy(s, o) } } modifyArrayBy (e, n) { let r = e, s = n; for (; r !== null;) { let a = s, l = r; if (r = this.parent(r), r === void 0) throw new Error; s = this.childrenArray(r); let u = s.findIndex(c => c.id === l); if (u < 0) throw new Error; s = [...s], s[u] = { ...s[u], children: a } } Object.setPrototypeOf(s, rn.prototype); let o = s; return o.fillCaches(), o } runOp (e) { switch (e.type) { case 7: return this.addOp(e); case 8: return this.deleteOp(e); case 9: return this.moveOp(e) }return null } checkDuplicatedIdRec ({ id: e, children: n }) { if (this.get(e) !== void 0) return !0; for (let r of n) if (this.checkDuplicatedIdRec(r)) return !0; return !1 } addOp (e) { let { parent: n, fi: r, id: s, data: o, children: a } = e; if (n !== null && this.get(n) === void 0) return null; if (this.checkDuplicatedIdRec(e)) return null; { let l = n, u = this.childrenArray(l), c = { fi: r, id: s, data: o, children: a }; return u = [...u, c], u.sort((d, f) => d.fi - f.fi), e.localIndex = u.indexOf(c), { data: this.modifyArrayBy(l, u), actual: e, reverse: { type: 8, id: s } } } } deleteOp (e) { let { id: n } = e; if (this.get(n) === null) return null; { let r = this.parent(n); if (r === void 0) return null; let s = this.childrenArray(r), o = s.findIndex(u => u.id === n); e.localIndex = o, s = [...s]; let a = s.splice(o, 1)[0]; return { data: this.modifyArrayBy(r, s), actual: e, reverse: { type: 7, ...a, parent: r } } } } moveOp (e) { let { parent: n, fi: r, id: s } = e; if (n !== null && this.get(n) === void 0) return this.deleteOp({ type: 8, id: s }); if (n !== null) { let f = n; for (; f !== null;) { if (f === void 0) throw new Error; if (f === s) throw new Eu("cyclic tree"); f = this.parent(f) } } let o = this.parent(s); if (o === void 0) return null; let a = o, l = this.childrenArray(o), u = l.findIndex(f => f.id === s); l = [...l]; let c = l.splice(u, 1)[0], h = this.modifyArrayBy(o, l); o = n, l = h.childrenArray(o); let d = c.fi; return c = { ...c, fi: r }, l = [...l, c], l.sort((f, p) => f.fi - p.fi), e.localIndex = l.indexOf(c), h = h.modifyArrayBy(o, l), { data: h, actual: e, reverse: { type: 9, parent: a, fi: d, id: s } } } previous (e, n) { if (n === null) { let s = this.childrenArray(e); return s.length === 0 ? null : s[s.length - 1].id } let r = null; for (let s of this.childrenArray(e)) { if (s.id === n) return r; r = s.id } return null } traverseSortNext (e) { let n = this.parent(e); if (n !== void 0) { let r = this.childrenArray(n), s = r.findIndex(o => o.id === e) + 1; if (s < r.length) return r[s].id; if (n) return this.traverseSortNext(n) } } sortNext (e) { let n = this.childrenArray(e); return n.length > 0 ? n[0].id : this.traverseSortNext(e) } traverseSortPrevious (e) { let n = this.childrenArray(e); return n.length > 0 ? this.traverseSortPrevious(n[n.length - 1].id) : e } sortPrevious (e) { let n = this.parent(e); if (n !== void 0) { let r = this.childrenArray(n), s = r.findIndex(o => o.id === e) - 1; return s >= 0 ? this.traverseSortPrevious(r[s].id) : n } } getAllSorted (e) { let n = []; for (let r of e) { let s = this.getWithSortKey(r.id); s !== void 0 && n.push({ ...r, ...s }) } n.sort((r, s) => NT(r.sortKey, s.sortKey)); for (let r of n) delete r.sortKey; return n } getWithSortKey (e) { var n = e; let r = [], s = this.get(n), o = s; if (s !== void 0) { for (; n;)r.splice(0, 0, s.fi), n = this.parent(n), n !== null && (s = this.get(n)); return { ...o, sortKey: r } } } insertBeforeHelper (e, n, r) { return this.insertAfterHelper(e, this.previous(e, n), r) } insertAfterHelper (e, n, r) { let s = this.childrenArray(e); if (n === null) { if (s.length === 0) return ws(0, r, r); { let o = s[0].fi; return ws(o - r, o, r) } } else { let o = this.get(n); if (o === void 0 || this.parent(n) !== e) throw new Error("illegal args"); let a = s.find(l => l.fi > o.fi); if (a === void 0) { let l = s[s.length - 1].fi; return ws(l, l + r, r) } else return ws(o.fi, a.fi, r) } } }; var Tu; (t => { function i (e, n) { if (n.type !== 0) return null; if (Array.isArray(e)) { let r = n.props, s = {}, o = [...e], a = !1; if (r) for (let l of Object.keys(r)) { let u = parseInt(l); if (isNaN(u)) throw new Error("wrong index"); s[l] = o[u], o[u] = r[l], a = !0 } return a ? { data: o, actual: n, reverse: { type: 0, props: s } } : null } else { let r = n.props, s = {}, o = { ...e }, a = !1; if (r) for (let l of Object.keys(r)) { s[l] = o[l]; let u = r[l]; u === void 0 ? delete o[l] : o[l] = u, a = !0 } return a ? { data: o, actual: n, reverse: { type: 0, props: s } } : null } } t.runOp = i })(Tu || (Tu = {})); var Ue = class extends Array { constructor(...e) { super(...e); Object.setPrototypeOf(this, Ue.prototype) } deepFreeze () { let e = 0; for (; e < this.length;)pf(this[e]), e++ } fillCaches0 (e) { this.objCaches.set(e.id, e) } fillCaches () { if (this.objCaches === void 0) { this.objCaches = new Map, Object.getOwnPropertyDescriptor(this, "objCaches").enumerable = !1; for (let e of this) this.fillCaches0(e) } } randomId () { this.fillCaches(); let e = Array.from(this.objCaches.keys()); if (e.length !== 0) return e[Math.max(0, Math.floor(Math.random() * e.length) - 1)] } data (e) { return this.get(e)?.data } get (e) { return this.fillCaches(), this.objCaches.get(e) } modifyById (e, n) { if (this.get(e) === void 0) throw new Error("not expected"); { let s = this, o = s.findIndex(u => u.id === e); if (o < 0) throw new Error("not expected"); let a = s[o]; return s = [...s], s[o] = { ...a, data: n }, this.modifyArrayBy(s) } } modifyArrayBy (e) { Object.setPrototypeOf(e, Ue.prototype); let n = e; return BT() || n.fillCaches(), n } runOp (e) { switch (e.type) { case 4: return this.addOp(e); case 5: return this.deleteOp(e); case 6: return this.moveOp(e) }return null } addOp (e) { let { fi: n, id: r, data: s } = e, o = this, a = { fi: n, id: r, data: s }; return o = [...o, a], o.sort((u, c) => u.fi - c.fi), e.localIndex = o.indexOf(a), { data: this.modifyArrayBy(o), actual: e, reverse: { type: 5, id: r } } } deleteOp (e) { let { id: n } = e, r = this, s = r.findIndex(l => l.id === n); if (s === -1) return null; e.localIndex = s, r = [...r]; let o = r.splice(s, 1)[0]; return { data: this.modifyArrayBy(r), actual: e, reverse: { type: 4, ...o } } } moveOp (e) { let { fi: n, id: r } = e, s = this; s = [...s]; let o = s.findIndex(c => c.id === r); if (o === -1) return null; let a = s[o].fi, l = { ...s[o], fi: n }; return s[o] = l, s.sort((c, h) => c.fi - h.fi), e.localIndex = s.indexOf(l), { data: this.modifyArrayBy(s), actual: e, reverse: { type: 6, fi: a, id: r } } } previous (e) { if (e === null) return this.length === 0 ? null : this[this.length - 1].id; let n = null; for (let r of this) { if (r.id === e) return n; n = r.id } return null } insertBeforeHelper (e, n) { return this.insertAfterHelper(this.previous(e), n) } insertAfterHelper (e, n) { let r = this; if (e === null) { if (r.length === 0) return ws(0, n, n); { let s = r[0].fi; return ws(s - n, s, n) } } else { let s = this.get(e); if (s === void 0) throw new Error("illegal args"); let o = r.find(a => a.fi > s.fi); if (o === void 0) { let a = r[r.length - 1].fi; return ws(a, a + n, n) } else return ws(s.fi, o.fi, n) } } }; function Cu (i) { return i && typeof i == "object" && i instanceof Vt } var Vt = class { unusedFunOverridesTable (t) { } runOp (t) { let e = [], n = this, r = 0, s = {}; for (; r < t.path.length;) { if (e.push(n), n = n === void 0 ? void 0 : n[t.path[r]], n !== void 0 && !Cu(n)) return null; r += 1 } n = n ? wg(n) : new Vt; for (let [l, u] of Object.entries(t.props)) { let c = n[l]; s[l] = c, u === void 0 ? delete n[l] : n[l] = u } for (; r > 0;) { if (Object.keys(n).length === 0) { let l = e[r - 1]; l && (n = wg(l), delete n[t.path[r - 1]]) } else { let l = e[r - 1]; if (l) { let u = wg(l); u[t.path[r - 1]] = n, n = u } else { let u = new Vt; u[t.path[r - 1]] = n, n = u } } r -= 1 } let o = Object.setPrototypeOf(n, Vt.prototype), a = { ...t, props: s }; return { data: o, actual: t, reverse: a } } }, Ss; (n => { function i (r, s) { return mf(r, s) ?? r } n.apply = i; function t (r, s) { return bb(r, s) } n.merge = t; function e (r, s) { let o = 0, a = s.path, l = r; for (; o < a.length && l !== void 0;) { if (l = Fr.zoomOnce(l, a[o]), l === void 0) return s; if (!Cu(l)) return; o += 1 } if (l === void 0) return s; if (Cu(l)) if (s.type === 0) { let u = { ...s.props }; for (let c of Object.keys(l)) delete u[c]; return { ...s, props: u } } else if (s.type === 1 || s.type === 4 || s.type === 7) { let u = xb([s], l); return u ? (console.log(u), u) : s } else return s } n.filterOp = e })(Ss || (Ss = {})); function xb (i, t) { if (t === void 0) return; let e = !1, n = i.map(r => { let s = r.id, o = mf(r.data, t[s]); if (e = e || o !== void 0, o === void 0 && (o = r.data), r.children) { let a = xb(r.children, t); return a !== void 0 ? e = !0 : a = r.children, { ...r, id: s, data: o, children: a } } else return { ...r, id: s, data: o } }); if (e) return n } function i5 (i, t) { if (t === void 0) return; let e = !1, n = i.map(r => { let s = r.id, o = mf(r.data, t[s]); return e = e || o !== void 0, o === void 0 && (o = r.data), { ...r, id: s, data: o } }); if (e) return Object.setPrototypeOf(n, Object.getPrototypeOf(i)), n } function mf (i, t) { if (!Cu(t)) return t; if (i instanceof rn) { let e = xb(i, t); return e !== void 0 && Object.setPrototypeOf(e, Object.getPrototypeOf(i)), e } else { if (i instanceof Ue) return i5(i, t); if (Array.isArray(i)) { let e = !1, n = i.map((r, s) => { let o = mf(r, t[s]); return e = e || o !== void 0, o === void 0 && (o = r), o }); return e ? (Object.setPrototypeOf(n, Object.getPrototypeOf(i)), n) : void 0 } else { if (i instanceof Vt) return bb(i, t); if (i && typeof i == "object") { let e = {}, n = !1; for (let [r, s] of Object.entries(i)) { let o = mf(s, t[r]); n = n || o !== void 0, o === void 0 && (o = s), e[r] = o } return n ? (Object.setPrototypeOf(e, Object.getPrototypeOf(i)), e) : void 0 } } } } function bb (i, t) { if (i === void 0) return t; if (t === void 0) return i; if (!Cu(t)) return t; if (!Cu(i)) return Ss.apply(i, t); let e = new Set; for (let r of Object.keys(i)) e.add(r); for (let r of Object.keys(t)) e.add(r); let n = new Vt; for (let r of e) { let s = bb(i === void 0 ? void 0 : i[r], t === void 0 ? void 0 : t[r]); n[r] = s } return n } function UT (i, t) { let e = { cur: [], result: [], len: 0 }; return i = gf(i, t, e) ?? i, [i, e.result] } function Sg (i, t) { return i === null ? null : (i.cur[i.len] = t, i.len += 1, i) } function Ag (i) { i && (i.len -= 1) } function s5 (i) { if (i === null) return null; i.result.push(i.cur.slice(0, i.len)) } function zT (i, t, e) { let n = !1, r = i.map(s => { let o = s.id, a = t[o]; if (a !== void 0 && typeof a == "string" && (n = !0, o = a, e !== null)) throw new Error("not supported"); let l = gf(s.data, t, Sg(e, o)); Ag(e), n = n || l !== void 0, l === void 0 && (l = s.data); let u = zT(s.children, t, e); return u !== void 0 ? n = !0 : u = s.children, { ...s, id: o, data: l, children: u } }); if (n) return r } function o5 (i, t, e) { let n = !1, r = i.map(s => { let o = s.id, a = t[o]; if (a !== void 0 && typeof a == "string" && (n = !0, o = a, e !== null)) throw new Error("not supported"); let l = gf(s.data, t, Sg(e, o)); return Ag(e), n = n || l !== void 0, l === void 0 && (l = s.data), { ...s, id: o, data: l } }); if (n) return Object.setPrototypeOf(r, Object.getPrototypeOf(i)), r } function gf (i, t, e) { if (i instanceof rn) { let n = zT(i, t, e); return n !== void 0 && Object.setPrototypeOf(n, Object.getPrototypeOf(i)), n } else { if (i instanceof Ue) return o5(i, t, e); if (Array.isArray(i)) { let n = !1, r = i.map((s, o) => { let a = gf(s, t, Sg(e, o)); return Ag(e), n = n || a !== void 0, a === void 0 && (a = s), a }); return n ? (Object.setPrototypeOf(r, Object.getPrototypeOf(i)), r) : void 0 } else if (i && typeof i == "object" && !Mu(i)) { let n = {}, r = !1; for (let [s, o] of Object.entries(i)) if (s !== "name" && s !== "text") { let a = t[s]; if (typeof a == "string") { if (e !== null) throw new Error("not supported"); r = !0, s = a } let l = gf(o, t, Sg(e, s)); Ag(e), r = r || l !== void 0, l === void 0 && (l = o), n[s] = l } else n[s] = o; return r ? (Object.setPrototypeOf(n, Object.getPrototypeOf(i)), n) : void 0 } else if (typeof i == "string") { let n = t[i]; if (n !== void 0) { if (i.length !== 36) throw new Error("for now you should only call this method when the key is a uuid"); s5(e) } return n } else return } } var _g; (t => { function i (e, n) { let r = Fr.zoom(n, e.path); if (typeof r == "object") { let s = {}; for (let o of Object.keys(e.props)) s[o] = r[o]; return { ...e, props: s } } else return { ...e, props: {} } } t.replaceProps = i })(_g || (_g = {})); var xr; (a => { function i (l, u) { return { ...l, path: l.path.slice(u) } } a.drop = i; function t (l, u) { return e(l, u)?.data ?? l } a.applySimple = t; function e (l, u) { let c = u.path; for (var h = []; ;) { let d; if (l instanceof Vt && u.type === 0 && (d = l.runOp({ ...u, path: c.slice(h.length) }), d === null && (d = void 0)), d === void 0 && h.length === c.length && (l instanceof rn || l instanceof Ue || l instanceof Ut ? d = l.runOp(u) : d = Tu.runOp(l, u)), d !== void 0) if (d !== null) { let m = d.data; for (let g = h.length - 1; g >= 0; g--) { let y = c[g], v = h[g]; if (v instanceof rn) { if (typeof y == "number") throw new Error("illegal arg"); m = v.modifyById(y, m) } else if (v instanceof Ue) { if (typeof y == "number") throw new Error("illegal arg"); m = v.modifyById(y, m) } else if (v instanceof Ut) { if (typeof y == "number") throw new Error("illegal arg"); m = v.modifyById(y, m) } else if (v instanceof Vt) { let x = { ...v, [y]: m }; m = Object.setPrototypeOf(x, Vt.prototype) } else if (typeof v == "object") if (Array.isArray(v)) { if (typeof y == "string" && (y = parseInt(y), isNaN(y))) throw new Error("Invalid path"); let x = m; m = [...v], m[y] = x } else m = { ...v, [y]: m }; else return null } return { data: m, actual: { ...d.actual, path: c }, reverse: { ...d.reverse, path: c } } } else return null; let f = c[h.length], p; if (l instanceof rn) { if (typeof f == "number") throw new Error(""); p = l.get(f)?.data } else if (l instanceof Ue) { if (typeof f == "number") throw new Error(""); p = l.get(f)?.data } else l !== null && (p = l[f]); if (p !== void 0) h.push(l), l = p; else return null } } a.apply = e; function n (l, u) { for (let c = 0; c < l.length && c < u.length; c++)if (l[c] !== u[c]) return !0; return !1 } a.pathDisjoint = n; function r (l, u) { if (l.length !== u.length) return !1; for (let c = 0; c < l.length; c++)if (l[c] !== u[c]) return !1; return !0 } a.pathEq = r; function s (l, u) { return n(l.path, u.path) } a.commutative = s; function o (l, u) { return l.type === 0 && u.type === 0 && r(l.path, u.path) ? Object.keys(l.props).every(c => u.props[c] !== void 0) : !1 } a.subsumed = o })(xr || (xr = {})); var wb; (l => { function i () { return [] } l.empty = i; function t (u, c) { let h = []; for (let d of u) { let [f, ...p] = d.path; f === c && h.push({ ...d, path: p }) } return h } l.removePrefix = t; function e (u, c) { return u.map(h => ({ ...h, path: [c, ...h.path] })) } l.addPrefix = e; function n (u, c) { return [...u, ...c] } l.concat = n; function r (u, c) { return [...u.filter(d => !c.some(f => xr.subsumed(d, f))), ...c] } l.compress = r; function s (u, c) { return u.every(h => c.every(d => xr.commutative(h, d))) } l.commutative = s; function o (u, c) { for (let h of c) { let d = a(u, h); d !== null && (u = d.data) } return u } l.applyAll = o; function a (u, c) { var h = u; let d = [], f = []; for (let p of c) try { if (p.type === 3) { let m = Fr.zoom(h, [...p.path, p.id]), g = xr.apply(h, { ...p, type: 2 }); if (g !== null) { h = g.data; let [y, v] = UT(h, { [p.id]: m }); h = y; for (let x of v) { let b = x[x.length - 1]; x.splice(x.length - 1, 1), d.push({ type: 0, path: x, props: { [b]: m } }), f.push({ type: 0, path: x, props: { [b]: p.id } }) } f.push(g.reverse), d.push(g.actual) } } else { let m = xr.apply(h, p); m !== null && (d.push(m.actual), h = m.data, f.push(m.reverse)) } } catch (m) { if (m instanceof Eu) return null; throw m } return { data: h, actual: d, reverse: f.reverse() } } l.apply = a })(wb || (wb = {})); var GT = Symbol(), a5 = Symbol(), Mg = Symbol(), Tl = class { reportOp (t, e, n = []) { let r = this; if (e === null) return; r._current = e.data; let s = n; for (; !(r instanceof Eg);) { let o = r._path, a = r._current; if (o !== "" && s.splice(0, 0, o), r = r._parent, r === null) return; r.update(o, a) } r.push(s, t, e.actual, e.reverse) } deleteChildren (t) { if (this._children) { let e = this._children[t]; if (e) { let n = e[Mg]; n && n(), delete this._children[t] } } } }, Ab = class extends Tl { constructor(t, e, n) { super(), this._parent = t, this._path = e, this._current = n } update (t, e) { if (Array.isArray(this._current)) { if (typeof t == "string" && (t = parseInt(t), isNaN(t))) throw new Error("Invalid path"); this._current = [...this._current], this._current[t] = e } else this._current = { ...this._current, [t]: e } } runOp (t) { this.reportOp(t, Tu.runOp(this._current, t), t.path) } }, _b = class extends Tl { constructor(t, e, n) { super(), this._parent = t, this._path = e, this._current = n } update (t, e) { this._current = { ...this._current, [t]: e }, Object.setPrototypeOf(this._current, Ut.prototype) } runOp (t) { this.reportOp(t, this._current.runOp(t)) } }, VT = { get (i, t) { if (t === Mg) return () => { i._parent = null }; if (t === GT) return i._current; if (t === a5) return i; let { _current: e, _children: n } = i; if (t === "push" && Array.isArray(e)) throw new Error("not supported to expand array"); let r = n === void 0 ? void 0 : n[t]; if (r !== void 0) return r; let s = e[t], o = Tg(i, t, s); return o !== s ? (n === void 0 && (n = {}, i._children = n), n[t] = o, o) : s }, has (i, t) { return t in i._current }, ownKeys (i) { return Reflect.ownKeys(i._current) }, defineProperty () { throw Error("not supported") }, getPrototypeOf (i) { return Object.getPrototypeOf(i._current) }, setPrototypeOf () { throw Error("not supported") }, getOwnPropertyDescriptor (i, t) { let e = i._current, n = Reflect.getOwnPropertyDescriptor(e, t); return n && { writable: !0, configurable: !0, enumerable: n.enumerable, value: e[t] } } }, l5 = { ...VT, set (i, t, e) { let n = { type: 0, props: { [t]: Bn(e) ?? e } }; return i.deleteChildren(t), i.runOp(n), !0 }, deleteProperty (i, t) { let e = { type: 0, props: { [t]: void 0 } }; return i.deleteChildren(t), i.runOp(e), !0 } }, c5 = { ...VT, set (i, t, e) { return e === void 0 ? this.deleteProperty(i, t) : (i.deleteChildren(t), i.runOp({ type: 1, id: t, data: e })), !0 }, deleteProperty (i, t) { return i.runOp({ type: 2, id: t }), !0 } }, Pu = class extends Tl { constructor(t, e, n) { super(), this._children = {}, this._parent = t, this._path = e, this._current = n, this[Mg] = () => { this._parent = null } } unproxy () { return this._current } update (t, e) { this._current = this._current.modifyById(t, e) } runOp (t) { this.reportOp(t, this._current.runOp(t)) } randomId () { return this._current.randomId() } isDescendantOf (t, e) { return this._current.isDescendantOf(t, e) } childrenOf (t) { return this._current.childrenOf(t) } traverse (t) { return this._current.traverse(t) } get (t) { return this._current.get(t) } parent (t) { return this._current.parent(t) } traverse (t) { this._current.traverse((e, n) => { t(e, this.data(e)) }) } data (t) { let { _current: e, _children: n } = this, r = n === void 0 ? void 0 : n[t]; if (r !== void 0) return r; let s = e.get(t)?.data, o = Tg(this, t, s); return o !== s ? (n === void 0 && (n = {}, this._children = n), n[t] = o, o) : s } add (t, e, n, r, s) { this.runOp({ type: 7, parent: t, fi: e, id: n, data: r, children: s }) } move (t, e, n) { this.runOp({ type: 9, parent: t, fi: e, id: n }) } insertAfter (t, e, n) { let r = this._current.insertAfterHelper(t, e, n.length); for (let s = 0; s < n.length; s++) { let o = n[s]; this.add(t, r[s], o.id, o.data, o.children) } } insertBefore (t, e, n) { let r = this._current.insertBeforeHelper(t, e, n.length); for (let s = 0; s < n.length; s++) { let o = n[s]; this.add(t, r[s], o.id, o.data, o.children) } } moveAfter (t, e, n) { let r = this._current.insertAfterHelper(t, e, n.length); for (let s = 0; s < n.length; s++) { let o = n[s]; this.move(t, r[s], o) } } moveBefore (t, e, n) { let r = this._current.insertBeforeHelper(t, e, n.length); for (let s = 0; s < n.length; s++) { let o = n[s]; this.move(t, r[s], o) } } delete (t) { this.deleteChildren(t), this.runOp({ type: 8, id: t }) } sortNext (t) { return this._current.sortNext(t) } sortPrevious (t) { return this._current.sortPrevious(t) } getAllSorted (t) { return this._current.getAllSorted(t) } }, Iu = class extends Tl { constructor(t, e, n) { super(), this._children = {}, this._parent = t, this._path = e, this._current = n, this[Mg] = () => { this._parent = null } } unproxy () { return this._current } get length () { return this._current.length } forEach (t) { let e = this.length; for (let n = 0; n < e; n++) { let r = this._current[n].id, s = this._current[n].fi; t(this.data(this._current[n].id), r, s) } } find (t) { let e = this.length; for (let n = 0; n < e; n++) { let r = this._current[n].id; if (t(this.data(r), r)) return this.get(r) } } update (t, e) { this._current = this._current.modifyById(t, e) } randomId () { return this._current.randomId() } get (t) { return { ...this._current.get(t), data: this.data(t) } } data (t) { let { _current: e, _children: n } = this, r = n === void 0 ? void 0 : n[t]; if (r !== void 0) return r; let s = e.get(t)?.data, o = Tg(this, t, s); return o !== s ? (n === void 0 && (n = {}, this._children = n), n[t] = o, o) : s } runOp (t) { this.reportOp(t, this._current.runOp(t)) } add (t, e, n) { this.runOp({ type: 4, fi: t, id: e, data: n }) } move (t, e) { this.runOp({ type: 6, fi: t, id: e }) } insertAfter (t, e) { let n = this._current.insertAfterHelper(t, e.length); for (let r = 0; r < e.length; r++) { let s = e[r]; this.add(n[r], s.id, s.data) } } insertBefore (t, e) { let n = this._current.insertBeforeHelper(t, e.length); for (let r = 0; r < e.length; r++) { let s = e[r]; this.add(n[r], s.id, s.data) } } moveAfter (t, e) { let n = this._current.insertAfterHelper(t, e.length); for (let r = 0; r < e.length; r++) { let s = e[r]; this.move(n[r], s) } } moveBefore (t, e) { let n = this._current.insertBeforeHelper(t, e.length); for (let r = 0; r < e.length; r++) { let s = e[r]; this.move(n[r], s) } } delete (t) { this.deleteChildren(t), this.runOp({ type: 5, id: t }) } }; function Sb (i, t, e) { if (i.length > 0) { let n = i[i.length - 1]; if (n.type === 0 && t.type === 0 && Fr.equal(n.path, e)) { Object.assign(n.props, t.props); return } } i.push({ ...t, path: e }) } var Eg = class extends Tl { constructor(t) { super(), this.ts = [], this.actual = [], this.reverse = [], this._current = t } update (t, e) { if (t !== "") throw new Error(""); this._current = e } push (t, e, n, r) { Sb(this.ts, e, t), Sb(this.actual, n, t), Sb(this.reverse, r, t) } result () { return { data: this._current, ts: this.ts, actual: this.actual, reverse: this.reverse.reverse() } } }; function Tg (i, t, e) { return e instanceof rn ? new Pu(i, t, e) : e instanceof Ue ? new Iu(i, t, e) : e instanceof Ut ? new Proxy(new _b(i, t, e), c5) : e !== null && typeof e == "object" ? Mu(e) ? e : new Proxy(new Ab(i, t, e), l5) : e } function Eb (i) { let t = new Eg(i); return [Tg(t, "", i), t] } function Du (i, t) { let [e, n] = Eb(i); return t(e), n.result() } function Bn (i) { return i instanceof Pu || i instanceof Iu ? i._current : i !== null && typeof i == "object" ? i[GT] : i } var Fr; (r => { function i (s, o) { if (o.length === s.length) for (var a = 0; a < s.length;) { if (s[a] !== o[a]) return !1; a += 1 } else return !1; return !0 } r.equal = i; function t (s, o, a) { let l = n(a, s); if (l !== void 0 && typeof l == "object" && l !== null) { let u = { ...o }; return Object.keys(l).forEach(c => { delete u[c] }), u } else return o } r.removeOverridden = t; function e (s, o) { if ((s instanceof rn || s instanceof Pu) && typeof o == "string") return s.data(o); if ((s instanceof Ue || s instanceof Iu) && typeof o == "string") return s.data(o); if (typeof o == "number" && Array.isArray(s)) return s[o]; if (typeof o == "string" && typeof s == "object" && s !== null) return s[o] } r.zoomOnce = e; function n (s, o, a = 0) { for (; a < o.length && s !== void 0;)s = e(s, o[a]), a += 1; return s } r.zoom = n })(Fr || (Fr = {})); function HT (i, t) { let e = []; if (t.length === i.length) for (var n = 0; n < i.length;) { if (t[n] === "*") e.push(i[n]); else if (i[n] !== t[n]) return null; n += 1 } else return null; return e } function Pr (i, t) { let e = []; if (t.length <= i.length) for (var n = 0; n < t.length;) { if (t[n] === "*") e.push(i[n]); else if (i[n] !== t[n]) return null; n += 1 } else return null; return e } var Cg = class { }, yf = class extends Cg { constructor(e) { super(); this.id = e } }, vf = class extends Cg { constructor(e) { super(); this.data = e } }; var Tb; try { Tb = new TextDecoder } catch { } var Oe, xa, J = 0; var ZT = [], Cb = ZT, Pb = 0, qr = {}, Pt, va, Mi = 0, As = 0, pi, _o, kr = [], Nt, jT = { useRecords: !1, mapsAsObjects: !0 }, xf = class { }, Db = new xf; Db.name = "MessagePack 0xC1"; var Ou = !1, _s = class { constructor(t) { t && (t.useRecords === !1 && t.mapsAsObjects === void 0 && (t.mapsAsObjects = !0), t.structures ? t.structures.sharedLength = t.structures.length : t.getStructures && ((t.structures = []).uninitialized = !0, t.structures.sharedLength = 0)), Object.assign(this, t) } unpack (t, e) { if (Oe) return nC(() => (Ig(), this ? this.unpack(t, e) : _s.prototype.unpack.call(jT, t, e))); xa = e > -1 ? e : t.length, J = 0, Pb = 0, As = 0, va = null, Cb = ZT, pi = null, Oe = t; try { Nt = t.dataView || (t.dataView = new DataView(t.buffer, t.byteOffset, t.byteLength)) } catch (n) { throw Oe = null, t instanceof Uint8Array ? n : new Error("Source must be a Uint8Array or Buffer but was a " + (t && typeof t == "object" ? t.constructor.name : typeof t)) } if (this instanceof _s) { if (qr = this, this.structures) return Pt = this.structures, Pg(); (!Pt || Pt.length > 0) && (Pt = []) } else qr = jT, (!Pt || Pt.length > 0) && (Pt = []); return Pg() } unpackMultiple (t, e) { let n, r = 0; try { Ou = !0; let s = t.length, o = this ? this.unpack(t, s) : Rg.unpack(t, s); if (e) { for (e(o); J < s;)if (r = J, e(Pg()) === !1) return } else { for (n = [o]; J < s;)r = J, n.push(Pg()); return n } } catch (s) { throw s.lastPosition = r, s.values = n, s } finally { Ou = !1, Ig() } } _mergeStructures (t, e) { t = t || []; for (let n = 0, r = t.length; n < r; n++) { let s = t[n]; s && (s.isShared = !0, n >= 32 && (s.highByte = n - 32 >> 5)) } t.sharedLength = t.length; for (let n in e || []) if (n >= 0) { let r = t[n], s = e[n]; s && (r && ((t.restoreStructures || (t.restoreStructures = []))[n] = r), t[n] = s) } return this.structures = t } decode (t, e) { return this.unpack(t, e) } }; function Pg () { try { if (!qr.trusted && !Ou) { let t = Pt.sharedLength || 0; t < Pt.length && (Pt.length = t) } let i = pn(); if (J == xa) Pt.restoreStructures && WT(), Pt = null, Oe = null, _o && (_o = null); else if (J > xa) { let t = new Error("Unexpected end of MessagePack data"); throw t.incomplete = !0, t } else if (!Ou) throw new Error("Data read, but end of buffer not reached"); return i } catch (i) { throw Pt.restoreStructures && WT(), Ig(), (i instanceof RangeError || i.message.startsWith("Unexpected end of buffer")) && (i.incomplete = !0), i } } function WT () { for (let i in Pt.restoreStructures) Pt[i] = Pt.restoreStructures[i]; Pt.restoreStructures = null } function pn () { let i = Oe[J++]; if (i < 160) if (i < 128) { if (i < 64) return i; { let t = Pt[i & 63] || qr.getStructures && JT()[i & 63]; return t ? (t.read || (t.read = Ob(t, i & 63)), t.read()) : i } } else if (i < 144) if (i -= 128, qr.mapsAsObjects) { let t = {}; for (let e = 0; e < i; e++)t[eC()] = pn(); return t } else { let t = new Map; for (let e = 0; e < i; e++)t.set(pn(), pn()); return t } else { i -= 144; let t = new Array(i); for (let e = 0; e < i; e++)t[e] = pn(); return t } else if (i < 192) { let t = i - 160; if (As >= J) return va.slice(J - Mi, (J += t) - Mi); if (As == 0 && xa < 140) { let e = t < 16 ? Rb(t) : $T(t); if (e != null) return e } return Ib(t) } else { let t; switch (i) { case 192: return null; case 193: return pi ? (t = pn(), t > 0 ? pi[1].slice(pi.position1, pi.position1 += t) : pi[0].slice(pi.position0, pi.position0 -= t)) : Db; case 194: return !1; case 195: return !0; case 196: return Mb(Oe[J++]); case 197: return t = Nt.getUint16(J), J += 2, Mb(t); case 198: return t = Nt.getUint32(J), J += 4, Mb(t); case 199: return Cl(Oe[J++]); case 200: return t = Nt.getUint16(J), J += 2, Cl(t); case 201: return t = Nt.getUint32(J), J += 4, Cl(t); case 202: if (t = Nt.getFloat32(J), qr.useFloat32 > 2) { let e = Og[(Oe[J] & 127) << 1 | Oe[J + 1] >> 7]; return J += 4, (e * t + (t > 0 ? .5 : -.5) >> 0) / e } return J += 4, t; case 203: return t = Nt.getFloat64(J), J += 8, t; case 204: return Oe[J++]; case 205: return t = Nt.getUint16(J), J += 2, t; case 206: return t = Nt.getUint32(J), J += 4, t; case 207: return qr.int64AsNumber ? (t = Nt.getUint32(J) * 4294967296, t += Nt.getUint32(J + 4)) : t = Nt.getBigUint64(J), J += 8, t; case 208: return Nt.getInt8(J++); case 209: return t = Nt.getInt16(J), J += 2, t; case 210: return t = Nt.getInt32(J), J += 4, t; case 211: return qr.int64AsNumber ? (t = Nt.getInt32(J) * 4294967296, t += Nt.getUint32(J + 4)) : t = Nt.getBigInt64(J), J += 8, t; case 212: if (t = Oe[J++], t == 114) return KT(Oe[J++] & 63); { let e = kr[t]; if (e) return e.read ? (J++, e.read(pn())) : e.noBuffer ? (J++, e()) : e(Oe.subarray(J, ++J)); throw new Error("Unknown extension " + t) } case 213: return t = Oe[J], t == 114 ? (J++, KT(Oe[J++] & 63, Oe[J++])) : Cl(2); case 214: return Cl(4); case 215: return Cl(8); case 216: return Cl(16); case 217: return t = Oe[J++], As >= J ? va.slice(J - Mi, (J += t) - Mi) : h5(t); case 218: return t = Nt.getUint16(J), J += 2, As >= J ? va.slice(J - Mi, (J += t) - Mi) : d5(t); case 219: return t = Nt.getUint32(J), J += 4, As >= J ? va.slice(J - Mi, (J += t) - Mi) : f5(t); case 220: return t = Nt.getUint16(J), J += 2, YT(t); case 221: return t = Nt.getUint32(J), J += 4, YT(t); case 222: return t = Nt.getUint16(J), J += 2, XT(t); case 223: return t = Nt.getUint32(J), J += 4, XT(t); default: if (i >= 224) return i - 256; if (i === void 0) { let e = new Error("Unexpected end of MessagePack data"); throw e.incomplete = !0, e } throw new Error("Unknown MessagePack token " + i) } } } var u5 = /^[a-zA-Z_$][a-zA-Z\d_$]*$/; function Ob (i, t) { function e () { if (e.count++ > 2) { let r = i.read = new Function("r", "return function(){return {" + i.map(s => u5.test(s) ? s + ":r()" : "[" + JSON.stringify(s) + "]:r()").join(",") + "}}")(pn); return i.highByte === 0 && (i.read = qT(t, i.read)), r() } let n = {}; for (let r = 0, s = i.length; r < s; r++) { let o = i[r]; n[o] = pn() } return n } return e.count = 0, i.highByte === 0 ? qT(t, e) : e } var qT = (i, t) => function () { let e = Oe[J++]; if (e === 0) return t(); let n = i < 32 ? -(i + (e << 5)) : i + (e << 5), r = Pt[n] || JT()[n]; if (!r) throw new Error("Record id is not defined for " + n); return r.read || (r.read = Ob(r, i)), r.read() }; function JT () { let i = nC(() => (Oe = null, qr.getStructures())); return Pt = qr._mergeStructures(i, Pt) } var Ib = Dg, h5 = Dg, d5 = Dg, f5 = Dg; function Dg (i) { let t; if (i < 16 && (t = Rb(i))) return t; if (i > 64 && Tb) return Tb.decode(Oe.subarray(J, J += i)); let e = J + i, n = []; for (t = ""; J < e;) { let r = Oe[J++]; if ((r & 128) === 0) n.push(r); else if ((r & 224) === 192) { let s = Oe[J++] & 63; n.push((r & 31) << 6 | s) } else if ((r & 240) === 224) { let s = Oe[J++] & 63, o = Oe[J++] & 63; n.push((r & 31) << 12 | s << 6 | o) } else if ((r & 248) === 240) { let s = Oe[J++] & 63, o = Oe[J++] & 63, a = Oe[J++] & 63, l = (r & 7) << 18 | s << 12 | o << 6 | a; l > 65535 && (l -= 65536, n.push(l >>> 10 & 1023 | 55296), l = 56320 | l & 1023), n.push(l) } else n.push(r); n.length >= 4096 && (t += sr.apply(String, n), n.length = 0) } return n.length > 0 && (t += sr.apply(String, n)), t } function YT (i) { let t = new Array(i); for (let e = 0; e < i; e++)t[e] = pn(); return t } function XT (i) { if (qr.mapsAsObjects) { let t = {}; for (let e = 0; e < i; e++)t[eC()] = pn(); return t } else { let t = new Map; for (let e = 0; e < i; e++)t.set(pn(), pn()); return t } } var sr = String.fromCharCode; function $T (i) { let t = J, e = new Array(i); for (let n = 0; n < i; n++) { let r = Oe[J++]; if ((r & 128) > 0) { J = t; return } e[n] = r } return sr.apply(String, e) } function Rb (i) { if (i < 4) if (i < 2) { if (i === 0) return ""; { let t = Oe[J++]; if ((t & 128) > 1) { J -= 1; return } return sr(t) } } else { let t = Oe[J++], e = Oe[J++]; if ((t & 128) > 0 || (e & 128) > 0) { J -= 2; return } if (i < 3) return sr(t, e); let n = Oe[J++]; if ((n & 128) > 0) { J -= 3; return } return sr(t, e, n) } else { let t = Oe[J++], e = Oe[J++], n = Oe[J++], r = Oe[J++]; if ((t & 128) > 0 || (e & 128) > 0 || (n & 128) > 0 || (r & 128) > 0) { J -= 4; return } if (i < 6) { if (i === 4) return sr(t, e, n, r); { let s = Oe[J++]; if ((s & 128) > 0) { J -= 5; return } return sr(t, e, n, r, s) } } else if (i < 8) { let s = Oe[J++], o = Oe[J++]; if ((s & 128) > 0 || (o & 128) > 0) { J -= 6; return } if (i < 7) return sr(t, e, n, r, s, o); let a = Oe[J++]; if ((a & 128) > 0) { J -= 7; return } return sr(t, e, n, r, s, o, a) } else { let s = Oe[J++], o = Oe[J++], a = Oe[J++], l = Oe[J++]; if ((s & 128) > 0 || (o & 128) > 0 || (a & 128) > 0 || (l & 128) > 0) { J -= 8; return } if (i < 10) { if (i === 8) return sr(t, e, n, r, s, o, a, l); { let u = Oe[J++]; if ((u & 128) > 0) { J -= 9; return } return sr(t, e, n, r, s, o, a, l, u) } } else if (i < 12) { let u = Oe[J++], c = Oe[J++]; if ((u & 128) > 0 || (c & 128) > 0) { J -= 10; return } if (i < 11) return sr(t, e, n, r, s, o, a, l, u, c); let h = Oe[J++]; if ((h & 128) > 0) { J -= 11; return } return sr(t, e, n, r, s, o, a, l, u, c, h) } else { let u = Oe[J++], c = Oe[J++], h = Oe[J++], d = Oe[J++]; if ((u & 128) > 0 || (c & 128) > 0 || (h & 128) > 0 || (d & 128) > 0) { J -= 12; return } if (i < 14) { if (i === 12) return sr(t, e, n, r, s, o, a, l, u, c, h, d); { let f = Oe[J++]; if ((f & 128) > 0) { J -= 13; return } return sr(t, e, n, r, s, o, a, l, u, c, h, d, f) } } else { let f = Oe[J++], p = Oe[J++]; if ((f & 128) > 0 || (p & 128) > 0) { J -= 14; return } if (i < 15) return sr(t, e, n, r, s, o, a, l, u, c, h, d, f, p); let m = Oe[J++]; if ((m & 128) > 0) { J -= 15; return } return sr(t, e, n, r, s, o, a, l, u, c, h, d, f, p, m) } } } } } function Mb (i) { return qr.copyBuffers ? Uint8Array.prototype.slice.call(Oe, J, J += i) : Oe.subarray(J, J += i) } function Cl (i) { let t = Oe[J++]; if (kr[t]) return kr[t](Oe.subarray(J, J += i)); throw new Error("Unknown extension type " + t) } var QT = new Array(4096); function eC () { let i = Oe[J++]; if (i >= 160 && i < 192) { if (i = i - 160, As >= J) return va.slice(J - Mi, (J += i) - Mi); if (!(As == 0 && xa < 180)) return Ib(i) } else return J--, pn(); let t = (i << 5 ^ (i > 1 ? Nt.getUint16(J) : i > 0 ? Oe[J] : 0)) & 4095, e = QT[t], n = J, r = J + i - 3, s, o = 0; if (e && e.bytes == i) { for (; n < r;) { if (s = Nt.getUint32(n), s != e[o++]) { n = 1879048192; break } n += 4 } for (r += 3; n < r;)if (s = Oe[n++], s != e[o++]) { n = 1879048192; break } if (n === r) return J = n, e.string; r -= 3, n = J } for (e = [], QT[t] = e, e.bytes = i; n < r;)s = Nt.getUint32(n), e.push(s), n += 4; for (r += 3; n < r;)s = Oe[n++], e.push(s); let a = i < 16 ? Rb(i) : $T(i); return a != null ? e.string = a : e.string = Ib(i) } var KT = (i, t) => { var e = pn(); let n = i; t !== void 0 && (i = i < 32 ? -((t << 5) + i) : (t << 5) + i, e.highByte = t); let r = Pt[i]; return r && r.isShared && ((Pt.restoreStructures || (Pt.restoreStructures = []))[i] = r), Pt[i] = e, e.read = Ob(e, n), e.read() }, tC = typeof self == "object" ? self : global; kr[0] = () => { }; kr[0].noBuffer = !0; kr[101] = () => { let i = pn(); return (tC[i[0]] || Error)(i[1]) }; kr[105] = i => { let t = Nt.getUint32(J - 4); _o || (_o = new Map); let e = Oe[J], n; e >= 144 && e < 160 || e == 220 || e == 221 ? n = [] : n = {}; let r = { target: n }; _o.set(t, r); let s = pn(); return r.used ? Object.assign(n, s) : (r.target = s, s) }; kr[112] = i => { let t = Nt.getUint32(J - 4), e = _o.get(t); return e.used = !0, e.target }; kr[115] = () => new Set(pn()); var Lb = ["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64", "BigInt64", "BigUint64"].map(i => i + "Array"); kr[116] = i => { let t = i[0], e = Lb[t]; if (!e) throw new Error("Could not find typed array for code " + t); return new tC[e](Uint8Array.prototype.slice.call(i, 1).buffer) }; kr[120] = () => { let i = pn(); return new RegExp(i[0], i[1]) }; kr[98] = i => { let t = (i[0] << 24) + (i[1] << 16) + (i[2] << 8) + i[3], e = J; J += t - 4, pi = [pn(), pn()], pi.position0 = 0, pi.position1 = 0; let n = J; J = e; try { return pn() } finally { J = n } }; kr[255] = i => i.length == 4 ? new Date((i[0] * 16777216 + (i[1] << 16) + (i[2] << 8) + i[3]) * 1e3) : i.length == 8 ? new Date(((i[0] << 22) + (i[1] << 14) + (i[2] << 6) + (i[3] >> 2)) / 1e6 + ((i[3] & 3) * 4294967296 + i[4] * 16777216 + (i[5] << 16) + (i[6] << 8) + i[7]) * 1e3) : i.length == 12 ? new Date(((i[0] << 24) + (i[1] << 16) + (i[2] << 8) + i[3]) / 1e6 + ((i[4] & 128 ? -281474976710656 : 0) + i[6] * 1099511627776 + i[7] * 4294967296 + i[8] * 16777216 + (i[9] << 16) + (i[10] << 8) + i[11]) * 1e3) : new Date("invalid"); function nC (i) { let t = xa, e = J, n = Pb, r = Mi, s = As, o = va, a = Cb, l = _o, u = pi, c = new Uint8Array(Oe.slice(0, xa)), h = Pt, d = Pt.slice(0, Pt.length), f = qr, p = Ou, m = i(); return xa = t, J = e, Pb = n, Mi = r, As = s, va = o, Cb = a, _o = l, pi = u, Oe = c, Ou = p, Pt = h, Pt.splice(0, Pt.length, ...d), qr = f, Nt = new DataView(Oe.buffer, Oe.byteOffset, Oe.byteLength), m } function Ig () { Oe = null, _o = null, Pt = null } function rC (i) { i.unpack ? kr[i.type] = i.unpack : kr[i.type] = i } var Og = new Array(147); for (let i = 0; i < 256; i++)Og[i] = +("1e" + Math.floor(45.15 - i * .30103)); var Rg = new _s({ useRecords: !1 }), p5 = Rg.unpack, m5 = Rg.unpackMultiple, g5 = Rg.unpack, Lg = { NEVER: 0, ALWAYS: 1, DECIMAL_ROUND: 3, DECIMAL_FIT: 4 }, y5 = new Float32Array(1), Sre = new Uint8Array(y5.buffer, 0, 4); var Ng; try { Ng = new TextEncoder } catch { } var Bg, Bb, Fg = typeof Buffer < "u", Nb = Fg ? Buffer.allocUnsafeSlow : Uint8Array, aC = Fg ? Buffer : Uint8Array, iC = Fg ? 4294967296 : 2144337920, he, wn, re = 0, Es, Ms = null, v5 = /[\u0080-\uFFFF]/, bf = Symbol("record-id"), Pl = class extends _s { constructor(t) { super(t), this.offset = 0; let e, n, r, s, o, a, l = 0, u = aC.prototype.utf8Write ? function (w, M, T) { return he.utf8Write(w, M, T) } : Ng && Ng.encodeInto ? function (w, M) { return Ng.encodeInto(w, he.subarray(M)).written } : !1, c = this; t || (t = {}); let h = t && t.sequential, d = t.structures || t.saveStructures, f = t.maxSharedStructures; if (f == null && (f = d ? 32 : 0), f > 8160) throw new Error("Maximum maxSharedStructure is 8160"); let p = t.maxOwnStructures; p == null && (p = d ? 32 : 64), h && !t.saveStructures && (this.structures = []); let m = f > 32 || p + f > 64, g = f + 64, y = f + p + 64; if (y > 8256) throw new Error("Maximum maxSharedStructure + maxOwnStructure is 8192"); let v = [], x = 0, b = 0; this.pack = this.encode = function (w, M) { if (he || (he = new Nb(8192), wn = new DataView(he.buffer, 0, 8192), re = 0), Es = he.length - 10, Es - re < 2048 ? (he = new Nb(he.length), wn = new DataView(he.buffer, 0, he.length), Es = he.length - 10, re = 0) : re = re + 7 & 2147483640, n = re, a = c.structuredClone ? new Map : null, c.bundleStrings ? (Ms = ["", ""], he[re++] = 214, he[re++] = 98, Ms.position = re - n, re += 4) : Ms = null, r = c.structures, r) { r.uninitialized && (r = c._mergeStructures(c.getStructures())); let T = r.sharedLength || 0; if (T > f) throw new Error("Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to " + r.sharedLength); if (!r.transitions) { r.transitions = Object.create(null); for (let I = 0; I < T; I++) { let C = r[I]; if (!C) continue; let P, D = r.transitions; for (let L = 0, H = C.length; L < H; L++) { let U = C[L]; P = D[U], P || (P = D[U] = Object.create(null)), D = P } D[bf] = I + 64 } l = T } h || (r.nextId = T + 64) } s && (s = !1), o = r || []; try { if (S(w), Ms) { wn.setUint32(Ms.position + n, re - Ms.position - n); let T = Ms; Ms = null, S(T[0]), S(T[1]) } if (c.offset = re, a && a.idsToInsert) { re += a.idsToInsert.length * 6, re > Es && E(re), c.offset = re; let T = b5(he.subarray(n, re), a.idsToInsert); return a = null, T } return M & cC ? (he.start = n, he.end = re, he) : he.subarray(n, re) } finally { if (r) { if (b < 10 && b++, x > 1e4) r.transitions = null, b = 0, x = 0, v.length > 0 && (v = []); else if (v.length > 0 && !h) { for (let T = 0, I = v.length; T < I; T++)v[T][bf] = 0; v = [] } if (s && c.saveStructures) { let T = r.sharedLength || f; r.length > T && (r = r.slice(0, T)); let I = he.subarray(n, re); return c.saveStructures(r, l) === !1 ? (c._mergeStructures(c.getStructures()), c.pack(w)) : (l = T, I) } } M & T5 && (re = n) } }; let S = w => { re > Es && (he = E(re)); var M = typeof w, T; if (M === "string") { let I = w.length; if (Ms && I >= 8 && I < 4096) { let D = v5.test(w); Ms[D ? 0 : 1] += w, he[re++] = 193, S(D ? -I : I); return } let C; I < 32 ? C = 1 : I < 256 ? C = 2 : I < 65536 ? C = 3 : C = 5; let P = I * 3; if (re + P > Es && (he = E(re + P)), I < 64 || !u) { let D, L, H, U = re + C; for (D = 0; D < I; D++)L = w.charCodeAt(D), L < 128 ? he[U++] = L : L < 2048 ? (he[U++] = L >> 6 | 192, he[U++] = L & 63 | 128) : (L & 64512) === 55296 && ((H = w.charCodeAt(D + 1)) & 64512) === 56320 ? (L = 65536 + ((L & 1023) << 10) + (H & 1023), D++, he[U++] = L >> 18 | 240, he[U++] = L >> 12 & 63 | 128, he[U++] = L >> 6 & 63 | 128, he[U++] = L & 63 | 128) : (he[U++] = L >> 12 | 224, he[U++] = L >> 6 & 63 | 128, he[U++] = L & 63 | 128); T = U - re - C } else T = u(w, re + C, P); T < 32 ? he[re++] = 160 | T : T < 256 ? (C < 2 && he.copyWithin(re + 2, re + 1, re + 1 + T), he[re++] = 217, he[re++] = T) : T < 65536 ? (C < 3 && he.copyWithin(re + 3, re + 2, re + 2 + T), he[re++] = 218, he[re++] = T >> 8, he[re++] = T & 255) : (C < 5 && he.copyWithin(re + 5, re + 3, re + 3 + T), he[re++] = 219, wn.setUint32(re, T), re += 4), re += T } else if (M === "number") if (w >>> 0 === w) w < 64 ? he[re++] = w : w < 256 ? (he[re++] = 204, he[re++] = w) : w < 65536 ? (he[re++] = 205, he[re++] = w >> 8, he[re++] = w & 255) : (he[re++] = 206, wn.setUint32(re, w), re += 4); else if (w >> 0 === w) w >= -32 ? he[re++] = 256 + w : w >= -128 ? (he[re++] = 208, he[re++] = w + 256) : w >= -32768 ? (he[re++] = 209, wn.setInt16(re, w), re += 2) : (he[re++] = 210, wn.setInt32(re, w), re += 4); else { let I; if ((I = this.useFloat32) > 0 && w < 4294967296 && w >= -2147483648) { he[re++] = 202, wn.setFloat32(re, w); let C; if (I < 4 || (C = w * Og[(he[re] & 127) << 1 | he[re + 1] >> 7]) >> 0 === C) { re += 4; return } else re-- } he[re++] = 203, wn.setFloat64(re, w), re += 8 } else if (M === "object") if (!w) he[re++] = 192; else { if (a) { let C = a.get(w); if (C) { if (!C.id) { let P = a.idsToInsert || (a.idsToInsert = []); C.id = P.push(C) } he[re++] = 214, he[re++] = 112, wn.setUint32(re, C.id), re += 4; return } else a.set(w, { offset: re - n }) } let I = w.constructor; if (I === Object) _(w, !0); else if (I === Array) { T = w.length, T < 16 ? he[re++] = 144 | T : T < 65536 ? (he[re++] = 220, he[re++] = T >> 8, he[re++] = T & 255) : (he[re++] = 221, wn.setUint32(re, T), re += 4); for (let C = 0; C < T; C++)S(w[C]) } else if (I === Map) { T = w.size, T < 16 ? he[re++] = 128 | T : T < 65536 ? (he[re++] = 222, he[re++] = T >> 8, he[re++] = T & 255) : (he[re++] = 223, wn.setUint32(re, T), re += 4); for (let [C, P] of w) S(C), S(P) } else { for (let C = 0, P = Bg.length; C < P; C++) { let D = Bb[C]; if (w instanceof D) { let L = Bg[C]; if (L.write) { L.type && (he[re++] = 212, he[re++] = L.type, he[re++] = 0), S(L.write.call(this, w)); return } let H = he, U = wn, V = re; he = null; let G; try { G = L.pack.call(this, w, z => (he = H, H = null, re += z, re > Es && E(re), { target: he, targetView: wn, position: re - z }), S) } finally { H && (he = H, wn = U, re = V, Es = he.length - 10) } G && (G.length + re > Es && E(G.length + re), re = x5(G, he, re, L.type)); return } } _(w, !w.hasOwnProperty) } } else if (M === "boolean") he[re++] = w ? 195 : 194; else if (M === "bigint") { if (w < BigInt(1) << BigInt(63) && w >= -(BigInt(1) << BigInt(63))) he[re++] = 211, wn.setBigInt64(re, w); else if (w < BigInt(1) << BigInt(64) && w > 0) he[re++] = 207, wn.setBigUint64(re, w); else if (this.largeBigIntToFloat) he[re++] = 203, wn.setFloat64(re, Number(w)); else throw new RangeError(w + " was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64"); re += 8 } else if (M === "undefined") this.encodeUndefinedAsNil ? he[re++] = 192 : (he[re++] = 212, he[re++] = 0, he[re++] = 0); else if (M === "function") S(this.writeFunction && this.writeFunction()); else throw new Error("Unknown type: " + M) }, _ = this.useRecords === !1 ? this.variableMapSize ? w => { let M = Object.keys(w), T = M.length; T < 16 ? he[re++] = 128 | T : T < 65536 ? (he[re++] = 222, he[re++] = T >> 8, he[re++] = T & 255) : (he[re++] = 223, wn.setUint32(re, T), re += 4); let I; for (let C = 0; C < T; C++)S(I = M[C]), S(w[I]) } : (w, M) => { he[re++] = 222; let T = re - n; re += 2; let I = 0; for (let C in w) (M || w.hasOwnProperty(C)) && (S(C), S(w[C]), I++); he[T++ + n] = I >> 8, he[T + n] = I & 255 } : w => { let M = Object.keys(w), T, I = o.transitions || (o.transitions = Object.create(null)), C = 0; for (let D = 0, L = M.length; D < L; D++) { let H = M[D]; T = I[H], T || (T = I[H] = Object.create(null), C++), I = T } let P = I[bf]; if (P) P >= 96 && m ? (he[re++] = ((P -= 96) & 31) + 96, he[re++] = P >> 5) : he[re++] = P; else { P = o.nextId, P || (P = 64), P < g && this.shouldShareStructure && !this.shouldShareStructure(M) ? (P = o.nextOwnId, P < y || (P = g), o.nextOwnId = P + 1) : (P >= y && (P = g), o.nextId = P + 1); let D = M.highByte = P >= 96 && m ? P - 96 >> 5 : -1; I[bf] = P, o[P - 64] = M, P < g ? (M.isShared = !0, o.sharedLength = P - 63, s = !0, D >= 0 ? (he[re++] = (P & 31) + 96, he[re++] = D) : he[re++] = P) : (D >= 0 ? (he[re++] = 213, he[re++] = 114, he[re++] = (P & 31) + 96, he[re++] = D) : (he[re++] = 212, he[re++] = 114, he[re++] = P), C && (x += b * C), v.length >= p && (v.shift()[bf] = 0), v.push(I), S(M)) } for (let D = 0, L = M.length; D < L; D++)S(w[M[D]]) }, E = w => { let M; if (w > 16777216) { if (w - n > iC) throw new Error("Packed buffer would be larger than maximum buffer size"); M = Math.min(iC, Math.round(Math.max((w - n) * (w > 67108864 ? 1.25 : 2), 4194304) / 4096) * 4096) } else M = (Math.max(w - n << 2, he.length - 1) >> 12) + 1 << 12; let T = new Nb(M); return wn = new DataView(T.buffer, 0, M), he.copy ? he.copy(T, 0, n, w) : T.set(he.slice(n, w)), re -= n, n = 0, Es = T.length - 10, he = T } } useBuffer (t) { he = t, wn = new DataView(he.buffer, he.byteOffset, he.byteLength), re = 0 } }; Bb = [Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor, xf]; Bg = [{ pack (i, t, e) { let n = i.getTime() / 1e3; if ((this.useTimestamp32 || i.getMilliseconds() === 0) && n >= 0 && n < 4294967296) { let { target: r, targetView: s, position: o } = t(6); r[o++] = 214, r[o++] = 255, s.setUint32(o, n) } else if (n > 0 && n < 17179869184) { let { target: r, targetView: s, position: o } = t(10); r[o++] = 215, r[o++] = 255, s.setUint32(o, i.getMilliseconds() * 4e6 + (n / 1e3 / 4294967296 >> 0)), s.setUint32(o + 4, n) } else if (isNaN(n)) { if (this.onInvalidDate) return t(0), e(this.onInvalidDate()); let { target: r, targetView: s, position: o } = t(3); r[o++] = 212, r[o++] = 255, r[o++] = 255 } else { let { target: r, targetView: s, position: o } = t(15); r[o++] = 199, r[o++] = 12, r[o++] = 255, s.setUint32(o, i.getMilliseconds() * 1e6), s.setBigInt64(o + 4, BigInt(Math.floor(n))) } } }, { pack (i, t, e) { let n = Array.from(i), { target: r, position: s } = t(this.structuredClone ? 3 : 0); this.structuredClone && (r[s++] = 212, r[s++] = 115, r[s++] = 0), e(n) } }, { pack (i, t, e) { let { target: n, position: r } = t(this.structuredClone ? 3 : 0); this.structuredClone && (n[r++] = 212, n[r++] = 101, n[r++] = 0), e([i.name, i.message]) } }, { pack (i, t, e) { let { target: n, position: r } = t(this.structuredClone ? 3 : 0); this.structuredClone && (n[r++] = 212, n[r++] = 120, n[r++] = 0), e([i.source, i.flags]) } }, { pack (i, t) { this.structuredClone ? sC(i, 16, t) : oC(Fg ? Buffer.from(i) : new Uint8Array(i), t) } }, { pack (i, t) { let e = i.constructor; e !== aC && this.structuredClone ? sC(i, Lb.indexOf(e.name), t) : oC(i, t) } }, { pack (i, t) { let { target: e, position: n } = t(1); e[n] = 193 } }]; function sC (i, t, e, n) { let r = i.byteLength; if (r + 1 < 256) { var { target: s, position: o } = e(4 + r); s[o++] = 199, s[o++] = r + 1 } else if (r + 1 < 65536) { var { target: s, position: o } = e(5 + r); s[o++] = 200, s[o++] = r + 1 >> 8, s[o++] = r + 1 & 255 } else { var { target: s, position: o, targetView: a } = e(7 + r); s[o++] = 201, a.setUint32(o, r + 1), o += 4 } s[o++] = 116, s[o++] = t, s.set(new Uint8Array(i.buffer, i.byteOffset, i.byteLength), o) } function oC (i, t) { let e = i.byteLength; var n, r; if (e < 256) { var { target: n, position: r } = t(e + 2); n[r++] = 196, n[r++] = e } else if (e < 65536) { var { target: n, position: r } = t(e + 3); n[r++] = 197, n[r++] = e >> 8, n[r++] = e & 255 } else { var { target: n, position: r, targetView: s } = t(e + 5); n[r++] = 198, s.setUint32(r, e), r += 4 } n.set(i, r) } function x5 (i, t, e, n) { let r = i.length; switch (r) { case 1: t[e++] = 212; break; case 2: t[e++] = 213; break; case 4: t[e++] = 214; break; case 8: t[e++] = 215; break; case 16: t[e++] = 216; break; default: r < 256 ? (t[e++] = 199, t[e++] = r) : r < 65536 ? (t[e++] = 200, t[e++] = r >> 8, t[e++] = r & 255) : (t[e++] = 201, t[e++] = r >> 24, t[e++] = r >> 16 & 255, t[e++] = r >> 8 & 255, t[e++] = r & 255) }return t[e++] = n, t.set(i, e), e += r, e } function b5 (i, t) { let e, n = t.length * 6, r = i.length - n; for (t.sort((s, o) => s.offset > o.offset ? 1 : -1); e = t.pop();) { let s = e.offset, o = e.id; i.copyWithin(s + n, s, r), n -= 6; let a = s + n; i[a++] = 214, i[a++] = 105, i[a++] = o >> 24, i[a++] = o >> 16 & 255, i[a++] = o >> 8 & 255, i[a++] = o & 255, r = s } return i } function ba (i) { if (i.Class) { if (!i.pack && !i.write) throw new Error("Extension has no pack or write function"); if (i.pack && !i.type) throw new Error("Extension has no type (numeric code to identify the extension)"); Bb.unshift(i.Class), Bg.unshift(i) } rC(i) } var lC = new Pl({ useRecords: !1 }), w5 = lC.pack, S5 = lC.pack; var { NEVER: A5, ALWAYS: _5, DECIMAL_ROUND: E5, DECIMAL_FIT: M5 } = Lg, cC = 512, T5 = 1024; var uC = new Pl({ structuredClone: !0 }); ba({ Class: Ut.prototype.constructor, type: 1, write (i) { return { ...i } }, read (i) { return Object.setPrototypeOf(i, Ut.prototype), i } }); ba({ Class: Ue.prototype.constructor, type: 2, write (i) { return [...i] }, read (i) { return Object.setPrototypeOf(i, Ue.prototype), i } }); ba({ Class: rn.prototype.constructor, type: 3, write (i) { return [...i] }, read (i) { return Object.setPrototypeOf(i, rn.prototype), i } }); ba({ Class: yf.prototype.constructor, type: 4, write (i) { return i.id }, read (i) { return new yf(i) } }); ba({ Class: vf.prototype.constructor, type: 5, write (i) { return i.data }, read (i) { return new vf(i) } }); ba({ Class: Vt.prototype.constructor, type: 6, write (i) { return { ...i } }, read (i) { return Object.setPrototypeOf(i, Vt.prototype), i } }); function C5 (i) { var t = 0; if (i.length === 0) return t; for (let e = 0; e < i.length; e++) { let n = i[e]; t = (t << 5) - t + n, t = t & t } return t } function Fb (i) { if (Mu(i)) return i; if (Array.isArray(i)) return i.map(Fb); if (typeof i == "object" && i !== null) { let t = {}; for (let e of Object.keys(i).sort()) t[e] = Fb(i[e]); return Object.setPrototypeOf(t, Object.getPrototypeOf(i)), t } else return i } var kg; (n => { function i (r) { return uC.pack(r) } n.serialize = i; function t (r) { return uC.unpack(r) } n.deserialize = t; function e (r) { return C5(i(Fb(r))).toString() } n.checksum = e })(kg || (kg = {})); var Ki = { ["LookAt"]: [], ["Follow"]: ["Create"], ["DragDrop"]: ["Transition", "Animation", "Audio", "Create"], ["MouseHover"]: ["Transition", "Animation", "Create", "Destroy", "SwitchCamera", "SceneTransition"], ["Scroll"]: ["Transition", "Animation", "Create"], ["Start"]: ["Transition", "Animation", "Audio", "Video", "Create", "Destroy", "SwitchCamera", "SceneTransition"], ["Conditional"]: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset"], ["MouseDown"]: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset"], ["MouseUp"]: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset"], ["MousePress"]: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "SwitchCamera", "SceneTransition", "Reset"], ["KeyDown"]: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset"], ["KeyUp"]: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset"], ["KeyPress"]: ["Transition", "Animation", "Audio", "Video", "Link", "Create", "SwitchCamera", "Reset"], ["GameControl"]: ["Transition", "Animation", "Audio", "Video", "Create"], ["Collision"]: ["Transition", "Animation", "Audio", "Video", "Create", "Destroy", "Reset"], ["Trigger"]: ["Transition", "Audio", "Video", "Link", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset"], ["Resize"]: ["Transition", "Animation", "Audio", "Video", "Create", "Destroy", "SwitchCamera", "SceneTransition", "Reset"] }, hC; (e => { function i (n) { return n.type === "MouseDown" || n.type === "MouseUp" || n.type === "MousePress" || n.type === "KeyDown" || n.type === "KeyUp" || n.type === "KeyPress" } e.is = i; function t (n) { return n === "MouseDown" || n === "MouseUp" || n === "MousePress" ? { type: n, mode: "Object", disabled: !1, toggle: !1, actions: new Ue } : { type: n, disabled: !1, key: void 0, toggle: !1, actions: new Ue } } e.defaultData = t })(hC || (hC = {})); var Ug; (e => { function i (n) { return { type: "Property", value: [n ?? null, "position", "x"] } } e.propertyDefaultData = i, e.valueDefaultData = { type: "Literal", value: 0 } })(Ug || (Ug = {})); var kb; (n => { function i (r) { return { type: "Comparison", operator: "==", lOperand: Ug.propertyDefaultData(r), rOperand: { ...Ug.valueDefaultData } } } n.comparisonDefaultData = i; function t (r) { return { type: "Distance", toObject: r ?? null, fromObject: r ?? null, distance: 200 } } n.distanceDefaultData = t; function e (r, s) { return { type: "State", object: r ?? null, state: s ?? null } } n.stateDefaultData = e })(kb || (kb = {})); var dC; (e => { function i (n) { return n.type === "Conditional" } e.is = i; function t (n) { return { type: "Conditional", disabled: !1, inActions: new Ue, outActions: new Ue, condition: kb.distanceDefaultData(n) } } e.defaultData = t })(dC || (dC = {})); var fC; (t => t.defaultData = { type: "DragDrop", cursor: "hand", disabled: !1, dampingFactor: 1, objects: [], snapTo: "center", snapSurfaceMode: "bbox", snapSurfaceOffset: 0, dropOn: "all", autoOrient: !0, dropDestinations: [], plane: "adaptive", planeMode: "locked", referenceFrame: "global", limits: [-1 / 0, 1 / 0, -1 / 0, 1 / 0, -1 / 0, 1 / 0], drop: !1, resetOnSnapFail: !1, snapSpeed: 20, resetSpeed: 20, dragDropActions: { drag: new Ue, drop: new Ue } })(fC || (fC = {})); var zg; (t => t.defaultData = { type: "Follow", disabled: !1, maxDelta: 0, dampingFactor: 1, target: "cursor", plane: "custom", resetOnPointerLeave: !0, resetAfterDistanceLimit: !0, enabledTranslation: [!0, !0, !0], limitDistanceEnabled: !1, limitDistance: 1e3, snapDelay: 0, resetSpeed: 5, actions: new Ue })(zg || (zg = {})); var Gg; (t => t.defaultData = { type: "LookAt", disabled: !1, distance: 1e3, dampingFactor: 1, target: "cursor", tilt: "up", axis: "z", plane: "custom", resetOnPointerLeave: !0, resetAfterDistanceLimit: !0, enabledRotation: [!0, !0, !0], limitDistanceEnabled: !1, limitDistance: 1e3, snapDelay: 0, resetSpeed: 5 })(Gg || (Gg = {})); var pC; (e => { function i (n) { return n.type === "MouseHover" } e.is = i; function t () { return { type: "MouseHover", disabled: !1, actions: new Ue } } e.defaultData = t })(pC || (pC = {})); var mC; (e => { function i (n) { return n.type === "Scroll" } e.is = i; function t () { return { type: "Scroll", disabled: !1, steps: 100, trigger: "load", startFrom: "enter", enterAnchor: "top", startOffset: 0, endAfter: 400, actions: new Ue } } e.defaultData = t })(mC || (mC = {})); var gC; (e => { function i (n) { return n.type === "Start" } e.is = i; function t () { return { type: "Start", disabled: !1, actions: new Ue } } e.defaultData = t })(gC || (gC = {})); var yC; (e => { function i (n) { return n.type === "Collision" } e.is = i; function t () { return { type: "Collision", disabled: !1, toggle: !1, target: "character", actions: new Ue } } e.defaultData = t })(yC || (yC = {})); var vC; (e => { function i (n) { return n.type === "Trigger" } e.is = i; function t (n, r) { return { type: "Trigger", disabled: !1, toggle: !1, target: "all", triggeringObjects: [], actions: new Ue, triggerZone: "box", position: r.toArray(), rotation: [0, 0, 0], size: n.toArray(), radius: n.length() / 2, helperVisible: !0 } } e.defaultData = t })(vC || (vC = {})); var Vg; (o => { o.defaultSizes = { mobile: [480, 480], tablet: [768, 768], desktop: [1200, 1200], custom: [769, 1200] }; function t (a) { return a.type === "Resize" } o.is = t; function e (a) { return typeof a == "string" ? a : "custom" } o.sizeToDevice = e; function n (a) { return typeof a == "string" ? [...o.defaultSizes[a]] : [...a] } o.deviceToSize = n; function r () { let a = { size: "mobile", operator: "<", actions: new Ue }, l = { size: "tablet", operator: "<", actions: new Ue }, u = { size: [...o.defaultSizes.custom], operator: "<>", actions: new Ue }, c = new Ue; return c.push({ id: Ge.generateUUID(), fi: 0, data: a }, { id: Ge.generateUUID(), fi: 1, data: l }, { id: Ge.generateUUID(), fi: 2, data: u }), { type: "Resize", disabled: !1, orientation: "horizontal", breakpoints: c } } o.defaultData = r; function s () { return { size: [...o.defaultSizes.custom], operator: "<>", actions: new Ue } } o.defaultBreakpointData = s })(Vg || (Vg = {})); var Ti = "personal camera", Sa = "a218fcc3-276b-49b9-b485-49037fd14f5f", wC = 2960946, qn = 5526619; var Il; (e => { function i (n, r) { return n[0] === r[0] && n[1] === r[1] } e.isEqual = i; function t (n, r, s) { return [n[0] + (r[0] - n[0]) * s, n[1] + (r[1] - n[1]) * s] } e.lerp = t })(Il || (Il = {})); var Ts; (a => { function i (l, u) { return l[0] === u[0] && l[1] === u[1] && l[2] === u[2] } a.isEqual = i; function t (l, u) { return [l[0] + u[0], l[1] + u[1], l[2] + u[2]] } a.add = t; function e (l, u) { return [l[0] - u[0], l[1] - u[1], l[2] - u[2]] } a.sub = e; function n (l, u) { return [l[0] / u[0], l[1] / u[1], l[2] / u[2]] } a.div = n; function r (l, u) { return [l[0] * u[0], l[1] * u[1], l[2] * u[2]] } a.mul = r; function s (l, u) { return Math.hypot(l[0] - u[0], l[1] - u[1], l[2] - u[2]) } a.dist = s; function o (l, u, c) { return [l[0] + (u[0] - l[0]) * c, l[1] + (u[1] - l[1]) * c, l[2] + (u[2] - l[2]) * c] } a.lerp = o })(Ts || (Ts = {})); var wf; (e => { function i (n, r) { return n[0] === r[0] && n[1] === r[1] && n[2] === r[2] && n[3] === r[3] } e.isEqual = i; function t (n, r, s) { return [n[0] + (r[0] - n[0]) * s, n[1] + (r[1] - n[1]) * s, n[2] + (r[2] - n[2]) * s, n[3] + (r[3] - n[3]) * s] } e.lerp = t })(wf || (wf = {})); var wa; (r => { r.identity = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]; function t (s, o) { for (let a = 0; a < 16; a++)if (s[a] !== o[a]) return !1; return !0 } r.isEqual = t; function e (s) { return s ?? r.identity } r.simplify = e; function n (s, o) { let a = o.slice(0); for (var l = 0, u = o.length; l < u; l += 3) { let c = s[3] * o[l] + s[7] * o[l + 1] + s[11] * o[l + 2] + s[15]; a[l] = (s[0] * o[l] + s[4] * o[l + 1] + s[8] * o[l + 2] + s[12]) / c, a[l + 1] = (s[1] * o[l] + s[5] * o[l + 1] + s[9] * o[l + 2] + s[13]) / c, a[l + 2] = (s[2] * o[l] + s[6] * o[l + 1] + s[10] * o[l + 2] + s[14]) / c } return a } r.applyMatrix4 = n })(wa || (wa = {})); var or; (c => { function i (h) { return typeof h == "object" && typeof h.r == "number" && typeof h.g == "number" && typeof h.b == "number" } c.isRGB = i, c.white = { r: 1, g: 1, b: 1 }, c.red = { r: 1, g: 0, b: 0 }, c.black = { r: 0, g: 0, b: 0 }; function r (h) { return { r: Math.round(h.r * 255), g: Math.round(h.g * 255), b: Math.round(h.b * 255), a: 1 } } c.toRgb255a1 = r; function s (h) { return { r: h.r, g: h.g, b: h.b } } c.clone = s; function o (h) { return h = Math.floor(h), { r: (h >> 16 & 255) / 255, g: (h >> 8 & 255) / 255, b: (h & 255) / 255 } } c.fromHex = o; function a (h) { return Math.round(h.r * 255) * 65536 + Math.round(h.g * 255) * 256 + Math.round(h.b * 255) } c.toHex = a; function l (h, d) { return h.r === d.r && h.g === d.g && h.b === d.b } c.equals = l; function u (h, d, f) { return { r: h.r + (d.r - h.r) * f, g: h.g + (d.g - h.g) * f, b: h.b + (d.b - h.b) * f } } c.lerp = u })(or || (or = {})); var Ur; (a => { a.white = { ...or.white, a: 1 }, a.transparent = { ...or.white, a: 0 }; function e (l) { return { r: l[0], g: l[1], b: l[2], a: l[3] } } a.from0to1 = e; function n (l, u) { return { ...or.fromHex(l), a: u } } a.fromHexAndA = n; function r (l) { return { r: Math.round(l.r * 255), g: Math.round(l.g * 255), b: Math.round(l.b * 255), a: l.a } } a.toRgb255a1 = r; function s (l, u) { return or.equals(l, u) && l.a === u.a } a.equals = s; function o (l, u, c) { return { r: l.r + (u.r - l.r) * c, g: l.g + (u.g - l.g) * c, b: l.b + (u.b - l.b) * c, a: l.a + (u.a - l.a) * c } } a.lerp = o })(Ur || (Ur = {})); var Hg; (t => t.identity = { position: [0, 0, 0], rotation: [0, 0, 0], scale: [1, 1, 1] })(Hg || (Hg = {})); var xC; (t => t.defaultData = { mass: 1, stiffness: 80, damping: 10, velocity: 0 })(xC || (xC = {})); var bC; (t => t.defaultData = { control1: [.5, 0], control2: [.5, 1] })(bC || (bC = {})); var Eo; (s => (s.linear = [0, 0, 1, 1], s.ease = [.25, .1, .25, 1], s.easeIn = [.42, 0, 1, 1], s.easeOut = [0, 0, .58, 1], s.easeInOut = [.42, 0, .58, 1]))(Eo || (Eo = {})); var Zi; (e => { e.all = ["PerspectiveCamera", "OrthographicCamera"]; function t (n) { return e.all.includes(n) } e.is = t })(Zi || (Zi = {})); var Aa; (r => { r.DefaultUp = [0, 1, 0], r.DefaultTargetOffset = 1e3, r.defaultData = { far: 1e5, type: "OrthographicCamera", perspective: { near: 70, fov: 45, zoom: 1 }, orthographic: { near: -1e5, zoom: 1 }, up: r.DefaultUp, isUpVectorFlipped: !1, targetOffset: r.DefaultTargetOffset }; function n (s) { return s.type === "PerspectiveCamera" ? s.perspective.zoom : s.orthographic.zoom } r.getZoom = n })(Aa || (Aa = {})); var Cs; (e => { function i (n, r = .1) { return { disabled: !1, type: "linear", hideBase: !1, count: 3, radial: { radius: Math.max(n[0], n[1]) * 2, start: 0, end: 360, alignment: !1, axis: "y", scale: [1, 1, 1], rotation: [0, 0, 0], position: [0, 0, 0] }, toObject: { object: "", spreadType: "random", scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], axis: "x", seed: 0, count: 99, align: "normal" }, linear: { scale: [1, 1, 1], rotation: [0, 0, 0], position: [n[0] + n[0] * r, 0, 0] }, grid: { count: [2, 2, 2], size: n.map(s => s * (1 + r)), useCenter: !0 }, randomness: !1, randomnessObject: { strength: 100, scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], movement: 1, seed: 0, freqScale: 10, noiseType: "perlin" } } } e.defaultData = i; function t (n, r) { let s = { ...n }; if (Ub.forEach(o => { Object.assign(s, { [o]: r[o] ?? n[o] }) }), s.radial = { ...n.radial }, r.radial) { let o = n.radial, a = r.radial; zb.forEach(l => { Object.assign(s.radial, { [l]: a[l] ?? o[l] }) }) } if (s.linear = { ...n.linear }, r.linear) { let o = n.linear, a = r.linear; Gb.forEach(l => { Object.assign(s.linear, { [l]: a[l] ?? o[l] }) }) } if (s.grid = { ...n.grid }, r.grid) { let o = n.grid, a = r.grid; Vb.forEach(l => { Object.assign(s.grid, { [l]: a[l] ?? o[l] }) }) } if (s.toObject = { ...n.toObject }, r.toObject) { let o = n.toObject, a = r.toObject; Hb.forEach(l => { Object.assign(s.toObject, { [l]: a[l] ?? o[l] }) }) } if (s.randomnessObject = { ...n.randomnessObject }, r.randomnessObject) { let o = n.randomnessObject, a = r.randomnessObject; jb.forEach(l => { Object.assign(s.randomnessObject, { [l]: a[l] ?? o[l] }) }) } return s } e.merge = t })(Cs || (Cs = {})); var jg; (n => { n.defaultData = { radial: {}, linear: {}, grid: {}, toObject: {}, randomnessObject: {} }; let t = ["radial", "linear", "grid", "toObject", "randomnessObject"]; function e (r, s) { let o = []; r.count !== void 0 && o.push({ type: 0, path: s, props: { count: r.count } }); for (let a of t) { let l = r[a]; l && Object.keys(l).length > 0 && o.push({ type: 0, path: [...s, a], props: l }) } return o } n.toOps = e })(jg || (jg = {})); var Ub = ["count"], zb = ["radius", "start", "end", "position", "scale", "rotation"], Gb = ["position", "scale", "rotation"], Vb = ["count", "size"], Hb = ["count", "position", "scale", "rotation"], jb = ["strength", "scale", "rotation", "position", "movement", "seed", "freqScale"]; var Wg; (e => { e.all = ["PointLight", "SpotLight", "DirectionalLight", "HemisphereLight"]; function t (n) { return e.all.includes(n) } e.is = t })(Wg || (Wg = {})); var qg; (e => { function i (n) { return t(n) } e.defaultData = i; function t (n) { if (n === "PointLight") return { type: n, color: Ur.white, intensity: 1, distance: 2e3, decay: 1, shadows: !0, shadowResolution: 1024, shadowRadius: 1, penumbraSize: .5, depth: 1e5 }; if (n === "SpotLight") return { type: n, color: Ur.white, intensity: 1, distance: 2e3, decay: 1, shadows: !0, penumbra: 0, angle: 30 / 180 * Math.PI, depth: 1e5, penumbraSize: .5, shadowResolution: 1024, shadowRadius: 1 }; if (n === "DirectionalLight") return { type: n, color: Ur.white, intensity: 1, shadows: !0, size: 2e3, depth: 1e5, penumbraSize: .5, shadowResolution: 1024, shadowRadius: 1 }; throw new Error("not implemented") } })(qg || (qg = {})); var _a; (t => t.defaultData = { enabled: "visibility", fusedBody: !0, rigidBody: "positioned", density: 1, pointMass: 0, gravityScale: 1, friction: .5, damping: 0, restitution: .2, colliderType: "convex", enabledRotation: [!0, !0, !0], enabledTranslation: [!0, !0, !0] })(_a || (_a = {})); var Wb; (e => { e.defaultData = { castShadow: !0, receiveShadow: !0 }; function t (n, r) { return n.castShadow === r.castShadow && n.receiveShadow === r.receiveShadow } e.equals = t })(Wb || (Wb = {})); var qb; (e => { e.defaultData = { flatShading: !1, wireframe: !1, side: 0 }; function t (n, r) { return n.flatShading === r.flatShading && n.side === r.side && n.wireframe === r.wireframe } e.equals = t })(qb || (qb = {})); var Yg; (t => t.defaultData = { ...qb.defaultData, ...Wb.defaultData })(Yg || (Yg = {})); var Ru; (e => (e.defaultVideo = { data: "", thumb: "/_assets/_videos/catThumb.png", type: "video", name: "Cat video" }, e.maxSize = 3e7))(Ru || (Ru = {})); var SC; (t => { function i (e) { return e === "texture" || e === "video" || e === "color" || e === "depth" || e === "normal" || e === "gradient" || e === "noise" || e === "fresnel" || e === "rainbow" || e === "toon" || e === "outline" || e === "transmission" || e === "matcap" || e === "displace" || e === "pattern" || e === "light" } t.is = i })(SC || (SC = {})); function _C (i) { return i.type !== "displace" } var AC; (t => { function i (e) { return e === "phong" || e === "toon" || e === "lambert" || e === "physical" } t.is = i })(AC || (AC = {})); var Xg = ["mode", "gradientType", "noiseType", "displacementType", "projection", "cnormal", "crop", "axis", "side"], EC = ["wrapping", "image", "video", "name"], ar; (r => { function i (s, o) { let { texture: a, ...l } = o; if (Object.assign(s, l), a) { let u = s.texture; u && Object.assign(u, a) } } r.patch = i; function t (s, o) { return s === "light" && o ? e(o) : n(s) } r.defaultData = t; function e (s) { let o = { mode: 0, isMask: !1, visible: !0, bumpMap: void 0, bumpMapIntensity: 5, roughnessMap: void 0, alphaOverride: 1 }; switch (s) { case "phong": return { ...o, category: "phong", specular: { r: .2, g: .2, b: .2 }, shininess: 5, type: "light", visible: !0, mode: 0, occlusion: !0, alpha: .6 }; case "toon": return { ...o, category: "toon", specular: { r: .2, g: .2, b: .2 }, shininess: 10, type: "light", alpha: 1 }; case "lambert": return { ...o, category: "lambert", emissive: { r: 0, g: 0, b: 0 }, type: "light", alpha: 1, visible: !0, mode: 0, occlusion: !0 }; case "physical": return { ...o, category: "physical", roughness: .2, metalness: .2, reflectivity: .2, type: "light", alpha: 1, visible: !0, mode: 0, occlusion: !0 } } } function n (s) { let o = { alpha: 1, mode: 0, isMask: !1, visible: !0 }; switch (s) { case "texture": return { ...o, type: "texture", size: [128, 128], blending: 0, axis: "x", side: 2, projection: 0, texture: { image: "image_0", wrapping: 1e3, repeat: [1, 1], offset: [0, 0] }, crop: !1 }; case "video": return { ...o, type: "video", size: [128, 128], blending: 0, axis: "x", side: 2, projection: 0, texture: { video: Ru.defaultVideo, wrapping: 1001, repeat: [1, 1], offset: [0, 0] }, crop: !1 }; case "color": return { ...o, type: "color", color: or.fromHex(qn) }; case "depth": return { ...o, type: "depth", gradientType: 1, smooth: !1, isVector: !0, isWorldSpace: !1, origin: [0, 0, 0], direction: [1, 0, 0], colors: [[1, 1, 1, 1], [0, 0, 0, 1]], steps: [0, 1], near: 50, far: 200 }; case "normal": return { ...o, type: "normal", cnormal: [1, 1, 1] }; case "gradient": return { ...o, type: "gradient", gradientType: 0, smooth: !1, colors: [[0, 0, 0, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], steps: [0, 1, 1, 1, 1, 1, 1, 1, 1, 1], num: 2, angle: 0, offset: [0, 0], morph: [0, 0] }; case "noise": return { ...o, type: "noise", size: [100, 100, 100], noiseType: 0, scale: 1, move: 1, colorA: { ...or.fromHex(6710886), a: 1 }, colorB: { ...or.fromHex(6710886), a: 1 }, colorC: { ...or.fromHex(16777215), a: 1 }, colorD: { ...or.fromHex(16777215), a: 1 }, distortion: [1, 1], fA: [1.7, 9.2], fB: [8.3, 2.8], voronoiStyle: 0, highCut: 1, lowCut: 0, smoothness: .3, seed: 0, quality: 1 }; case "fresnel": return { ...o, type: "fresnel", color: Ur.fromHexAndA(16777215, 1), bias: .1, scale: 1, intensity: 2, factor: 1 }; case "rainbow": return { ...o, type: "rainbow", filmThickness: 30, movement: 0, wavelengths: [0, 0, 0], noiseStrength: 0, noiseScale: 1, offset: [0, 0, 0] }; case "toon": return { ...o, type: "toon", positioning: 2, colors: [[0, 0, 0, 1], [.5, .5, .5, 1], [.5, .5, .5, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]], steps: [0, .475, .525, 1, 1, 1, 1, 1, 1, 1], num: 4, source: [0, 1e3, 0], isWorldSpace: !0, noiseStrength: 0, noiseScale: 1, shadowColor: Ur.fromHexAndA(0, 0), offset: [0, 0, 0] }; case "outline": return { ...o, type: "outline", outlineColor: Ur.fromHexAndA(0, 1), contourColor: Ur.fromHexAndA(0, 1), outlineWidth: 2, contourWidth: 5, outlineThreshold: .4, contourThreshold: 0, outlineSmoothing: 0, contourFrequency: 10, contourDirection: [0, 1, 0], positionalLines: !1, compensation: !0 }; case "matcap": return { ...o, type: "matcap", texture: { image: "matcap_0", wrapping: 1001, repeat: [1, 1], offset: [0, 0] } }; case "transmission": return { ...o, type: "transmission", thickness: 10, ior: 1.5, roughness: 1 }; case "displace": return { visible: !0, type: "displace", displacementType: "noise", noiseType: 0, scale: 10, movement: 1, offset: [0, 0, 0], intensity: 8, voronoiStyle: 0, smoothness: .3, seed: 0, highCut: 1, lowCut: 0, quality: 1 }; case "pattern": return { ...o, type: "pattern", style: 0, projection: 0, axis: "y", blending: 0, offset: [0, 0], colorA: { ...or.fromHex(0), a: 1 }, colorB: { ...or.fromHex(16777215), a: 1 }, frequency: [10, 10], size: .5, variation: 0, smoothness: .5, zigzag: 0, rotation: 0, vertical: [0, 1], horizontal: [0, 1], sides: 6 } } } })(ar || (ar = {})); var Sn; (l => { function i (u) { return !u.layers.some(h => h.data.type === "texture" && h.data.projection !== 0 || h.data.type === "depth" && !h.data.isWorldSpace || h.data.type === "noise" || h.data.type === "displace") } l.isMergable = i; function t (u) { let c = ""; return u.layers.forEach(h => { Object.entries(h.data).forEach(([d, f]) => { c += `${d}${f}`, Array.isArray(f) ? f.forEach(p => c += `${p}`) : typeof f == "object" ? Object.values(f).forEach(p => { typeof p == "number" ? c += `${p.toFixed(4)}` : c += `${p}` }) : c += `${f}` }) }), c } l.getHash = t; function e () { return { layers: new Ue } } l.defaultEmptyData = e; function n (u = "layer1", c = "layer2") { return s("phong", u, c) } l.defaultData = n; function r (u, c) { return { ...u, name: c } } l.withName = r; function s (u, c = "layer1", h = "layer2") { let d = new Ue; return d.push({ fi: 0, data: ar.defaultData("light", u), id: c }), d.push({ fi: 1, data: ar.defaultData("color"), id: h }), { layers: d } } l.defaultTwoLayerData = s; function o (u, c = "phong", h = "layer1", d = "layer2") { let f = ar.defaultData("texture"); Object.assign(f.texture, { image: u }); let p = new Ue; return p.push({ fi: 0, data: f, id: h }), p.push({ fi: 1, data: ar.defaultData("light", c), id: d }), { layers: p } } l.defaultTwoLayerTextureData = o; function a (u, c = "phong", h = "layer1", d = "layer2") { let f = ar.defaultData("video"); Object.assign(f.texture, { video: u }); let p = new Ue; return p.push({ fi: 0, data: f, id: h }), p.push({ fi: 1, data: ar.defaultData("light", c), id: d }), { layers: p } } l.defaultTwoLayerVideoTextureData = a })(Sn || (Sn = {})); var Lu; (t => { function i () { return { points: new Ue, roundness: 0, shapeHoles: [], isClosed: !1 } } t.defaultData = i })(Lu || (Lu = {})); var Nu; (t => { function i () { return { points: new Ue, lastInsertionPlane: null, subdivisions: 12, isClosed: !1 } } t.defaultData = i })(Nu || (Nu = {})); var Yb = { type: "Ellipse", width: 100, height: 100, spikes: 16, angle: 360, innerRadius: 0 }; var Qg; (t => { function i (e, n) { let r = { ...e }; return Xb.forEach(s => { Object.assign(r, { [s]: n[s] ?? e[s] }) }), r } t.merge = i })(Qg || (Qg = {})); var Kg = { shape: Yb, depth: 1, offset: 0, bevel: 50, bevelSides: 6, angle: 0, twist: 0, startScale: 1, endScale: 1, capType: "flat" }, Xb = ["depth", "offset", "angle", "twist", "startScale", "endScale"]; var Sf; (e => { function i (n) { return n === "PolygonGeometry" || n === "RectangleGeometry" || n === "StarGeometry" || n === "TriangleGeometry" || n === "EllipseGeometry" } e.is2DParametricMesh = i; function t (n) { return n === "PolygonGeometry" || n === "PolygonGeometry" || n === "RectangleGeometry" || n === "StarGeometry" || n === "TriangleGeometry" || n === "EllipseGeometry" || n === "PathGeometry" || n === "VectorGeometry" || n === "ConeGeometry" || n === "CubeGeometry" || n === "CylinderGeometry" || n === "DodecahedronGeometry" || n === "HelixGeometry" || n === "IcosahedronGeometry" || n === "LatheGeometry" || n === "PyramidGeometry" || n === "SphereGeometry" || n === "PlaneGeometry" || n === "BackdropGeometry" || n === "TorusGeometry" || n === "TorusKnotGeometry" || n === "BooleanGeometry" || n === "TextGeometry" } e.isParametricMesh = t })(Sf || (Sf = {})); var Zg; (t => { function i (e, n) { let r = { ...e }; return Object.assign(r, n), r.type === "PathGeometry" && "extrusion" in n && n.extrusion && (r.extrusion = { ...e.extrusion }, Object.assign(r.extrusion, Qg.merge(r.extrusion, n.extrusion))), r } t.merge = i })(Zg || (Zg = {})); var Ea; (t => { function i (e) { if (e === "RectangleGeometry") return { width: 320, height: 320, type: e, cornerRadius: [0, 0, 0, 0], cornerType: 0, depth: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 }; if (e === "PathGeometry") return { type: e, width: 1, height: 1, depth: 1, path: Nu.defaultData(), extrusion: Kg }; if (e === "VectorGeometry") return { width: 1, height: 1, type: e, subdivisions: 12, shape: Lu.defaultData(), depth: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 }; if (e === "BooleanGeometry") return { type: e, operation: 2, width: 0, height: 0, depth: 0, phongAngle: 35 }; if (e === "TextGeometry") return { type: e, width: 100, height: 100, depth: 0, horizontalAlign: 1, verticalAlign: 1, fontSize: 16, lineHeight: 1.2, letterSpacing: 0, text: "", textTransform: 1, font: "Roboto_regular", extrudeBevelSize: 0, extrudeBevelSegments: 1 }; if (e === "SphereGeometry") return { type: "SphereGeometry", width: 100, height: 100, depth: 100, widthSegments: 64, heightSegments: 64, phiStart: 0, phiLength: 2 * Math.PI, thetaStart: 0, thetaLength: Math.PI }; throw new Error("not implemented") } t.defaultData = i })(Ea || (Ea = {})); var Qb = ["width", "height", "depth"]; var Jg; (t => t.defaultData = { enabled: !1, useBackgroundColor: !1, color: or.white, near: .1, far: 2e3 })(Jg || (Jg = {})); var Bu; (e => { let i = { opacity: 1, blendFunction: 13, enabled: !1 }; e.defaultData = { enabled: !1, pixelation: { ...i, blendFunction: 16, granularity: 15 }, bloom: { ...i, blendFunction: 16, intensity: 1, blurScale: 1, luminanceThreshold: .25, luminanceSmoothing: .025, kernelSize: 3 }, chromaticAberration: { ...i, offset: [2, 2] }, vignette: { ...i, darkness: 1, offset: 0 }, hueSaturation: { ...i, hue: 3, saturation: 0 }, brightnessContrast: { ...i, brightness: .25, contrast: 0 }, depthOfField: { ...i, focalLength: 2, focusDistance: 2, bokehScale: 2 }, noise: { ...i, blendFunction: 16 } } })(Bu || (Bu = {})); var Kb; (t => t.defaultData = { softShadowQuality: "low" })(Kb || (Kb = {})); var Zb; (t => t.defaultData = { enabled: !0, color: { r: .8274509803921568, g: .8274509803921568, b: .8274509803921568 }, intensity: .75 })(Zb || (Zb = {})); var Jb; (t => t.defaultData = { occlusion: !1, aoFullRes: !1, radius: 256, bias: .5, aoColor: { r: .19607843137254902, g: .19607843137254902, b: .19607843137254902 } })(Jb || (Jb = {})); var Ma; (t => t.defaultData = { usePhysics: !1, gravity: -10 })(Ma || (Ma = {})); var $b; (t => t.defaultData = { playCamera: Ti, gameControlObject: null })($b || ($b = {})); var $g; (t => t.defaultData = { backgroundColor: Ur.fromHexAndA(wC, 1), postprocessing: Bu.defaultData, fog: Jg.defaultData, globalPhysics: Ma.defaultData, ambient: Zb.defaultData, ao: Jb.defaultData, shadow: Kb.defaultData, publish: $b.defaultData })($g || ($g = {})); var MC; (e => { function i (n) { return n === "Component" || n === "Instance" } e.isComponentRelated = i; function t (n) { return n === "Empty" || n === "Instance" } e.isEmptyOrComponent = t })(MC || (MC = {})); var Fu; (r => { r.identity = { ...Hg.identity, hiddenMatrix: wa.identity }; function t (s) { return { position: s.position, rotation: s.rotation, scale: s.scale, hiddenMatrix: s.hiddenMatrix } } r.fromObject = t; function e (s, o) { return { position: o?.position || s.position, rotation: o?.rotation || s.rotation, scale: o?.scale || s.scale, hiddenMatrix: o?.hiddenMatrix || s.hiddenMatrix } } r.merge = e; function n (s, o) { return bT({ position: Ts.isEqual(s.position, o.position) ? void 0 : o.position, rotation: Ts.isEqual(s.rotation, o.rotation) ? void 0 : o.rotation, scale: Ts.isEqual(s.scale, o.scale) ? null : o.scale, hiddenMatrix: wa.isEqual(s.hiddenMatrix, o.hiddenMatrix) ? void 0 : o.hiddenMatrix }) } r.diff = n })(Fu || (Fu = {})); var br; (t => t.defaultData = { states: new Ue, events: new Ue, visible: !0, raycastLock: !1, physics: _a.defaultData, pathSnapping: { pathId: null, slide: 0, offset: 0, orientation: "tangential" }, ...Fu.identity, cloner: null })(br || (br = {})); var TC; (t => t.defaultData = { type: "Empty", ...br.defaultData })(TC || (TC = {})); var CC; (t => t.defaultData = { type: "Component", ...br.defaultData })(CC || (CC = {})); var Dl; (t => t.defaultData = { type: "Mesh", ...br.defaultData, ...Yg.defaultData })(Dl || (Dl = {})); var Ol; (t => t.defaultData = { ...br.defaultData, ...Fu.identity, position: [0, 0, Aa.DefaultTargetOffset], ...Aa.defaultData })(Ol || (Ol = {})); var ey; (e => { function i (n) { return { ...br.defaultData, ...qg.defaultData(n) } } e.defaultData = i, e.defaultDirectionalLightData = { ...e.defaultData("DirectionalLight"), position: [200, 300, 300], name: "Directional Light", intensity: .7 } })(ey || (ey = {})); var ku; (e => { function i (n, r, s = 0) { for (; s < r.length;) { let o = n ? n[r[s]] : void 0; if (r.length === s + 1) return o; if (o) n = o.descendants, s += 1; else return } } e.resolveWithDes = i; function t (n, r, s = 0) { let o = i(n, r, s); if (o) { let a = Object.keys(o); if (a.length === 1 && a[0] === "descendants") return } return o } e.resolve = t })(ku || (ku = {})); var Ps; (s => { s.rootOverrideProps = ["physics", "events"], s.compositeNonOptionalOverrideProps = ["geometry"], s.compositeEntireOverrideOverrideProps = ["material"]; function n (o, a) { return { ...br.defaultData, ...a, component: o, overrides: new Vt, physics: void 0, events: void 0, type: "Instance" } } s.ofComponent = n; function r (o) { let a = Fu.fromObject(o.data); return n(o.id, a) } s.fromComponentData = r })(Ps || (Ps = {})); var Mo; (t => t.defaultData = { type: "Page", ...br.defaultData, physics: { ..._a.defaultData, fusedBody: !1 }, ...$g.defaultData, camera: Ol.defaultData })(Mo || (Mo = {})); var ty; (s => (s.defaultCamera = { position: [0, 0, 1e3], scale: [1, 1, 1], rotation: [0, 0, 0], hiddenMatrix: wa.identity, name: "Play Camera", visible: !0, raycastLock: !1, physics: _a.defaultData, states: new Ue, events: new Ue, cloner: null, pathSnapping: { pathId: null, orientation: "tangential", slide: 0, offset: 0 }, ...Aa.defaultData }, s.KeysByResetCategory = { States: ["states"], Events: ["events"], Material: ["material", "materials"], Geometry: ["geometry"], Position: ["position"], Rotation: ["rotation"], Scale: ["scale"], Transform: ["position", "scale", "rotation", "hiddenMatrix"], Name: ["name"], Visibility: ["visible", "raycastLock", "flatShading", "wireframe", "side"], Shadows: ["castShadow", "receiveShadow"], Cloner: ["cloner"], Physics: ["physics"] }, s.defaultMeshObject = { name: "Rectangle", ...br.defaultData, ...Dl.defaultData, geometry: Ea.defaultData("RectangleGeometry"), material: Sn.defaultTwoLayerData("phong", "layer1", "layer2") }, s.defaultBooleanObject = { name: "Boolean", ...br.defaultData, ...Dl.defaultData, geometry: Ea.defaultData("BooleanGeometry"), material: Sn.defaultTwoLayerData("phong", "layer1", "layer2") }, s.defaultTextObject = { name: "Text", ...br.defaultData, ...Dl.defaultData, geometry: Ea.defaultData("TextGeometry"), material: Sn.defaultTwoLayerData("phong", "layer1", "layer2") }))(ty || (ty = {})); var To; (r => { function i (s, o) { let a = { name: o }; return s.type === "Mesh" ? (a.geometry = {}, "material" in s && (a.material = { layers: new Vt }), "materials" in s && (a.materials = s.materials.map(l => ({ layers: new Vt })))) : Zi.is(s.type) && (a.perspective = {}, a.orthographic = {}), a } r.newEmpty = i; function t (s, o) { if (o === void 0) return s; let a = { ...s }; return "material" in a && "material" in o && o.material && (a.material = Du(a.material, l => { if (typeof l != "string") for (let [u, c] of Object.entries(o.material.layers)) { let h = l.layers.data(u); h && ar.patch(h, c) } }).data), a.materials && o.materials && (a.materials = Du(a.materials, l => { for (let u = 0; u < a.materials.length; u++) { let c = o.materials[u]; if (typeof c != "string") for (let [h, d] of Object.entries(c.layers)) { let f = l[u]?.layers?.data(h); f && ar.patch(f, d) } } }).data), a } function e (s, o) { let a, l = [], u = { orthographic: 0, perspective: 0, geometry: 0 }; function c (h, d) { for (let [f, p] of Object.entries(d.layers)) { let { texture: m, ...g } = p; if (m !== void 0 && Object.keys(m).length > 0) { let y = { path: [...h, "layers", f, "texture"], props: m, type: 0 }; l.push(y) } if (Object.keys(g).length > 0) { let y = { path: [...h, "layers", f], props: g, type: 0 }; l.push(y) } } } for (let [h, d] of Object.entries(o)) if (h !== "name") if (h === "cloner") l.push(...jg.toOps(d, ["cloner"])); else if (h === "pathSnapping") l.push({ path: [h], props: { slide: d.slide, offset: d.offset }, type: 0 }); else if (h === "material") c(["material"], d); else if (h === "materials") for (let [f, p] of Object.entries(d)) c(["materials", f], p); else if (u[h] === 0) { if (h === "geometry" && d.extrusion !== void 0) { let f = { path: [h, "extrusion"], props: d.extrusion, type: 0 }; l.push(f), d = { ...d }, delete d.extrusion } if (Object.keys(d).length > 0) { let f = { path: [h], props: d, type: 0 }; l.push(f) } } else a === void 0 && (a = { path: [], props: {}, type: 0 }, l.push(a)), a.props[h] = d; return l } r.toOps = e; function n (s, o) { if (o === void 0) return s; let a = { ...s }; if (Object.assign(a, Fu.merge(a, o)), Object.assign(a, { pathSnapping: Object.assign({}, a.pathSnapping, { slide: o.pathSnapping?.slide ?? a.pathSnapping?.slide ?? 0, offset: o.pathSnapping?.offset ?? a.pathSnapping?.offset ?? 0 }) }), Zi.is(s.type)) { a.orthographic = { ...a.orthographic }, a.perspective = { ...a.perspective }; let l = o; l.orthographic?.zoom !== void 0 && (a.orthographic.zoom = l.orthographic.zoom), l.perspective?.zoom !== void 0 && (a.perspective.zoom = l.perspective.zoom), l.isUpVectorFlipped !== void 0 && (a.isUpVectorFlipped = l.isUpVectorFlipped), l.targetOffset !== void 0 && (a.targetOffset = l.targetOffset) } else if (s.type === "Mesh") "geometry" in o && Object.assign(a, { geometry: Zg.merge(a.geometry, o.geometry) }), (o.material || o.materials) && (a = t(a, o)), a.cloner && "cloner" in o && Object.assign(a, { cloner: Cs.merge(a.cloner, o.cloner) }); else if (s.type === "Empty") a.cloner && "cloner" in o && Object.assign(a, { cloner: Cs.merge(a.cloner, o.cloner) }); else if (Wg.is(s.type)) { let l = o; l.intensity !== void 0 && (a.intensity = l.intensity), l.color !== void 0 && (typeof l.color == "string" ? a.color = l.color : a.color = or.clone(l.color)) } return a } r.patch = n })(To || (To = {})); var Uu; (t => t.defaultData = { enablePan: !0, enableZoom: !0, enableRotate: !0, enableDamping: !0, rotationLimitsMode: 0, rotationVerticalOffset: { min: Math.PI / 4, max: Math.PI / 4 }, rotationHorizontalOffset: { min: Math.PI / 4, max: Math.PI / 4 }, rotationSoftLimit: 2, panLimitsMode: 0, panVerticalOffset: { min: 250, max: 250 }, panHorizontalOffset: { min: 250, max: 250 }, panSoftLimit: 2, zoomLimitsEnabled: !1, zoomLimits: { min: .1, max: 2 }, autoRotate: !1, autoRotateSpeed: 2, autoRotateClockwise: !0, hoverRotatePanMode: 0, hoverRotatePanStrength: 20, isTouchZoom: !0, orbitTouches: 2, panTouches: 3, resetHoverEffectOnPointerLeave: !0 })(Uu || (Uu = {})); var Is; (t => t.defaultData = { orbitControls: Uu.defaultData, playPage: Sa, withBackground: !0, preventScroll: !1, preventTouchScroll: !1, hideCursor: !1, mouseEventTarget: "canvas", joystickSizeAndXYOffset: Array(12).fill(0).map((e, n) => { let r = 0, s = 0; return n < 5 ? s = -30 : n < 10 && (s = 30), n === 0 || n === 10 || n === 5 ? r = 30 : (n === 4 || n === 11 || n === 9) && (r = -30), [120, [r, s], "show"] }), settings: { image: { format: "jpg", ratio: 1 }, video: { format: "mp4", imageFormat: "jpg", fps: 30, mbps: 80, ratio: Math.max(1, typeof window < "u" ? Math.floor(window.devicePixelRatio) : 1), stopMode: "manual", duration: 5e3 }, web: { logo: !0, compress: !0, preset: 1, preload: !0, hint: !1 } }, stopRaycast: !0, hdTransmission: !1 })(Is || (Is = {})); var ew; (t => t.defaultData = { id: "basic", label: "Basic", style: "None", prompt: "" })(ew || (ew = {})); var tw; (t => t.defaultData = { weather: 0, shadows: 0, lightOrigin: 0, temperature: 0, sun: 0, camera: 0, environment: 0, particles: 0, nature: 0, floor: 0 })(tw || (tw = {})); var Ta; (e => (e.defaultData = () => ({ mode: "line-art-both", prompt: "", negativePrompt: "", style: { ...ew.defaultData }, isRandomSeed: !0, seed: e.generateSeed(), guessMode: !1, advanced: !1, steps: 20, guidanceScale: 7.5, controlNetScale: 1, modifiers: tw.defaultData }), e.generateSeed = () => Math.round(Math.random() * 1e5)))(Ta || (Ta = {})); var Ca; (e => { function i (n) { return n.find(r => r.data.type === "Page" && r.data.globalPhysics.usePhysics) !== void 0 } e.physicsEnabled = i; function t (n, r, s) { n.traverseFrom(r, (o, a) => { if (a.type === "Instance") { let l = n.data(a.component); l && s(o, a, l.events) } else s(o, a, a.events) }) } e.traverseModuleInstances = t })(Ca || (Ca = {})); var ny; (a => { a.TRASH_CAN_ID = "830a2708-8ed9-49cf-a68e-085299892222"; function t (l = { withLight: !0, withSquare: !0 }) { let u = [], c = ty.defaultMeshObject; l.withLight === !0 && u.push({ fi: -1, data: ey.defaultDirectionalLightData, id: "830a2708-8ed9-49cf-a68e-085299899103", children: [] }), l.withSquare === !0 && u.push({ fi: 1, id: "7ba78968-2a55-48f2-b14c-5191da3e075e", data: c, children: [] }); let h = new rn; return h.push({ fi: 1, id: Sa, data: { ...Mo.defaultData, name: "Scene 1" }, children: u }), h } a.defaultData = { objects: t(), publish: Is.defaultData, styles: Ta.defaultData() }, a.emptyDataWithoutPage = function () { return { objects: new rn, publish: Is.defaultData, styles: Ta.defaultData() } }, a.emptyDataWithPage = function (l) { return { objects: t(l), publish: Is.defaultData, styles: Ta.defaultData() } }; function s (l) { return { ...a.defaultData, objects: Qi(l, rn.prototype) } } a.withObjs = s; function o (l, u) { return s([{ id: l, data: u, children: [], fi: 0 }]) } a.withObj = o })(ny || (ny = {})); var zu; (t => t.emptyImage = { data: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQYV2NgYAAAAAMAAWgmWQ0AAAAASUVORK5CYII=", name: "empty" })(zu || (zu = {})); var ry; (n => { function i () { let r = {}; return r["89b10010-844c-11ec-a8a3-0242ac120002"] = { r: .5, g: .5, b: .5, a: 1, name: "Default Color" }, Qi(r, Ut.prototype) } n.defaultColors = i; function t (r) { let s = {}; return r?.withAITexture && (s["a1b10010-844c-a8a3-11ec-0242ac2011ec"] = { ...zu.emptyImage, name: "AI generated image" }), Qi(s, Ut.prototype) } n.defaultImages = t; function e () { return { materials: new Ut, images: new Ut, videos: new Ut, colors: new Ut, audios: new Ut, fonts: new Ut } } n.emptyData = e })(ry || (ry = {})); var iy; (t => t.list = ["idle", "move", "jump", "run"])(iy || (iy = {})); var Gu; (e => (e.defaultColliderData = { type: "capsule", height: 200, radius: 50, position: [0, 0, 0], rotation: [0, 0, 0] }, e.defaultDataThirdPerson = { moveMode: "walk", forwardDirection: "+z", speedTranslate: 1e3, speedRotate: 100, runMultiplier: 2, rotationMode: "normal", rotBy: "keys", rotByTouch: "drag", delayPos: [.3, .3], delayRot: [.3, .3], keyAssignments: [["moveNegZ", "W"], ["moveNegX", "A"], ["movePosZ", "S"], ["movePosX", "D"], ["rotPosX", "\u25B2"], ["rotPosY", "\u25C0"], ["rotNegX", "\u25BC"], ["rotNegY", "\u25B6"], ["jump", "Space"], ["run", "\u21E7"], ["none", "Ctrl"]], touchControl: !0, joystickPosLoc: 5, joystickRotLoc: 11, jumpTouchButtonLoc: 9, collider: e.defaultColliderData, colliderHelperVisible: !0, collisionEnabled: !0, jumpPower: 100, resetYPosition: 3e3, alignToGround: !1, autoOrientMove: !0, orientWith: "camera", orientMode: "radial", delayPosCamera: .3, delayRotCamera: .3, camera: "", cameraXAxis: "Limit", cameraYAxis: "Free", cameraRotXLimits: [0, Math.PI / 2], cameraRotYLimits: [-Math.PI / 2, Math.PI / 2], gameActions: { idle: new Ue, move: new Ue, jump: new Ue, run: new Ue }, navmesh: { enabled: !1, ch: 6, cs: 6, walkableClimb: 5, walkableHeight: 1, walkableRadius: 0, zones: "all", objects: [], helperVisible: !0, destinationHelperRadius: 0, destinationHelperColor: Ur.fromHexAndA(3728051, 1) } }))(Gu || (Gu = {})); function PC (i) { i.layers.forEach(t => { if (t.type === "depth" && t.colorA !== void 0) { let e = t.colorA, n = t.colorB, r = [[e.r, e.g, e.b, e.a], [n.r, n.g, n.b, n.a]], s = [0, 1]; for (let a = 2; a < 10; a++)r.push(r[1]), s.push(1); let o = { ...fi(Bn(t), "type", "visible", "isVector", "isWorldSpace", "origin", "alpha", "mode"), near: Math.max(0, t.near), far: Math.max(0, t.far), colors: r, steps: s, num: 2, direction: [1, 0, 0], smooth: !1, gradientType: 1 }; Object.assign(t, o) } else if (t.type === "depth" && t.gradientType === 1 && (t.near < 0 || t.far < 0)) { let e = { ...Bn(t), near: Math.max(t.near, 0), far: Math.max(t.far, 0) }; Object.assign(t, e) } }) } function Co (i, t) { Object.values(i.shared.materials).forEach(e => t(e)) } function Po (i, t) { i.scene.objects.traverse((e, n) => { "materials" in n ? n.materials.forEach((r, s) => { r === void 0 && (n.materials[s] = Sn.defaultData(), r = n.materials[s]), typeof r != "string" && t(r) }) : "material" in n ? typeof n.material != "string" && (n.material === void 0 && (n.material = Sn.defaultData()), t(n.material)) : n.type === "Mesh" && (n.material === void 0 && (n.material = Sn.defaultData()), t(n.material)), "overrides" in n && Object.values(n.overrides).forEach(r => { r.material && typeof r.material != "string" && t(r.material) }) }) } function I5 (i) { Object.assign(i.scene.publish, { orbitControls: { ...Uu.defaultData, ...Bn(i.scene.publish.orbitControls) } }) } function D5 (i) { Object.assign(i.scene.publish.settings, { video: { ...Is.defaultData.settings.video, ...Bn(i.scene.publish.settings.video) } }) } function O5 (i) { function t (e) { if (e.layers) { for (let n of Object.values(e.layers)) if (n) { for (let [r, s] of Object.entries(n)) if ((Xg.includes(r) || typeof s == "boolean") && delete n[r], r === "texture") for (let [o, a] of Object.entries(s)) (EC.includes(o) || typeof a == "boolean") && delete s[o] } } } i.scene.objects.traverse((e, n) => { n.states.forEach(r => { let s = r; s.material ? t(s.material) : s.materials && s.materials.forEach(o => { t(o) }) }) }) } function R5 (i) { i.scene.publish.withBackground = !0 } function L5 (i) { i.scene.publish.settings.web = { compress: !0, preload: !0, preset: 1, logo: !0, hint: !1 } } function N5 (i) { i.scene.objects.traverse((t, e) => { let n = e.cloner; n && (n.radial.scale = n.radial.scale.map(r => r + 1), n.linear.scale = n.linear.scale.map(r => r + 1)) }) } function B5 (i) { i.scene.objects.traverse((t, e) => { let n = e.geometry; n && (n.type === "DodecahedronGeometry" || n.type === "IcosahedronGeometry") && (n.detail = Math.round(n.detail)) }) } function F5 (i) { i.scene.objects.traverse((t, e) => { let n = i.scene.objects.unproxy().parent(t); if (n) { let r = Bn(i.scene.objects.data(n)); r && r.type === "Mesh" && r.geometry.type === "BooleanGeometry" && e.type === "Mesh" && (e.visible = Bn(e).booleanExclude !== !0) } }) } function k5 (i) { i.scene.objects.traverse((t, e) => { if (e.type === "Mesh") { let n = e; e.geometry.type === "NonParametricGeometry" ? n.material !== void 0 && delete n.material : n.materials !== void 0 && delete n.materials } }) } function U5 (i) { function t (n) { Object.setPrototypeOf(n, Vt.prototype), n.texture && Object.setPrototypeOf(n.texture, Vt.prototype) } function e (n) { Object.setPrototypeOf(n, Vt.prototype); for (let r in n) t(n[r]) } i.scene.objects.traverse((n, r) => { r.states.forEach(s => { let o = s; if (o.material) { let a = Bn(o.material).layers; e(a), o.material.layers = a } if (o.materials) for (let a = 0; a < o.materials.length; a++) { let l = o.materials[a], u = Bn(l).layers; e(u), l.layers = u } }) }) } function IC (i) { i.layers === void 0 && Object.assign(i, Sn.defaultTwoLayerData("lambert")) } function nw (i) { !i.layers || i.layers.forEach(t => { if (t.type === "depth" && t.colors.length === 10) { let e = [...t.colors]; e.push(t.colors[9]); let n = [...t.steps]; n.push(t.steps[9]); let r = { ...Bn(t), colors: e, steps: n }; Object.assign(t, r) } }) } function z5 (i) { i.scene.objects.traverse((t, e) => { e.type === "Mesh" && (e.geometry.type === "BooleanGeometry" || e.geometry.type === "SubdivGeometry") && (e.geometry.phongAngle = 35) }) } function DC (i) { i.scene.objects.traverse((t, e) => { "materials" in e ? e.materials.forEach(n => { typeof n != "string" && nw(n) }) : "material" in e && typeof e.material != "string" && nw(e.material) }), Object.values(i.shared.materials).forEach(t => nw(t)) } function G5 (i) { i.scene.environment.ambientLight.softShadows = !1, i.scene.environment.ambientLight.softShadowQuality = "low", i.scene.objects.traverse((t, e) => { (e.type === "DirectionalLight" || e.type === "SpotLight") && (e.shadowResolution = 1024, e.shadowRadius = 1, e.depth = 1e5) }), i.shared.penumbraSize = new Array(5).fill(.5) } function V5 (i) { i.shared.audios = Qi({}, Ut.prototype) } function H5 (i) { i.shared.videos = Qi({}, Ut.prototype) } function j5 (i) { let t = i.shared.materials; Object.entries(t).forEach(([e, n]) => { if (!n.layers) { let r = { name: "Untitled Material", layers: [{ fi: 0, data: { type: "light", category: "phong", alpha: .6, visible: !0, mode: 0, specular: { r: .2, g: .2, b: .2 }, shininess: 5 }, id: "layer1" }, { fi: 1, data: { type: "color", alpha: 1, visible: !0, mode: 0, color: { r: .2823529411764706, g: .2823529411764706, b: .30196078431372547 } }, id: "layer2" }] }; Object.assign(t, { [e]: r }) } }) } function W5 (i) { Object.entries(Bn(i.shared.images)).filter(n => n[1].asset === !1).map(n => n[0]).forEach(n => { delete i.shared.images[n] }), Object.entries(Bn(i.shared.audios)).filter(n => n[1].asset === !1).map(n => n[0]).forEach(n => { delete i.shared.audios[n] }) } function q5 (i) { i.scene.publish.settings.web.preload = !1 } function OC (i) { i.layers && i.layers.forEach(t => { t.type === "depth" && t.num !== void 0 && (t.colors = t.colors.slice(0, t.num), t.steps = t.steps.slice(0, t.num), delete t.num) }) } function RC (i) { i.layers && i.layers.forEach(t => { _C(t) && t.isMask === void 0 && (t.isMask = !1), (t.type === "texture" || t.type === "video") && t.blending === void 0 && (t.blending = 0), (t.type === "noise" || t.type === "displace" && t.displacementType === "noise") && (t.voronoiStyle === void 0 && (t.voronoiStyle = 0), t.highCut === void 0 && (t.highCut = 1), t.lowCut === void 0 && (t.lowCut = 0), t.smoothness === void 0 && (t.smoothness = .3), t.seed === void 0 && (t.seed = 0), t.quality === void 0 && (t.quality = 1)) }) } function Y5 (i) { i.shared.fonts = Qi({}, Ut.prototype) } function X5 (i) { return i.replace(".typeface", "").replace(/optimer/gi, "open sans").replace("space_mono", "space mono").replace(/alma_mono/gi, "varela round").replace(/droid_sans_mono/gi, "noto sans mono").replace(/droid_sans|gentilis|gnomon_(simple|foreground)|helvetiker/gi, "roboto").replace(/droid_serif/gi, "roboto slab").replace("_sans", " sans").replace("crimson_text", "crimson text").replace("medium_medium", "medium").replace("fatface_fatface", "fatface").replace("100hairline", "thin").replace("200thin", "extralight").replace("300light", "light").replace("500medium", "medium").replace("600semi", "semibold").replace("800heavy", "extrabold").replace("900black", "black").replace(/bodoni_(11|16|24|36|48|72|96)([^_])/gi, "bodoni_$1_$2").replace(/bodoni_(11|16|24|36|48|72|96)/gi, "bodoni moda").replace(/(thin|hairline)(_regular)?/gi, "100").replace(/(extra|ultra)light(_regular)?/gi, "200").replace(/light(_regular)?/gi, "300").replace(/_book|_normal|_roman/gi, "_regular").replace(/medium(_regular)?/gi, "500").replace(/(semi|demi)bold(_regular)?/gi, "600").replace(/(extra|ultra)bold(_regular)?/gi, "800").replace(/bold(_regular)?/gi, "700").replace(/(black|heavy|fatface)(_regular)?/gi, "900").replace(/([1-9]00)_italic/gi, "$1italic").replace(/regularitalic/gi, "italic").replace(/regularitalic/gi, "italic").split(" ").map(e => e.charAt(0).toUpperCase() + e.slice(1)).join(" ") } function Q5 (i) { let t = []; i.scene.objects.traverse((e, n) => { let r = n; if (r.type === "TextFrame") { let s = Sn.defaultTwoLayerData("phong"), o = typeof r.color == "string" ? i.shared.colors[r.color] : r.color; s.layers[1].data.color = { r: o.r, g: o.g, b: o.b }, s.layers[1].data.alpha = r.alpha; let a = X5(r.font); i.shared.fonts[a] === void 0 && (i.shared.fonts[a] = { name: a }); let l = { name: r.name, ...br.defaultData, ...Dl.defaultData, flatShading: !1, wireframe: !1, geometry: { ...Ea.defaultData("TextGeometry"), width: r.width, height: r.height, font: a, depth: 0, horizontalAlign: r.horizontalAlign, verticalAlign: r.verticalAlign, fontSize: r.fontSize * 1.40625, lineHeight: r.lineHeight / 1.40625, letterSpacing: r.letterSpacing - 1, text: r.text, textTransform: r.textTransform, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, material: s, states: Bn(r.states), events: Bn(r.events), visible: r.visible, raycastLock: r.raycastLock, position: r.position, rotation: r.rotation, scale: r.scale, hiddenMatrix: r.hiddenMatrix }, u = Bn(i.scene.objects).parent(e); i.scene.objects.insertAfter(u ?? null, e, [{ id: e + "new", data: l, children: [] }]), t.push(e) } }), t.forEach(e => { i.scene.objects.delete(e) }) } function K5 (i) { let t = { 0: "MouseDown", 1: "MouseUp", 2: "MouseHover", 5: "KeyDown", 6: "KeyUp", 7: "Start", 9: "LookAt", 10: "Follow", 11: "Scroll", 12: "Audio", 13: "GameControl" }; i.scene.objects.traverse((e, n) => { n.events.forEach(r => { if (t[Number(r.type)]) if (Object.assign(r, { type: t[Number(r.type)] }), r.type === "Audio" && "audioEvent" in r && (Object.assign(r, { playAudio: r.audioEvent }), delete r.audioEvent), r.type === "GameControl") Object.assign(r, { gameActions: { idle: new Ue, move: new Ue, jump: new Ue } }); else { let s = new Ue; Object.assign(r, { actions: s }), (r.type === "MouseDown" || r.type === "MouseUp" || r.type === "KeyDown" || r.type === "KeyUp") && "url" in r && s.push({ fi: 0, id: Ge.generateUUID(), data: { type: "Link", url: r.url, delay: 0 } }), "targets" in r && (r.targets.forEach((o, a, l) => { let u = { state: void 0, repeat: 0, delay: 0, delayDirection: void 0, direction: "normal", duration: 0, easing: 4 }, c = { easing: o.easing, duration: o.duration }; o.easing === 6 ? Object.assign(c, fi(o, "mass", "stiffness", "damping", "velocity")) : o.easing === 5 && Object.assign(c, { control1: { ...o.control1 }, control2: { ...o.control2 } }); let h = { repeat: o.repeat ? -1 : 0, delay: o.delay, delayDirection: o.delayDirection, direction: o.cycle && o.rewind ? "pingpong-rewind" : o.cycle ? "pingpong" : "normal" }, d = { state: o.state, ...h, ...c }, f = { allowSlerp: !0, type: "Transition", object: o.object, repeat: 0, delay: 0, delayDirection: void 0, direction: "normal", tweens: new Ue({ fi: 0, id: Ge.generateUUID(), data: u }, { fi: 1, id: Ge.generateUUID(), data: d }) }; s.push({ fi: l, id: a, data: f }) }), delete r.targets) } }) }) } function Z5 (i) { i.scene.objects.traverse((t, e) => { function n (r, s) { let o = new Ue, a = []; if (e.events.forEach((l, u, c) => { if (l.type === "Audio" && l.trigger === s) { let h; a.push(u), l.interaction === "play" ? h = { ...fi(l, "interaction", "audio", "delay", "volume", "loop"), triggerAfter: "after" in l ? l.after : void 0, toggle: "after" in l ? l.toggle : void 0, type: "Audio" } : (l.interaction === "pause" || l.interaction === "stop") && (h = { ...fi(l, "interaction", "delay", "object", "playAudio"), type: "Audio" }), h && o.push({ fi: c, id: u, data: h }) } }), a.forEach(l => e.events.delete(l)), o.length) { let l = e.events.find(u => u.type === r)?.data; l ? "actions" in l && l.actions.insertBefore(null, o) : e.events.insertBefore(null, [{ id: Ge.generateUUID(), data: { type: r, actions: o } }]) } } n("Start", "start"), n("MouseDown", "mouseDown"), n("MouseUp", "mouseUp"), n("KeyDown", "keyDown"), n("KeyUp", "keyUp") }) } function LC (i) { let t = i.layers.find(e => e.type === "light")?.data; if (t?.category === "basic") { let e = ar.defaultData("light", "phong"), n = t; Object.assign(n, e), n.visible = !1 } } function NC (i) { Co(i, LC), Po(i, LC) } function J5 (i) { i.scene.objects.traverse((t, e) => { e.type === "Mesh" && e.geometry.type === "SubdivGeometry" && (e.geometry.scaleBaked || (e.geometry.scaleBaked = [1, 1, 1])) }) } function $5 (i) { i.scene.objects.traverse((t, e) => { (e.type === "Empty" || e.type === "Mesh") && e.cloner && !e.cloner.randomnessObject && !e.cloner.toObject && !e.cloner.randomness && (e.cloner = { ...e.cloner, toObject: { object: "", spreadType: "random", scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], axis: "x", seed: 0, count: 99, align: "normal" }, randomness: !1, randomnessObject: { strength: 100, scale: [0, 0, 0], rotation: [0, 0, 0], position: [0, 0, 0], movement: 1, seed: 0, freqScale: 10, noiseType: "perlin" } }) }) } function ej (i) { i.scene.objects.traverse((t, e) => { e.type === "Mesh" && e.geometry.type === "NonParametricGeometry" && !("material" in e) && !("materials" in e) && (e.material = Sn.defaultTwoLayerData("phong")) }) } function tj (i) { i.scene.publish.orbitControls.autoZoom === void 0 && (i.scene.publish.orbitControls.autoZoom = !1), i.scene.objects.traverse((t, e) => { (e.type === "OrthographicCamera" || e.type === "PerspectiveCamera") && (e.orthographic.autoZoom === void 0 && (e.orthographic.autoZoom = !1), e.orthographic.autoZoomFrustumSize === void 0 && (e.orthographic.autoZoomFrustumSize = 790)) }) } function nj (i) { i.scene.objects.traverse((t, e) => { e.pathSnapping === void 0 && (e.pathSnapping = { pathId: null, slide: 0, offset: 0, orientation: "tangential" }), e.pathSnapping.offset === void 0 && (e.pathSnapping.offset = 0) }) } function rj (i) { i.scene.publish.mouseEventTarget === void 0 && (i.scene.publish.mouseEventTarget = "canvas"), i.scene.publish.settings.web.hint === void 0 && (i.scene.publish.settings.web.hint = !1) } function ij (i) { let { video: t } = i.scene.publish.settings; t.format === "gif" && t.fps > 48 && (t.fps = 15) } function sj (i) { i.scene.objects.traverse((t, e) => { e.events.forEach(n => { n.type === "GameControl" && (n.resetYPosition = Math.abs(n.resetYPosition - e.position[1])) }) }) } function oj (i) { let t = i.scene.environment.usePhysics; i.scene.objects.traverse((e, n) => { t && n.physics === null ? n.collision = !1 : n.collision = "visibility" }) } function aj (i) { i.scene.objects.traverse((t, e) => { e.events.forEach(n => { n.type === "GameControl" && (n.navmesh = Gu.defaultDataThirdPerson.navmesh) }) }) } function lj (i) { i.scene.styles || (i.scene.styles = Ta.defaultData()) } function BC (i) { i.layers.forEach(t => { t.type === "light" && t.category !== "toon" && t.occlusion === void 0 && (t.occlusion = !0) }) } function cj (i) { i.scene.environment.ambientLight.occlusion === void 0 && (i.scene.environment.ambientLight.occlusion = !1), i.scene.environment.ambientLight.aoFullRes === void 0 && (i.scene.environment.ambientLight.aoFullRes = !1), i.scene.environment.ambientLight.radius === void 0 && (i.scene.environment.ambientLight.radius = 256), i.scene.environment.ambientLight.bias === void 0 && (i.scene.environment.ambientLight.bias = .5), i.scene.environment.ambientLight.aoColor === void 0 && (i.scene.environment.ambientLight.aoColor = { r: .19607843137254902, g: .19607843137254902, b: .19607843137254902 }), Po(i, BC), Co(i, BC) } function uj (i) { i.scene.objects.traverse((t, e) => { e.events.forEach(n => { n.type === "GameControl" && Object.assign(n.gameActions, { run: new Ue }) }) }) } function hj (i) { i.scene.objects.traverse((t, e) => { e.events.forEach(n => { n.type === "GameControl" && (n.keyAssignments = [...n.keyAssignments, ["run", "\u21E7"], ["none", "Ctrl"]]) }) }) } function FC (i) { i.layers && i.layers.forEach(t => { t.type === "light" && t.bumpMapIntensity === void 0 && (t.bumpMapIntensity = 5) }) } function kC (i, t) { if (t < 1 && (Po(i, PC), Co(i, PC), i.schema = 1), t < 2 && (I5(i), i.schema = 2), t < 3 && (O5(i), i.schema = 3), t < 4 && (R5(i), i.schema = 4), t < 5 && (L5(i), i.schema = 5), t < 6 && (N5(i), i.schema = 6), t < 7 && (B5(i), i.schema = 7), t < 8 && (i.schema = 8), t < 9 && (DC(i), i.schema = 9), t < 10 && (z5(i), i.schema = 10), t < 11 && (G5(i), i.schema = 11), t < 12 && (DC(i), i.schema = 12), t < 13 && (V5(i), i.schema = 13), t < 14 && (j5(i), i.schema = 14), t < 15 && (W5(i), i.schema = 15), t < 16 && (q5(i), i.schema = 16), t < 17 && (Po(i, OC), Co(i, OC), i.schema = 17), t < 18 && (Po(i, IC), Co(i, IC), i.schema = 18), t < 19 && (D5(i), i.schema = 19), t < 20 && (Y5(i), Q5(i), i.schema = 20), t < 21 && (K5(i), Z5(i), i.schema = 21), t < 22 && (NC(i), i.schema = 22), t < 23 && (J5(i), i.schema = 23), t < 24 && ($5(i), i.schema = 24), (t < 25 || i.shared.videos === void 0) && (H5(i), t < 25 && (i.schema = 25)), t < 26 && (F5(i), i.schema = 26), t < 27 && (k5(i), i.schema = 27), t < 28 && (NC(i), i.schema = 28), t < 29 && (U5(i), i.schema = 29), t < 30 && (ej(i), i.schema = 30), t < 31 && (tj(i), i.schema = 31), t < 33 && (nj(i), i.schema = 33), t < 34 && (rj(i), i.schema = 34), t < 35 && (ij(i), i.schema = 35), t < 36 && (sj(i), i.schema = 36), t < 37 && (oj(i), i.schema = 37), t < 38 && (Po(i, RC), Co(i, RC), i.schema = 38), t < 39 && (aj(i), i.schema = 39), t < 40 && (lj(i), i.schema = 40), t < 41 && (cj(i), i.schema = 41), t < 42 && (uj(i), i.schema = 42), t < 43 && (hj(i), i.schema = 43), t < 99) { Po(i, FC), Co(i, FC), i.scene.publish.playCamera === null && (i.scene.publish.playCamera = Ti); let e = Bn(i.scene.objects), n = i.scene.objects; i.scene.publish.playPage = Sa, n.insertBefore(null, null, [{ id: Sa, data: { ...Mo.defaultData, backgroundColor: i.scene.backgroundColor, fog: i.scene.fog, postprocessing: i.scene.postprocessing, ao: fi(i.scene.environment.ambientLight, "occlusion", "aoFullRes", "radius", "bias", "aoColor"), publish: { playCamera: i.scene.publish.playCamera, gameControlObject: i.scene.publish.gameControlObject }, shadow: fi(i.scene.environment.ambientLight, "softShadowQuality"), globalPhysics: { ...Ma.defaultData, ...fi(i.scene.environment, "usePhysics", "gravity") }, camera: Bn(i.scene.ownerCamera) ?? Mo.defaultData.camera, name: "Scene" }, children: [] }]); for (let o of e) o.id !== ny.TRASH_CAN_ID && n.move(Sa, o.fi, o.id); let r = 0, s = 0; i.shared.penumbraSize && i.scene.objects.traverse((o, a) => { a.type === "DirectionalLight" ? (a.penumbraSize = i.shared.penumbraSize[Math.min(r, 2)], r += 1) : a.type === "SpotLight" && (a.penumbraSize = i.shared.penumbraSize[3 + Math.min(s, 1)], s += 1), (a.physics === void 0 || a.physics === null) && a.type !== "Instance" && (a.physics = {}, Object.assign(a.physics, _a.defaultData)), a.physics !== void 0 && a.physics !== null && (a.physics.enabled = a.collision ?? "visibility", delete a.collision) }), i.schema = 99 } } function UC (i) { i.layers && i.layers.forEach(t => { t.type === "light" && t.alphaOverride === void 0 && (t.alphaOverride = 1) }) } function dj (i) { i.scene.objects.traverse((t, e) => { let n = e.geometry; n && n.type === "PathGeometry" && (n.extrusion.capType = "flat", n.extrusion.bevel = 50, n.extrusion.bevelSides = 6, n.extrusion.shape.type === "Custom" && (n.extrusion.shape.shapeQuality = "low")) }) } var zC = 102; function GC (i) { let t = i.schema ?? 0; t !== zC && (console.warn("updating from ", t, "to ", zC), kC(i, t), t < 100 && (i.scene.publish.joystickSizeAndXYOffset === void 0 && (i.scene.publish.joystickSizeAndXYOffset = Is.defaultData.joystickSizeAndXYOffset), i.schema = 100), t < 101 && (Po(i, UC), Co(i, UC), i.schema = 101), t < 102 && (dj(i), i.schema = 102)) } function Ji (i, t = !1) { let e = i[0].index !== null, n = new Set(Object.keys(i[0].attributes)), r = new Set(Object.keys(i[0].morphAttributes)), s = {}, o = {}, a = i[0].morphTargetsRelative, l = new Ce, u = 0; for (let c = 0; c < i.length; ++c) { let h = i[c], d = 0; if (e !== (h.index !== null)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + ". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."), null; for (let f in h.attributes) { if (!n.has(f)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + '. All geometries must have compatible attributes; make sure "' + f + '" attribute exists among all geometries, or in none of them.'), null; s[f] === void 0 && (s[f] = []), s[f].push(h.attributes[f]), d++ } if (d !== n.size) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + ". Make sure all geometries have the same number of attributes."), null; if (a !== h.morphTargetsRelative) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + ". .morphTargetsRelative must be consistent throughout all geometries."), null; for (let f in h.morphAttributes) { if (!r.has(f)) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + ".  .morphAttributes must be consistent throughout all geometries."), null; o[f] === void 0 && (o[f] = []), o[f].push(h.morphAttributes[f]) } if (t) { let f; if (e) f = h.index.count; else if (h.attributes.position !== void 0) f = h.attributes.position.count; else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index " + c + ". The geometry must have either an index or a position attribute"), null; l.addGroup(u, f, c), u += f } } if (e) { let c = 0, h = []; for (let d = 0; d < i.length; ++d) { let f = i[d].index; for (let p = 0; p < f.count; ++p)h.push(f.getX(p) + c); c += i[d].attributes.position.count } l.setIndex(h) } for (let c in s) { let h = VC(s[c]); if (!h) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + c + " attribute."), null; l.setAttribute(c, h) } for (let c in o) { let h = o[c][0].length; if (h === 0) break; l.morphAttributes = l.morphAttributes || {}, l.morphAttributes[c] = []; for (let d = 0; d < h; ++d) { let f = []; for (let m = 0; m < o[c].length; ++m)f.push(o[c][m][d]); let p = VC(f); if (!p) return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the " + c + " morphAttribute."), null; l.morphAttributes[c].push(p) } } return l } function VC (i) { let t, e, n, r = 0; for (let a = 0; a < i.length; ++a) { let l = i[a]; if (l.isInterleavedBufferAttribute) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."), null; if (t === void 0 && (t = l.array.constructor), t !== l.array.constructor) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."), null; if (e === void 0 && (e = l.itemSize), e !== l.itemSize) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."), null; if (n === void 0 && (n = l.normalized), n !== l.normalized) return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."), null; r += l.array.length } let s = new t(r), o = 0; for (let a = 0; a < i.length; ++a)s.set(i[a].array, o), o += i[a].array.length; return new ze(s, e, n) } var HC = Math.pow(2, -24); var Rl = class { constructor() { } }; function Ci (i, t, e) { return e.min.x = t[i], e.min.y = t[i + 1], e.min.z = t[i + 2], e.max.x = t[i + 3], e.max.y = t[i + 4], e.max.z = t[i + 5], e } function rw (i) { let t = -1, e = -1 / 0; for (let n = 0; n < 3; n++) { let r = i[n + 3] - i[n]; r > e && (e = r, t = n) } return t } function iw (i, t) { t.set(i) } function sw (i, t, e) { let n, r; for (let s = 0; s < 3; s++) { let o = s + 3; n = i[s], r = t[s], e[s] = n < r ? n : r, n = i[o], r = t[o], e[o] = n > r ? n : r } } function _f (i, t, e) { for (let n = 0; n < 3; n++) { let r = t[i + 2 * n], s = t[i + 2 * n + 1], o = r - s, a = r + s; o < e[n] && (e[n] = o), a > e[n + 3] && (e[n + 3] = a) } } function Vu (i) { let t = i[3] - i[0], e = i[4] - i[1], n = i[5] - i[2]; return 2 * (t * e + e * n + n * t) } function mj (i, t) { if (!i.index) { let e = i.attributes.position.count, n = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer, r; e > 65535 ? r = new Uint32Array(new n(4 * e)) : r = new Uint16Array(new n(2 * e)), i.setIndex(new ze(r, 1)); for (let s = 0; s < e; s++)r[s] = s } } function gj (i) { if (!i.groups || !i.groups.length) return [{ offset: 0, count: i.index.count / 3 }]; let t = [], e = new Set; for (let r of i.groups) e.add(r.start), e.add(r.start + r.count); let n = Array.from(e.values()).sort((r, s) => r - s); for (let r = 0; r < n.length - 1; r++) { let s = n[r], o = n[r + 1]; t.push({ offset: s / 3, count: (o - s) / 3 }) } return t } function aw (i, t, e, n, r = null) { let s = 1 / 0, o = 1 / 0, a = 1 / 0, l = -1 / 0, u = -1 / 0, c = -1 / 0, h = 1 / 0, d = 1 / 0, f = 1 / 0, p = -1 / 0, m = -1 / 0, g = -1 / 0, y = r !== null; for (let v = t * 6, x = (t + e) * 6; v < x; v += 6) { let b = i[v + 0], S = i[v + 1], _ = b - S, E = b + S; _ < s && (s = _), E > l && (l = E), y && b < h && (h = b), y && b > p && (p = b); let w = i[v + 2], M = i[v + 3], T = w - M, I = w + M; T < o && (o = T), I > u && (u = I), y && w < d && (d = w), y && w > m && (m = w); let C = i[v + 4], P = i[v + 5], D = C - P, L = C + P; D < a && (a = D), L > c && (c = L), y && C < f && (f = C), y && C > g && (g = C) } n[0] = s, n[1] = o, n[2] = a, n[3] = l, n[4] = u, n[5] = c, y && (r[0] = h, r[1] = d, r[2] = f, r[3] = p, r[4] = m, r[5] = g) } function yj (i, t, e, n) { let r = 1 / 0, s = 1 / 0, o = 1 / 0, a = -1 / 0, l = -1 / 0, u = -1 / 0; for (let c = t * 6, h = (t + e) * 6; c < h; c += 6) { let d = i[c + 0]; d < r && (r = d), d > a && (a = d); let f = i[c + 2]; f < s && (s = f), f > l && (l = f); let p = i[c + 4]; p < o && (o = p), p > u && (u = p) } n[0] = r, n[1] = s, n[2] = o, n[3] = a, n[4] = l, n[5] = u } function vj (i, t, e, n, r) { let s = e, o = e + n - 1, a = r.pos, l = r.axis * 2; for (; ;) { for (; s <= o && t[s * 6 + l] < a;)s++; for (; s <= o && t[o * 6 + l] >= a;)o--; if (s < o) { for (let u = 0; u < 3; u++) { let c = i[s * 3 + u]; i[s * 3 + u] = i[o * 3 + u], i[o * 3 + u] = c; let h = t[s * 6 + u * 2 + 0]; t[s * 6 + u * 2 + 0] = t[o * 6 + u * 2 + 0], t[o * 6 + u * 2 + 0] = h; let d = t[s * 6 + u * 2 + 1]; t[s * 6 + u * 2 + 1] = t[o * 6 + u * 2 + 1], t[o * 6 + u * 2 + 1] = d } s++, o-- } else return s } } var Io = 32, xj = (i, t) => i.candidate - t.candidate, Pa = new Array(Io).fill().map(() => ({ count: 0, bounds: new Float32Array(6), rightCacheBounds: new Float32Array(6), leftCacheBounds: new Float32Array(6), candidate: 0 })), sy = new Float32Array(6); function bj (i, t, e, n, r, s) { let o = -1, a = 0; if (s === 0) o = rw(t), o !== -1 && (a = (t[o] + t[o + 3]) / 2); else if (s === 1) o = rw(i), o !== -1 && (a = wj(e, n, r, o)); else if (s === 2) { let l = Vu(i), u = 1.25 * r, c = n * 6, h = (n + r) * 6; for (let d = 0; d < 3; d++) { let f = t[d], g = (t[d + 3] - f) / Io; if (r < Io / 4) { let y = [...Pa]; y.length = r; let v = 0; for (let b = c; b < h; b += 6, v++) { let S = y[v]; S.candidate = e[b + 2 * d], S.count = 0; let { bounds: _, leftCacheBounds: E, rightCacheBounds: w } = S; for (let M = 0; M < 3; M++)w[M] = 1 / 0, w[M + 3] = -1 / 0, E[M] = 1 / 0, E[M + 3] = -1 / 0, _[M] = 1 / 0, _[M + 3] = -1 / 0; _f(b, e, _) } y.sort(xj); let x = r; for (let b = 0; b < x; b++) { let S = y[b]; for (; b + 1 < x && y[b + 1].candidate === S.candidate;)y.splice(b + 1, 1), x-- } for (let b = c; b < h; b += 6) { let S = e[b + 2 * d]; for (let _ = 0; _ < x; _++) { let E = y[_]; S >= E.candidate ? _f(b, e, E.rightCacheBounds) : (_f(b, e, E.leftCacheBounds), E.count++) } } for (let b = 0; b < x; b++) { let S = y[b], _ = S.count, E = r - S.count, w = S.leftCacheBounds, M = S.rightCacheBounds, T = 0; _ !== 0 && (T = Vu(w) / l); let I = 0; E !== 0 && (I = Vu(M) / l); let C = 1 + 1.25 * (T * _ + I * E); C < u && (o = d, u = C, a = S.candidate) } } else { for (let x = 0; x < Io; x++) { let b = Pa[x]; b.count = 0, b.candidate = f + g + x * g; let S = b.bounds; for (let _ = 0; _ < 3; _++)S[_] = 1 / 0, S[_ + 3] = -1 / 0 } for (let x = c; x < h; x += 6) { let _ = ~~((e[x + 2 * d] - f) / g); _ >= Io && (_ = Io - 1); let E = Pa[_]; E.count++, _f(x, e, E.bounds) } let y = Pa[Io - 1]; iw(y.bounds, y.rightCacheBounds); for (let x = Io - 2; x >= 0; x--) { let b = Pa[x], S = Pa[x + 1]; sw(b.bounds, S.rightCacheBounds, b.rightCacheBounds) } let v = 0; for (let x = 0; x < Io - 1; x++) { let b = Pa[x], S = b.count, _ = b.bounds, w = Pa[x + 1].rightCacheBounds; S !== 0 && (v === 0 ? iw(_, sy) : sw(_, sy, sy)), v += S; let M = 0, T = 0; v !== 0 && (M = Vu(sy) / l); let I = r - v; I !== 0 && (T = Vu(w) / l); let C = 1 + 1.25 * (M * v + T * I); C < u && (o = d, u = C, a = b.candidate) } } } } else console.warn(`MeshBVH: Invalid build strategy value ${s} used.`); return { axis: o, pos: a } } function wj (i, t, e, n) { let r = 0; for (let s = t, o = t + e; s < o; s++)r += i[s * 6 + n * 2]; return r / e } function Sj (i, t) { let e = i.attributes.position, n = i.index.array, r = n.length / 3, s = new Float32Array(r * 6), o = e.normalized, a = e.array, l = e.offset || 0, u = 3; e.isInterleavedBufferAttribute && (u = e.data.stride); let c = ["getX", "getY", "getZ"]; for (let h = 0; h < r; h++) { let d = h * 3, f = h * 6, p, m, g; o ? (p = n[d + 0], m = n[d + 1], g = n[d + 2]) : (p = n[d + 0] * u + l, m = n[d + 1] * u + l, g = n[d + 2] * u + l); for (let y = 0; y < 3; y++) { let v, x, b; o ? (v = e[c[y]](p), x = e[c[y]](m), b = e[c[y]](g)) : (v = a[p + y], x = a[m + y], b = a[g + y]); let S = v; x < S && (S = x), b < S && (S = b); let _ = v; x > _ && (_ = x), b > _ && (_ = b); let E = (_ - S) / 2, w = y * 2; s[f + w + 0] = S + E, s[f + w + 1] = E + (Math.abs(S) + E) * HC, S < t[y] && (t[y] = S), _ > t[y + 3] && (t[y + 3] = _) } } return s } function Aj (i, t) { function e (y) { d && d(y / f) } function n (y, v, x, b = null, S = 0) { if (!p && S >= l && (p = !0, u && (console.warn(`MeshBVH: Max depth of ${l} reached when generating BVH. Consider increasing maxDepth.`), console.warn(i))), x <= c || S >= l) return e(v + x), y.offset = v, y.count = x, y; let _ = bj(y.boundingData, b, o, v, x, h); if (_.axis === -1) return e(v + x), y.offset = v, y.count = x, y; let E = vj(a, o, v, x, _); if (E === v || E === v + x) e(v + x), y.offset = v, y.count = x; else { y.splitAxis = _.axis; let w = new Rl, M = v, T = E - v; y.left = w, w.boundingData = new Float32Array(6), aw(o, M, T, w.boundingData, s), n(w, M, T, s, S + 1); let I = new Rl, C = E, P = x - T; y.right = I, I.boundingData = new Float32Array(6), aw(o, C, P, I.boundingData, s), n(I, C, P, s, S + 1) } return y } mj(i, t); let r = new Float32Array(6), s = new Float32Array(6), o = Sj(i, r), a = i.index.array, l = t.maxDepth, u = t.verbose, c = t.maxLeafTris, h = t.strategy, d = t.onProgress, f = i.index.count / 3, p = !1, m = [], g = gj(i); if (g.length === 1) { let y = g[0], v = new Rl; v.boundingData = r, yj(o, y.offset, y.count, s), n(v, y.offset, y.count, s), m.push(v) } else for (let y of g) { let v = new Rl; v.boundingData = new Float32Array(6), aw(o, y.offset, y.count, v.boundingData, s), n(v, y.offset, y.count, s), m.push(v) } return m } function qC (i, t) { let e = Aj(i, t), n, r, s, o = [], a = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer; for (let c = 0; c < e.length; c++) { let h = e[c], d = l(h), f = new a(32 * d); n = new Float32Array(f), r = new Uint32Array(f), s = new Uint16Array(f), u(0, h), o.push(f) } return o; function l (c) { return c.count ? 1 : 1 + l(c.left) + l(c.right) } function u (c, h) { let d = c / 4, f = c / 2, p = !!h.count, m = h.boundingData; for (let g = 0; g < 6; g++)n[d + g] = m[g]; if (p) { let g = h.offset, y = h.count; return r[d + 6] = g, s[f + 14] = y, s[f + 15] = 65535, c + 32 } else { let g = h.left, y = h.right, v = h.splitAxis, x; if (x = u(c + 32, g), x / 4 > Math.pow(2, 32)) throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits."); return r[d + 6] = x / 4, x = u(x, y), r[d + 7] = v, x } } } var Yr = class { constructor() { this.min = 1 / 0, this.max = -1 / 0 } setFromPointsField (t, e) { let n = 1 / 0, r = -1 / 0; for (let s = 0, o = t.length; s < o; s++) { let l = t[s][e]; n = l < n ? l : n, r = l > r ? l : r } this.min = n, this.max = r } setFromPoints (t, e) { let n = 1 / 0, r = -1 / 0; for (let s = 0, o = e.length; s < o; s++) { let a = e[s], l = t.dot(a); n = l < n ? l : n, r = l > r ? l : r } this.min = n, this.max = r } isSeparated (t) { return this.min > t.max || t.min > this.max } }; Yr.prototype.setFromBox = function () { let i = new A; return function (e, n) { let r = n.min, s = n.max, o = 1 / 0, a = -1 / 0; for (let l = 0; l <= 1; l++)for (let u = 0; u <= 1; u++)for (let c = 0; c <= 1; c++) { i.x = r.x * l + s.x * (1 - l), i.y = r.y * u + s.y * (1 - u), i.z = r.z * c + s.z * (1 - c); let h = e.dot(i); o = Math.min(h, o), a = Math.max(h, a) } this.min = o, this.max = a } }(); var $oe = function () { let i = new Yr; return function (e, n) { let r = e.points, s = e.satAxes, o = e.satBounds, a = n.points, l = n.satAxes, u = n.satBounds; for (let c = 0; c < 3; c++) { let h = o[c], d = s[c]; if (i.setFromPoints(d, a), h.isSeparated(i)) return !1 } for (let c = 0; c < 3; c++) { let h = u[c], d = l[c]; if (i.setFromPoints(d, r), h.isSeparated(i)) return !1 } } }(); var _j = function () { let i = new A, t = new A, e = new A; return function (r, s, o) { let a = r.start, l = i, u = s.start, c = t; e.subVectors(a, u), i.subVectors(r.end, r.start), t.subVectors(s.end, s.start); let h = e.dot(c), d = c.dot(l), f = c.dot(c), p = e.dot(l), g = l.dot(l) * f - d * d, y, v; g !== 0 ? y = (h * d - p * f) / g : y = 0, v = (h + y * d) / f, o.x = y, o.y = v } }(), Ef = function () { let i = new B, t = new A, e = new A; return function (r, s, o, a) { _j(r, s, i); let l = i.x, u = i.y; if (l >= 0 && l <= 1 && u >= 0 && u <= 1) { r.at(l, o), s.at(u, a); return } else if (l >= 0 && l <= 1) { u < 0 ? s.at(0, a) : s.at(1, a), r.closestPointToPoint(a, !0, o); return } else if (u >= 0 && u <= 1) { l < 0 ? r.at(0, o) : r.at(1, o), s.closestPointToPoint(o, !0, a); return } else { let c; l < 0 ? c = r.start : c = r.end; let h; u < 0 ? h = s.start : h = s.end; let d = t, f = e; if (r.closestPointToPoint(h, !0, t), s.closestPointToPoint(c, !0, e), d.distanceToSquared(h) <= f.distanceToSquared(c)) { o.copy(d), a.copy(h); return } else { o.copy(c), a.copy(f); return } } } }(), YC = function () { let i = new A, t = new A, e = new bn, n = new Hn; return function (s, o) { let { radius: a, center: l } = s, { a: u, b: c, c: h } = o; if (n.start = u, n.end = c, n.closestPointToPoint(l, !0, i).distanceTo(l) <= a || (n.start = u, n.end = h, n.closestPointToPoint(l, !0, i).distanceTo(l) <= a) || (n.start = c, n.end = h, n.closestPointToPoint(l, !0, i).distanceTo(l) <= a)) return !0; let m = o.getPlane(e); if (Math.abs(m.distanceToPoint(l)) <= a) { let y = m.projectPoint(l, t); if (o.containsPoint(y)) return !0 } return !1 } }(); var Ej = 1e-15; function Hu (i) { return Math.abs(i) < Ej } var Xr = class extends nn { constructor(...t) { super(...t), this.isExtendedTriangle = !0, this.satAxes = new Array(4).fill().map(() => new A), this.satBounds = new Array(4).fill().map(() => new Yr), this.points = [this.a, this.b, this.c], this.sphere = new dn, this.plane = new bn, this.needsUpdate = !0 } intersectsSphere (t) { return YC(t, this) } update () { let t = this.a, e = this.b, n = this.c, r = this.points, s = this.satAxes, o = this.satBounds, a = s[0], l = o[0]; this.getNormal(a), l.setFromPoints(a, r); let u = s[1], c = o[1]; u.subVectors(t, e), c.setFromPoints(u, r); let h = s[2], d = o[2]; h.subVectors(e, n), d.setFromPoints(h, r); let f = s[3], p = o[3]; f.subVectors(n, t), p.setFromPoints(f, r), this.sphere.setFromPoints(this.points), this.plane.setFromNormalAndCoplanarPoint(a, t), this.needsUpdate = !1 } }; Xr.prototype.closestPointToSegment = function () { let i = new A, t = new A, e = new Hn; return function (r, s = null, o = null) { let { start: a, end: l } = r, u = this.points, c, h = 1 / 0; for (let d = 0; d < 3; d++) { let f = (d + 1) % 3; e.start.copy(u[d]), e.end.copy(u[f]), Ef(e, r, i, t), c = i.distanceToSquared(t), c < h && (h = c, s && s.copy(i), o && o.copy(t)) } return this.closestPointToPoint(a, i), c = a.distanceToSquared(i), c < h && (h = c, s && s.copy(i), o && o.copy(a)), this.closestPointToPoint(l, i), c = l.distanceToSquared(i), c < h && (h = c, s && s.copy(i), o && o.copy(l)), Math.sqrt(h) } }(); Xr.prototype.intersectsTriangle = function () { let i = new Xr, t = new Array(3), e = new Array(3), n = new Yr, r = new Yr, s = new A, o = new A, a = new A, l = new A, u = new Hn, c = new Hn, h = new Hn; return function (f, p = null, m = !1) { this.needsUpdate && this.update(), f.isExtendedTriangle ? f.needsUpdate && f.update() : (i.copy(f), i.update(), f = i); let g = this.plane, y = f.plane; if (Math.abs(g.normal.dot(y.normal)) > 1 - 1e-10) { let v = this.satBounds, x = this.satAxes; e[0] = f.a, e[1] = f.b, e[2] = f.c; for (let _ = 0; _ < 4; _++) { let E = v[_], w = x[_]; if (n.setFromPoints(w, e), E.isSeparated(n)) return !1 } let b = f.satBounds, S = f.satAxes; t[0] = this.a, t[1] = this.b, t[2] = this.c; for (let _ = 0; _ < 4; _++) { let E = b[_], w = S[_]; if (n.setFromPoints(w, t), E.isSeparated(n)) return !1 } for (let _ = 0; _ < 4; _++) { let E = x[_]; for (let w = 0; w < 4; w++) { let M = S[w]; if (s.crossVectors(E, M), n.setFromPoints(s, t), r.setFromPoints(s, e), n.isSeparated(r)) return !1 } } return p && (m || console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."), p.start.set(0, 0, 0), p.end.set(0, 0, 0)), !0 } else { let v = this.points, x = !1, b = 0; for (let D = 0; D < 3; D++) { let L = v[D], H = v[(D + 1) % 3]; u.start.copy(L), u.end.copy(H), u.delta(o); let U = x ? c.start : c.end, V = Hu(y.distanceToPoint(L)); if (Hu(y.normal.dot(o)) && V) { c.copy(u), b = 2; break } if ((y.intersectLine(u, U) || V) && !Hu(U.distanceTo(H))) { if (b++, x) break; x = !0 } } if (b === 1 && f.containsPoint(c.end)) return p && (p.start.copy(c.end), p.end.copy(c.end)), !0; if (b !== 2) return !1; let S = f.points, _ = !1, E = 0; for (let D = 0; D < 3; D++) { let L = S[D], H = S[(D + 1) % 3]; u.start.copy(L), u.end.copy(H), u.delta(a); let U = _ ? h.start : h.end, V = Hu(g.distanceToPoint(L)); if (Hu(g.normal.dot(a)) && V) { h.copy(u), E = 2; break } if ((g.intersectLine(u, U) || V) && !Hu(U.distanceTo(H))) { if (E++, _) break; _ = !0 } } if (E === 1 && this.containsPoint(h.end)) return p && (p.start.copy(h.end), p.end.copy(h.end)), !0; if (E !== 2) return !1; if (c.delta(o), h.delta(a), o.dot(a) < 0) { let D = h.start; h.start = h.end, h.end = D } let w = c.start.dot(o), M = c.end.dot(o), T = h.start.dot(o), I = h.end.dot(o), C = M < T, P = w < I; return w !== I && T !== M && C === P ? !1 : (p && (l.subVectors(c.start, h.start), l.dot(o) > 0 ? p.start.copy(c.start) : p.start.copy(h.start), l.subVectors(c.end, h.end), l.dot(o) < 0 ? p.end.copy(c.end) : p.end.copy(h.end)), !0) } } }(); Xr.prototype.distanceToPoint = function () { let i = new A; return function (e) { return this.closestPointToPoint(e, i), e.distanceTo(i) } }(); Xr.prototype.distanceToTriangle = function () { let i = new A, t = new A, e = ["a", "b", "c"], n = new Hn, r = new Hn; return function (o, a = null, l = null) { let u = a || l ? n : null; if (this.intersectsTriangle(o, u)) return (a || l) && (a && u.getCenter(a), l && u.getCenter(l)), 0; let c = 1 / 0; for (let h = 0; h < 3; h++) { let d, f = e[h], p = o[f]; this.closestPointToPoint(p, i), d = p.distanceToSquared(i), d < c && (c = d, a && a.copy(i), l && l.copy(p)); let m = this[f]; o.closestPointToPoint(m, i), d = m.distanceToSquared(i), d < c && (c = d, a && a.copy(m), l && l.copy(i)) } for (let h = 0; h < 3; h++) { let d = e[h], f = e[(h + 1) % 3]; n.set(this[d], this[f]); for (let p = 0; p < 3; p++) { let m = e[p], g = e[(p + 1) % 3]; r.set(o[m], o[g]), Ef(n, r, i, t); let y = i.distanceToSquared(t); y < c && (c = y, a && a.copy(i), l && l.copy(t)) } } return Math.sqrt(c) } }(); var Qr = class { constructor(t, e, n) { this.isOrientedBox = !0, this.min = new A, this.max = new A, this.matrix = new se, this.invMatrix = new se, this.points = new Array(8).fill().map(() => new A), this.satAxes = new Array(3).fill().map(() => new A), this.satBounds = new Array(3).fill().map(() => new Yr), this.alignedSatBounds = new Array(3).fill().map(() => new Yr), this.needsUpdate = !1, t && this.min.copy(t), e && this.max.copy(e), n && this.matrix.copy(n) } set (t, e, n) { this.min.copy(t), this.max.copy(e), this.matrix.copy(n), this.needsUpdate = !0 } copy (t) { this.min.copy(t.min), this.max.copy(t.max), this.matrix.copy(t.matrix), this.needsUpdate = !0 } }; Qr.prototype.update = function () { return function () { let t = this.matrix, e = this.min, n = this.max, r = this.points; for (let u = 0; u <= 1; u++)for (let c = 0; c <= 1; c++)for (let h = 0; h <= 1; h++) { let d = 1 * u | 2 * c | 4 * h, f = r[d]; f.x = u ? n.x : e.x, f.y = c ? n.y : e.y, f.z = h ? n.z : e.z, f.applyMatrix4(t) } let s = this.satBounds, o = this.satAxes, a = r[0]; for (let u = 0; u < 3; u++) { let c = o[u], h = s[u], d = 1 << u, f = r[d]; c.subVectors(a, f), h.setFromPoints(c, r) } let l = this.alignedSatBounds; l[0].setFromPointsField(r, "x"), l[1].setFromPointsField(r, "y"), l[2].setFromPointsField(r, "z"), this.invMatrix.copy(this.matrix).invert(), this.needsUpdate = !1 } }(); Qr.prototype.intersectsBox = function () { let i = new Yr; return function (e) { this.needsUpdate && this.update(); let n = e.min, r = e.max, s = this.satBounds, o = this.satAxes, a = this.alignedSatBounds; if (i.min = n.x, i.max = r.x, a[0].isSeparated(i) || (i.min = n.y, i.max = r.y, a[1].isSeparated(i)) || (i.min = n.z, i.max = r.z, a[2].isSeparated(i))) return !1; for (let l = 0; l < 3; l++) { let u = o[l], c = s[l]; if (i.setFromBox(u, e), c.isSeparated(i)) return !1 } return !0 } }(); Qr.prototype.intersectsTriangle = function () { let i = new Xr, t = new Array(3), e = new Yr, n = new Yr, r = new A; return function (o) { this.needsUpdate && this.update(), o.isExtendedTriangle ? o.needsUpdate && o.update() : (i.copy(o), i.update(), o = i); let a = this.satBounds, l = this.satAxes; t[0] = o.a, t[1] = o.b, t[2] = o.c; for (let d = 0; d < 3; d++) { let f = a[d], p = l[d]; if (e.setFromPoints(p, t), f.isSeparated(e)) return !1 } let u = o.satBounds, c = o.satAxes, h = this.points; for (let d = 0; d < 3; d++) { let f = u[d], p = c[d]; if (e.setFromPoints(p, h), f.isSeparated(e)) return !1 } for (let d = 0; d < 3; d++) { let f = l[d]; for (let p = 0; p < 4; p++) { let m = c[p]; if (r.crossVectors(f, m), e.setFromPoints(r, t), n.setFromPoints(r, h), e.isSeparated(n)) return !1 } } return !0 } }(); Qr.prototype.closestPointToPoint = function () { return function (t, e) { return this.needsUpdate && this.update(), e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix), e } }(); Qr.prototype.distanceToPoint = function () { let i = new A; return function (e) { return this.closestPointToPoint(e, i), e.distanceTo(i) } }(); Qr.prototype.distanceToBox = function () { let i = ["x", "y", "z"], t = new Array(12).fill().map(() => new Hn), e = new Array(12).fill().map(() => new Hn), n = new A, r = new A; return function (o, a = 0, l = null, u = null) { if (this.needsUpdate && this.update(), this.intersectsBox(o)) return (l || u) && (o.getCenter(r), this.closestPointToPoint(r, n), o.closestPointToPoint(n, r), l && l.copy(n), u && u.copy(r)), 0; let c = a * a, h = o.min, d = o.max, f = this.points, p = 1 / 0; for (let g = 0; g < 8; g++) { let y = f[g]; r.copy(y).clamp(h, d); let v = y.distanceToSquared(r); if (v < p && (p = v, l && l.copy(y), u && u.copy(r), v < c)) return Math.sqrt(v) } let m = 0; for (let g = 0; g < 3; g++)for (let y = 0; y <= 1; y++)for (let v = 0; v <= 1; v++) { let x = (g + 1) % 3, b = (g + 2) % 3, S = y << x | v << b, _ = 1 << g | y << x | v << b, E = f[S], w = f[_]; t[m].set(E, w); let T = i[g], I = i[x], C = i[b], P = e[m], D = P.start, L = P.end; D[T] = h[T], D[I] = y ? h[I] : d[I], D[C] = v ? h[C] : d[I], L[T] = d[T], L[I] = y ? h[I] : d[I], L[C] = v ? h[C] : d[I], m++ } for (let g = 0; g <= 1; g++)for (let y = 0; y <= 1; y++)for (let v = 0; v <= 1; v++) { r.x = g ? d.x : h.x, r.y = y ? d.y : h.y, r.z = v ? d.z : h.z, this.closestPointToPoint(r, n); let x = r.distanceToSquared(n); if (x < p && (p = x, l && l.copy(n), u && u.copy(r), x < c)) return Math.sqrt(x) } for (let g = 0; g < 12; g++) { let y = t[g]; for (let v = 0; v < 12; v++) { let x = e[v]; Ef(y, x, n, r); let b = n.distanceToSquared(r); if (b < p && (p = b, l && l.copy(n), u && u.copy(r), b < c)) return Math.sqrt(b) } } return Math.sqrt(p) } }(); var ju = new A, Wu = new A, qu = new A, ay = new B, ly = new B, cy = new B, XC = new A, QC = new A, KC = new A, uy = new A; function Mj (i, t, e, n, r, s) { let o; return s === Ln ? o = i.intersectTriangle(n, e, t, !0, r) : o = i.intersectTriangle(t, e, n, s !== Nr, r), o === null ? null : { distance: i.origin.distanceTo(r), point: r.clone() } } function Tj (i, t, e, n, r, s, o, a, l) { ju.fromBufferAttribute(t, s), Wu.fromBufferAttribute(t, o), qu.fromBufferAttribute(t, a); let u = Mj(i, ju, Wu, qu, uy, l); if (u) { n && (ay.fromBufferAttribute(n, s), ly.fromBufferAttribute(n, o), cy.fromBufferAttribute(n, a), u.uv = nn.getInterpolation(uy, ju, Wu, qu, ay, ly, cy, new B)), r && (ay.fromBufferAttribute(r, s), ly.fromBufferAttribute(r, o), cy.fromBufferAttribute(r, a), u.uv1 = nn.getInterpolation(uy, ju, Wu, qu, ay, ly, cy, new B)), e && (XC.fromBufferAttribute(e, s), QC.fromBufferAttribute(e, o), KC.fromBufferAttribute(e, a), u.normal = nn.getInterpolation(uy, ju, Wu, qu, XC, QC, KC, new A), u.normal.dot(i.direction) > 0 && u.normal.multiplyScalar(-1)); let c = { a: s, b: o, c: a, normal: new A, materialIndex: 0 }; nn.getNormal(ju, Wu, qu, c.normal), u.face = c, u.faceIndex = s } return u } function cw (i, t, e, n, r) { let s = n * 3, o = i.index.getX(s), a = i.index.getX(s + 1), l = i.index.getX(s + 2), { position: u, normal: c, uv: h, uv1: d } = i.attributes, f = Tj(e, u, c, h, d, o, a, l, t); return f ? (f.faceIndex = n, r && r.push(f), f) : null } function ZC (i, t, e, n, r, s) { for (let o = n, a = n + r; o < a; o++)cw(i, t, e, o, s) } function JC (i, t, e, n, r) { let s = 1 / 0, o = null; for (let a = n, l = n + r; a < l; a++) { let u = cw(i, t, e, a); u && u.distance < s && (o = u, s = u.distance) } return o } function Pi (i, t, e, n) { let r = i.a, s = i.b, o = i.c, a = t, l = t + 1, u = t + 2; e && (a = e.getX(t), l = e.getX(t + 1), u = e.getX(t + 2)), r.x = n.getX(a), r.y = n.getY(a), r.z = n.getZ(a), s.x = n.getX(l), s.y = n.getY(l), s.z = n.getZ(l), o.x = n.getX(u), o.y = n.getY(u), o.z = n.getZ(u) } function uw (i, t, e, n, r, s, o) { let a = e.index, l = e.attributes.position; for (let u = i, c = t + i; u < c; u++)if (Pi(o, u * 3, a, l), o.needsUpdate = !0, n(o, u, r, s)) return !0; return !1 } var Yu = class { constructor(t) { this._getNewPrimitive = t, this._primitives = [] } getPrimitive () { let t = this._primitives; return t.length === 0 ? this._getNewPrimitive() : t.pop() } releasePrimitive (t) { this._primitives.push(t) } }; function Do (i, t) { return t[i + 15] === 65535 } function Ll (i, t) { return t[i + 6] } function Xu (i, t) { return t[i + 14] } function Qu (i) { return i + 8 } function Ku (i, t) { return t[i + 6] } function $C (i, t) { return t[i + 7] } var Zu = new _t, dy = new A, Pj = ["x", "y", "z"]; function fy (i, t, e, n, r) { let s = i * 2, o = Ju, a = Ia, l = Da; if (Do(s, a)) { let c = Ll(i, l), h = Xu(s, a); ZC(t, e, n, c, h, r) } else { let c = Qu(i); my(c, o, n, dy) && fy(c, t, e, n, r); let h = Ku(i, l); my(h, o, n, dy) && fy(h, t, e, n, r) } } function py (i, t, e, n) { let r = i * 2, s = Ju, o = Ia, a = Da; if (Do(r, o)) { let u = Ll(i, a), c = Xu(r, o); return JC(t, e, n, u, c) } else { let u = $C(i, a), c = Pj[u], d = n.direction[c] >= 0, f, p; d ? (f = Qu(i), p = Ku(i, a)) : (f = Ku(i, a), p = Qu(i)); let g = my(f, s, n, dy) ? py(f, t, e, n) : null; if (g) { let x = g.point[c]; if (d ? x <= s[p + u] : x >= s[p + u + 3]) return g } let v = my(p, s, n, dy) ? py(p, t, e, n) : null; return g && v ? g.distance <= v.distance ? g : v : g || v || null } } var eP = function () { let i, t, e = [], n = new Yu(() => new _t); return function (...o) { i = n.getPrimitive(), t = n.getPrimitive(), e.push(i, t); let a = r(...o); n.releasePrimitive(i), n.releasePrimitive(t), e.pop(), e.pop(); let l = e.length; return l > 0 && (t = e[l - 1], i = e[l - 2]), a }; function r (s, o, a, l, u = null, c = 0, h = 0) { function d (x) { let b = x * 2, S = Ia, _ = Da; for (; !Do(b, S);)x = Qu(x), b = x * 2; return Ll(x, _) } function f (x) { let b = x * 2, S = Ia, _ = Da; for (; !Do(b, S);)x = Ku(x, _), b = x * 2; return Ll(x, _) + Xu(b, S) } let p = s * 2, m = Ju, g = Ia, y = Da; if (Do(p, g)) { let x = Ll(s, y), b = Xu(p, g); return Ci(s, m, i), l(x, b, !1, h, c + s, i) } else { let x = Qu(s), b = Ku(s, y), S = x, _ = b, E, w, M, T; if (u && (M = i, T = t, Ci(S, m, M), Ci(_, m, T), E = u(M), w = u(T), w < E)) { S = b, _ = x; let U = E; E = w, w = U, M = T } M || (M = i, Ci(S, m, M)); let I = Do(S * 2, g), C = a(M, I, E, h + 1, c + S), P; if (C === 2) { let U = d(S), G = f(S) - U; P = l(U, G, !0, h + 1, c + S, M) } else P = C && r(S, o, a, l, u, c, h + 1); if (P) return !0; T = t, Ci(_, m, T); let D = Do(_ * 2, g), L = a(T, D, w, h + 1, c + _), H; if (L === 2) { let U = d(_), G = f(_) - U; H = l(U, G, !0, h + 1, c + _, T) } else H = L && r(_, o, a, l, u, c, h + 1); return !!H } } }(), tP = function () { let i = new Xr, t = new Xr, e = new se, n = new Qr, r = new Qr; return function s (o, a, l, u, c = null) { let h = o * 2, d = Ju, f = Ia, p = Da; if (c === null && (l.boundingBox || l.computeBoundingBox(), n.set(l.boundingBox.min, l.boundingBox.max, u), c = n), Do(h, f)) { let g = a, y = g.index, v = g.attributes.position, x = l.index, b = l.attributes.position, S = Ll(o, p), _ = Xu(h, f); if (e.copy(u).invert(), l.boundsTree) return Ci(o, d, r), r.matrix.copy(e), r.needsUpdate = !0, l.boundsTree.shapecast({ intersectsBounds: w => r.intersectsBox(w), intersectsTriangle: w => { w.a.applyMatrix4(u), w.b.applyMatrix4(u), w.c.applyMatrix4(u), w.needsUpdate = !0; for (let M = S * 3, T = (_ + S) * 3; M < T; M += 3)if (Pi(t, M, y, v), t.needsUpdate = !0, w.intersectsTriangle(t)) return !0; return !1 } }); for (let E = S * 3, w = _ + S * 3; E < w; E += 3) { Pi(i, E, y, v), i.a.applyMatrix4(e), i.b.applyMatrix4(e), i.c.applyMatrix4(e), i.needsUpdate = !0; for (let M = 0, T = x.count; M < T; M += 3)if (Pi(t, M, x, b), t.needsUpdate = !0, i.intersectsTriangle(t)) return !0 } } else { let g = o + 8, y = p[o + 6]; return Ci(g, d, Zu), !!(c.intersectsBox(Zu) && s(g, a, l, u, c) || (Ci(y, d, Zu), c.intersectsBox(Zu) && s(y, a, l, u, c))) } } }(); function my (i, t, e, n) { return Ci(i, t, Zu), e.intersectBox(Zu, n) } var hw = [], hy, Ju, Ia, Da; function $u (i) { hy && hw.push(hy), hy = i, Ju = new Float32Array(i), Ia = new Uint16Array(i), Da = new Uint32Array(i) } function Mf () { hy = null, Ju = null, Ia = null, Da = null, hw.length && $u(hw.pop()) } var dw = Symbol("skip tree generation"), fw = new _t, pw = new _t, eh = new se, Nl = new Qr, Tf = new Qr, Cf = new A, gy = new A, Ij = new A, Dj = new A, Oj = new A, nP = new _t, Ds = new Yu(() => new Xr), Os = class { static serialize (t, e = {}) { if (e.isBufferGeometry) return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."), Os.serialize(arguments[0], { cloneBuffers: arguments[2] === void 0 ? !0 : arguments[2] }); e = { cloneBuffers: !0, ...e }; let n = t.geometry, r = t._roots, s = n.getIndex(), o; return e.cloneBuffers ? o = { roots: r.map(a => a.slice()), index: s.array.slice() } : o = { roots: r, index: s.array }, o } static deserialize (t, e, n = {}) { if (typeof n == "boolean") return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."), Os.deserialize(arguments[0], arguments[1], { setIndex: arguments[2] === void 0 ? !0 : arguments[2] }); n = { setIndex: !0, ...n }; let { index: r, roots: s } = t, o = new Os(e, { ...n, [dw]: !0 }); if (o._roots = s, n.setIndex) { let a = e.getIndex(); if (a === null) { let l = new ze(t.index, 1, !1); e.setIndex(l) } else a.array !== r && (a.array.set(r), a.needsUpdate = !0) } return o } constructor(t, e = {}) { if (t.isBufferGeometry) { if (t.index && t.index.isInterleavedBufferAttribute) throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.") } else throw new Error("MeshBVH: Only BufferGeometries are supported."); if (e = Object.assign({ strategy: 0, maxDepth: 40, maxLeafTris: 10, verbose: !0, useSharedArrayBuffer: !1, setBoundingBox: !0, onProgress: null, [dw]: !1 }, e), e.useSharedArrayBuffer && typeof SharedArrayBuffer > "u") throw new Error("MeshBVH: SharedArrayBuffer is not available."); this._roots = null, e[dw] || (this._roots = qC(t, e), !t.boundingBox && e.setBoundingBox && (t.boundingBox = this.getBoundingBox(new _t))), this.geometry = t } refit (t = null) { t && Array.isArray(t) && (t = new Set(t)); let e = this.geometry, n = e.index.array, r = e.attributes.position, s, o, a, l, u = 0, c = this._roots; for (let d = 0, f = c.length; d < f; d++)s = c[d], o = new Uint32Array(s), a = new Uint16Array(s), l = new Float32Array(s), h(0, u), u += s.byteLength; function h (d, f, p = !1) { let m = d * 2; if (a[m + 15] === 65535) { let y = o[d + 6], v = a[m + 14], x = 1 / 0, b = 1 / 0, S = 1 / 0, _ = -1 / 0, E = -1 / 0, w = -1 / 0; for (let M = 3 * y, T = 3 * (y + v); M < T; M++) { let I = n[M], C = r.getX(I), P = r.getY(I), D = r.getZ(I); C < x && (x = C), C > _ && (_ = C), P < b && (b = P), P > E && (E = P), D < S && (S = D), D > w && (w = D) } return l[d + 0] !== x || l[d + 1] !== b || l[d + 2] !== S || l[d + 3] !== _ || l[d + 4] !== E || l[d + 5] !== w ? (l[d + 0] = x, l[d + 1] = b, l[d + 2] = S, l[d + 3] = _, l[d + 4] = E, l[d + 5] = w, !0) : !1 } else { let y = d + 8, v = o[d + 6], x = y + f, b = v + f, S = p, _ = !1, E = !1; t ? S || (_ = t.has(x), E = t.has(b), S = !_ && !E) : (_ = !0, E = !0); let w = S || _, M = S || E, T = !1; w && (T = h(y, f, S)); let I = !1; M && (I = h(v, f, S)); let C = T || I; if (C) for (let P = 0; P < 3; P++) { let D = y + P, L = v + P, H = l[D], U = l[D + 3], V = l[L], G = l[L + 3]; l[d + P] = H < V ? H : V, l[d + P + 3] = U > G ? U : G } return C } } } traverse (t, e = 0) { let n = this._roots[e], r = new Uint32Array(n), s = new Uint16Array(n); o(0); function o (a, l = 0) { let u = a * 2, c = s[u + 15] === 65535; if (c) { let h = r[a + 6], d = s[u + 14]; t(l, c, new Float32Array(n, a * 4, 6), h, d) } else { let h = a + 32 / 4, d = r[a + 6], f = r[a + 7]; t(l, c, new Float32Array(n, a * 4, 6), f) || (o(h, l + 1), o(d, l + 1)) } } } raycast (t, e = ai) { let n = this._roots, r = this.geometry, s = [], o = e.isMaterial, a = Array.isArray(e), l = r.groups, u = o ? e.side : e; for (let c = 0, h = n.length; c < h; c++) { let d = a ? e[l[c].materialIndex].side : u, f = s.length; if ($u(n[c]), fy(0, r, d, t, s), Mf(), a) { let p = l[c].materialIndex; for (let m = f, g = s.length; m < g; m++)s[m].face.materialIndex = p } } return s } raycastFirst (t, e = ai) { let n = this._roots, r = this.geometry, s = e.isMaterial, o = Array.isArray(e), a = null, l = r.groups, u = s ? e.side : e; for (let c = 0, h = n.length; c < h; c++) { let d = o ? e[l[c].materialIndex].side : u; $u(n[c]); let f = py(0, r, d, t); Mf(), f != null && (a == null || f.distance < a.distance) && (a = f, o && (f.face.materialIndex = l[c].materialIndex)) } return a } intersectsGeometry (t, e) { let n = this.geometry, r = !1; for (let s of this._roots) if ($u(s), r = tP(0, n, t, e), Mf(), r) break; return r } shapecast (t, e, n) { let r = this.geometry; if (t instanceof Function) { if (e) { let d = e; e = (f, p, m, g) => { let y = p * 3; return d(f, y, y + 1, y + 2, m, g) } } t = { boundsTraverseOrder: n, intersectsBounds: t, intersectsTriangle: e, intersectsRange: null }, console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.") } let s = Ds.getPrimitive(), { boundsTraverseOrder: o, intersectsBounds: a, intersectsRange: l, intersectsTriangle: u } = t; if (l && u) { let d = l; l = (f, p, m, g, y) => d(f, p, m, g, y) ? !0 : uw(f, p, r, u, m, g, s) } else l || (u ? l = (d, f, p, m) => uw(d, f, r, u, p, m, s) : l = (d, f, p) => p); let c = !1, h = 0; for (let d of this._roots) { if ($u(d), c = eP(0, r, a, l, o, h), Mf(), c) break; h += d.byteLength } return Ds.releasePrimitive(s), c } bvhcast (t, e, n) { let { intersectsRanges: r, intersectsTriangles: s } = n, o = this.geometry.index, a = this.geometry.attributes.position, l = t.geometry.index, u = t.geometry.attributes.position; eh.copy(e).invert(); let c = Ds.getPrimitive(), h = Ds.getPrimitive(); if (s) { let f = function (p, m, g, y, v, x, b, S) { for (let _ = g, E = g + y; _ < E; _++) { Pi(h, _ * 3, l, u), h.a.applyMatrix4(e), h.b.applyMatrix4(e), h.c.applyMatrix4(e), h.needsUpdate = !0; for (let w = p, M = p + m; w < M; w++)if (Pi(c, w * 3, o, a), c.needsUpdate = !0, s(c, h, w, _, v, x, b, S)) return !0 } return !1 }; if (r) { let p = r; r = function (m, g, y, v, x, b, S, _) { return p(m, g, y, v, x, b, S, _) ? !0 : f(m, g, y, v, x, b, S, _) } } else r = f } t.getBoundingBox(pw), pw.applyMatrix4(e); let d = this.shapecast({ intersectsBounds: f => pw.intersectsBox(f), intersectsRange: (f, p, m, g, y, v) => (fw.copy(v), fw.applyMatrix4(eh), t.shapecast({ intersectsBounds: x => fw.intersectsBox(x), intersectsRange: (x, b, S, _, E) => r(f, p, x, b, g, y, _, E) })) }); return Ds.releasePrimitive(c), Ds.releasePrimitive(h), d } intersectsBox (t, e) { return Nl.set(t.min, t.max, e), Nl.needsUpdate = !0, this.shapecast({ intersectsBounds: n => Nl.intersectsBox(n), intersectsTriangle: n => Nl.intersectsTriangle(n) }) } intersectsSphere (t) { return this.shapecast({ intersectsBounds: e => t.intersectsBox(e), intersectsTriangle: e => e.intersectsSphere(t) }) } closestPointToGeometry (t, e, n = {}, r = {}, s = 0, o = 1 / 0) { t.boundingBox || t.computeBoundingBox(), Nl.set(t.boundingBox.min, t.boundingBox.max, e), Nl.needsUpdate = !0; let a = this.geometry, l = a.attributes.position, u = a.index, c = t.attributes.position, h = t.index, d = Ds.getPrimitive(), f = Ds.getPrimitive(), p = gy, m = Ij, g = null, y = null; r && (g = Dj, y = Oj); let v = 1 / 0, x = null, b = null; return eh.copy(e).invert(), Tf.matrix.copy(eh), this.shapecast({ boundsTraverseOrder: S => Nl.distanceToBox(S), intersectsBounds: (S, _, E) => E < v && E < o ? (_ && (Tf.min.copy(S.min), Tf.max.copy(S.max), Tf.needsUpdate = !0), !0) : !1, intersectsRange: (S, _) => { if (t.boundsTree) return t.boundsTree.shapecast({ boundsTraverseOrder: E => Tf.distanceToBox(E), intersectsBounds: (E, w, M) => M < v && M < o, intersectsRange: (E, w) => { for (let M = E * 3, T = (E + w) * 3; M < T; M += 3) { Pi(f, M, h, c), f.a.applyMatrix4(e), f.b.applyMatrix4(e), f.c.applyMatrix4(e), f.needsUpdate = !0; for (let I = S * 3, C = (S + _) * 3; I < C; I += 3) { Pi(d, I, u, l), d.needsUpdate = !0; let P = d.distanceToTriangle(f, p, g); if (P < v && (m.copy(p), y && y.copy(g), v = P, x = I / 3, b = M / 3), P < s) return !0 } } } }); { let E = h ? h.count : c.count; for (let w = 0, M = E; w < M; w += 3) { Pi(f, w, h, c), f.a.applyMatrix4(e), f.b.applyMatrix4(e), f.c.applyMatrix4(e), f.needsUpdate = !0; for (let T = S * 3, I = (S + _) * 3; T < I; T += 3) { Pi(d, T, u, l), d.needsUpdate = !0; let C = d.distanceToTriangle(f, p, g); if (C < v && (m.copy(p), y && y.copy(g), v = C, x = T / 3, b = w / 3), C < s) return !0 } } } } }), Ds.releasePrimitive(d), Ds.releasePrimitive(f), v === 1 / 0 ? null : (n.point ? n.point.copy(m) : n.point = m.clone(), n.distance = v, n.faceIndex = x, r && (r.point ? r.point.copy(y) : r.point = y.clone(), r.point.applyMatrix4(eh), m.applyMatrix4(eh), r.distance = m.sub(r.point).length(), r.faceIndex = b), n) } closestPointToPoint (t, e = {}, n = 0, r = 1 / 0) { let s = n * n, o = r * r, a = 1 / 0, l = null; if (this.shapecast({ boundsTraverseOrder: c => (Cf.copy(t).clamp(c.min, c.max), Cf.distanceToSquared(t)), intersectsBounds: (c, h, d) => d < a && d < o, intersectsTriangle: (c, h) => { c.closestPointToPoint(t, Cf); let d = t.distanceToSquared(Cf); return d < a && (gy.copy(Cf), a = d, l = h), d < s } }), a === 1 / 0) return null; let u = Math.sqrt(a); return e.point ? e.point.copy(gy) : e.point = gy.clone(), e.distance = u, e.faceIndex = l, e } getBoundingBox (t) { return t.makeEmpty(), this._roots.forEach(n => { Ci(0, new Float32Array(n), nP), t.union(nP) }), t } }; var jh = sc(iP()); var Rj = .5 * (Math.sqrt(3) - 1), Pf = (3 - Math.sqrt(3)) / 6, Lj = 1 / 3, Rs = 1 / 6, qae = (Math.sqrt(5) - 1) / 4, Yae = (5 - Math.sqrt(5)) / 20, If = i => Math.floor(i) | 0, sP = new Float64Array([1, 1, -1, 1, 1, -1, -1, -1, 1, 0, -1, 0, 1, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, -1]), gw = new Float64Array([1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1, 0, 1, 0, 1, -1, 0, 1, 1, 0, -1, -1, 0, -1, 0, 1, 1, 0, -1, 1, 0, 1, -1, 0, -1, -1]); function yy (i = Math.random) { let t = aP(i), e = new Float64Array(t).map(r => sP[r % 12 * 2]), n = new Float64Array(t).map(r => sP[r % 12 * 2 + 1]); return function (s, o) { let a = 0, l = 0, u = 0, c = (s + o) * Rj, h = If(s + c), d = If(o + c), f = (h + d) * Pf, p = h - f, m = d - f, g = s - p, y = o - m, v, x; g > y ? (v = 1, x = 0) : (v = 0, x = 1); let b = g - v + Pf, S = y - x + Pf, _ = g - 1 + 2 * Pf, E = y - 1 + 2 * Pf, w = h & 255, M = d & 255, T = .5 - g * g - y * y; if (T >= 0) { let P = w + t[M], D = e[P], L = n[P]; T *= T, a = T * T * (D * g + L * y) } let I = .5 - b * b - S * S; if (I >= 0) { let P = w + v + t[M + x], D = e[P], L = n[P]; I *= I, l = I * I * (D * b + L * S) } let C = .5 - _ * _ - E * E; if (C >= 0) { let P = w + 1 + t[M + 1], D = e[P], L = n[P]; C *= C, u = C * C * (D * _ + L * E) } return 70 * (a + l + u) } } function oP (i = Math.random) { let t = aP(i), e = new Float64Array(t).map(s => gw[s % 12 * 3]), n = new Float64Array(t).map(s => gw[s % 12 * 3 + 1]), r = new Float64Array(t).map(s => gw[s % 12 * 3 + 2]); return function (o, a, l) { let u, c, h, d, f = (o + a + l) * Lj, p = If(o + f), m = If(a + f), g = If(l + f), y = (p + m + g) * Rs, v = p - y, x = m - y, b = g - y, S = o - v, _ = a - x, E = l - b, w, M, T, I, C, P; S >= _ ? _ >= E ? (w = 1, M = 0, T = 0, I = 1, C = 1, P = 0) : S >= E ? (w = 1, M = 0, T = 0, I = 1, C = 0, P = 1) : (w = 0, M = 0, T = 1, I = 1, C = 0, P = 1) : _ < E ? (w = 0, M = 0, T = 1, I = 0, C = 1, P = 1) : S < E ? (w = 0, M = 1, T = 0, I = 0, C = 1, P = 1) : (w = 0, M = 1, T = 0, I = 1, C = 1, P = 0); let D = S - w + Rs, L = _ - M + Rs, H = E - T + Rs, U = S - I + 2 * Rs, V = _ - C + 2 * Rs, G = E - P + 2 * Rs, z = S - 1 + 3 * Rs, $ = _ - 1 + 3 * Rs, F = E - 1 + 3 * Rs, j = p & 255, X = m & 255, q = g & 255, k = .6 - S * S - _ * _ - E * E; if (k < 0) u = 0; else { let W = j + t[X + t[q]]; k *= k, u = k * k * (e[W] * S + n[W] * _ + r[W] * E) } let Z = .6 - D * D - L * L - H * H; if (Z < 0) c = 0; else { let W = j + w + t[X + M + t[q + T]]; Z *= Z, c = Z * Z * (e[W] * D + n[W] * L + r[W] * H) } let K = .6 - U * U - V * V - G * G; if (K < 0) h = 0; else { let W = j + I + t[X + C + t[q + P]]; K *= K, h = K * K * (e[W] * U + n[W] * V + r[W] * G) } let Q = .6 - z * z - $ * $ - F * F; if (Q < 0) d = 0; else { let W = j + 1 + t[X + 1 + t[q + 1]]; Q *= Q, d = Q * Q * (e[W] * z + n[W] * $ + r[W] * F) } return 32 * (u + c + h + d) } } function aP (i) { let e = new Uint8Array(512); for (let n = 0; n < 512 / 2; n++)e[n] = n; for (let n = 0; n < 512 / 2 - 1; n++) { let r = n + ~~(i() * (256 - n)), s = e[n]; e[n] = e[r], e[r] = s } for (let n = 256; n < 512; n++)e[n] = e[n - 256]; return e } var $i = new nn, vy = class { constructor(t) { this.weightAttribute = null; let e = t.geometry; if (!e.isBufferGeometry || e.attributes.position.itemSize !== 3) throw new Error("THREE.MeshSurfaceSampler: Requires BufferGeometry triangle mesh."); e.index && (e = e.toNonIndexed()), this.geometry = e, this.randomFunction = Math.random, this.positionAttribute = this.geometry.getAttribute("position"), this.distribution = null } build () { let t = this.positionAttribute, e = new Float32Array(t.count / 3); for (let r = 0; r < t.count; r += 3) { let s = 1; $i.a.fromBufferAttribute(t, r), $i.b.fromBufferAttribute(t, r + 1), $i.c.fromBufferAttribute(t, r + 2), s *= $i.getArea(), e[r / 3] = s } this.distribution = new Float32Array(t.count / 3); let n = 0; for (let r = 0; r < e.length; r++)n += e[r], this.distribution[r] = n; return this } setRandomGenerator (t) { return this.randomFunction = t, this } sample (t, e) { if (this.distribution) { let n = this.distribution[this.distribution.length - 1], r = this.binarySearch(this.randomFunction() * n); return this.sampleFace(r, t, e) } } binarySearch (t) { if (!this.distribution) return 0; let e = this.distribution, n = 0, r = e.length - 1, s = -1; for (; n <= r;) { let o = Math.ceil((n + r) / 2); if (o === 0 || e[o - 1] <= t && e[o] > t) { s = o; break } else t < e[o] ? r = o - 1 : n = o + 1 } return s } sampleFace (t, e, n) { let r = this.randomFunction(), s = this.randomFunction(); return r + s > 1 && (r = 1 - r, s = 1 - s), $i.a.fromBufferAttribute(this.positionAttribute, t * 3), $i.b.fromBufferAttribute(this.positionAttribute, t * 3 + 1), $i.c.fromBufferAttribute(this.positionAttribute, t * 3 + 2), e.set(0, 0, 0).addScaledVector($i.a, r).addScaledVector($i.b, s).addScaledVector($i.c, 1 - (r + s)), $i.getNormal(n), this } }; var cP = sc(yw()), Nj = new se, Bj = new se, Fj = new se, th; (t => { function i (e) { return e && e.__isSPEObject } t.is = i })(th || (th = {})); var nh = i => class extends i { constructor() { super(...arguments); this.previousModelViewMatrix = new se; this.copyPreviousMatrix = !0; this.hiddenMatrix = new se; this.matrixWorldRigid = new se; this.shearScale = new se; this.shearScaleInv = new se } get __isSPEObject () { return !0 } isDescendantOf (n) { n instanceof ft && (n = n.uuid); let r = this; for (; r.parent;) { if (r.parent.uuid === n) return !0; r = r.parent } return !1 } updateMatrixWorld (n) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || n) && (this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, n = !0); for (let r of this.children) r.updateMatrixWorld(n) } updateWorldMatrix (n, r) { let s = this.parent; if (n && s !== null && s.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.parent === null ? this.matrixWorld.multiplyMatrices(this.hiddenMatrix, this.matrix) : (this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.hiddenMatrix), this.matrixWorld.multiplyMatrices(this.matrixWorld, this.matrix)), r) for (let o of this.children) o.updateWorldMatrix(!1, !0) } traverseChildren (n, r = 0) { for (let s of this.children) th.is(s) && s.traverseObject(n, r + 1) } traverseObject (n, r = 0) { if (n(this, r) !== !0) for (let o of this.children) th.is(o) && o.traverseObject(n, r + 1) } updateMatrixWorldSVD () { let n = this.matrixWorld.elements, r = [[n[0], n[4], n[8]], [n[1], n[5], n[9]], [n[2], n[6], n[10]]], { u: s, v: o, q: a } = (0, cP.SVD)(r), l = Nj.set(s[0][0], s[0][1], s[0][2], 0, s[1][0], s[1][1], s[1][2], 0, s[2][0], s[2][1], s[2][2], 0, 0, 0, 0, 1), u = Bj.set(o[0][0], o[0][1], o[0][2], 0, o[1][0], o[1][1], o[1][2], 0, o[2][0], o[2][1], o[2][2], 0, 0, 0, 0, 1), c = Fj.copy(u).transpose(); this.shearScale.makeScale(a[0], a[1], a[2]).multiply(c).premultiply(u), this.shearScaleInv.copy(this.shearScale).invert(), this.matrixWorldRigid.multiplyMatrices(l, c).copyPosition(this.matrixWorld), a.every(h => Math.abs(a[0] - h) < .01) ? this.hasNonUniformScale = !1 : this.hasNonUniformScale = !0 } attach (n, r) { this.updateWorldMatrix(!0, !1); let s = new se().copy(this.matrixWorld).invert(); return n.parent !== null && (n.parent.updateWorldMatrix(!0, !1), s.multiply(n.parent.matrixWorld)), "hiddenMatrix" in n && n.hiddenMatrix instanceof se ? n.hiddenMatrix.premultiply(s) : n.applyMatrix4(s), n.updateWorldMatrix(!1, !1), this.add(n), r !== void 0 && (this.children.pop(), this.children.splice(r, 0, n)), this } copy (n, r = !1) { return super.copy(n, r), this.hasNonUniformScale = n.hasNonUniformScale, this } onAfterRender (n, r, s, o, a, l) { this.copyPreviousMatrix && this.previousModelViewMatrix.copy(this.modelViewMatrix) } }; var vw = class extends nh(ft) { }, kj = i => i.type === "Mesh", sn = class extends vw { constructor(e) { super(); this.object = e; this.matrixAutoUpdate = !1, this.hasNonUniformScale = e.hasNonUniformScale } raycast (e, n) { } expand () { let e = 0, n = this.object.entityChildren(e); for (; n;) { let r = this.children[e]; r?.object !== n && (r && this.remove(r), r = new sn(n), this.add(r), this.children.splice(e, 0, this.children.pop()), r.matrixWorldNeedsUpdate = !0, r.matrixAutoUpdate = !1, r.matrix = n.matrix, r.hiddenMatrix = n.hiddenMatrix), r.expand(), e += 1, n = this.object.entityChildren(e) } for (; this.children.length > e;)this.remove(this.children[e]) } get visible () { return this.playModeVisible !== void 0 ? this.playModeVisible : this.object.visible || this.object.dataPatched.visible && this.object.dataPatched.cloner?.hideBase === !0 } set visible (e) { } get castShadow () { return this.object.castShadow } set castShadow (e) { } get receiveShadow () { return this.object.receiveShadow } set receiveShadow (e) { } get isMesh () { return kj(this.object) } get isLight () { return this.object.isLight } get layers () { return this.object.layers } set layers (e) { } get isCamera () { return !1 } get geometry () { if (this.object.geometry) return this.object.geometry } get material () { if (this.object.material) return this.object.material } }; var Bl = new A, Fl = new A, rh = new se, hP = [new A(-1, 1, 1), new A(-1, -1, 1), new A(1, -1, 1), new A(1, 1, 1), new A(-1, 1, -1), new A(-1, -1, -1), new A(1, -1, -1), new A(1, 1, -1)], Uj = [[0, 3], [1, 2], [5, 6], [4, 7], [0, 1], [3, 2], [7, 6], [4, 5], [0, 4], [1, 5], [2, 6], [3, 7]], zj = [[0, 2], [7, 5], [4, 1], [3, 6], [4, 3], [1, 6]], uP = (i, t, e) => { i.updateEntityBoxSize(Bl, Fl), rh.copy(t).multiply(i.matrixWorld), Fl.x === 0 && Fl.y === 0 && Fl.z === 0 ? e.push(new A(Bl.x, Bl.y, Bl.z).applyMatrix4(rh)) : hP.forEach(n => { e.push(n.clone().multiply(Fl).add(Bl).applyMatrix4(rh)) }) }, Df = class extends _t { constructor() { super(...arguments); this.matrix = new se; this.vertices = []; this.faces = []; this.edges = []; this.centerEdges = [] } copy (e) { return super.copy(e), this.matrix.copy(e.matrix), this.vertices = e.vertices.map(n => n.clone()), this.faces = e.faces.map(n => n.clone()), this.edges = e.edges.map(n => n.clone()), this.centerEdges = e.centerEdges.map(n => n.clone()), this } setFromObjectSize (e, n = !1) { e.updateWorldMatrix(!1, n), this.makeEmpty(), this.matrix.copy(e.matrixWorld); let r = new se().copy(e.matrixWorld).invert(); return this.expandByObjectSize(e, r, n) } expandByObjectSize (e, n, r = !1) { let s = []; return r === !0 ? e.traverseEntity(o => { if (o.visible || o.cloner && o.data.visible) { if (!("geometry" in o)) { s.push(new A); return } uP(o, n, s) } }) : uP(e, n, s), this.setFromPoints(s) } getCenter (e) { return e = super.getCenter(e), e.applyMatrix4(this.matrix), e } getPositionToCenter (e) { return e = super.getCenter(e), e.applyMatrix4(rh.copy(this.matrix).setPosition(0, 0, 0)), e } computeVertices () { this.getSize(Fl).multiplyScalar(.5), this.getCenter(Bl), rh.copy(this.matrix).setPosition(Bl), this.vertices = hP.map(e => e.clone().multiply(Fl).applyMatrix4(rh)) } computeEdges () { this.vertices.length > 0 && this.computeVertices(), this.edges = Uj.map(([e, n]) => new Hn(this.vertices[e], this.vertices[n])), this.centerEdges = this.edges.map(e => e.getCenter(new A)) } computeFaces () { this.vertices.length > 0 && this.computeVertices(), this.faces = zj.map(([e, n]) => this.vertices[e].clone().add(this.vertices[n]).multiplyScalar(.5)) } }; var es = { Cloner: () => { }, changeEntityProptotype: () => { }, createEntity: () => { } }; var bw = class extends Xd { constructor() { super() } getPoints (t = 12) { let e = [], n, r = this.getCurveLengths(), o = r[r.length - 1] / r.length; for (let a = 0, l = this.curves; a < l.length; a++) { let u = l[a], c = a === 0 ? r[a] : r[a] - r[a - 1], h = Math.ceil(t * c / o), d = u.getPoints(h); for (let f = 0; f < d.length; f++) { let p = d[f]; n && n.equals(p) || (e.push(p), n = p) } } return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e } }; var ww = .001; function Sw (i, t, e) { return t.clone().sub(i).cross(t.clone().sub(e)).length() <= ww } function xw (i, t) { let e = new A(...i.position), n = new A(...i.controlNext.position), r = new A(...t.controlPrevious.position), s = new A(...t.position); return Sw(e, n, s) && Sw(e, r, s) } function by (i) { let t = i.points.map(c => new A(...c.data.position)), e = [i.points[0]], n = new A(...e[0].data.position); for (let c = 0; c < i.points.length - 1; c++)Sw(n, t[c], t[c + 1]) || (e.push(i.points[c]), n = t[c]); e.push(i.points[i.points.length - 1]); let r = i.isClosed, s = e.length - (r ? 0 : 1), o = e.length, a = []; for (let c = 0; c < o; c++) { let h = e[c].data, d = new A(...h.position), f = new A(...h.controlPrevious.position), p = new A(...h.controlNext.position), m = { position: d, baseRoundness: h.roundness, controlPrevious: f, controlNext: p }; if (h.roundness === 0 || !i.isClosed && (c === 0 || c === o - 1)) { a[c] = { ...m, removedLength: 0 }; continue } let g = r && c == 0 ? o - 1 : c - 1, y = r && c == o - 1 ? 0 : c + 1, v = e[g].data, x = e[y].data, b = new A(...v.position), S = new A(...x.position), _ = b.clone().sub(d).normalize(), E = S.clone().sub(d).normalize(); Object.assign(m, { prevDir: _, nextDir: E }); let w = xw(v, h), M = xw(h, x); if (!w || !M) a[c] = { ...m, removedLength: 0 }; else { let T = _.clone().add(E).normalize(), I = T.clone().cross(_).length() / _.dot(T); a[c] = { ...m, tan: I, removedLength: h.roundness / I } } } for (let c = 0; c < s; c++) { let h = c, d = r && c === o - 1 ? 0 : c + 1, f = a[h], p = a[d]; if (f.removedLength !== 0 || p.removedLength !== 0) { let m = f.position.distanceTo(p.position); f.removedLength = Math.min(f.removedLength, m / 2), p.removedLength = Math.min(p.removedLength, m / 2) } } let l = []; for (let c = 0; c < s; c++) { let h = c, d = r && c === o - 1 ? 0 : c + 1, f = a[h], p = a[d], m = null; if (!xw(e[h].data, e[d].data)) f.position.distanceTo(p.position) > ww && (m = new pl(f.position, f.controlNext, p.controlPrevious, p.position)); else { let g = f.position.clone(), y = p.position.clone(); (f.removedLength !== 0 || p.removedLength !== 0) && (f.nextDir && g.add(f.nextDir.clone().setLength(f.removedLength)), p.prevDir && y.add(p.prevDir.clone().setLength(p.removedLength))), g.distanceTo(y) > ww && (m = new pl(g, g.clone().lerp(y, .3), y.clone().lerp(g, .3), y)) } l[2 * c + 1] = m } for (let c = 0; c < o; c++) { let h = a[c]; if (h.removedLength === 0) { l[2 * c] = null; continue } let d = h.position, f = h.prevDir.clone().multiplyScalar(h.removedLength).add(d), p = h.nextDir.clone().multiplyScalar(h.removedLength).add(d), m = h.tan * h.removedLength, g = h.prevDir.clone().add(h.nextDir).normalize(), y = f.clone().lerp(p, .5), v = f.distanceTo(p) / 2, x = g.clone().multiplyScalar(Math.sqrt(Math.pow(m, 2) - Math.pow(v, 2))).add(y), b = g.clone().multiplyScalar(-m).add(x), S = d.distanceTo(b) / d.distanceTo(y), _ = h.prevDir.clone().multiplyScalar(S * d.distanceTo(f)).add(d), E = _.clone().lerp(b, 2), w = f.clone().lerp(_, 4 / 3), M = p.clone().lerp(E, 4 / 3); l[2 * c] = new pl(f, w, M, p) } let u = new bw; return l.forEach(c => { c && u.add(c) }), u } var ct; (t => { function i (e) { return e && e.__isEntity } t.is = i })(ct || (ct = {})); var Ls = i => ct.is(i), Gj = { type: "completeState", isfromEntity: !0 }, ih = i => class extends nh(i) { constructor() { super(...arguments); this.raycastLock = !1; this.scaleLock = !1; this.disposed = !1; this.stateSelection = null; this.instances = []; this.prevState = null; this.currentState = null; this.reversibleToState = null; this.currentTransitionEvent = null; this.previousAction = null; this._singleBBox = new Df; this._recursiveBBox = new Df; this.singleBBoxNeedsUpdate = !0; this.recursiveBBoxNeedsUpdate = !0; this._needApplyPathSnapping = !0; this.attachedPaths = new Set } get __isEntity () { return !0 } entityChildren (n) { let r = this.children[n]; if (ct.is(r)) return r } entityChildrenCount () { let n = this.children.length; for (; n--;)if (ct.is(this.children[n])) return n + 1; return 0 } get isConcreteEntity () { return typeof this.identity == "string" } get isVirtualEntity () { return typeof this.identity != "string" } get isInstanceRoot () { return this.isConcreteEntity && this.data.type === "Instance" } nearestInstanceSelfOrParent () { let n = this; for (; n.data.type !== "Instance";) { let r = n.parent; if (ct.is(r)) n = r; else return } return n } forInstancesRec (n) { this.instances.forEach(r => { r.disposed || n(r), r.forInstancesRec(n) }) } super_Entity (n, r) { typeof n == "string" && (this.uuid = n), this.identity = n, this.data = r, this.matrixAutoUpdate = !1, this.dataPatched = this.data } changeSelectedState (n, r, s = !1) { if (!(this.data.states.length === 0 && !s)) { for (let o of this.data.states) To.toOps(this.data, o.data).forEach(l => { let u = _g.replaceProps(l, this.data); this.dataPatched = this.data, this.updateByPatchedOp(u, this.data, r) }); if (n !== null) { let o = this.data.states.data(n); o && (this.dataPatched = To.patch(this.data, o), To.toOps(this.data, o).forEach(l => { this.updateByPatchedOp(l, this.dataPatched, r) })) } s && this.updateTransformState(this.dataPatched), this.stateSelection = n, this.updatePathSnapping(this.dataPatched.pathSnapping) } } get singleBBox () { return this.singleBBoxNeedsUpdate && (this.singleBBoxNeedsUpdate = !1, this._singleBBox.setFromObjectSize(this, !1), this._singleBBox.computeVertices(), this._singleBBox.computeEdges(), this._singleBBox.computeFaces()), this._singleBBox } get recursiveBBox () { return this.recursiveBBoxNeedsUpdate && (this.recursiveBBoxNeedsUpdate = !1, this._recursiveBBox.setFromObjectSize(this, !0), this._recursiveBBox.computeVertices(), this._recursiveBBox.computeEdges(), this._recursiveBBox.computeFaces()), this._recursiveBBox } updateEntityBoxSize (n, r) { n.setScalar(0), r.setScalar(0) } resetBBoxNeedsUpdateSelf () { this.singleBBoxNeedsUpdate = !0, this.recursiveBBoxNeedsUpdate = !0 } resetBBoxNeedsUpdate () { this.resetBBoxNeedsUpdateSelf(), this.traverseAncestors(n => { Ls(n) && n.resetBBoxNeedsUpdateSelf() }), this.traverseEntity(n => { n.resetBBoxNeedsUpdateSelf() }) } find (n) { let r; return this.traverseEntity(s => { s.uuid === n && (r = s) }), r } traverseSortNextHelper () { let n = this.parent; if (n) { let r = n.children, s = r.indexOf(this) + 1; if (ct.is(r[s])) return r[s]; if (ct.is(n)) return n.traverseSortNextHelper() } } sortNext () { let n = this.children; return this.children.length > 0 && ct.is(this.children[0]) ? n[0] : this.traverseSortNextHelper() } goUp (n) { let r = this; for (; n > 0 && r !== null;)r = r.parent, n -= 1; return r } hasAnccestorOrSelf (n) { return this === n || this.hasAnccestor(n) } hasAnccestor (n) { let r = this.parent; for (; r;) { if (n === r) return !0; r = r.parent } return !1 } countToAccestor (n) { let r = 0, s = this; for (; s !== n;) { if (s === null) return -1; s = s.parent, r += 1 } return r } forEachEntity (n) { for (let r of this.children) Ls(r) && n(r) } traverseEntityAncestors (n) { this.traverseAncestors(r => { ct.is(r) && n(r) }) } traverseConcreteEntity (n, r = 0) { if (n(this, r) !== !0) for (let o of this.children) Ls(o) && o.isConcreteEntity && o.traverseEntity(n, r + 1) } traverseEntity (n, r = 0) { if (n(this, r) !== !0) for (let o of this.children) Ls(o) && o.traverseEntity(n, r + 1) } traverseVisibleEntity (n) { n(this); for (let r of this.children) Ls(r) && r.visible && r.traverseVisibleEntity(n) } updateMatrix () { super.updateMatrix(), this.cloner && this.cloner.onObjUpdateMatrix(), this.dispatchEvent({ type: "updateMatrix" }) } copy (n, r = !1) { return super.copy(n, r), this.dataPatched = n.dataPatched, this.raycastLock = n.raycastLock, this.scaleLock = n.scaleLock, this.hiddenMatrix.copy(n.hiddenMatrix), this } hasEntityChild () { return this.children.some(n => Ls(n)) } isAncestorOf (n) { if (this.uuid === n) return !1; let r = !1; return this.traverseEntity(s => { s.uuid === n && (r = !0) }), r } toObjectTransformState (n = []) { this.updateWorldMatrix(!0, !1); let r = { position: this.position.toArray(), rotation: [this.rotation.x, this.rotation.y, this.rotation.z], scale: this.scale.toArray(), hiddenMatrix: this.hiddenMatrix.toArray() }; return Au(r, n) } updateTransformState (n) { let r = !1; return n.position && (this.position.fromArray(n.position), r = !0), n.rotation && (this.rotation.fromArray(n.rotation), r = !0), n.scale && (r = !0, this.scale.fromArray(n.scale)), n.hiddenMatrix !== void 0 && (r = !0, this.hiddenMatrix.fromArray(n.hiddenMatrix ?? wa.identity)), r && (this.updateMatrix(), this.resetBBoxNeedsUpdate(), this.invalidateClonerTransform(this), this.traverseEntityAncestors(s => { s.invalidateClonerTransform(this) })), n.position && n.rotation && n.scale && n.hiddenMatrix !== void 0 && this.updateWorldMatrix(!1, !0), r } dispose () { this.disposed = !0, this.cloner && (this.cloner.removeFromParent(), this.cloner = void 0) } disposeChildrenRecursively () { for (let n of this.children) ct.is(n) && n.disposeRecursively() } disposeRecursively () { this.dispose(), this.children.forEach(n => { ct.is(n) && n.disposeRecursively() }) } toState (n = []) { let r = { name: this.name, visible: this.visible, raycastLock: this.raycastLock, ...this.toObjectTransformState(n) }; return Au(r, n) } updateByObjUpdateOp (n, r) { n !== void 0 && this.updateByOp({ type: 0, props: n, path: [] }, { ...this.data, ...n }, r, !1) } updateByOp (n, r, s, o) { let a = this.data; this.data = r; let l = n, u = Pr(n.path, ["states", "*"]); if (u !== null) { if (n.type === 0) { let [c] = u; if (this?.stateSelection === c) { let h = { ...n.props }; if (delete h.name, Object.values(n.props).some(d => d === void 0)) { let d = this.data; if (d !== void 0) { let f = Fr.zoom(d, n.path.slice(2)); if (f) for (let p in n.props) n.props[p] === void 0 && p in f && (h[p] = f[p]) } } l = { ...n, props: h, path: n.path.slice(2) } } } } else if (n.type === 0) { let c = this.stateSelection ? this.data.states.data(this.stateSelection) : void 0; if (c !== void 0) { if (n.props.name !== void 0 && c.name) { let { name: d, ...f } = c; c = f } if (n.props.material !== void 0 && "material" in c) { let { material: d, ...f } = c; c = f } let h = Fr.removeOverridden(n.path, n.props, c); l = { ...n, props: h } } } if (this.updateByPatchedOpBase(l, To.patch(this.data, this.stateSelection ? this.data.states.data(this.stateSelection) : void 0), s), Pr(n.path, ["overrides"])) { let c = [], h = [...n.path]; for (c.push(h[1]), h.splice(0, 2); h.length > 0 && h[0] === "descendants";)c.push(h[1]), h.splice(0, 2); if (c[c.length - 1] === void 0) { if (n.type === 0) for (let d of Object.keys(n.props)) { c[c.length - 1] = d; let f = s.scene.findInstance([this.uuid, ...c]); f && (f.overrideData = n.props[d], f.updateState(Ss.apply(f.component.data, f.overrideData), s)) } } else { let d = s.scene.findInstance([this.uuid, ...c]); if (d) { let f = Fr.zoom(d.component.data, h); if (n = { ...n, path: h }, n.type === 0) { let p = n.props; if (f) for (let [m, g] of Object.entries(n.props)) g === void 0 && (p === n.props && (p = { ...n.props }), p[m] = f[m]); n = { ...n, props: p } } d.overrideData = ku.resolve(r.overrides, c), d.updateByOp(n, xr.applySimple(d.data, n), s, !1) } } } else if (this.instances.length > 0) { let c; if (n.path.length === 0 && n.type === 0) { let h; for (let d of Ps.rootOverrideProps) d in n.props && (h === void 0 && (h = {}), h[d] = n.props[d]); h && (c = { ...n, props: h }) } else for (let h of Ps.rootOverrideProps) if (Pr(n.path, [h])) { c = n; break } c !== void 0 && this.instances.forEach(h => { if (h.isInstanceRoot) { let d = Ss.filterOp(h.overrideData, c); d && h.updateByOp(d, xr.applySimple(h.data, d), s, !0) } }), this.instances.forEach(h => { if (!h.isInstanceRoot) { let d = Ss.filterOp(h.overrideData, n); if (d) { let f; a === h.data && n === d ? f = r : f = xr.applySimple(h.data, d), h.updateByOp(d, f, s, !0) } } }) } } updateByPatchedOpBase (n, r, s) { if (this.dataPatched = r, n.path.length === 0 && n.type === 0) n.props.type !== void 0 && !Zi.is(n.props.type) && es.changeEntityProptotype(this, r, s); else if (n.path.length === 1 && n.path[0] === "geometry" && n.type === 0 && "type" in n.props) { es.changeEntityProptotype(this, r, s); for (let o of this.children) ct.is(o) && o.updateVisible() } this.updateByPatchedOp(n, r, s) } updateByPatchedOp (n, r, s) { if (n.path.length === 0 && n.type === 0 && this.updateState(n.props, s), Pr(n.path, ["pathSnapping"]) !== null && this.updatePathSnapping(r.pathSnapping), Pr(n.path, ["cloner"]) !== null) { let o = xr.drop(n, 1); o.path.length === 0 && o.type === 0 && o.props.disabled === !0 ? this.setFromClonerState(null, s) : this.cloner ? this.cloner.updateState(r.cloner, s.scene) : (this.setFromClonerState(r.cloner, s), this.expandCloner(s.scene)), this.updateVisible() } } updatePathSnapping (n) { this._updatedPathSnapping = n, this._needApplyPathSnapping = !0 } get updatedPathSnapping () { return this._updatedPathSnapping } applyPathSnapping (n) { let r = this._updatedPathSnapping?.pathId ?? this.dataPatched.pathSnapping.pathId, s = this._updatedPathSnapping?.slide ?? this.dataPatched.pathSnapping.slide ?? 0, o = this._updatedPathSnapping?.offset ?? this.dataPatched.pathSnapping.offset, a = this._updatedPathSnapping?.orientation ?? this.dataPatched.pathSnapping.orientation; if (r === null) return; let l = n.find(r); if (!l || this._needApplyPathSnapping === !1) return; this._needApplyPathSnapping = !1; let u = l.data; if (u.geometry.path.points.length <= 1) return; let c = by(u.geometry.path), h = (s + o) % 1; s + o === 1 && h === 0 && (h = 1); let d = c.getPointAt(h), f = this.parent ? this.parent?.matrixWorld : new se; l.updateMatrixWorld(); let p = new se().multiplyMatrices(f.clone().invert(), l.matrixWorld); d.applyMatrix4(p); let m = { position: d.toArray(), rotation: u.rotation }; if (a === "tangential") { let g = new se().extractRotation(l.matrixWorld), y = c.getTangentAt(h).applyMatrix4(g).add(d), v = new se().lookAt(d, y, new A(0, 1, 0)), x = new Gt().setFromRotationMatrix(v); m = { ...m, rotation: [x.x, x.y, x.z] } } this.updateTransformState(m), this.traverseEntity(g => { g._cameraType && g.dispatchEvent(Gj) }) } updateVisible () { this.visible = this.dataPatched.visible && (!this.dataPatched.cloner || (this.dataPatched.cloner.disabled ?? !1) || this.dataPatched.cloner?.hideBase !== !0) } updateState_Entity (n, r) { n.name !== void 0 && (this.name = n.name), n.raycastLock !== void 0 && (this.raycastLock = n.raycastLock), n.visible !== void 0 && (this.updateVisible(), this.resetBBoxNeedsUpdate()), r && "cloner" in n && n.cloner !== void 0 && (this.setFromClonerState(n.cloner, r), this.updateVisible()), this.updateTransformState(n) } get attachedSurfaceCloners () { return this.children.filter(n => n instanceof es.Cloner && n.parameters.type === "toObject") } setFromClonerState (n, r) { this.disposed || (n === null || n.disabled ? (this.cloner && this.cloner.removeFromParent(), this.cloner = void 0) : this.cloner === void 0 ? (this.cloner = new es.Cloner(this, n), r.scene.addPendingExpandCloner(this)) : this.cloner.updateState(n, r.scene)) } expandCloner (n) { !this.disposed && this.cloner && this.cloner.expandClones(n) } invalidateClonerTransform (n) { this.cloner && this.cloner.invalidateTransform(n) } }; var wy = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, radialSegments: 64, heightSegments: 1, openEnded: !1, thetaStart: 0, thetaLength: 360, cornerRadius: 8, cornerSegments: 8, hollow: 0 }, i.parameters), n = e.width / 2, r = e.radiusTop ?? n, s = e.radiusBottom ?? n; return r === s ? (r = n, s = n) : r > s ? (r = n, s = s * n / r) : (r = r * n / s, s = n), { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width), radiusTop: r, radiusBottom: s }) } } static build (i) { let { width: t, depth: e, height: n, radialSegments: r, heightSegments: s, openEnded: o, thetaStart: a, thetaLength: l, radiusTop: u, radiusBottom: c, cornerRadius: h, cornerSegments: d, hollow: f } = i.parameters, p; return h || f ? p = new Of(u, c, n, r, s, o, a, l * Math.PI / 180, h, h, d, f) : p = new gl(u, c, n, r, s, o, a, l * Math.PI / 180), p.scale(1, 1, e / t), Object.assign(p, { userData: { ...i, type: "CylinderGeometry" } }) } }; function Oa (i, t, e) { e.x = i.x * t.x, e.y = i.y, e.z = i.x * t.y } function dP (i) { return new B(i.y, -i.x) } var Of = class extends Ce { constructor(t, e, n, r, s, o, a, l, u, c, h, d, f = !1) { super(), this.type = "RoundedCylinderBufferGeometry", t = t !== void 0 ? t : 1, e = e !== void 0 ? e : 1, n = n || 1, r = Math.floor(r) || 8, s = Math.floor(s) || 1, o = o !== void 0 ? o : !1, a = a !== void 0 ? a : 0, l = l !== void 0 ? l : Math.PI * 2, o && (u = 0, c = 0); let p = [], m = [], g = [], y = [], v = 0, x = n / 2, b = new A, S = new A; f && t == 0 && (t = u), f && e == 0 && (e = c); let _ = new B(t, x), E = new B(e, -x), w = null, M = null, T = null, I = null, C = _.clone().sub(E), P = 0, D = 0, L = 0; d > 0 && (P = Math.min(t, e) * (1 - d), D = t - P, L = e - P); let H = _.clone(); H.x -= P; let U = Math.PI - C.angle(), V = C.angle(), G = Math.tan(V / 2), z = Math.tan(U / 2), $ = G + z, F = d ? $ : z, j = d ? $ : G; if (u = Math.min(u, (t - D) / F, C.length() / $), c = Math.min(c, (e - L) / j, C.length() / $), u > 0) { let Q = u / G; w = _.clone().sub(new B(Q, u)), d && (T = w.clone(), T.x -= P - $ * u), _.sub(C.clone().setLength(Q)) } if (c > 0) { let Q = c / z; M = E.clone().sub(new B(Q, -c)), E.add(C.clone().setLength(Q)), d && (I = M.clone(), I.x -= P - $ * c, H.sub(C.clone().setLength(Q))) } C = _.clone().sub(E); let X = C.length() < .5, q = []; for (let Q = 0; Q <= r; Q++) { let W = [], ge = Q / r, de = ge * l + a, ie = new B(Math.sin(de), Math.cos(de)); I && M ? (k(W, ge, ie, U, c, I, -1, !0), k(W, ge, ie, V, c, M, -1, !1)) : M ? (Z(W, ie, M.x, 0, -1), k(W, ge, ie, V, c, M, -1, !1)) : o || Z(W, ie, e, L, -1); let be = dP(C).normalize(); if (Oa(be, ie, b), !X) for (let ve = 0; ve <= s; ve++) { let Ie = ve / s, Pe = C.clone().multiplyScalar(Ie).add(E); Oa(Pe, ie, S), m.push(S.x, S.y, S.z), g.push(b.x, b.y, b.z), y.push(ge, .5 + S.y / n), W.push(v++) } if (T && w ? (k(W, ge, ie, U, u, w, 1, !1), k(W, ge, ie, V, u, T, 1, !0)) : w ? (k(W, ge, ie, U, u, w, 1, !1), Z(W, ie, w.x, 0, 1)) : o || Z(W, ie, t, D, 1), d && !X) { let ve = dP(C).multiplyScalar(-1).normalize(); Oa(ve, ie, b); for (let Ie = 0; Ie <= s; Ie++) { let Pe = Ie / s, Me = C.clone().multiplyScalar(-Pe).add(H); Oa(Me, ie, S), m.push(S.x, S.y, S.z), g.push(b.x, b.y, b.z), y.push(ge, .5 + S.y / n), W.push(v++) } } d && !o && W.push(W[0]), q.push(W) } for (let Q = 0; Q < q.length - 1; Q++)for (let W = 0; W < q[0].length - 1; W++) { if (o && d && W == s) continue; let ge = q[Q][W], de = q[Q + 1][W], ie = q[Q + 1][W + 1], be = q[Q][W + 1], ve = m[ie * 3 + 0], Ie = m[ie * 3 + 2]; p.push(ge, de, be), (ve != 0 || Ie != 0) && p.push(de, ie, be) } l < Math.PI * 2 && (K(-1, q[0], a), K(1, q[q.length - 1], a + l)), this.setIndex(p), this.setAttribute("position", new _e(m, 3)), this.setAttribute("normal", new _e(g, 3)), this.setAttribute("uv", new _e(y, 2)); function k (Q, W, ge, de, ie, be, ve, Ie) { for (let Pe = 0; Pe < h + 1; Pe++) { let Me = Pe / h, Se = ve < 0 ? Me : 1 - Me; Ie && (Se -= 1), Se *= de; let Fe = new B(Math.sin(Se), Math.cos(Se) * ve), ke = Fe.clone().multiplyScalar(ie).add(be); Oa(ke, ge, S), m.push(S.x, S.y, S.z), Oa(Fe, ge, b), g.push(b.x, b.y, b.z), y.push(W, .5 + S.y / n), Q.push(v++) } } function Z (Q, W, ge, de, ie) { let be = new A, ve = new B, Ie = [ge, de]; ie < 0 && Ie.reverse(); for (let Pe of Ie) ve.set(Pe, x * ie), Oa(ve, W, be), m.push(be.x, be.y, be.z), g.push(0, ie, 0), y.push(.5, .5), Q.push(v++) } function K (Q, W, ge) { let de = new B(Math.sin(ge), Math.cos(ge)), ie = new B(-Math.cos(ge), Math.sin(ge)), be = new A, ve = Q < 0 ? (Me, Se, Fe) => p.push(Me, Se, Fe) : (Me, Se, Fe) => p.push(Me, Fe, Se), Ie = new B((t + e + D + L) / 4, 0); Oa(Ie, de, be), m.push(be.x, be.y, be.z), g.push(ie.x, 0, ie.y), y.push(.5, .5); let Pe = v++; for (let Me of W) { let Se = m.slice(Me * 3, Me * 3 + 3); m.push(...Se), g.push(ie.x, 0, ie.y); let Fe = y.slice(Me * 2, Me * 2 + 2); y.push(...Fe), v++ } for (let Me = Pe + 1; Me < v - 1; Me++)ve(Pe, Me, Me + 1); ve(Pe, v - 1, Pe + 1) } } }; var fP = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, radialSegments: 32, heightSegments: 8, openEnded: !1, thetaStart: 0, thetaLength: 360, cornerRadiusTop: 8, cornerRadiusBottom: 8, cornerSegments: 8 }, i.parameters); return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) } } static build (i) { let { width: t, depth: e, height: n, radialSegments: r, heightSegments: s, openEnded: o, thetaStart: a, thetaLength: l, cornerRadiusTop: u, cornerRadiusBottom: c, cornerSegments: h } = i.parameters, d; return u > 0 || c > 0 || l < 360 ? d = new Of(0, t / 2, n, r, s, o, a, l * Math.PI / 180, u, c, h, 0, !0) : d = new Rc(t / 2, n, r, s, o), d.scale(1, 1, e / t), Object.assign(d, { userData: { ...i, type: "ConeGeometry" } }) } }; var pP = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, widthSegments: 1, heightSegments: 1, depthSegments: 1, cornerRadius: 8, cornerSegments: 8 }, i.parameters); return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) } } static build (i) { let { width: t, height: e, depth: n, widthSegments: r, heightSegments: s, depthSegments: o, cornerRadius: a, cornerSegments: l } = i.parameters, u; return a == 0 ? u = new er(t, e, n, r, s, o) : u = new _w(t, e, n, r, s, o, a, l), Object.assign(u, { userData: { ...i, type: "CubeGeometry" } }) } }, Aw = Math.PI / 2, _w = class extends Ce { constructor(t = 1, e = 1, n = 1, r = 1, s = 1, o = 1, a = 0, l = 4) { super(), this.type = "BoxGeometry"; let u = this; r = Math.floor(r), s = Math.floor(s), o = Math.floor(o), l = Math.floor(l), a = Math.min(a, t / 2, e / 2, n / 2); let c = [], h = [], d = [], f = [], p = 0, m = 0; g("z", "y", "x", -1, -1, n, e, t, o, s, 0), g("z", "y", "x", 1, -1, n, e, -t, o, s, 1), g("x", "z", "y", 1, 1, t, n, e, r, o, 2), g("x", "z", "y", 1, -1, t, n, -e, r, o, 3), g("x", "y", "z", 1, -1, t, e, n, r, s, 4), g("x", "y", "z", -1, -1, t, e, -n, r, s, 5), a > 0 && (y("z", "y", "x", -1, -1, 1, n, e, t, o, 0), y("z", "y", "x", 1, -1, -1, n, e, t, o, 1), y("z", "y", "x", -1, 1, -1, n, e, t, o, 1), y("z", "y", "x", 1, 1, 1, n, e, t, o, 0), y("x", "y", "z", -1, -1, -1, t, e, n, r, 0), y("x", "y", "z", 1, -1, 1, t, e, n, r, 1), y("x", "y", "z", -1, 1, 1, t, e, n, r, 0), y("x", "y", "z", 1, 1, -1, t, e, n, r, 1), y("y", "x", "z", -1, -1, 1, e, t, n, s, 0), y("y", "x", "z", 1, -1, -1, e, t, n, s, 1), y("y", "x", "z", 1, 1, 1, e, t, n, s, 1), y("y", "x", "z", -1, 1, -1, e, t, n, s, 0), v(1, 1, 1), v(-1, 1, 1), v(1, -1, 1), v(-1, -1, 1), v(1, 1, -1), v(-1, 1, -1), v(1, -1, -1), v(-1, -1, -1)), this.setIndex(c), this.setAttribute("position", new _e(h, 3)), this.setAttribute("normal", new _e(d, 3)), this.setAttribute("uv", new _e(f, 2)); function g (x, b, S, _, E, w, M, T, I, C, P) { let D = (w - 2 * a) / I, L = (M - 2 * a) / C, H = w / 2 - a, U = M / 2 - a, V = T / 2, G = I + 1, z = C + 1, $ = 0, F = 0, j = new A; for (let X = 0; X < z; X++) { let q = X * L - U; for (let k = 0; k < G; k++) { let Z = k * D - H; j[x] = Z * _, j[b] = q * E, j[S] = V, h.push(j.x, j.y, j.z), j[x] = 0, j[b] = 0, j[S] = T > 0 ? 1 : -1, d.push(j.x, j.y, j.z), f.push(k / I), f.push(1 - X / C), $ += 1 } } for (let X = 0; X < C; X++)for (let q = 0; q < I; q++) { let k = p + q + G * X, Z = p + q + G * (X + 1), K = p + (q + 1) + G * (X + 1), Q = p + (q + 1) + G * X; c.push(k, Z, Q), c.push(Z, K, Q), F += 6 } u.addGroup(m, F, P), m += F, p += $ } function y (x, b, S, _, E, w, M, T, I, C, P) { let D = (M - 2 * a) / C, L = M / 2 - a, H = T / 2 - a, U = I / 2, V = C + 1, G = 0, z = 0, $ = new A, F = new A; for (let j = 0; j < l + 1; j++) { let X = j / l * Aw, q = Math.sin(X) * a, k = (1 - Math.cos(X)) * a, Z = Math.sin(X), K = Math.cos(X); $[b] = (H + q) * E, $[S] = (U - k) * w, F[x] = 0, F[b] = Z * Math.sign($[b]), F[S] = K * Math.sign($[S]); for (let Q = 0; Q < V; Q++) { let W = Q * D - L; $[x] = W * _, h.push($.x, $.y, $.z), d.push(F.x, F.y, F.z), f.push(Q / C), f.push(0), G += 1 } } for (let j = 0; j < l; j++)for (let X = 0; X < C; X++) { let q = p + X + V * j, k = p + X + V * (j + 1), Z = p + (X + 1) + V * (j + 1), K = p + (X + 1) + V * j; c.push(q, k, K), c.push(k, Z, K), z += 6 } u.addGroup(m, z, P), m += z, p += G } function v (x, b, S) { let _ = new A, E = new A(t / 2, e / 2, n / 2); E.subScalar(a); let w = [], M = x * b * S > 0 ? (I, C, P) => c.push(I, C, P) : (I, C, P) => c.push(I, P, C); for (let I = 0; I <= l; I++) { let C = [], P = Aw * (1 - I / l), D = Math.cos(P), L = Math.sin(P), H = 0; for (let U = 0; U <= I; U++) { let V = Math.cos(H), G = Math.sin(H); _.x = D * V, _.y = L, _.z = D * G; let z = E.clone().addScaledVector(_, a); h.push(x * z.x, b * z.y, S * z.z), d.push(x * _.x, b * _.y, S * _.z), f.push(0, 0), C.push(p++), H += Aw / I } w.push(C) } let T = w.length - 1; for (let I = 0; I < T; I++) { let C = w[I], P = w[I + 1], D = C.length - 1; M(C[0], P[1], P[0]); for (let L = 1; L <= D; L++)M(C[L - 1], C[L], P[L]), M(C[L], P[L + 1], P[L]) } } } }; var Ra = class extends Ce { constructor(t = [], e = [], n = "", r = 1, s = .2, o = 4) { super(), this.type = "PolyhedronGeometryRound"; let a = [], l = [], u = []; c(), h(), this.setAttribute("position", new _e(a, 3)), this.setAttribute("normal", new _e(u, 3)), this.setAttribute("uv", new _e(l, 2)); return; function c () { s = Math.min(1 - 1e-5, s), s == 0 && (o = 0); let f = { IcosahedronGeometry: 5, DodecahedronGeometry: 3, HexahedronGeometry: 3, OctahedronGeometry: 4, TetrahedronGeometry: 3 }[n], p = new A, m = p.clone(), g = new nn, y = s * r, v = r - y, x = o + 1, b = new A, S = (G, z) => b.subVectors(G, z).normalize(), _ = (G, z) => Array(G).fill(void 0).map(z), E = _(t.length / 3, (G, z) => new A().fromArray(t, z * 3).setLength(r)), w = [], M = 1e6; for (let G = 0; G < E.length; G++) { let z = E[G], $ = [], F, j, X, q = 1e10, k = -1; for (; (k = e.indexOf(G, k + 1)) != -1;) { let W = k - k % 3; F = e[W + (k + 1) % 3], j = e[W + (k + 2) % 3], X = z.distanceToSquared(E[F]), q = Math.min(q, X), $.push([F, j, X]) } q += 1e-6; let Z = [], K = 0, Q = $.length; for (let W = 0; W < Q; W++) { [F, j, X] = $[K]; let ge = w[F]?.includes(G) == !0; X <= q && Z.push(F + +ge * M), K = $.findIndex(de => de[0] == j) } w.push(Z) } let T = []; { let G = 0, z = 0, $, F, j = f == 3; for (let X = 0; X <= o; X++) { $ = X * (X + 1) / 2, F = (X + 1) * (X + 2) / 2; for (let q = 0; q < o - X; q++) [G, z] = [$ + q + X + 2, F + q + X + 3], T.push($, F, ...j ? [z, $] : [G, F], z, G), [$, F] = [G, z]; T.push($, F, $ + o + 2) } } let I = p.clone(), C = p.clone(), P = p.clone(), D = p.clone(), L = p.clone(), H = [], U = _(E.length, () => _(f, () => p.clone())); for (let G = 0; G < E.length; G++) { p.copy(E[G]).normalize(), I.copy(p).multiplyScalar(v); let z = w[G]; for (let Z = 0; Z < z.length; Z++) { let K = z[Z], Q = z[(Z + 1) % f]; g.setFromPointsAndIndices(E, G, K % M, Q % M), g.b.sub(g.a).setLength(1e10).add(g.a), g.c.sub(g.a).setLength(1e10).add(g.a), g.closestPointToPoint(I, U[G][Z]) } let $ = [], F = [], j = [], X = new A; o == 0 && [...U[G]].reduce((Z, K) => Z.add(K), X).multiplyScalar(1 / f); for (let Z = 0; Z < f; Z++) { let K = [], Q = (Z - 1 + f) % f, W = U[G][Q], ge = U[G][Z]; p.copy(W).sub(I), m.copy(ge).sub(I); let de = I.angleTo(p), ie = p.angleTo(m), be = Math.cos(de) * y; o == 0 ? C.copy(X) : C.copy(I).setLength(v + be), F.push(be); let ve = [C, W, ge]; for (let Ie = 0; Ie < 2; Ie++) { let Pe = ve[Ie], Me = ve[Ie + 1]; D.subVectors(Pe, I), L.subVectors(Me, I), P.crossVectors(D, L).normalize(); for (let Se = 0; Se < x; Se++) { let Fe = [de, ie][Ie] * Se / x; p.copy(D).applyAxisAngle(P, Fe).add(I), $.push(p.clone()), Ie && (S(p, I), K.push([Se == 0 ? Pe : p.clone(), b.clone()])) } Ie && (S(Me, I), K.push([Me, b.clone()])) } j.push(K) } H.push(j); let q = 2 * x, k = 2; for (let Z = 0; Z < f; Z++) { let K = q * Z, Q = q * ((Z + 1) % f), W = [$[K]]; for (let de = 1; de < x; de++) { D = $[K + de], L = $[Q + de], W.push(D); for (let ie = 1, be = de - k + 1; ie <= be; ie++)p.lerpVectors(D, L, ie / (be + 1)), p.sub(I).setLength(F[Z]).add(I), W.push(p.clone()); W.push(L) } for (let de = 0; de < x; de++)W.push($[de + x + K]); W.push($[Q + x]); let ge = T.map(de => W[de]); a.push(...ge.map(de => [de.x, de.y, de.z]).flat()), u.push(...ge.map(de => (S(de, I), [b.x, b.y, b.z])).flat()) } } let V = []; for (let G = 0; G < w.length; G++)for (let z = 0; z < f; z++) { let $ = w[G][z]; if ($ < M) { let F = w[$].findIndex(q => q % M == G), j = H[G][z], X = H[$][F]; for (let q = 0; q < x; q++) { let k = j[q], Z = X[x - q], K = j[q + 1], Q = X[x - (q + 1)];[k, Z, K, K, Z, Q].forEach(W => { a.push(W[0].x, W[0].y, W[0].z), u.push(W[1].x, W[1].y, W[1].z) }) } V.push(j[0][0], X[x][0], j[x][0], X[0][0]) } } for (; V.length;) { let G, z, $, F;[G, z] = V.splice(0, 2); let j = [G]; for (; G != z;)j.push(z), $ = V.indexOf(z), F = $ % 2, z = V.splice($ - F, 2)[1 - F]; b.subVectors(j[0], j[1]).cross(p.subVectors(j[0], j[2])).normalize(); let X = b.dot(j[0]) < 0; X && b.negate(); for (let q = 1; q <= j.length - 2; q++) [j[q + +X], j[q + 1 - +X], j[0]].forEach(k => { a.push(k.x, k.y, k.z), u.push(b.x, b.y, b.z) }) } } function h () { let d = new A; for (let E = 0; E < a.length; E += 3) { d.x = a[E + 0], d.y = a[E + 1], d.z = a[E + 2]; let w = S(d) / 2 / Math.PI + .5, M = _(d) / Math.PI + .5; l.push(w, 1 - M) } let f = new A, p = new A, m = new A, g = new A, y = new B, v = new B, x = new B, b = (E, w, M, T) => { T < 0 && E.x === 1 && (l[w] = E.x - 1), M.x === 0 && M.z === 0 && (l[w] = T / 2 / Math.PI + .5) }; for (let E = 0, w = 0; E < a.length; E += 9, w += 6) { f.set(a[E + 0], a[E + 1], a[E + 2]), p.set(a[E + 3], a[E + 4], a[E + 5]), m.set(a[E + 6], a[E + 7], a[E + 8]), y.set(l[w + 0], l[w + 1]), v.set(l[w + 2], l[w + 3]), x.set(l[w + 4], l[w + 5]), g.copy(f).add(p).add(m).divideScalar(3); let M = S(g); b(y, w + 0, f, M), b(v, w + 2, p, M), b(x, w + 4, m, M) } for (let E = 0; E < l.length; E += 6) { let w = l[E + 0], M = l[E + 2], T = l[E + 4], I = Math.max(w, M, T), C = Math.min(w, M, T); I > .9 && C < .1 && (w < .2 && (l[E + 0] += 1), M < .2 && (l[E + 2] += 1), T < .2 && (l[E + 4] += 1)) } function S (E) { return Math.atan2(E.z, -E.x) } function _ (E) { return Math.atan2(-E.y, Math.sqrt(E.x * E.x + E.z * E.z)) } } } static fromJSON (t) { return new Ra(t.vertices, t.indices, t.radius, t.corner, t.cornerSides) } }; var mP = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, detail: 0, corner: 0, cornerSides: 4 }, i.parameters); return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) } } static build (i) { let { width: t, height: e, depth: n, detail: r, corner: s, cornerSides: o } = i.parameters, a = r === 0 && s !== 0 ? new Rf(t * .5, s, o) : new Nc(t * .5, r); return a.scale(1, e / t, n / t), Object.assign(a, { userData: { ...i, type: "DodecahedronGeometry" } }) } }, Rf = class extends Ra { constructor(t = 1, e = .2, n = 4) { let r = (1 + Math.sqrt(5)) / 2, s = 1 / r, o = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -s, -r, 0, -s, r, 0, s, -r, 0, s, r, -s, -r, 0, -s, r, 0, s, -r, 0, s, r, 0, -r, 0, -s, r, 0, -s, -r, 0, s, r, 0, s], a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], l = "DodecahedronGeometry"; super(o, a, l, t, e, n), this.type = l } static fromJSON (t) { return new Rf(t.radius, t.corner, t.cornerSides) } }; var Lf = 1e-12, sh = class { constructor(t) { this.position = new B; this.startPosition = new B; this.uuid = Ge.generateUUID(); this.position = t.clone() } start () { this.reset() } reset () { this.startPosition.copy(this.position) } applyOffset (t) { this.position.copy(this.startPosition).add(t) } copy (t) { return this.position.copy(t.position), this.startPosition.copy(t.startPosition), this } clone () { return new sh(this.position).copy(this) } toJSON () { return [this.position.x, this.position.y] } }, oh = class extends sh { constructor(e) { super(e.position); this.parent = e } copy (e) { return super.copy(e), this } clone () { return new oh(this.parent).copy(this) } }, ts = class extends sh { constructor(e, n) { super(n); this.controls = []; this.roundness = 0; this.areControlsDirectionsMirrored = !0; this.uuid = e, this.controls.push(new oh(this), new oh(this)) } static create (e, n) { let r = new ts(e, new B(...n.position)); return r.controls[0].position.set(...n.controlPrevious.position), r.controls[1].position.set(...n.controlNext.position), r.roundness = n.roundness, r.areControlsDirectionsMirrored = n.areControlsDirectionsMirrored, r } getOppositeControl (e) { let n = this.controls.indexOf(e); return n === 0 ? this.controls[1] : n === 1 ? this.controls[0] : null } applyOffsetToControls (e, n = 1) { for (let r = 0, s = this.controls.length; r < s; r++) { let o = this.controls[r]; this.position.distanceTo(o.position) <= n ? o.position.copy(this.position) : o.applyOffset(e) } } controlsMoved () { return !(this.position.equals(this.controls[0].position) && this.position.equals(this.controls[1].position)) } copy (e) { return super.copy(e), this.controls[0].copy(e.controls[0]), this.controls[1].copy(e.controls[1]), this.roundness = e.roundness, this.uuid = e.uuid, this } clone () { return new ts(this.uuid, this.position).copy(this) } toJSON () { return super.toJSON().concat(this.controls[0].toJSON(), this.controls[1].toJSON(), [this.roundness]) } computeTangents () { let e = this.curveBefore?.getTangentAt(1), n = this.curveAfter?.getTangentAt(0); return [e, n] } computeNormals (e = new B, n = new B) { let [r, s] = this.computeTangents(); return r && s && (gP(r, e), gP(s, n)), [e, n] } computeTangent (e = new B) { let [n, r] = this.computeTangents(); return n && r && e.copy(n).add(r).normalize(), e } computeNormal (e = new B) { let [n, r] = this.computeNormals(); return e.copy(n).add(r).normalize(), e } }; function gP (i, t = new B) { let e = i.length(); return t.set(-i.y / e, i.x / e) } var Mw = i => i, ah = new B, Sy = new B, Vj = new B, Hj = new B, jj = new B, Wj = new B, vP = new A, xP = new A; function bP (i) { let t = new B; t.addVectors(i.v0, ah.subVectors(i.v1, i.v0).multiplyScalar(2 / 3)); let e = new B; return e.addVectors(i.v2, Sy.subVectors(i.v1, i.v2).multiplyScalar(2 / 3)), new Tr(i.v0, t, e, i.v2) } function Nf (i, t, e = Number.EPSILON) { return Math.abs(i - t) < e } function qj (i, t, e = Number.EPSILON) { return i.distanceTo(t) < e } function Yj (i, t, e = Number.EPSILON) { return i.distanceTo(t) < e } function Tw (i, t, e) { let n = Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2)), r = Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2)), s = Math.sqrt(Math.pow(e.x - i.x, 2) + Math.pow(e.y - i.y, 2)); return Math.acos((r * r + n * n - s * s) / (2 * r * n)) } function wP (i, t, e) { return yP(i, t) && yP(t, e) && Ew(i.position, t.position, e.position) } function Ew (i, t, e) { return ah.copy(t).sub(i).cross(Sy.copy(e).sub(i)) === 0 } function SP (i, t, e, n, r) { let s = Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2)), o = (i.y + t.y) / 2, a = (i.x + t.x) / 2, l = Math.sqrt(Math.pow(e, 2) - Math.pow(s / 2, 2)) * (i.y - t.y) / s, u = Math.sqrt(Math.pow(e, 2) - Math.pow(s / 2, 2)) * (t.x - i.x) / s; return n.set(a + l, o + u), r.set(a - l, o - u), [n, r] } function AP (i, t, e) { let n = i.distanceTo(e), r = t.distanceTo(e); return n < r ? t : i } function _P (i, t, e, n, r, s) { let o = t.x - i.x, a = t.y - i.y, l = e.x - i.x, u = e.y - i.y, c = Math.sqrt((o + l) * (o + l) + (a + u) * (a + u)), h; return Tw(t, i, e) > Math.PI && (c *= -1), Nf(u, a) ? h = (a + u) * (n / c - .5) * 8 / 3 / (o - l) : h = (o + l) * (n / c - .5) * 8 / 3 / (u - a), r.set(t.x - h * a, t.y + h * o), s.set(e.x + h * u, e.y - h * l), [r, s] } function Cw (i, t) { return i.position.equals(i.controls[1].position) && t.position.equals(t.controls[0].position) } function yP (i, t) { return Ew(i.position, i.controls[1].position, t.position) && Ew(i.position, t.controls[0].position, t.position) } function EP (i, t, e, n, r = .5) { let s = ah.subVectors(t, i).multiplyScalar(r).add(i), o = Sy.subVectors(e, t).multiplyScalar(r).add(t), a = Vj.subVectors(n, e).multiplyScalar(r).add(e), l = s, u = Hj.subVectors(o, s).multiplyScalar(r).add(s), c = jj.subVectors(a, o).multiplyScalar(r).add(o), h = a, d = Wj.subVectors(c, u).multiplyScalar(r).add(u); return [i.x, i.y, l.x, l.y, u.x, u.y, d.x, d.y, c.x, c.y, h.x, h.y, n.x, n.y] } function MP (i, t, e = 12, n = !0) { let r = xP.set(0, 0, 0), s, o = 0, a = []; for (let l = 0; l < t.length; l++) { let u = Mw(t[l]), c = ah, h = La(u, e); a.push(h); for (let d = 0; d <= h; d++)if (u instanceof Tr || u instanceof ci || u instanceof Cr) { if (u.getPoint(d / h, c), r.set(c.x, c.y, 0), s !== void 0 && Yj(s, r)) continue; s === void 0 && (s = vP), s.copy(r), i.setXYZ(o, r.x, r.y, r.z), o++ } } return n && o > 1 && !(i.getX(o - 1) === i.getX(0) && i.getY(o - 1) === i.getY(0) && i.getZ(o - 1) === i.getZ(0)) && (i.setXYZ(o, i.getX(0), i.getY(0), i.getZ(0)), o++), i } function TP (i, t, e, n = 12, r = !0) { let s = xP.set(0, 0, 0), o = 0, a = []; for (let l = 0; l < t.length; l++) { if (e[l] === !1) continue; let u, c = Mw(t[l]), h = ah, d = La(c, n); a.push(d); for (let f = 0; f <= d; f++)if (c instanceof Tr || c instanceof ci || c instanceof Cr) { if (c.getPoint(f / d, h), s.set(h.x, h.y, 0), u?.equals(s)) continue; u === void 0 ? u = vP : (i.setXYZ(o, u.x, u.y, u.z), o++, i.setXYZ(o, s.x, s.y, s.z), o++), u.copy(s) } } return r && o > 1 && !(i.getX(o - 1) === i.getX(0) && i.getY(o - 1) === i.getY(0) && i.getZ(o - 1) === i.getZ(0)) && (i.setXYZ(o, i.getX(0), i.getY(0), i.getZ(0)), o++), a } function Pw (i, t = 12, e = !1) { let n = []; for (let r = 0, s = i.length; r < s; r++) { let o = i[r], a = 0; if (e && o.roundedCurveCorner !== void 0) { let l = La(o.roundedCurveCorner, t) * .5; r > 0 && (n[r - 1] += l), a += l } o.curveAfter !== void 0 && (a += La(o.curveAfter, t)), n.push(a) } return i.length > 0 && e && i[0].roundedCurveCorner !== void 0 && (n[i.length - 1] += La(i[0].roundedCurveCorner, t) * .5), n } function La (i, t = 12) { return i && i instanceof fl ? t * 2 : i && (i instanceof Cr || i instanceof Yd) ? 1 : i && i instanceof Dc ? t * i.points.length : t } function CP (i, t, e = 12, n = !0) { let r, s = 0; for (let o = 0; o < t.length; o++) { let a = Mw(t[o]), l = La(a, e), u = ah; for (let c = 0; c <= l; c++)if (a instanceof Tr || a instanceof ci || a instanceof Cr) { if (a.getPoint(c / l, u), r !== void 0 && qj(r, u, Lf)) continue; r === void 0 && (r = Sy), r.copy(u), i.push(u.x, u.y), s++ } } return Nf(i[0], i[i.length - 2], Lf) && Nf(i[1], i[i.length - 1], Lf) && (i.pop(), i.pop()), n && s > 1 && !(Nf(i[s - 1], i[1], Lf) && Nf(i[s - 2], i[0], Lf)) && (i.push(i[0], i[1]), s++), i } var Iw = new B, Xj = new B, Qj = new B, Kj = new B, Zj = new B, Jj = new B, Mt = class extends yo { constructor(e = 100, n = 100) { super(); this.points = []; this.shapeHoles = []; this.plane = new bn(new A(0, 0, -1)); this.subdivision = 0; this.controlSnapDistance = 4; this.pointIDs = 0; this.isMesh2D = !1; this._roundness = 0; this.isClosed = !1; this.useCubicForRoundedCorners = !0; this.uuid = Ge.generateUUID(); this.needsUpdate = !1; this.roundedCurves = []; this._width = e, this._height = n } static createFromState (e, n, r) { let s = new Mt; return s.isClosed = e.isClosed, s.points = e.points.map(o => ts.create(o.id, o.data)), typeof e.roundness == "number" && (s.roundness = e.roundness), s.shapeHoles = e.shapeHoles.map(o => Mt.createFromState(o)), n !== void 0 && r !== void 0 && s.applySize(n, r), s.update(), s } get width () { return this._width } get height () { return this._height } get roundness () { return this._roundness } set roundness (e) { if (this._roundness !== e) { this._roundness = e; for (let n = 0, r = this.points.length; n < r; n++)this.points[n].roundness = e; this.needsUpdate = !0 } } getPointsIndexesByIds (e) { return e.map(n => this.getPointIndexById(n)).filter(n => n >= 0) } getPointIndexById (e) { let n = this.points.length, r = this.points.findIndex(s => s.uuid === e); if (r < 0) { let s = n; for (let o = 0, a = this.shapeHoles.length; o < a; o++) { let l = this.shapeHoles[o], u = l.points.length, c = l.getPointIndexById(e); if (c < 0) s += u; else return c + s } } return r } getLineIndexById (e) { return this.getPointIndexById(e) } getBezierPoint (e) { if (e <= this.points.length - 1) return this.points[e]; if (this.shapeHoles.length > 0) { let n = this.points.length; for (let r = 0, s = this.shapeHoles.length; r < s; r++) { let o = this.shapeHoles[r], a = e - n; if (a <= o.points.length - 1) return o.points[a]; n += o.points.length } } throw new Error("This shape does not have a point for this index: " + e) } getBezierPointIndex (e) { let n = this.points.indexOf(e); if (n >= 0) return n; if (n = this.points.length, this.shapeHoles.length > 0) for (let r = 0, s = this.shapeHoles.length; r < s; r++) { let o = this.shapeHoles[r], a = o.points.indexOf(e); if (a >= 0) return n + a; n += o.points.length } return -1 } getAllPoints () { let e = [].concat(...this.shapeHoles.map(n => n.points)); return [...this.points, ...e] } applySize (e, n) { e === 0 && (e = .001), n === 0 && (n = .001), this._width = e, this._height = n } applyScale (e, n) { let r = Iw.set(e, n); for (let s = 0, o = this.points.length; s < o; s++) { let a = this.points[s]; a.position.multiply(r), a.controls[0].position.multiply(r), a.controls[1].position.multiply(r) } for (let s = 0, o = this.shapeHoles.length; s < o; s++)this.shapeHoles[s].applyScale(e, n); this._update() } createPoint (e, n = 0, r = Ge.generateUUID()) { let s; e instanceof B ? s = e : s = new B(e, n); let o = new ts(r, s); return o.roundness = this.roundness, o } addPoint (e) { this.points.push(e), this.needsUpdate = !0 } addPointAt (e, n) { this.points.splice(n, 0, e), this.needsUpdate = !0 } getPointByUuid (e) { for (let n = 0, r = this.points.length; n < r; n++) { let s = this.points[n]; if (s.uuid === e) return s } for (let n = 0, r = this.shapeHoles.length; n < r; n++) { let o = this.shapeHoles[n].getPointByUuid(e); if (o) return o } } getFirstPoint () { return this.points[0] } getLastPoint () { return this.points[this.points.length - 1] } removePoint (e) { let n = this.points.indexOf(e); n >= 0 && this.points.splice(n, 1), this.needsUpdate = !0 } removePointById (e) { let n = this.points.find(r => r.uuid === e); n && this.removePoint(n) } update () { for (let e = 0, n = this.shapeHoles.length; e < n; e++)this.shapeHoles[e].update(); this._update() } extractShapePointsToBuffer (e, n = 12, r = !1) { this.subdivision = n, this.curveDivisions === void 0 && this.computeCurveDivisions(n); let s = r ? this.roundedCurveDivisions : this.curveDivisions; return MP(e, r ? this.roundedCurves : this.curves, n, this.autoClose), s.reduce((o, a) => o + a, 0) + 1 } computeCurveDivisions (e = 12) { return this.curveDivisions = Pw(this.points, e, !1), this.roundedCurveDivisions = Pw(this.points, e, !0), this.curveDivisions } extractFilteredShapePointsToBuffer (e, n, r = 12) { return TP(e, this.curves, n, r, this.autoClose).reduce((o, a) => o + a, 0) * 2 } extractShapePointsToFlatArray (e, n = 12) { return this.subdivision = n, this.curveDivisions === void 0 && this.computeCurveDivisions(n), CP(e, this.roundedCurves, n, this.autoClose) } getCurveIndexFromVertexId (e, n = !1) { let r = 0; this.curveDivisions === void 0 && this.computeCurveDivisions(this.subdivision); let s = n ? this.roundedCurveDivisions : this.curveDivisions, o = 0; n && this.points[0].roundedCurveCorner !== void 0 && (o = La(this.points[0].roundedCurveCorner, this.subdivision) * .5); let a = e - o; a < 0 && (a += s.reduce((l, u) => l + u, 0)); for (let l = 0, u = s.length; l < u; l++) { let c = s[l]; if (a < r + c) return [l, (a - r + 1) / c]; r += c } return [0, 1] } getCurveT (e, n, r) { let s = this.points[e], o = this.points[e >= this.points.length - 1 ? 0 : e + 1], a = this.curveDivisions, l = a[e]; if (Cw(s, o)) { let h = s.position.distanceTo(o.position); return s.position.distanceTo(Iw.set(r.x, r.y)) / h } let u = 0; for (let h = 0; h < e; h++)u += a[h]; return (n - u) / l } dispose () { } _applyCurveForPoint (e, n) { Cw(n, e) ? this.lineTo(e.position.x, e.position.y) : this.bezierCurveTo(n.controls[1].position.x, n.controls[1].position.y, e.controls[0].position.x, e.controls[0].position.y, e.position.x, e.position.y); let r = this.curves[this.curves.length - 1]; e.curveBefore = r, n.curveAfter = r; let s = r.clone(); e.roundedCurveBefore = s, n.roundedCurveAfter = s, e.roundedCurveCorner = void 0, this.roundedCurves.push(s) } _update () { if (this.curves = [], this.roundedCurves = [], !this.points.length) return; for (let n = 0, r = this.points.length; n < r; n++) { let s = this.points[n]; if (n === 0) this.moveTo(s.position.x, s.position.y); else { let o = this.points[n - 1]; this._applyCurveForPoint(s, o) } } let e = this.getLastPoint(); if (e?.curveAfter && (e.curveAfter = void 0), this.isClosed) { let n = this.points[0], r = this.points[this.points.length - 1]; this._applyCurveForPoint(n, r) } if (this.points.length > 2) { let n = 0; for (let r = 0, s = this.points.length; r < s; r++) { let o = this.points[r], a = this.points[r - 1] ?? this.points[this.points.length - 1], l = this.points[r + 1] ?? this.points[0], u = o.roundness, c = a && l && wP(a, o, l); if (!o.controlsMoved() && u > 0 && !c) { let h = o.curveBefore, d = o.curveAfter; if (h === void 0 || d === void 0) continue; let f = o.roundedCurveBefore, p = o.roundedCurveAfter, m = h.getLength(), g = d.getLength(), y = Math.min(u, m * .499), v = Math.min(u, g * .499), x = Math.min(y, v), b = 1 - x / m, S = x / g, _ = h.getPointAt(b, Iw), E = d.getPointAt(S, Xj); this._subSplitCurve(h, f, b, _, void 0), this._subSplitCurve(d, p, S, void 0, E); let w; if (this.useCubicForRoundedCorners) { let M = Tw(_, o.position, E) / 2, T = Math.tan(M) * _.distanceTo(o.position), [I, C] = SP(_, E, T, Qj, Kj), P = AP(I, C, o.position), [D, L] = _P(P, _, E, T, Zj, Jj); w = new Tr(_.clone(), D.clone(), L.clone(), E.clone()) } else w = new ci(_.clone(), o.position.clone(), E.clone()); o.roundedCurveCorner = w, this.roundedCurves.splice(r + n, 0, w), n++ } } } } _subSplitCurve (e, n, r, s, o) { if (e instanceof Cr) s !== void 0 && n.v2.copy(s), o !== void 0 && n.v1.copy(o); else { let a = e, l = n, u = a.getUtoTmapping(r, 0), c = EP(a.v0, a.v1, a.v2, a.v3, u); return s !== void 0 && (l.v0.set(c[0], c[1]), l.v1.set(c[2], c[3]), l.v2.set(c[4], c[5]), l.v3.set(c[6], c[7])), o !== void 0 && (l.v0.set(c[6], c[7]), l.v1.set(c[8], c[9]), l.v2.set(c[10], c[11]), l.v3.set(c[12], c[13])), l } return n } clone () { let e = new Mt(this._width, this._height); return e.points = this.points.map(n => n.clone()), e.isClosed = this.isClosed, e.roundness = this.roundness, e.isMesh2D = this.isMesh2D, e.shapeHoles = this.shapeHoles.map(n => n.clone()), e } toJSON () { return { points: this.points.reduce((e, n) => e.concat(n.toJSON()), []), shapeHoles: this.shapeHoles.map(e => e.toJSON()), isClosed: this.isClosed, roundness: this.roundness } } fromJSON (e) { this.points = [], this.pointIDs = 0; let n = e.points.length / 7; for (let r = 0; r < n; r++) { let s = r * 7, o = e.points[s + 0], a = e.points[s + 1], l = e.points[s + 2], u = e.points[s + 3], c = e.points[s + 4], h = e.points[s + 5], d = e.points[s + 6], f = new ts(Ge.generateUUID(), new B(o, a)); f.controls[0].position.set(l, u), f.controls[1].position.set(c, h), f.roundness = d, this.points.push(f) } return this.shapeHoles = e.shapeHoles?.length ? e.shapeHoles.map(r => { let s = new Mt; return s.fromJSON(r), s }) : [], this.isClosed = e.isClosed, this._roundness = e.roundness, this._update(), this } fromShape (e) { let n = (s, o) => { o instanceof Tr && o.v3.equals(s.position) && s.controls[0].position.copy(o.v2) }, r = s => { let o = [], a, l; for (a = 0, l = s.length; a < l; a++)s[a] instanceof ci && (s[a] = bP(s[a])); for (a = 0, l = s.length; a < l; a++) { let h = s[a], d = a > 0 ? s[a - 1] : null, f; h instanceof Tr ? (f = this.createPoint(h.v0), f.controls[1].position.copy(h.v1)) : h instanceof Cr && (f = this.createPoint(h.v1)), f !== void 0 && (d !== null && n(f, d), o.push(f)) } let u = s[s.length - 1], c = !1; return u instanceof Tr ? u.v3.equals(o[0].position) && (o[0].controls[0].position.copy(u.v2), c = !0) : u instanceof Cr && u.v2.equals(o[0].position) && (c = !0), this.isClosed = c, o }; return this.points = r(e.curves), e instanceof yo && (this.shapeHoles = e.holes.map(s => { let o = new Mt; return o.fromShape(s), o })), this.update(), this } updatePoint (e, n) { let r = this.getPointByUuid(e); r && (n.position !== void 0 && r.position.fromArray(n.position), n.roundness !== void 0 && (r.roundness = n.roundness), n.areControlsDirectionsMirrored !== void 0 && (r.areControlsDirectionsMirrored = n.areControlsDirectionsMirrored), this.needsUpdate = !0) } updatePreviousControl (e, n) { let s = this.getPointByUuid(e)?.controls[0]; s && (n.position && s.position.fromArray(n.position), this.needsUpdate = !0) } updateNextControl (e, n) { let s = this.getPointByUuid(e)?.controls[1]; s && (n.position && s.position.fromArray(n.position), this.needsUpdate = !0) } }; var Ow = Math.PI * 2; function Dw ({ x: i, y: t }, e, n, r, s) { return { x: i * e + r, y: t * n + s } } function $j (i, t) { let e = t === 1.5707963267948966 ? .551915024494 : t === -1.5707963267948966 ? -.551915024494 : 1.3333333333333333 * Math.tan(t / 4), n = Math.cos(i), r = Math.sin(i), s = Math.cos(i + t), o = Math.sin(i + t); return [{ x: n - r * e, y: r + n * e }, { x: s + o * e, y: o - s * e }, { x: s, y: o }] } function PP (i, t, e, n) { let r = i * n - t * e < 0 ? -1 : 1, s = Math.min(1, Math.max(-1, i * e + t * n)); return r * Math.acos(s) } function eW (i, t, e, n, r, s, o, a, l, u) { let c = Math.pow(r, 2), h = Math.pow(s, 2), d = Math.pow(o, 2), f = Math.pow(a, 2), p = c * h - c * f - h * d; p < 0 && (p = 0), p /= c * f + h * d, p = Math.sqrt(p) * (l === u ? -1 : 1); let m = p * r / s * a, g = p * -s / r * o, y = m + (i + e) / 2, v = g + (t + n) / 2, x = (o - m) / r, b = (a - g) / s, S = (-o - m) / r, _ = (-a - g) / s, E = PP(1, 0, x, b), w = PP(x, b, S, _); return !u && w > 0 && (w -= Ow), u && w < 0 && (w += Ow), { centerx: y, centery: v, ang1: E, ang2: w } } function IP ({ px: i, py: t, cx: e, cy: n, rx: r, ry: s, largeArcFlag: o, sweepFlag: a }) { let l = []; if (r === 0 || s === 0) return []; let u = (i - e) / 2, c = (t - n) / 2; if (u === 0 && c === 0) return []; r = Math.abs(r), s = Math.abs(s); let h = Math.pow(u, 2) / Math.pow(r, 2) + Math.pow(c, 2) / Math.pow(s, 2); h > 1 && (r *= Math.sqrt(h), s *= Math.sqrt(h)); let d = eW(i, t, e, n, r, s, u, c, o, a), { ang1: f, ang2: p } = d, { centerx: m, centery: g } = d, y = Math.abs(p) / (Ow / 4); Math.abs(1 - y) < 1e-7 && (y = 1); let v = Math.max(Math.ceil(y), 1); p /= v; for (let x = 0; x < v; x++)l.push($j(f, p)), f += p; return l.map(x => { let { x: b, y: S } = Dw(x[0], r, s, m, g), { x: _, y: E } = Dw(x[1], r, s, m, g), { x: w, y: M } = Dw(x[2], r, s, m, g); return { x1: b, y1: S, x2: _, y2: E, x: w, y: M } }) } var yt; (function (i) { i[i.ODD = 0] = "ODD", i[i.NONZERO = 1] = "NONZERO", i[i.POSITIVE = 2] = "POSITIVE", i[i.NEGATIVE = 3] = "NEGATIVE", i[i.ABS_GEQ_TWO = 4] = "ABS_GEQ_TWO" })(yt || (yt = {})); var ln; (function (i) { i[i.POLYGONS = 0] = "POLYGONS", i[i.CONNECTED_POLYGONS = 1] = "CONNECTED_POLYGONS", i[i.BOUNDARY_CONTOURS = 2] = "BOUNDARY_CONTOURS" })(ln || (ln = {})); function et (i, t) { if (!i) throw t || "Assertion Failed!" } var Qe = function () { function i () { } return i.vertEq = function (t, e) { return t.s === e.s && t.t === e.t }, i.vertLeq = function (t, e) { return t.s < e.s || t.s === e.s && t.t <= e.t }, i.transLeq = function (t, e) { return t.t < e.t || t.t === e.t && t.s <= e.s }, i.edgeGoesLeft = function (t) { return i.vertLeq(t.Dst, t.Org) }, i.edgeGoesRight = function (t) { return i.vertLeq(t.Org, t.Dst) }, i.vertL1dist = function (t, e) { return Math.abs(t.s - e.s) + Math.abs(t.t - e.t) }, i.edgeEval = function (t, e, n) { et(i.vertLeq(t, e) && i.vertLeq(e, n)); var r = e.s - t.s, s = n.s - e.s; return r + s > 0 ? r < s ? e.t - t.t + (t.t - n.t) * (r / (r + s)) : e.t - n.t + (n.t - t.t) * (s / (r + s)) : 0 }, i.edgeSign = function (t, e, n) { et(i.vertLeq(t, e) && i.vertLeq(e, n)); var r = e.s - t.s, s = n.s - e.s; return r + s > 0 ? (e.t - n.t) * r + (e.t - t.t) * s : 0 }, i.transEval = function (t, e, n) { et(i.transLeq(t, e) && i.transLeq(e, n)); var r = e.t - t.t, s = n.t - e.t; return r + s > 0 ? r < s ? e.s - t.s + (t.s - n.s) * (r / (r + s)) : e.s - n.s + (n.s - t.s) * (s / (r + s)) : 0 }, i.transSign = function (t, e, n) { et(i.transLeq(t, e) && i.transLeq(e, n)); var r = e.t - t.t, s = n.t - e.t; return r + s > 0 ? (e.s - n.s) * r + (e.s - t.s) * s : 0 }, i.vertCCW = function (t, e, n) { return t.s * (e.t - n.t) + e.s * (n.t - t.t) + n.s * (t.t - e.t) >= 0 }, i.interpolate = function (t, e, n, r) { return t = t < 0 ? 0 : t, n = n < 0 ? 0 : n, t <= n ? n === 0 ? (e + r) / 2 : e + (r - e) * (t / (t + n)) : r + (e - r) * (n / (t + n)) }, i.intersect = function (t, e, n, r, s) { var o, a, l; i.vertLeq(t, e) || (l = t, t = e, e = l), i.vertLeq(n, r) || (l = n, n = r, r = l), i.vertLeq(t, n) || (l = t, t = n, n = l, l = e, e = r, r = l), i.vertLeq(n, e) ? i.vertLeq(e, r) ? (o = i.edgeEval(t, n, e), a = i.edgeEval(n, e, r), o + a < 0 && (o = -o, a = -a), s.s = i.interpolate(o, n.s, a, e.s)) : (o = i.edgeSign(t, n, e), a = -i.edgeSign(t, r, e), o + a < 0 && (o = -o, a = -a), s.s = i.interpolate(o, n.s, a, r.s)) : s.s = (n.s + e.s) / 2, i.transLeq(t, e) || (l = t, t = e, e = l), i.transLeq(n, r) || (l = n, n = r, r = l), i.transLeq(t, n) || (l = t, t = n, n = l, l = e, e = r, r = l), i.transLeq(n, e) ? i.transLeq(e, r) ? (o = i.transEval(t, n, e), a = i.transEval(n, e, r), o + a < 0 && (o = -o, a = -a), s.t = i.interpolate(o, n.t, a, e.t)) : (o = i.transSign(t, n, e), a = -i.transSign(t, r, e), o + a < 0 && (o = -o, a = -a), s.t = i.interpolate(o, n.t, a, r.t)) : s.t = (n.t + e.t) / 2 }, i }(), Bf = function () { function i () { this.next = null, this.prev = null, this.anEdge = null, this.trail = null, this.n = 0, this.marked = !1, this.inside = !1 } return i }(), Ay = function () { function i (t) { this.side = t, this.next = null, this.Org = null, this.Sym = null, this.Onext = null, this.Lnext = null, this.Lface = null, this.activeRegion = null, this.winding = 0 } return Object.defineProperty(i.prototype, "Rface", { get: function () { return this.Sym.Lface }, set: function (t) { this.Sym.Lface = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "Dst", { get: function () { return this.Sym.Org }, set: function (t) { this.Sym.Org = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "Oprev", { get: function () { return this.Sym.Lnext }, set: function (t) { this.Sym.Lnext = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "Lprev", { get: function () { return this.Onext.Sym }, set: function (t) { this.Onext.Sym = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "Dprev", { get: function () { return this.Lnext.Sym }, set: function (t) { this.Lnext.Sym = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "Rprev", { get: function () { return this.Sym.Onext }, set: function (t) { this.Sym.Onext = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "Dnext", { get: function () { return this.Sym.Onext.Sym }, set: function (t) { this.Sym.Onext.Sym = t }, enumerable: !0, configurable: !0 }), Object.defineProperty(i.prototype, "Rnext", { get: function () { return this.Sym.Lnext.Sym }, set: function (t) { this.Sym.Lnext.Sym = t }, enumerable: !0, configurable: !0 }), i }(), lh = function () { function i () { this.next = null, this.prev = null, this.anEdge = null, this.coords = [0, 0, 0], this.s = 0, this.t = 0, this.pqHandle = 0, this.n = 0, this.idx = 0 } return i }(), DP = function () { function i () { var t = new lh, e = new Bf, n = new Ay(0), r = new Ay(1); t.next = t.prev = t, t.anEdge = null, e.next = e.prev = e, n.next = n, n.Sym = r, r.next = r, r.Sym = n, this.vHead = t, this.fHead = e, this.eHead = n, this.eHeadSym = r } return i.prototype.makeEdge_ = function (t) { var e = new Ay(0), n = new Ay(1); t.Sym.side < t.side && (t = t.Sym); var r = t.Sym.next; return n.next = r, r.Sym.next = e, e.next = t, t.Sym.next = n, e.Sym = n, e.Onext = e, e.Lnext = n, e.Org = null, e.Lface = null, e.winding = 0, e.activeRegion = null, n.Sym = e, n.Onext = n, n.Lnext = e, n.Org = null, n.Lface = null, n.winding = 0, n.activeRegion = null, e }, i.prototype.splice_ = function (t, e) { var n = t.Onext, r = e.Onext; n.Sym.Lnext = e, r.Sym.Lnext = t, t.Onext = r, e.Onext = n }, i.prototype.makeVertex_ = function (t, e, n) { var r = t; et(r, "Vertex can't be null!"); var s = n.prev; r.prev = s, s.next = r, r.next = n, n.prev = r, r.anEdge = e; var o = e; do o.Org = r, o = o.Onext; while (o !== e) }, i.prototype.makeFace_ = function (t, e, n) { var r = t; et(r, "Face can't be null"); var s = n.prev; r.prev = s, s.next = r, r.next = n, n.prev = r, r.anEdge = e, r.trail = null, r.marked = !1, r.inside = n.inside; var o = e; do o.Lface = r, o = o.Lnext; while (o !== e) }, i.prototype.killEdge_ = function (t) { t.Sym.side < t.side && (t = t.Sym); var e = t.next, n = t.Sym.next; e.Sym.next = n, n.Sym.next = e }, i.prototype.killVertex_ = function (t, e) { var n = t.anEdge, r = n; do r.Org = e, r = r.Onext; while (r !== n); var s = t.prev, o = t.next; o.prev = s, s.next = o }, i.prototype.killFace_ = function (t, e) { var n = t.anEdge, r = n; do r.Lface = e, r = r.Lnext; while (r !== n); var s = t.prev, o = t.next; o.prev = s, s.next = o }, i.prototype.makeEdge = function () { var t = new lh, e = new lh, n = new Bf, r = this.makeEdge_(this.eHead); return this.makeVertex_(t, r, this.vHead), this.makeVertex_(e, r.Sym, this.vHead), this.makeFace_(n, r, this.fHead), r }, i.prototype.splice = function (t, e) { var n = !1, r = !1; if (t !== e) { if (e.Org !== t.Org && (r = !0, this.killVertex_(e.Org, t.Org)), e.Lface !== t.Lface && (n = !0, this.killFace_(e.Lface, t.Lface)), this.splice_(e, t), !r) { var s = new lh; this.makeVertex_(s, e, t.Org), t.Org.anEdge = t } if (!n) { var o = new Bf; this.makeFace_(o, e, t.Lface), t.Lface.anEdge = t } } }, i.prototype.delete = function (t) { var e = t.Sym, n = !1; if (t.Lface !== t.Rface && (n = !0, this.killFace_(t.Lface, t.Rface)), t.Onext === t) this.killVertex_(t.Org, null); else if (t.Rface.anEdge = t.Oprev, t.Org.anEdge = t.Onext, this.splice_(t, t.Oprev), !n) { var r = new Bf; this.makeFace_(r, t, t.Lface) } e.Onext === e ? (this.killVertex_(e.Org, null), this.killFace_(e.Lface, null)) : (t.Lface.anEdge = e.Oprev, e.Org.anEdge = e.Onext, this.splice_(e, e.Oprev)), this.killEdge_(t) }, i.prototype.addEdgeVertex = function (t) { var e = this.makeEdge_(t), n = e.Sym; this.splice_(e, t.Lnext), e.Org = t.Dst; var r = new lh; return this.makeVertex_(r, n, e.Org), e.Lface = n.Lface = t.Lface, e }, i.prototype.splitEdge = function (t) { var e = this.addEdgeVertex(t), n = e.Sym; return this.splice_(t.Sym, t.Sym.Oprev), this.splice_(t.Sym, n), t.Dst = n.Org, n.Dst.anEdge = n.Sym, n.Rface = t.Rface, n.winding = t.winding, n.Sym.winding = t.Sym.winding, n.idx = t.idx, n.Sym.idx = t.Sym.idx, n }, i.prototype.connect = function (t, e) { var n = !1, r = this.makeEdge_(t), s = r.Sym; if (e.Lface !== t.Lface && (n = !0, this.killFace_(e.Lface, t.Lface)), this.splice_(r, t.Lnext), this.splice_(s, e), r.Org = t.Dst, s.Org = e.Org, r.Lface = s.Lface = t.Lface, t.Lface.anEdge = s, !n) { var o = new Bf; this.makeFace_(o, r, t.Lface) } return r }, i.prototype.zapFace = function (t) { var e = t.anEdge, n, r, s, o, a; r = e.Lnext; do n = r, r = n.Lnext, n.Lface = null, n.Rface === null && (n.Onext === n ? this.killVertex_(n.Org, null) : (n.Org.anEdge = n.Onext, this.splice_(n, n.Oprev)), s = n.Sym, s.Onext === s ? this.killVertex_(s.Org, null) : (s.Org.anEdge = s.Onext, this.splice_(s, s.Oprev)), this.killEdge_(n)); while (n != e); o = t.prev, a = t.next, a.prev = o, o.next = a }, i.prototype.countFaceVerts_ = function (t) { var e = t.anEdge, n = 0; do n++, e = e.Lnext; while (e !== t.anEdge); return n }, i.prototype.mergeConvexFaces = function (t) { var e, n, r, s, o, a, l; for (e = this.fHead.next; e !== this.fHead; e = e.next)if (e.inside) for (n = e.anEdge, o = n.Org; r = n.Lnext, s = n.Sym, s && s.Lface && s.Lface.inside && (a = this.countFaceVerts_(e), l = this.countFaceVerts_(s.Lface), a + l - 2 <= t && Qe.vertCCW(n.Lprev.Org, n.Org, s.Lnext.Lnext.Org) && Qe.vertCCW(s.Lprev.Org, s.Org, n.Lnext.Lnext.Org) && (r = s.Lnext, this.delete(s), n = null, s = null)), !(n && n.Lnext.Org === o);)n = r; return !0 }, i.prototype.check = function () { var t = this.fHead, e = this.vHead, n = this.eHead, r, s, o, a, l, u; for (s = t, s = t; (r = s.next) !== t; s = r) { et(r.prev === s), l = r.anEdge; do et(l.Sym !== l), et(l.Sym.Sym === l), et(l.Lnext.Onext.Sym === l), et(l.Onext.Sym.Lnext === l), et(l.Lface === r), l = l.Lnext; while (l !== r.anEdge) } for (et(r.prev === s && r.anEdge === null), a = e, a = e; (o = a.next) !== e; a = o) { et(o.prev === a), l = o.anEdge; do et(l.Sym !== l), et(l.Sym.Sym === l), et(l.Lnext.Onext.Sym === l), et(l.Onext.Sym.Lnext === l), et(l.Org === o), l = l.Onext; while (l !== o.anEdge) } for (et(o.prev === a && o.anEdge === null), u = n, u = n; (l = u.next) !== n; u = l)et(l.Sym.next === u.Sym), et(l.Sym !== l), et(l.Sym.Sym === l), et(l.Org !== null), et(l.Dst !== null), et(l.Lnext.Onext.Sym === l), et(l.Onext.Sym.Lnext === l); et(l.Sym.next === u.Sym && l.Sym === this.eHeadSym && l.Sym.Sym === l && l.Org === null && l.Dst === null && l.Lface === null && l.Rface === null) }, i }(), OP = function () { function i () { this.handle = null } return i }(), RP = function () { function i () { this.key = null, this.node = 0 } return i }(), tW = function () { function i (t, e) { this.leq = e, this.max = 0, this.nodes = [], this.handles = [], this.initialized = !1, this.freeList = 0, this.size = 0, this.max = t, this.nodes = [], this.handles = []; for (var n = 0; n < t + 1; n++)this.nodes[n] = new OP, this.handles[n] = new RP; this.initialized = !1, this.nodes[1].handle = 1, this.handles[1].key = null } return i.prototype.floatDown_ = function (t) { var e = this.nodes, n = this.handles, r, s, o; for (r = e[t].handle; ;) { if (o = t << 1, o < this.size && this.leq(n[e[o + 1].handle].key, n[e[o].handle].key) && ++o, et(o <= this.max), s = e[o].handle, o > this.size || this.leq(n[r].key, n[s].key)) { e[t].handle = r, n[r].node = t; break } e[t].handle = s, n[s].node = t, t = o } }, i.prototype.floatUp_ = function (t) { var e = this.nodes, n = this.handles, r, s, o; for (r = e[t].handle; ;) { if (o = t >> 1, s = e[o].handle, o === 0 || this.leq(n[s].key, n[r].key)) { e[t].handle = r, n[r].node = t; break } e[t].handle = s, n[s].node = t, t = o } }, i.prototype.init = function () { for (var t = this.size; t >= 1; --t)this.floatDown_(t); this.initialized = !0 }, i.prototype.min = function () { return this.handles[this.nodes[1].handle].key }, i.prototype.insert = function (t) { var e, n; if (e = ++this.size, e * 2 > this.max) { this.max *= 2; var r, s; for (s = this.nodes.length, this.nodes.length = this.max + 1, r = s; r < this.nodes.length; r++)this.nodes[r] = new OP; for (s = this.handles.length, this.handles.length = this.max + 1, r = s; r < this.handles.length; r++)this.handles[r] = new RP } return this.freeList === 0 ? n = e : (n = this.freeList, this.freeList = this.handles[n].node), this.nodes[e].handle = n, this.handles[n].node = e, this.handles[n].key = t, this.initialized && this.floatUp_(e), n }, i.prototype.extractMin = function () { var t = this.nodes, e = this.handles, n = t[1].handle, r = e[n].key; return this.size > 0 && (t[1].handle = t[this.size].handle, e[t[1].handle].node = 1, e[n].key = null, e[n].node = this.freeList, this.freeList = n, --this.size, this.size > 0 && this.floatDown_(1)), r }, i.prototype.delete = function (t) { var e = this.nodes, n = this.handles, r; et(t >= 1 && t <= this.max && n[t].key !== null), r = n[t].node, e[r].handle = e[this.size].handle, n[e[r].handle].node = r, --this.size, r <= this.size && (r <= 1 || this.leq(n[e[r >> 1].handle].key, n[e[r].handle].key) ? this.floatDown_(r) : this.floatUp_(r)), n[t].key = null, n[t].node = this.freeList, this.freeList = t }, i }(), Rw = function () { function i () { this.eUp = null, this.nodeUp = null, this.windingNumber = 0, this.inside = !1, this.sentinel = !1, this.dirty = !1, this.fixUpperEdge = !1 } return i }(), LP = function () { function i () { this.key = null, this.next = null, this.prev = null } return i }(), nW = function () { function i (t, e) { this.frame = t, this.leq = e, this.head = new LP, this.head.next = this.head, this.head.prev = this.head } return i.prototype.min = function () { return this.head.next }, i.prototype.max = function () { return this.head.prev }, i.prototype.insert = function (t) { return this.insertBefore(this.head, t) }, i.prototype.search = function (t) { var e = this.head; do e = e.next; while (e.key !== null && !this.leq(this.frame, t, e.key)); return e }, i.prototype.insertBefore = function (t, e) { do t = t.prev; while (t.key !== null && !this.leq(this.frame, t.key, e)); var n = new LP; return n.key = e, n.next = t.next, t.next.prev = n, n.prev = t, t.next = n, n }, i.prototype.delete = function (t) { t.next.prev = t.prev, t.prev.next = t.next }, i }(), rW = function () { function i () { } return i.regionBelow = function (t) { return t.nodeUp.prev.key }, i.regionAbove = function (t) { return t.nodeUp.next.key }, i.debugEvent = function (t) { }, i.addWinding = function (t, e) { t.winding += e.winding, t.Sym.winding += e.Sym.winding }, i.edgeLeq = function (t, e, n) { var r = t.event, s = e.eUp, o = n.eUp; if (s.Dst === r) return o.Dst === r ? Qe.vertLeq(s.Org, o.Org) ? Qe.edgeSign(o.Dst, s.Org, o.Org) <= 0 : Qe.edgeSign(s.Dst, o.Org, s.Org) >= 0 : Qe.edgeSign(o.Dst, r, o.Org) <= 0; if (o.Dst === r) return Qe.edgeSign(s.Dst, r, s.Org) >= 0; var a = Qe.edgeEval(s.Dst, r, s.Org), l = Qe.edgeEval(o.Dst, r, o.Org); return a >= l }, i.deleteRegion = function (t, e) { e.fixUpperEdge && et(e.eUp.winding === 0), e.eUp.activeRegion = null, t.dict.delete(e.nodeUp) }, i.fixUpperEdge = function (t, e, n) { et(e.fixUpperEdge), t.mesh.delete(e.eUp), e.fixUpperEdge = !1, e.eUp = n, n.activeRegion = e }, i.topLeftRegion = function (t, e) { var n = e.eUp.Org, r; do e = i.regionAbove(e); while (e.eUp.Org === n); if (e.fixUpperEdge) { if (r = t.mesh.connect(i.regionBelow(e).eUp.Sym, e.eUp.Lnext), r === null) return null; i.fixUpperEdge(t, e, r), e = i.regionAbove(e) } return e }, i.topRightRegion = function (t) { var e = t.eUp.Dst; do t = i.regionAbove(t); while (t.eUp.Dst === e); return t }, i.addRegionBelow = function (t, e, n) { var r = new Rw; return r.eUp = n, r.nodeUp = t.dict.insertBefore(e.nodeUp, r), r.fixUpperEdge = !1, r.sentinel = !1, r.dirty = !1, n.activeRegion = r, r }, i.isWindingInside = function (t, e) { switch (t.windingRule) { case yt.ODD: return (e & 1) !== 0; case yt.NONZERO: return e !== 0; case yt.POSITIVE: return e > 0; case yt.NEGATIVE: return e < 0; case yt.ABS_GEQ_TWO: return e >= 2 || e <= -2 }throw new Error("Invalid winding rulle") }, i.computeWinding = function (t, e) { e.windingNumber = i.regionAbove(e).windingNumber + e.eUp.winding, e.inside = i.isWindingInside(t, e.windingNumber) }, i.finishRegion = function (t, e) { var n = e.eUp, r = n.Lface; r.inside = e.inside, r.anEdge = n, i.deleteRegion(t, e) }, i.finishLeftRegions = function (t, e, n) { for (var r, s = null, o = e, a = e.eUp; o !== n;) { if (o.fixUpperEdge = !1, s = i.regionBelow(o), r = s.eUp, r.Org != a.Org) { if (!s.fixUpperEdge) { i.finishRegion(t, o); break } r = t.mesh.connect(a.Lprev, r.Sym), i.fixUpperEdge(t, s, r) } a.Onext !== r && (t.mesh.splice(r.Oprev, r), t.mesh.splice(a, r)), i.finishRegion(t, o), a = s.eUp, o = s } return a }, i.addRightEdges = function (t, e, n, r, s, o) { var a, l, u, c, h = !0; u = n; do et(Qe.vertLeq(u.Org, u.Dst)), i.addRegionBelow(t, e, u.Sym), u = u.Onext; while (u !== r); for (s === null && (s = i.regionBelow(e).eUp.Rprev), l = e, c = s; a = i.regionBelow(l), u = a.eUp.Sym, u.Org === c.Org;)u.Onext !== c && (t.mesh.splice(u.Oprev, u), t.mesh.splice(c.Oprev, u)), a.windingNumber = l.windingNumber - u.winding, a.inside = i.isWindingInside(t, a.windingNumber), l.dirty = !0, !h && i.checkForRightSplice(t, l) && (i.addWinding(u, c), i.deleteRegion(t, l), t.mesh.delete(c)), h = !1, l = a, c = u; l.dirty = !0, et(l.windingNumber - u.winding === a.windingNumber), o && i.walkDirtyRegions(t, l) }, i.spliceMergeVertices = function (t, e, n) { t.mesh.splice(e, n) }, i.vertexWeights = function (t, e, n) { var r = Qe.vertL1dist(e, t), s = Qe.vertL1dist(n, t), o = .5 * s / (r + s), a = .5 * r / (r + s); t.coords[0] += o * e.coords[0] + a * n.coords[0], t.coords[1] += o * e.coords[1] + a * n.coords[1], t.coords[2] += o * e.coords[2] + a * n.coords[2] }, i.getIntersectData = function (t, e, n, r, s, o) { e.coords[0] = e.coords[1] = e.coords[2] = 0, e.idx = -1, i.vertexWeights(e, n, r), i.vertexWeights(e, s, o) }, i.checkForRightSplice = function (t, e) { var n = i.regionBelow(e), r = e.eUp, s = n.eUp; if (Qe.vertLeq(r.Org, s.Org)) { if (Qe.edgeSign(s.Dst, r.Org, s.Org) > 0) return !1; Qe.vertEq(r.Org, s.Org) ? r.Org !== s.Org && (t.pq.delete(r.Org.pqHandle), i.spliceMergeVertices(t, s.Oprev, r)) : (t.mesh.splitEdge(s.Sym), t.mesh.splice(r, s.Oprev), e.dirty = n.dirty = !0) } else { if (Qe.edgeSign(r.Dst, s.Org, r.Org) < 0) return !1; i.regionAbove(e).dirty = e.dirty = !0, t.mesh.splitEdge(r.Sym), t.mesh.splice(s.Oprev, r) } return !0 }, i.checkForLeftSplice = function (t, e) { var n = i.regionBelow(e), r = e.eUp, s = n.eUp, o; if (et(!Qe.vertEq(r.Dst, s.Dst)), Qe.vertLeq(r.Dst, s.Dst)) { if (Qe.edgeSign(r.Dst, s.Dst, r.Org) < 0) return !1; i.regionAbove(e).dirty = e.dirty = !0, o = t.mesh.splitEdge(r), t.mesh.splice(s.Sym, o), o.Lface.inside = e.inside } else { if (Qe.edgeSign(s.Dst, r.Dst, s.Org) > 0) return !1; e.dirty = n.dirty = !0, o = t.mesh.splitEdge(s), t.mesh.splice(r.Lnext, s.Sym), o.Rface.inside = e.inside } return !0 }, i.checkForIntersect = function (t, e) { var n = i.regionBelow(e), r = e.eUp, s = n.eUp, o = r.Org, a = s.Org, l = r.Dst, u = s.Dst, c, h, d = new lh, f, p; if (et(!Qe.vertEq(u, l)), et(Qe.edgeSign(l, t.event, o) <= 0), et(Qe.edgeSign(u, t.event, a) >= 0), et(o !== t.event && a !== t.event), et(!e.fixUpperEdge && !n.fixUpperEdge), o === a || (c = Math.min(o.t, l.t), h = Math.max(a.t, u.t), c > h)) return !1; if (Qe.vertLeq(o, a)) { if (Qe.edgeSign(u, o, a) > 0) return !1 } else if (Qe.edgeSign(l, a, o) < 0) return !1; return i.debugEvent(t), Qe.intersect(l, o, u, a, d), et(Math.min(o.t, l.t) <= d.t), et(d.t <= Math.max(a.t, u.t)), et(Math.min(u.s, l.s) <= d.s), et(d.s <= Math.max(a.s, o.s)), Qe.vertLeq(d, t.event) && (d.s = t.event.s, d.t = t.event.t), f = Qe.vertLeq(o, a) ? o : a, Qe.vertLeq(f, d) && (d.s = f.s, d.t = f.t), Qe.vertEq(d, o) || Qe.vertEq(d, a) ? (i.checkForRightSplice(t, e), !1) : !Qe.vertEq(l, t.event) && Qe.edgeSign(l, t.event, d) >= 0 || !Qe.vertEq(u, t.event) && Qe.edgeSign(u, t.event, d) <= 0 ? u === t.event ? (t.mesh.splitEdge(r.Sym), t.mesh.splice(s.Sym, r), e = i.topLeftRegion(t, e), r = i.regionBelow(e).eUp, i.finishLeftRegions(t, i.regionBelow(e), n), i.addRightEdges(t, e, r.Oprev, r, r, !0), !0) : l === t.event ? (t.mesh.splitEdge(s.Sym), t.mesh.splice(r.Lnext, s.Oprev), n = e, e = i.topRightRegion(e), p = i.regionBelow(e).eUp.Rprev, n.eUp = s.Oprev, s = i.finishLeftRegions(t, n, null), i.addRightEdges(t, e, s.Onext, r.Rprev, p, !0), !0) : (Qe.edgeSign(l, t.event, d) >= 0 && (i.regionAbove(e).dirty = e.dirty = !0, t.mesh.splitEdge(r.Sym), r.Org.s = t.event.s, r.Org.t = t.event.t), Qe.edgeSign(u, t.event, d) <= 0 && (e.dirty = n.dirty = !0, t.mesh.splitEdge(s.Sym), s.Org.s = t.event.s, s.Org.t = t.event.t), !1) : (t.mesh.splitEdge(r.Sym), t.mesh.splitEdge(s.Sym), t.mesh.splice(s.Oprev, r), r.Org.s = d.s, r.Org.t = d.t, r.Org.pqHandle = t.pq.insert(r.Org), i.getIntersectData(t, r.Org, o, l, a, u), i.regionAbove(e).dirty = e.dirty = n.dirty = !0, !1) }, i.walkDirtyRegions = function (t, e) { for (var n = i.regionBelow(e), r, s; ;) { for (; n.dirty;)e = n, n = i.regionBelow(n); if (!e.dirty && (n = e, e = i.regionAbove(e), e === null || !e.dirty)) return; if (e.dirty = !1, r = e.eUp, s = n.eUp, r.Dst !== s.Dst && i.checkForLeftSplice(t, e) && (n.fixUpperEdge ? (i.deleteRegion(t, n), t.mesh.delete(s), n = i.regionBelow(e), s = n.eUp) : e.fixUpperEdge && (i.deleteRegion(t, e), t.mesh.delete(r), e = i.regionAbove(n), r = e.eUp)), r.Org !== s.Org) if (r.Dst !== s.Dst && !e.fixUpperEdge && !n.fixUpperEdge && (r.Dst === t.event || s.Dst === t.event)) { if (i.checkForIntersect(t, e)) return } else i.checkForRightSplice(t, e); r.Org === s.Org && r.Dst === s.Dst && (i.addWinding(s, r), i.deleteRegion(t, e), t.mesh.delete(r), e = i.regionAbove(n)) } }, i.connectRightVertex = function (t, e, n) { var r, s = n.Onext, o = i.regionBelow(e), a = e.eUp, l = o.eUp, u = !1; if (a.Dst !== l.Dst && i.checkForIntersect(t, e), Qe.vertEq(a.Org, t.event) && (t.mesh.splice(s.Oprev, a), e = i.topLeftRegion(t, e), s = i.regionBelow(e).eUp, i.finishLeftRegions(t, i.regionBelow(e), o), u = !0), Qe.vertEq(l.Org, t.event) && (t.mesh.splice(n, l.Oprev), n = i.finishLeftRegions(t, o, null), u = !0), u) { i.addRightEdges(t, e, n.Onext, s, s, !0); return } Qe.vertLeq(l.Org, a.Org) ? r = l.Oprev : r = a, r = t.mesh.connect(n.Lprev, r), i.addRightEdges(t, e, r, r.Onext, r.Onext, !1), r.Sym.activeRegion.fixUpperEdge = !0, i.walkDirtyRegions(t, e) }, i.connectLeftDegenerate = function (t, e, n) { var r, s, o, a, l; if (r = e.eUp, Qe.vertEq(r.Org, n)) { et(!1), i.spliceMergeVertices(t, r, n.anEdge); return } if (!Qe.vertEq(r.Dst, n)) { t.mesh.splitEdge(r.Sym), e.fixUpperEdge && (t.mesh.delete(r.Onext), e.fixUpperEdge = !1), t.mesh.splice(n.anEdge, r), i.sweepEvent(t, n); return } et(!1), e = i.topRightRegion(e), l = i.regionBelow(e), o = l.eUp.Sym, s = a = o.Onext, l.fixUpperEdge && (et(s !== o), i.deleteRegion(t, l), t.mesh.delete(o), o = s.Oprev), t.mesh.splice(n.anEdge, o), Qe.edgeGoesLeft(s) || (s = null), i.addRightEdges(t, e, o.Onext, a, s, !0) }, i.connectLeftVertex = function (t, e) { var n, r, s, o, a, l, u = new Rw; if (u.eUp = e.anEdge.Sym, n = t.dict.search(u).key, r = i.regionBelow(n), !!r) { if (o = n.eUp, a = r.eUp, Qe.edgeSign(o.Dst, e, o.Org) === 0) { i.connectLeftDegenerate(t, n, e); return } if (s = Qe.vertLeq(a.Dst, o.Dst) ? n : r, n.inside || s.fixUpperEdge) { if (s === n) l = t.mesh.connect(e.anEdge.Sym, o.Lnext); else { var c = t.mesh.connect(a.Dnext, e.anEdge); l = c.Sym } s.fixUpperEdge ? i.fixUpperEdge(t, s, l) : i.computeWinding(t, i.addRegionBelow(t, n, l)), i.sweepEvent(t, e) } else i.addRightEdges(t, n, e.anEdge, e.anEdge, null, !0) } }, i.sweepEvent = function (t, e) { t.event = e, i.debugEvent(t); for (var n = e.anEdge; n.activeRegion === null;)if (n = n.Onext, n === e.anEdge) { i.connectLeftVertex(t, e); return } var r = i.topLeftRegion(t, n.activeRegion); et(r !== null); var s = i.regionBelow(r), o = s.eUp, a = i.finishLeftRegions(t, s, null); a.Onext === o ? i.connectRightVertex(t, r, a) : i.addRightEdges(t, r, a.Onext, o, o, !0) }, i.addSentinel = function (t, e, n, r) { var s = new Rw, o = t.mesh.makeEdge(); o.Org.s = n, o.Org.t = r, o.Dst.s = e, o.Dst.t = r, t.event = o.Dst, s.eUp = o, s.windingNumber = 0, s.inside = !1, s.fixUpperEdge = !1, s.sentinel = !0, s.dirty = !1, s.nodeUp = t.dict.insert(s) }, i.initEdgeDict = function (t) { t.dict = new nW(t, i.edgeLeq); var e = t.bmax[0] - t.bmin[0], n = t.bmax[1] - t.bmin[1], r = t.bmin[0] - e, s = t.bmax[0] + e, o = t.bmin[1] - n, a = t.bmax[1] + n; i.addSentinel(t, r, s, o), i.addSentinel(t, r, s, a) }, i.doneEdgeDict = function (t) { for (var e, n = 0; (e = t.dict.min().key) !== null;)e.sentinel || (et(e.fixUpperEdge), et(++n === 1)), et(e.windingNumber === 0), i.deleteRegion(t, e) }, i.removeDegenerateEdges = function (t) { var e, n, r, s = t.mesh.eHead; for (e = s.next; e !== s; e = n)n = e.next, r = e.Lnext, Qe.vertEq(e.Org, e.Dst) && e.Lnext.Lnext !== e && (i.spliceMergeVertices(t, r, e), t.mesh.delete(e), e = r, r = e.Lnext), r.Lnext === e && (r !== e && ((r === n || r === n.Sym) && (n = n.next), t.mesh.delete(r)), (e === n || e === n.Sym) && (n = n.next), t.mesh.delete(e)) }, i.initPriorityQ = function (t) { var e, n, r, s = 0; for (r = t.mesh.vHead, n = r.next; n !== r; n = n.next)s++; for (s += 8, e = t.pq = new tW(s, Qe.vertLeq), r = t.mesh.vHead, n = r.next; n !== r; n = n.next)n.pqHandle = e.insert(n); return n !== r ? !1 : (e.init(), !0) }, i.donePriorityQ = function (t) { t.pq = null }, i.removeDegenerateFaces = function (t, e) { var n, r, s; for (n = e.fHead.next; n !== e.fHead; n = r)r = n.next, s = n.anEdge, et(s.Lnext !== s), s.Lnext.Lnext === s && (i.addWinding(s.Onext, s), t.mesh.delete(s)); return !0 }, i.computeInterior = function (t, e) { e === void 0 && (e = !0); var n, r; if (i.removeDegenerateEdges(t), !i.initPriorityQ(t)) return !1; for (i.initEdgeDict(t); (n = t.pq.extractMin()) !== null;) { for (; r = t.pq.min(), !(r === null || !Qe.vertEq(r, n));)r = t.pq.extractMin(), i.spliceMergeVertices(t, n.anEdge, r.anEdge); i.sweepEvent(t, n) } return t.event = t.dict.min().key.eUp.Org, i.debugEvent(t), i.doneEdgeDict(t), i.donePriorityQ(t), i.removeDegenerateFaces(t, t.mesh) ? (e && t.mesh.check(), !0) : !1 }, i }(), iW = function () { function i () { this.mesh = new DP, this.normal = [0, 0, 0], this.sUnit = [0, 0, 0], this.tUnit = [0, 0, 0], this.bmin = [0, 0], this.bmax = [0, 0], this.windingRule = yt.ODD, this.dict = null, this.pq = null, this.event = null, this.vertexIndexCounter = 0, this.vertices = [], this.vertexIndices = [], this.vertexCount = 0, this.elements = [], this.elementCount = 0 } return i.prototype.dot_ = function (t, e) { return t[0] * e[0] + t[1] * e[1] + t[2] * e[2] }, i.prototype.normalize_ = function (t) { var e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2]; if (!e) throw "Zero-size vector!"; e = Math.sqrt(e), t[0] /= e, t[1] /= e, t[2] /= e }, i.prototype.longAxis_ = function (t) { var e = 0; return Math.abs(t[1]) > Math.abs(t[0]) && (e = 1), Math.abs(t[2]) > Math.abs(t[e]) && (e = 2), e }, i.prototype.computeNormal_ = function (t) { var e, n, r, s, o, a, l = [0, 0, 0], u = [0, 0, 0], c = [0, 0, 0], h = [0, 0, 0], d = [0, 0, 0], f = [null, null, null], p = [null, null, null], m = this.mesh.vHead; e = m.next; for (var g = 0; g < 3; ++g)s = e.coords[g], u[g] = s, p[g] = e, l[g] = s, f[g] = e; for (e = m.next; e !== m; e = e.next)for (var y = 0; y < 3; ++y)s = e.coords[y], s < u[y] && (u[y] = s, p[y] = e), s > l[y] && (l[y] = s, f[y] = e); var v = 0; if (l[1] - u[1] > l[0] - u[0] && (v = 1), l[2] - u[2] > l[v] - u[v] && (v = 2), u[v] >= l[v]) { t[0] = 0, t[1] = 0, t[2] = 1; return } for (a = 0, n = p[v], r = f[v], c[0] = n.coords[0] - r.coords[0], c[1] = n.coords[1] - r.coords[1], c[2] = n.coords[2] - r.coords[2], e = m.next; e !== m; e = e.next)h[0] = e.coords[0] - r.coords[0], h[1] = e.coords[1] - r.coords[1], h[2] = e.coords[2] - r.coords[2], d[0] = c[1] * h[2] - c[2] * h[1], d[1] = c[2] * h[0] - c[0] * h[2], d[2] = c[0] * h[1] - c[1] * h[0], o = d[0] * d[0] + d[1] * d[1] + d[2] * d[2], o > a && (a = o, t[0] = d[0], t[1] = d[1], t[2] = d[2]); a <= 0 && (t[0] = t[1] = t[2] = 0, t[this.longAxis_(c)] = 1) }, i.prototype.checkOrientation_ = function () { for (var t = this.mesh.fHead, e, n = this.mesh.vHead, r, s = 0, o = t.next; o !== t; o = o.next)if (r = o.anEdge, !(r.winding <= 0)) do s += (r.Org.s - r.Dst.s) * (r.Org.t + r.Dst.t), r = r.Lnext; while (r !== o.anEdge); if (s < 0) { for (e = n.next; e !== n; e = e.next)e.t = -e.t; this.tUnit[0] = -this.tUnit[0], this.tUnit[1] = -this.tUnit[1], this.tUnit[2] = -this.tUnit[2] } }, i.prototype.projectPolygon_ = function () { var t = this.mesh.vHead, e = [0, 0, 0], n, r, s = !1; e[0] = this.normal[0], e[1] = this.normal[1], e[2] = this.normal[2], !e[0] && !e[1] && !e[2] && (this.computeNormal_(e), s = !0), n = this.sUnit, r = this.tUnit; var o = this.longAxis_(e); n[o] = 0, n[(o + 1) % 3] = 1, n[(o + 2) % 3] = 0, r[o] = 0, r[(o + 1) % 3] = 0, r[(o + 2) % 3] = e[o] > 0 ? 1 : -1; for (var a = t.next; a !== t; a = a.next)a.s = this.dot_(a.coords, n), a.t = this.dot_(a.coords, r); s && this.checkOrientation_(); for (var l = !0, u = t.next; u !== t; u = u.next)l ? (this.bmin[0] = this.bmax[0] = u.s, this.bmin[1] = this.bmax[1] = u.t, l = !1) : (u.s < this.bmin[0] && (this.bmin[0] = u.s), u.s > this.bmax[0] && (this.bmax[0] = u.s), u.t < this.bmin[1] && (this.bmin[1] = u.t), u.t > this.bmax[1] && (this.bmax[1] = u.t)) }, i.prototype.addWinding_ = function (t, e) { t.winding += e.winding, t.Sym.winding += e.Sym.winding }, i.prototype.tessellateMonoRegion_ = function (t, e) { var n, r; if (n = e.anEdge, !(n.Lnext !== n && n.Lnext.Lnext !== n)) throw "Mono region invalid"; for (; Qe.vertLeq(n.Dst, n.Org); n = n.Lprev); for (; Qe.vertLeq(n.Org, n.Dst); n = n.Lnext); r = n.Lprev; for (var s = void 0; n.Lnext !== r;)if (Qe.vertLeq(n.Dst, r.Org)) { for (; r.Lnext !== n && (Qe.edgeGoesLeft(r.Lnext) || Qe.edgeSign(r.Org, r.Dst, r.Lnext.Dst) <= 0);)s = t.connect(r.Lnext, r), r = s.Sym; r = r.Lprev } else { for (; r.Lnext !== n && (Qe.edgeGoesRight(n.Lprev) || Qe.edgeSign(n.Dst, n.Org, n.Lprev.Org) >= 0);)s = t.connect(n, n.Lprev), n = s.Sym; n = n.Lnext } if (r.Lnext === n) throw "Mono region invalid"; for (; r.Lnext.Lnext !== n;)s = t.connect(r.Lnext, r), r = s.Sym; return !0 }, i.prototype.tessellateInterior_ = function (t) { for (var e, n = t.fHead.next; n !== t.fHead; n = e)if (e = n.next, n.inside && !this.tessellateMonoRegion_(t, n)) return !1; return !0 }, i.prototype.discardExterior_ = function (t) { for (var e, n = t.fHead.next; n !== t.fHead; n = e)e = n.next, n.inside || t.zapFace(n) }, i.prototype.setWindingNumber_ = function (t, e, n) { for (var r, s = t.eHead.next; s !== t.eHead; s = r)r = s.next, s.Rface.inside !== s.Lface.inside ? s.winding = s.Lface.inside ? e : -e : n ? t.delete(s) : s.winding = 0 }, i.prototype.getNeighbourFace_ = function (t) { return !t.Rface || !t.Rface.inside ? -1 : t.Rface.n }, i.prototype.outputPolymesh_ = function (t, e, n, r) { var s, o = 0, a = 0, l; n > 3 && t.mergeConvexFaces(n); for (var u = t.vHead.next; u !== t.vHead; u = u.next)u.n = -1; for (var c = t.fHead.next; c !== t.fHead; c = c.next)if (c.n = -1, !!c.inside) { s = c.anEdge, l = 0; do { var u = s.Org; u.n === -1 && (u.n = a, a++), l++, s = s.Lnext } while (s !== c.anEdge); if (l > n) throw "Face vertex greater that support polygon"; c.n = o, ++o } this.elementCount = o, e === ln.CONNECTED_POLYGONS && (o *= 2), this.elements = [], this.elements.length = o * n, this.vertexCount = a, this.vertices = [], this.vertices.length = a * r, this.vertexIndices = [], this.vertexIndices.length = a; for (var u = t.vHead.next; u !== t.vHead; u = u.next)if (u.n !== -1) { var h = u.n * r; this.vertices[h + 0] = u.coords[0], this.vertices[h + 1] = u.coords[1], r > 2 && (this.vertices[h + 2] = u.coords[2]), this.vertexIndices[u.n] = u.idx } for (var d = 0, c = t.fHead.next; c !== t.fHead; c = c.next)if (c.inside) { s = c.anEdge, l = 0; do { var u = s.Org; this.elements[d++] = u.n, l++, s = s.Lnext } while (s !== c.anEdge); for (var f = l; f < n; ++f)this.elements[d++] = -1; if (e === ln.CONNECTED_POLYGONS) { s = c.anEdge; do this.elements[d++] = this.getNeighbourFace_(s), s = s.Lnext; while (s !== c.anEdge); for (var p = l; p < n; ++p)this.elements[d++] = -1 } } }, i.prototype.outputContours_ = function (t, e) { var n, r, s = 0, o = 0; this.vertexCount = 0, this.elementCount = 0; for (var a = t.fHead.next; a !== t.fHead; a = a.next)if (a.inside) { r = n = a.anEdge; do this.vertexCount++, n = n.Lnext; while (n !== r); this.elementCount++ } this.elements = [], this.elements.length = this.elementCount * 2, this.vertices = [], this.vertices.length = this.vertexCount * e, this.vertexIndices = [], this.vertexIndices.length = this.vertexCount; var l = 0, u = 0, c = 0; s = 0; for (var a = t.fHead.next; a !== t.fHead; a = a.next)if (a.inside) { o = 0, r = n = a.anEdge; do this.vertices[l++] = n.Org.coords[0], this.vertices[l++] = n.Org.coords[1], e > 2 && (this.vertices[l++] = n.Org.coords[2]), this.vertexIndices[u++] = this.vertexIdCallback ? this.vertexIdCallback(n) : n.Org.idx, o++, n = n.Lnext; while (n !== r); this.elements[c++] = s, this.elements[c++] = o, s += o } }, i.prototype.addContour = function (t, e) { this.mesh === null && (this.mesh = new DP), t < 2 && (t = 2), t > 3 && (t = 3); for (var n = null, r = 0; r < e.length; r += t)n === null ? (n = this.mesh.makeEdge(), this.mesh.splice(n, n.Sym)) : (this.mesh.splitEdge(n), n = n.Lnext), n.Org.coords[0] = e[r + 0], n.Org.coords[1] = e[r + 1], t > 2 ? n.Org.coords[2] = e[r + 2] : n.Org.coords[2] = 0, n.Org.idx = this.vertexIndexCounter++, this.edgeCreateCallback && this.edgeCreateCallback(n), n.winding = 1, n.Sym.winding = -1 }, i.prototype.tesselate = function (t, e, n, r, s, o) { if (t === void 0 && (t = yt.ODD), e === void 0 && (e = ln.POLYGONS), o === void 0 && (o = !0), this.vertices = [], this.elements = [], this.vertexIndices = [], this.vertexIndexCounter = 0, s && (this.normal[0] = s[0], this.normal[1] = s[1], this.normal[2] = s[2]), this.windingRule = t, r < 2 && (r = 2), r > 3 && (r = 3), !this.mesh) return !1; this.projectPolygon_(), rW.computeInterior(this, o); var a = this.mesh; return e === ln.BOUNDARY_CONTOURS ? this.setWindingNumber_(a, 1, !0) : this.tessellateInterior_(a), o && a.check(), e === ln.BOUNDARY_CONTOURS ? this.outputContours_(a, r) : this.outputPolymesh_(a, e, n, r), !0 }, i }(); function ns (i) { var t = i.windingRule, e = t === void 0 ? yt.ODD : t, n = i.elementType, r = n === void 0 ? ln.POLYGONS : n, s = i.polySize, o = s === void 0 ? 3 : s, a = i.vertexSize, l = a === void 0 ? 2 : a, u = i.normal, c = u === void 0 ? [0, 0, 1] : u, h = i.contours, d = h === void 0 ? [] : h, f = i.strict, p = f === void 0 ? !0 : f, m = i.debug, g = m === void 0 ? !1 : m; if (!d && p) throw new Error("Contours can't be empty"); if (d) { var y = new iW; i.edgeCreateCallback && (y.edgeCreateCallback = i.edgeCreateCallback), i.vertexIdCallback && (y.vertexIdCallback = i.vertexIdCallback); for (var v = 0; v < d.length; v++)y.addContour(l || 2, d[v]); return y.tesselate(e, r, o, l, c, p), { vertices: y.vertices, vertexIndices: y.vertexIndices, vertexCount: y.vertexCount, elements: y.elements, elementCount: y.elementCount, mesh: g ? y.mesh : void 0 } } } var wce = yt.ODD, Sce = yt.NONZERO, Ace = yt.POSITIVE, _ce = yt.NEGATIVE, Ece = yt.ABS_GEQ_TWO, Mce = ln.POLYGONS, Tce = ln.CONNECTED_POLYGONS, Cce = ln.BOUNDARY_CONTOURS; var _y = class { constructor(t = 256, e = !1) { this.capacity = t, this.size = 0, this.debug = e, this.debug && console.log(`allocating with cap ${t}`); let n = t * _y.eSize; this.buffer = new ArrayBuffer(n); let r = Float32Array.BYTES_PER_ELEMENT, s = 0; this.positions = new Float32Array(this.buffer, s * r, 3 * t), s += 3 * t, this.normals = new Float32Array(this.buffer, s * r, 3 * t), s += 3 * t, this.uvs = new Float32Array(this.buffer, s * r, 2 * t) } realloc (t, e = !1) { if (t < this.size) throw Error("cannot shrink buffer"); if (t <= this.capacity && !e) return; this.debug && console.log(`resizing from ${this.capacity} \u2192 ${t}`); let n = t * _y.eSize, r = new ArrayBuffer(n), s = Float32Array.BYTES_PER_ELEMENT, o = 0, a = new Float32Array(r, o * s, 3 * t); o += 3 * t; let l = new Float32Array(r, o * s, 3 * t); o += 3 * t; let u = new Float32Array(r, o * s, 2 * t); e ? (a.set(this.positions.subarray(0, this.size * 3)), l.set(this.normals.subarray(0, this.size * 3)), u.set(this.uvs.subarray(0, this.size * 2))) : (a.set(this.positions), l.set(this.normals), u.set(this.uvs)), this.buffer = r, this.positions = a, this.normals = l, this.uvs = u, this.capacity = t } get (t = 1) { let e = this.size + t; if (e > this.capacity) { let r = this.capacity; for (; e > r;)r *= 2; this.realloc(r) } let n = this.size; return this.size = e, n } reserve (t) { let e = this.size + t; e > this.capacity && this.realloc(e) } shrink () { this.debug && console.log(`shrinking ${this.capacity} \u2192 ${this.size}`), this.realloc(this.size, !0) } }, Ff = _y; Ff.eSize = (3 + 3 + 2) * Float32Array.BYTES_PER_ELEMENT; var kP = sc(FP()), kf = { vertices: [160, 160, -160, 160, -160, -160, 160, -160], vertexIndices: [1, 0, 3, 2], vertexCount: 4, elements: [0, 4], elementCount: 1, mesh: void 0 }, kw = { vertices: [], vertexIndices: [], vertexCount: 0, elements: [], elementCount: 0, mesh: void 0 }, Uw = { vertices: [-160, 160, 160, -160, 160, 160, -160, -160], vertexIndices: [1, 3, 0, 2], vertexCount: 4, elements: [0, 1, 2, 1, 0, 3], elementCount: 2, mesh: void 0 }, Fw = (i, t) => ([e, n]) => (n < e && (n += t), (i >= e ? i : i + t) <= n), Ba = class extends Ce { constructor(e, n, r = 0, s = 12, o = 3, a = yt.ODD, l = !1) { super(); this.forPathBevel = l; this.type = "ShapeGeometry"; this.vertexCache = {}; this._shape = e, this._depth = n, this._curveSegments = s, this._bevelSegmentsInput = o; let u = this._shape.extractShapePointsToFlatArray([], s), c = this._shape.shapeHoles.map(I => { let C = I.extractShapePointsToFlatArray([], s), P = []; for (let D = C.length - 1; D >= 1; D -= 2) { let L = C[D - 1], H = C[D - 0]; P.push(L, H) } return P }), h = [], d = []; for (let I = 0; I < u.length; I += 2)d.push([u[I], u[I + 1]]); h.push(d); for (let I = 0; I < c.length; I++) { let C = c[I], P = []; for (let D = 0; D < C.length; D += 2)P.push([C[D], C[D + 1]]); h.push(P) } let f = h[0].length ? (0, kP.default)(h).distance : r; r <= 0 ? (this._bevel = 0, this._bevelSegments = 0) : (this._bevel = Math.min(r, f, n / 2), this._bevelSegments = Math.floor(o)); let p; try { p = ns({ windingRule: a, elementType: ln.BOUNDARY_CONTOURS, vertexSize: 2, strict: !0, contours: [u] }) } catch { p = kf } let m; try { m = ns({ windingRule: yt.ODD, elementType: ln.BOUNDARY_CONTOURS, vertexSize: 2, strict: !0, contours: [...c] }) } catch { m = kw } if (!p) throw new Error("error generating geometry"); let g = p.elementCount; if (m) { p.elementCount += m.elementCount; for (let I = 0; I < m.elements.length; I++) { let C = m.elements[I], P = I % 2 === 0 ? p.vertexCount : 0; p.elements.push(C + P) } for (let I = 0; I < m.vertexIndices.length; I++) { let C = m.vertexIndices[I], P = p.vertexCount; p.vertexIndices.push(C + P) } for (let I = 0; I < m.vertices.length; I++) { let C = m.vertices[I]; p.vertices.push(C) } } let y = 1 / 0, v = -1 / 0, x = 1 / 0, b = -1 / 0; for (let I = 0, C = p.vertexCount; I < C; I++) { let P = I * 2, D = p.vertices[P + 0], L = p.vertices[P + 1]; D < y && (y = D), D > v && (v = D), L < x && (x = L), L > b && (b = L) } this._minX = y, this._minY = x, this._width = v - y, this._height = b - x, this._buffer = new Ff(this._computeBufferEstimatedSize(p)); let S = [], _ = []; for (let I = p.elementCount - 1; I >= 0; I--) { let C = I >= g, P = I * 2, D = p.elements[P + 0], L = p.elements[P + 1], H = D + L, U = { start: D, count: L, normals: [], continuous: [], concave: [] }, V = D, G = H - 1, z = D + 1, $ = this._shape.roundedCurves.length; do { let k = V - D, Z = p.vertices[G * 2 + 0], K = p.vertices[G * 2 + 1], Q = p.vertices[V * 2 + 0], W = p.vertices[V * 2 + 1], ge = p.vertices[z * 2 + 0], de = p.vertices[z * 2 + 1], ie = Q - Z, be = W - K, ve = Math.sqrt(ie * ie + be * be); ie /= ve, be /= ve; let Ie = Q - ge, Pe = W - de, Me = Math.sqrt(Ie * Ie + Pe * Pe); Ie /= Me, Pe /= Me, U.normals[k * 2 + 0] = -Pe, U.normals[k * 2 + 1] = Ie, U.concave[k] = ie * Pe - be * Ie > 0; let Se = p.vertexIndices[V]; if (Array.isArray(Se)) U.continuous[k] = !1; else { let [Fe, ke] = this._shape.getCurveIndexFromVertexId(Se - 1, !0); if (ke > 0 && ke < 1) U.continuous[k] = !0; else { let R = ke === 1 ? Fe + 1 : Fe - 1; R = (R + $) % $; let O = ke === 1 ? 0 : 1, ne = this._shape.roundedCurves[Fe].getTangent(ke), ce = this._shape.roundedCurves[R].getTangent(O); U.continuous[k] = ne.dot(ce) > .95 } } C && (U.normals[k * 2 + 0] *= -1, U.normals[k * 2 + 1] *= -1), [G, V, z] = [V, z, z + 1], z >= H && (z -= L) } while (z !== D + 1); let F = []; F.push({ bevelI: 0, angle: 0, size: 0, boundary: { vertices: p.vertices.slice(D * 2, H * 2), vertexCount: L, vertexIndices: new Array(L).fill(!0).map((k, Z) => [Z, Z]), elements: [0, L], elementCount: 1, mesh: null }, reverseMap: [], insetPoints: p.vertices.slice(D * 2, H * 2) }); let j = 0; for (let k = 1; k <= this._bevelSegments; k++) { let Z = k / this._bevelSegments * Math.PI / 2, K = (1 - Math.cos(Z)) * this._bevel, Q = [], W = [], ge = [], de = [], ie = 0; for (let ve = 0; ve < L; ve++) { let Ie = ve * 2, Pe = (ve - 1 + L) % L * 2, Me = p.vertices[U.start * 2 + Ie + 0], Se = p.vertices[U.start * 2 + Ie + 1], Fe = -U.normals[Pe + 0] * K, ke = -U.normals[Pe + 1] * K, R = -U.normals[Ie + 0] * K, O = -U.normals[Ie + 1] * K; if (U.concave[ve] || !U.concave[ve] && C) { let ne = Math.atan2(ke, Fe), ce = Math.atan2(O, R); ce > ne && (ce -= Math.PI * 2); let pe = ce - ne; if (U.continuous[ve] || C) { let Te = ne + pe / 2, Ae = Math.cos(Te) * K, we = Math.sin(Te) * K; Q[2 * ie + 0] = Me + Ae * (C ? -1 : 1), Q[2 * ie + 1] = Se + we * (C ? -1 : 1), de[ie] = ve, ie++ } else { let Te = Math.max(1, Math.floor(s / 4 * Math.abs(pe) / Math.PI)); for (let Ae = 0; Ae <= Te; Ae++) { let we = ne + pe * (Ae / Te), ae = Math.cos(we) * K, Xe = Math.sin(we) * K; Q[2 * ie + 0] = Me + ae, Q[2 * ie + 1] = Se + Xe, de[ie] = ve, ie++ } } } else Q[2 * ie + 0] = Me + Fe, Q[2 * ie + 1] = Se + ke, de[ie] = ve, W[ve] = ie, ie++, Q[2 * ie + 0] = Me, Q[2 * ie + 1] = Se, de[ie] = ve, ie++, Q[2 * ie + 0] = Me + R, Q[2 * ie + 1] = Se + O, de[ie] = ve, ge[ve] = ie, ie++ } let be = ns({ windingRule: yt.POSITIVE, elementType: ln.BOUNDARY_CONTOURS, vertexSize: 2, strict: !0, contours: [Q], edgeCreateCallback: ve => { let Pe = ve.Org.idx, Me = de[Pe], Se = de[(Pe + 1) % de.length]; ve.idx = [Me, Se], ve.Sym.idx = [Se, Me] }, vertexIdCallback: ve => { let Ie = ve.Lprev.idx; return [Ie ? Ie[1] : 0, ve.idx ? ve.idx[0] : 0] } }); if (!be) throw console.log("Error"), new Error(`error generating bevel geometry for ${k}'th loop`); if (!be.vertexCount) { let ve = (k - 1) / this._bevelSegments * Math.PI / 2; j = (1 - Math.sin(ve)) * this._bevel; break } for (let ve = 0; ve < be.vertexIndices.length; ve++) { let [Ie, Pe] = be.vertexIndices[ve]; if (Ie === Pe) continue; let Me = Pe; Pe < Ie && (Me += L); for (let Se = Ie; Se < Me; Se++) { let Fe = Se % L, ke = (Se + 1) % L; if (!U.continuous[Fe] || !U.continuous[ke]) { be.vertexIndices[ve] = [Ie, Fe], be.vertexIndices.splice(ve + 1, 0, [ke, Pe]), be.vertices.splice((ve + 1) * 2, 0, be.vertices[ve * 2], be.vertices[ve * 2 + 1]); break } } } F.push({ bevelI: k, angle: Z, size: K, boundary: be, reverseMap: de, insetPoints: Q }) } let X = (k, Z, K) => { let Q = 0, W = k.boundary.vertexIndices.length; for (; Q < W && K(k.boundary.vertexIndices[Z]);)Z = (Z + 1) % W, Q++; return Q }, q = S.length; for (let k = 1; k < F.length; k++) { let Z = F[k - 1], K = F[k], Q = Z.boundary.vertexIndices.length, W = K.boundary.vertexIndices.length; if (!Q || !W) break; let ge = U.concave.length, de = 0, ie = Fw(de, L); for (; !Z.boundary.vertexIndices.filter(ie).length || !K.boundary.vertexIndices.filter(ie).length;)de++, ie = Fw(de, L); let be = Z.boundary.vertexIndices.findIndex(ie), ve = K.boundary.vertexIndices.findIndex(ie); do be = (be + 1) % Q; while (ie(Z.boundary.vertexIndices[be])); do ve = (ve + 1) % W; while (ie(K.boundary.vertexIndices[ve])); de = (de + 1) % L; let Ie = de, Pe = 0, Me = this._buildBevelVert(U, Z, (be - 1 + Q) % Q, void 0, Pe), Se = this._buildBevelVert(U, K, (ve - 1 + W) % W, void 0, Pe), Fe = Me, ke = Se, R, O, ne = !1; do { Pe = (de || ge) / ge, ie = Fw(de, L); let ce = X(Z, be, ie), pe = X(K, ve, ie), Te = ne; if (ne = !1, ce && !pe) { for (let Ae = 0; Ae < ce; Ae++)R = this._buildBevelVert(U, Z, (be + Ae) % Q, Ae / (ce - 1), Pe), S.push(Fe.topN, R.topP, ke.topN), l === !1 && S.push(R.bottomP, Fe.bottomN, ke.bottomN), Fe = R; ne = !0 } else if (!ce && pe) for (let Ae = 0; Ae < pe; Ae++)O = this._buildBevelVert(U, K, (ve + Ae) % W, Ae / (pe - 1), Pe), S.push(ke.topN, Fe.topP, O.topP), l === !1 && S.push(Fe.bottomP, ke.bottomN, O.bottomP), ke = O; else if (ce && pe) if (R = this._buildBevelVert(U, Z, be, 0, Pe), O = this._buildBevelVert(U, K, ve, 0, Pe), Te ? (S.push(Fe.topN, O.topP, ke.topN), S.push(Fe.topN, R.topP, O.topP), l === !1 && (S.push(O.bottomP, Fe.bottomN, ke.bottomN), S.push(O.bottomP, R.bottomP, Fe.bottomN))) : (S.push(ke.topN, Fe.topN, R.topP), S.push(ke.topN, R.topP, O.topP), l === !1 && (S.push(R.bottomP, Fe.bottomN, ke.bottomN), S.push(R.bottomP, ke.bottomN, O.bottomP))), Fe = R, ke = O, ce === pe) for (let Ae = 1; Ae < ce; Ae++)R = this._buildBevelVert(U, Z, (be + Ae) % Q, Ae / (ce - 1), Pe), O = this._buildBevelVert(U, K, (ve + Ae) % W, Ae / (pe - 1), Pe), S.push(Fe.topN, R.topP, ke.topN), S.push(ke.topN, R.topP, O.topP), l === !1 && (S.push(R.bottomP, Fe.bottomN, ke.bottomN), S.push(R.bottomP, ke.bottomN, O.bottomP)), Fe = R, ke = O; else if (ce > pe) { let Ae = ce / pe, we = 0; for (let ae = 1; ae < ce; ae++)R = this._buildBevelVert(U, Z, (be + ae) % Q, ae / (ce - 1), Pe), S.push(Fe.topN, R.topP, ke.topN), l === !1 && S.push(R.bottomP, Fe.bottomN, ke.bottomN), Fe = R, ae > (we + 1) * Ae && (we++, O = this._buildBevelVert(U, K, (ve + we) % W, we / (pe - 1), Pe), S.push(ke.topN, R.topP, O.topP), l === !1 && S.push(R.bottomP, ke.bottomN, O.bottomP), ke = O) } else { let Ae = pe / ce, we = 0; for (let ae = 1; ae < pe; ae++)O = this._buildBevelVert(U, K, (ve + ae) % W, ae / (pe - 1), Pe), S.push(ke.topN, R.topP, O.topP), l === !1 && S.push(R.bottomP, ke.bottomN, O.bottomP), ke = O, ae > (we + 1) * Ae && (we++, R = this._buildBevelVert(U, Z, (be + we) % Q, we / (ce - 1), Pe), S.push(Fe.topN, R.topP, ke.topN), l === !1 && S.push(R.bottomP, Fe.bottomN, ke.bottomN), Fe = R) } be = (be + ce) % Q, ve = (ve + pe) % W, de = (de + 1) % ge } while (de !== Ie) } if (l === !1 && this._depth > this._bevel * 2 && this._buildWall(F, U, S), C) { let k = []; for (let Z = S.length - 1; Z >= q + 2; Z -= 3) { let K = S[Z - 2], Q = S[Z - 1], W = S[Z - 0]; k.push(W, Q, K) } S.splice(q, S.length - q, ...k) } if (C) { let k = []; for (let Z = F[F.length - 1].boundary.vertices.length - 1; Z >= 1; Z -= 2) { let K = F[F.length - 1].boundary.vertices[Z - 1], Q = F[F.length - 1].boundary.vertices[Z - 0]; k.push(K, Q) } _.push(k) } if (!C) { let k = F[F.length - 1], Z; try { Z = ns({ windingRule: F.length > 1 ? yt.POSITIVE : yt.ODD, elementType: ln.POLYGONS, vertexSize: 2, strict: !0, contours: [k.insetPoints, ..._] }) } catch { Z = Uw } if (!Z) throw new Error("Error generating geometry for surface"); c.length === 0 && this._bevel < f && Object.assign(this, { useNgonForTopBottomFaceDuringBake: !0 }); for (let K = 0; K < Z.elementCount * 3; K += 3) { let Q = this._buildSurfaceVert(Z, Z.elements[K + 0], j), W = this._buildSurfaceVert(Z, Z.elements[K + 1], j), ge = this._buildSurfaceVert(Z, Z.elements[K + 2], j); S.push(Q.top, W.top, ge.top), l === !1 && S.push(ge.bottom, W.bottom, Q.bottom) } } this.vertexCache = {} } this._buffer.shrink(); let E = new ze(Uint32Array.from(S), 1), w = new ze(this._buffer.positions, 3), M = new ze(this._buffer.normals, 3), T = new ze(this._buffer.uvs, 2); w.needsUpdate = !0, M.needsUpdate = !0, T.needsUpdate = !0, E.needsUpdate = !0, this.setAttribute("position", w), this.setAttribute("normal", M), this.setAttribute("uv", T), this.setIndex(E) } _computeBufferEstimatedSize (e) { return e.vertexCount * 2 * (2 + this._bevelSegments) } _buildWall (e, n, r) { let s = e[0]; for (let o = 0, a = s.boundary.vertexCount; o < a; o++) { let l = this._buildBevelVert(n, s, o), u = this._buildBevelVert(n, s, (o + 1) % a); r.push(u.topP, l.topN, l.bottomN), r.push(u.topP, l.bottomN, u.bottomP) } } _buildSurfaceVert (e, n, r) { let s = n.toString(); if (s in this.vertexCache) return this.vertexCache[s]; let o = e.vertices[n * 2 + 0], a = e.vertices[n * 2 + 1], l = (o - this._minX) / this._width, u = (a - this._minY) / this._height; this.forPathBevel && (u = 1); let c = this._buffer.get(this.forPathBevel ? 1 : 2), h = c * 3, d = c * 2, f = { top: c + 0, bottom: c + 1 }; return this._buffer.positions[h + 0] = o, this._buffer.positions[h + 1] = a, this._buffer.positions[h + 2] = this.forPathBevel ? this._bevel : this._depth - r, this._buffer.normals[h + 0] = 0, this._buffer.normals[h + 1] = 0, this._buffer.normals[h + 2] = 1, this._buffer.uvs[d + 0] = l, this._buffer.uvs[d + 1] = u, this.forPathBevel === !1 && (this._buffer.positions[h + 3] = o, this._buffer.positions[h + 4] = a, this._buffer.positions[h + 5] = r, this._buffer.normals[h + 3] = 0, this._buffer.normals[h + 4] = 0, this._buffer.normals[h + 5] = -1, this._buffer.uvs[d + 2] = l, this._buffer.uvs[d + 3] = u), this.vertexCache[s] = f, f } _buildBevelVert (e, n, r, s = 1, o) { let a = `${n.bevelI}:${r}`; if (a in this.vertexCache && o !== 0 && o !== 1 && (!o || o === this.vertexCache[a].pathBevelUCoord)) return this.vertexCache[a]; let [l, u] = n.boundary.vertexIndices[r], c, h, d, f; l !== u ? (h = l, c = u, f = !1, d = e.continuous[h] && e.continuous[c]) : (c = l, h = (c - 1 + e.count) % e.count, f = e.concave[c] && n.bevelI > 0, d = e.continuous[c] || f); let p = Math.cos(n.angle), m = Math.sin(n.angle), g = r * 2, y = c * 2, v = h * 2, x = n.boundary.vertices[g + 0], b = n.boundary.vertices[g + 1], S = (1 - m) * this._bevel, _ = (x - this._minX) / this._width, E = (b - this._minY) / this._height; this.forPathBevel && (o !== void 0 && (_ = o), E = 1); let w = e.normals[y + 0], M = e.normals[y + 1], T = e.normals[v + 0], I = e.normals[v + 1]; if (f) { let H = T - w, U = I - M; w = w + H * (1 - s), M = M + U * (1 - s); let V = Math.sqrt(w * w + M * M); w /= V, M /= V } let C = this.forPathBevel ? this._buffer.get(d ? 1 : 2) : this._buffer.get(d ? 2 : 4), P = C * 3, D = C * 2, L = { i: r, fi: c, topP: C + 0, topN: C + 0, bottomP: C + 1, bottomN: C + 1, pathBevelUCoord: o }; return this._buffer.positions[P + 0] = x, this._buffer.positions[P + 1] = b, this._buffer.positions[P + 2] = (this.forPathBevel ? this._bevel : this._depth) - S, this._buffer.normals[P + 0] = w * p, this._buffer.normals[P + 1] = M * p, this._buffer.normals[P + 2] = m, this._buffer.uvs[D + 0] = _, this._buffer.uvs[D + 1] = E, this.forPathBevel === !1 && (this._buffer.positions[P + 3] = x, this._buffer.positions[P + 4] = b, this._buffer.positions[P + 5] = S, this._buffer.normals[P + 3] = w * p, this._buffer.normals[P + 4] = M * p, this._buffer.normals[P + 5] = -m, this._buffer.uvs[D + 2] = E, this._buffer.uvs[D + 3] = _), d || (this.forPathBevel ? (C += 1, P += 3, D += 2) : (C += 2, P += 6, D += 4), L.topP = C + 0, L.bottomP = C + 1, this._buffer.positions[P + 0] = x, this._buffer.positions[P + 1] = b, this._buffer.positions[P + 2] = (this.forPathBevel ? this._bevel : this._depth) - S, this._buffer.normals[P + 0] = T * p, this._buffer.normals[P + 1] = I * p, this._buffer.normals[P + 2] = m, this._buffer.uvs[D + 0] = _, this._buffer.uvs[D + 1] = E, this.forPathBevel === !1 && (this._buffer.positions[P + 3] = x, this._buffer.positions[P + 4] = b, this._buffer.positions[P + 5] = S, this._buffer.normals[P + 3] = T * p, this._buffer.normals[P + 4] = I * p, this._buffer.normals[P + 5] = -m, this._buffer.uvs[D + 2] = E, this._buffer.uvs[D + 3] = _)), this.vertexCache[a] = L, L } clone () { let e = new Ba(this._shape, this._depth, this._bevel, this._curveSegments, this._bevelSegmentsInput); return e.userData = Ao(this.userData), e } }; var ch = class extends Ce { constructor(e, n = 12, r = {}) { super(); this.type = "ShapeGeometry"; this.windingRule = yt.ODD; this.elementType = ln.POLYGONS; this.polySize = 3; this.vertexSize = 2; this.strict = !0; this._shape = e, this._curveSegments = n, this._triangulationOptions = Object.assign({ windingRule: yt.ODD, elementType: ln.POLYGONS, polySize: 3, vertexSize: 2, strict: !0 }, r); let s = this._shape.extractShapePointsToFlatArray([], this._curveSegments), o = this._shape.shapeHoles.map(p => p.extractShapePointsToFlatArray([], this._curveSegments)), a, l = !0, u = !0, c, h; for (let p = 0, m = s.length / 2; p < m; p++) { let g = p * 2, y = s[g + 0], v = s[g + 1]; if (c !== void 0 && y !== c && (l = !1), h !== void 0 && v !== h && (u = !1), c = y, h = v, !l && !u) break } if (!l && !u) try { a = ns({ contours: [s, ...o], windingRule: this._triangulationOptions.windingRule, elementType: this._triangulationOptions.elementType, polySize: this._triangulationOptions.polySize, vertexSize: this._triangulationOptions.vertexSize, strict: this._triangulationOptions.strict }) } catch { a = kf } let d = a?.vertexCount ?? 1, f = a?.elementCount ?? 1; if (this._positionAttribute = new ze(new Float32Array(d * 3), 3), this._normalAttribute = new ze(new Float32Array(d * 3), 3), this._uvAttribute = new ze(new Float32Array(d * 2), 2), this._indexAttribute = new ze(new Uint32Array(f * 3), 1), a) { let p = 1 / 0, m = -1 / 0, g = 1 / 0, y = -1 / 0; for (let b = 0, S = d; b < S; b++) { let _ = b * 2, E = a.vertices[_ + 0], w = a.vertices[_ + 1]; E < p && (p = E), E > m && (m = E), w < g && (g = w), w > y && (y = w) } let v = m - p, x = y - g; for (let b = 0, S = d; b < S; b++) { let _ = b * 2, E = a.vertices[_ + 0], w = a.vertices[_ + 1], M = (E - p) / v, T = (w - g) / x; this._positionAttribute.setXYZ(b, E, w, 0), this._normalAttribute.setXYZ(b, 0, 0, 1), this._uvAttribute.setXY(b, M, T) } for (let b = 0, S = f; b < S; b++) { let _ = b * 3, E = a.elements[_ + 0], w = a.elements[_ + 1], M = a.elements[_ + 2]; this._indexAttribute.setX(_ + 0, E), this._indexAttribute.setX(_ + 1, w), this._indexAttribute.setX(_ + 2, M) } } this.setAttribute("position", this._positionAttribute), this.setAttribute("normal", this._normalAttribute), this.setAttribute("uv", this._uvAttribute), this.setIndex(this._indexAttribute), this.setDrawRange(0, (a?.elementCount ?? 1) * 3) } clone () { let e = new ch(this._shape, this._curveSegments); return e.userData = Ao(this.userData), e } }; var uh = class extends Ba { constructor(e, n, r = 0, s = 12, o = 3, a = yt.ODD) { super(e, n, r, s, o, a); this.type = "ShapeGeometry" } _computeBufferEstimatedSize (e) { return e.vertexCount * 2 * (2 + this._bevelSegments) } _buildWall (e, n, r) { let s = e[0]; for (let o = 0, a = s.boundary.vertexCount; o < a; o++) { let l = this._buildBevelVert(n, s, o), u = this._buildBevelVert(n, s, (o + 1) % a); r.push(u.topP, l.topN, l.bottomN), r.push(u.topP, l.bottomN, u.bottomP) } } clone () { let e = new uh(this._shape, this._depth, this._bevel, this._curveSegments, this._bevelSegmentsInput); return e.userData = Ao(this.userData), e } }; var Kr = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, subdivisions: 40, roundness: 0, extrudeBevelSize: 0, extrudeBevelSegments: 3, windingRule: yt.ODD }, i.parameters), n = Math.abs(e.width), r = Math.abs(e.height ?? e.width), s = Math.abs(e.depth ?? 0), o = i.shape ?? t?.shape, a = o?.roundness ?? e.roundness; o !== void 0 && (o instanceof Mt ? (o.width !== n || o.height !== r) && o.applySize(n, r) : o = new Mt(n, r).fromJSON(o), i.parameters?.roundness !== void 0 && i.parameters?.roundness > 0 && o.update()); let l = o ?? new Mt(n, r); return { parameters: Object.assign(e, { width: n, height: r, depth: s, roundness: a }), shape: l } } static build (i) { let { depth: t, extrudeBevelSize: e, extrudeBevelSegments: n, subdivisions: r, roundness: s, windingRule: o } = i.parameters; i.shape.roundness = s; let a; return t <= 0 ? a = new ch(i.shape, r, { windingRule: o }) : a = new uh(i.shape, t, e, r, n, o), Object.assign(a, { userData: { ...i, type: "VectorGeometry" } }) } }; var zP = Math.PI * 2, dh = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, depth: 0, spikes: 64, angle: 360, innerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, i.parameters); return { shape: i.shape && i.shape instanceof Mt ? i.shape : new Mt, parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) } } static build (i) { let { width: t, height: e, spikes: n, angle: r, innerRadius: s, depth: o, extrudeBevelSize: a, extrudeBevelSegments: l } = i.parameters, u = i.shape, c = t * .5, h = e * .5, d = cW(u, c, h, r * Math.PI / 180, n, s); u.isClosed = !0, u.update(); let f = Kr.create({ shape: u, parameters: { subdivisions: d, depth: o, extrudeBevelSize: a, extrudeBevelSegments: l } }); return Object.assign(f, { userData: { ...i, type: "EllipseGeometry" } }) } }; function cW (i, t, e, n, r, s) { if (n >= zP) return r > 30 || r % 4 === 0 ? (hW(i, t, e, s), Math.round(r / 4)) : UP(i, n, r, t, e, s); n = Math.max(n, .001); let o = { x: 0, y: e }, a = n + Math.PI * .5, l = { x: Math.cos(a) * t, y: Math.sin(a) * e }, u = IP({ px: o.x, py: o.y, cx: l.x, cy: l.y, rx: t, ry: e, largeArcFlag: n > Math.PI, sweepFlag: !0 }); return r > 30 || r % u.length === 0 ? uW(i, o.x, o.y, u, r, t, e, s) : UP(i, n, r, t, e, s) } function uW (i, t, e, n, r, s, o, a) { let l = Math.round(r / n.length); i.addPoint(hh(t, e)); for (let u = 0, c = n.length; u < c; u++) { let h = n[u], d = i.points[u], f = hh(h.x, h.y); d.controls[1].position.set(h.x1, h.y1), f.controls[0].position.set(h.x2, h.y2), i.addPoint(f) } return a > 0 ? GP(i, s, o, a) : i.addPoint(hh(0, 0)), l } function UP (i, t, e, n, r, s) { let o = -t / e; for (let a = 0; a <= e; a++) { let l = o * a, u = Math.sin(l) * n, c = Math.cos(l) * r; i.addPoint(hh(u, c)) } return t < zP ? s > 0 ? GP(i, n, r, s) : i.addPoint(hh(0, 0)) : (i.removePoint(i.points[i.points.length - 1]), s > 0 && VP(i, n, r, s)), 1 } function hW (i, t, e, n = 0, r = 0, s = 0) { let o = .5522847498, a = t * o, l = e * o; i.addPoint(My(r - t, s, r - t, s - l, r - t, s + l)), i.addPoint(My(r, s + e, r - a, s + e, r + a, s + e)), i.addPoint(My(r + t, s, r + t, s + l, r + t, s - l)), i.addPoint(My(r, s - e, r + a, s - e, r - a, s - e)), n > 0 && VP(i, t, e, n) } function hh (i, t) { return new ts(Ge.generateUUID(), new B(i, t)) } function My (i, t, e, n, r, s) { let o = hh(i, t); return o.controls[0].position.set(e, n), o.controls[1].position.set(r, s), o } function GP (i, t, e, n) { HP(i, t, e, n).forEach(s => i.addPoint(s)) } function VP (i, t, e, n) { let r = HP(i, t, e, n), s = new Mt; r.forEach(o => s.addPoint(o)), s.isClosed = !0, i.shapeHoles.push(s) } function HP (i, t, e, n) { let r = n * t / 100, s = r * (Math.abs(e) / Math.abs(t)), o = new B(r / t, s / e), a = i.points.map(l => { let u = l.clone(); return u.uuid = Ge.generateUUID(), u }).reverse(); return a.forEach(l => { l.position.multiply(o); let u = l.controls[0].position.clone().multiply(o), c = l.controls[1].position.clone().multiply(o); l.controls[0].position.copy(c), l.controls[1].position.copy(u) }), a } var jP = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, revolutions: 2, segments: 40, pathRadius: 10, pathType: 0, pathSegments: 30, cornerRadius: 30, cornerSegments: 4 }, i.parameters), n = Math.abs(e.width), r = Math.abs(e.height ?? n), s = Math.abs(e.depth ?? n), o = Math.abs(Math.min(n, s)) / 2; return { parameters: Object.assign(e, { width: n, height: r, depth: s, radius: o, segments: Math.round(e.segments), pathSegments: Math.round(e.pathSegments), cornerSegments: Math.round(e.cornerSegments) }) } } static build (i) { let { width: t, height: e, depth: n, radius: r, revolutions: s, segments: o, pathRadius: a, pathType: l, pathSegments: u, cornerRadius: c, cornerSegments: h } = i.parameters, d = new Uf(!1, t, e, n, r, s, o, a, l, u, c, h); return Object.assign(d, { userData: { ...i, type: "HelixGeometry" } }) } }, zw = new xs([0, 0, 0], 1), Uf = class extends Ce { constructor(t = !0, e = 1, n = 1, r = 1, s = 1, o = 1, a = 1, l = 1, u = 1, c = 1, h = 1, d = 1) { if (super(), o === 0) return; let f = t && o === 1; f && (d = 0), h > 100 && (h = 100), h === 0 && (d = 0); let p = () => new A, m = new A, g = p(), y = p(), v = p(), x, b, S, _, E, w, M, T, I = p(), C = p(), P = p(), D = p(), L = p(), H = p(), U = p(), V = p(), G = n - 2 * l + .001, z = G / o, $ = Math.ceil(a * o), F = $ + 1, j = G / $, X = -G / 2, q = c + 1, k = 2 * Math.PI / c, Z = Math.PI / 2 / d, K = .01, Q = Math.min((1 - h / 100) * l, l - K), W = l - Q, ge = 0, de = 2, ie = d * de + de, be = q * ie / de, ve = be + q * F, Ie = q * (F + ie), [Pe, Me, Se] = [3, 3, 2].map(Ne => Array(Ie * Ne).fill(0)), Fe = [], ke = s - l; function R (Ne, De) { let He = Math.PI / 2; w = De * j, T = 2 * Math.PI * (w % z) / z + He, w += X, M = Math.sin(T) * ke, E = Math.cos(T) * ke, t ? Ne.set(E, M, w) : Ne.set(E, w, M) } R(m, -1e-10), R(g, 0), I.copy(m), R(m, 1); let O = m.distanceTo(g), ne = f ? 0 : W + Q, ce = O * $ + 2 * ne, pe = Q, Te = ce - ne; for (let Ne = 0; Ne <= $; Ne++) { R(y, Ne), V.subVectors(y, I).normalize(), I.copy(y), H.copy(y).setComponent(+t + 1, 0).normalize(), U.crossVectors(V, H).normalize(); let De = Ne === 0, He = Ne === $, Ze = De ? 3 * Math.PI / 2 : Z, xt = De ? pe : Te, qt = De ? q : ve, Cn = De ? 0 : Ie - q, Y = V.clone().multiplyScalar(De ? -W : W).add(y), le = V.clone().multiplyScalar(De ? -1 : 1).normalize(); for (let ye = 0; ye < q; ye++) { let Be = ye * k; if (C.addVectors(m.copy(H).multiplyScalar(l * Math.cos(Be)), g.copy(U).multiplyScalar(l * Math.sin(Be))), P.copy(C).normalize(), De || He) { f || (ge = Cn + ye, [0, 1, 2].forEach(Re => { Pe[ge * 3 + Re] = Y.getComponent(Re), Me[ge * 3 + Re] = le.getComponent(Re) }), Se[ge * 2] = +He, Se[ge * 2 + 1] = ye / c), g.copy(P).multiplyScalar(Q), v.addVectors(y, g); for (let Re = 0; Re < d; Re++) { let bt = Re * Z + Ze; D.addVectors(m.copy(V).multiplyScalar(W * Math.sin(bt)), g.copy(P).multiplyScalar(W * Math.cos(bt))), L.copy(D).normalize(), g.addVectors(v, D), D.normalize(), ge = qt + Re * q + ye, [0, 1, 2].forEach(yn => { Pe[ge * 3 + yn] = g.getComponent(yn), Me[ge * 3 + yn] = L.getComponent(yn) }); let Pn = +De + Math.sin(bt); Se[ge * 2] = (xt + W * Pn) / ce, Se[ge * 2 + 1] = ye / c } } g.addVectors(y, C), ge = be + Ne * q + ye, [0, 1, 2].forEach(Re => { Pe[ge * 3 + Re] = g.getComponent(Re), Me[ge * 3 + Re] = P.getComponent(Re) }), Se[ge * 2] = (ne + Ne * O) / ce, Se[ge * 2 + 1] = ye / c } } let Ae = F + 2 * d + de, we = 1, [ae, Xe] = [+f, Ae - 1]; for (let Ne = ae; Ne <= Xe - 1; Ne++) { let De = f && Ne === Xe - 1; for (let He = 0; He < q - 1; He++)x = Ne * q + He, b = x + 1, S = (De ? He : x) + q, _ = (De ? He + 1 : b) + q, Ne === 0 ? Fe.push(b, _, S) : Ne === Ae - 2 ? Fe.push(x, b, S) : Fe.push(x, b, S, b, _, S) } this.setIndex(Fe), this.setAttribute("position", new _e(Pe, 3)), this.setAttribute("normal", new _e(Me, 3)), this.setAttribute("uv", new _e(Se, 2)) } getClosedTorusIndicesForBooleanOrSubdiv () { let t = this.userData.parameters, e = Math.ceil(t.tubularSegments), n = t.radialSegments + 1, r = Array.from(this.getIndex().array), s, o, a, l, u = 6 * (e - 1) * t.radialSegments, c = e, h = c === e; for (let d = 0; d < t.radialSegments; d++)s = c * n + d, o = s + 1, a = (h ? d : s) + n, l = (h ? d + 1 : o) + n, r[u++] = s, r[u++] = o, r[u++] = a, r[u++] = o, r[u++] = l, r[u++] = a; return r.length = u, zw.array = r, zw.count = r.length, zw } }; var WP = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, detail: 0, corner: 0, cornerSides: 4 }, i.parameters); return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) } } static build (i) { let { width: t, height: e, depth: n, detail: r, corner: s, cornerSides: o } = i.parameters, a = r === 0 && s !== 0 ? new zf(t * .5, s, o) : new Fc(t * .5, r); return a.scale(1, e / t, n / t), Object.assign(a, { userData: { ...i, type: "IcosahedronGeometry" } }) } }, zf = class extends Ra { constructor(t = 1, e = .2, n = 4) { let r = (1 + Math.sqrt(5)) / 2, s = [-1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, 0, 0, -1, r, 0, 1, r, 0, -1, -r, 0, 1, -r, r, 0, -1, r, 0, 1, -r, 0, -1, -r, 0, 1], o = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], a = "IcosahedronGeometry"; super(s, o, a, t, e, n), this.type = a } static fromJSON (t) { return new zf(t.radius, t.corner, t.cornerSides) } }; var qP = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { (i.parameters?.points ?? []).forEach(n => { Array.isArray(n) && (n.x = n[0], n.y = n[1]) }); let e = Object.assign({}, t?.parameters ?? { width: 100, segments: 64, verticalSegments: 64, points: [{ x: 0, y: -50, id: 0 }, { x: 50, y: -50, id: 1 }, { x: 50, y: 50, id: 2 }, { x: 0, y: 50, id: 3 }] }, i.parameters); return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) } } static build (i) { let { points: t, segments: e, verticalSegments: n } = i.parameters, r = new yo; r.moveTo(t[0].x, t[0].y), r.bezierCurveTo(t[1].x, t[1].y, t[2].x, t[2].y, t[3].x, t[3].y); let s = new Oc(r.extractPoints(n).shape, e); return s.rotateZ(Math.PI), Object.assign(s, { userData: { ...i, type: "LatheGeometry" } }) } }; var Ns = new se, Gw = new ft, Ty = new A, Fa = class extends kt { constructor() { super(), this.uuid = Ge.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.elementsNeedUpdate = !1, this.verticesNeedUpdate = !1, this.uvsNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.lineDistancesNeedUpdate = !1, this.groupsNeedUpdate = !1 } applyMatrix4 (t) { let e = new Xt().getNormalMatrix(t); for (let n = 0, r = this.vertices.length; n < r; n++)this.vertices[n].applyMatrix4(t); for (let n = 0, r = this.faces.length; n < r; n++) { let s = this.faces[n]; s.normal.applyMatrix3(e).normalize(); for (let o = 0, a = s.vertexNormals.length; o < a; o++)s.vertexNormals[o].applyMatrix3(e).normalize() } return this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this.verticesNeedUpdate = !0, this.normalsNeedUpdate = !0, this } rotateX (t) { return Ns.makeRotationX(t), this.applyMatrix4(Ns), this } rotateY (t) { return Ns.makeRotationY(t), this.applyMatrix4(Ns), this } rotateZ (t) { return Ns.makeRotationZ(t), this.applyMatrix4(Ns), this } translate (t, e, n) { return Ns.makeTranslation(t, e, n), this.applyMatrix4(Ns), this } scale (t, e, n) { return Ns.makeScale(t, e, n), this.applyMatrix4(Ns), this } lookAt (t) { return Gw.lookAt(t), Gw.updateMatrix(), this.applyMatrix4(Gw.matrix), this } fromBufferGeometry (t) { let e = this, n = t.index !== null ? t.index : void 0, r = t.attributes; if (r.position === void 0) return console.error("THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion."), this; let s = r.position, o = r.normal, a = r.color, l = r.uv, u = r.uv2; u !== void 0 && (this.faceVertexUvs[1] = []); for (let d = 0; d < s.count; d++)e.vertices.push(new A().fromBufferAttribute(s, d)), a !== void 0 && e.colors.push(new Le().fromBufferAttribute(a, d)); function c (d, f, p, m) { let g = a === void 0 ? [] : [e.colors[d].clone(), e.colors[f].clone(), e.colors[p].clone()], y = o === void 0 ? [] : [new A().fromBufferAttribute(o, d), new A().fromBufferAttribute(o, f), new A().fromBufferAttribute(o, p)], v = new fh(d, f, p, y, g, m); e.faces.push(v), l !== void 0 && e.faceVertexUvs[0].push([new B().fromBufferAttribute(l, d), new B().fromBufferAttribute(l, f), new B().fromBufferAttribute(l, p)]), u !== void 0 && e.faceVertexUvs[1].push([new B().fromBufferAttribute(u, d), new B().fromBufferAttribute(u, f), new B().fromBufferAttribute(u, p)]) } let h = t.groups; if (h.length > 0) for (let d = 0; d < h.length; d++) { let f = h[d], p = f.start, m = f.count; for (let g = p, y = p + m; g < y; g += 3)n !== void 0 ? c(n.getX(g), n.getX(g + 1), n.getX(g + 2), f.materialIndex) : c(g, g + 1, g + 2, f.materialIndex) } else if (n !== void 0) for (let d = 0; d < n.count; d += 3)c(n.getX(d), n.getX(d + 1), n.getX(d + 2)); else for (let d = 0; d < s.count; d += 3)c(d, d + 1, d + 2); return this.computeFaceNormals(), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), this } center () { return this.computeBoundingBox(), this.boundingBox.getCenter(Ty).negate(), this.translate(Ty.x, Ty.y, Ty.z), this } normalize () { this.computeBoundingSphere(); let t = this.boundingSphere.center, e = this.boundingSphere.radius, n = e === 0 ? 1 : 1 / e, r = new se; return r.set(n, 0, 0, -n * t.x, 0, n, 0, -n * t.y, 0, 0, n, -n * t.z, 0, 0, 0, 1), this.applyMatrix4(r), this } computeFaceNormals () { let t = new A, e = new A; for (let n = 0, r = this.faces.length; n < r; n++) { let s = this.faces[n], o = this.vertices[s.a], a = this.vertices[s.b], l = this.vertices[s.c]; t.subVectors(l, a), e.subVectors(o, a), t.cross(e), t.normalize(), s.normal.copy(t) } } computeVertexNormals (t = !0) { let e = new Array(this.vertices.length); for (let n = 0, r = this.vertices.length; n < r; n++)e[n] = new A; if (t) { let n = new A, r = new A; for (let s = 0, o = this.faces.length; s < o; s++) { let a = this.faces[s], l = this.vertices[a.a], u = this.vertices[a.b], c = this.vertices[a.c]; n.subVectors(c, u), r.subVectors(l, u), n.cross(r), e[a.a].add(n), e[a.b].add(n), e[a.c].add(n) } } else { this.computeFaceNormals(); for (let n = 0, r = this.faces.length; n < r; n++) { let s = this.faces[n]; e[s.a].add(s.normal), e[s.b].add(s.normal), e[s.c].add(s.normal) } } for (let n = 0, r = this.vertices.length; n < r; n++)e[n].normalize(); for (let n = 0, r = this.faces.length; n < r; n++) { let s = this.faces[n], o = s.vertexNormals; o.length === 3 ? (o[0].copy(e[s.a]), o[1].copy(e[s.b]), o[2].copy(e[s.c])) : (o[0] = e[s.a].clone(), o[1] = e[s.b].clone(), o[2] = e[s.c].clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) } computeFlatVertexNormals () { this.computeFaceNormals(); for (let t = 0, e = this.faces.length; t < e; t++) { let n = this.faces[t], r = n.vertexNormals; r.length === 3 ? (r[0].copy(n.normal), r[1].copy(n.normal), r[2].copy(n.normal)) : (r[0] = n.normal.clone(), r[1] = n.normal.clone(), r[2] = n.normal.clone()) } this.faces.length > 0 && (this.normalsNeedUpdate = !0) } computeMorphNormals () { for (let e = 0, n = this.faces.length; e < n; e++) { let r = this.faces[e]; r.__originalFaceNormal ? r.__originalFaceNormal.copy(r.normal) : r.__originalFaceNormal = r.normal.clone(), r.__originalVertexNormals || (r.__originalVertexNormals = []); for (let s = 0, o = r.vertexNormals.length; s < o; s++)r.__originalVertexNormals[s] ? r.__originalVertexNormals[s].copy(r.vertexNormals[s]) : r.__originalVertexNormals[s] = r.vertexNormals[s].clone() } let t = new Fa; t.faces = this.faces; for (let e = 0, n = this.morphTargets.length; e < n; e++) { if (!this.morphNormals[e]) { this.morphNormals[e] = {}, this.morphNormals[e].faceNormals = [], this.morphNormals[e].vertexNormals = []; let s = this.morphNormals[e].faceNormals, o = this.morphNormals[e].vertexNormals; for (let a = 0, l = this.faces.length; a < l; a++) { let u = new A, c = { a: new A, b: new A, c: new A }; s.push(u), o.push(c) } } let r = this.morphNormals[e]; t.vertices = this.morphTargets[e].vertices, t.computeFaceNormals(), t.computeVertexNormals(); for (let s = 0, o = this.faces.length; s < o; s++) { let a = this.faces[s], l = r.faceNormals[s], u = r.vertexNormals[s]; l.copy(a.normal), u.a.copy(a.vertexNormals[0]), u.b.copy(a.vertexNormals[1]), u.c.copy(a.vertexNormals[2]) } } for (let e = 0, n = this.faces.length; e < n; e++) { let r = this.faces[e]; r.normal = r.__originalFaceNormal, r.vertexNormals = r.__originalVertexNormals } } computeBoundingBox () { this.boundingBox === null && (this.boundingBox = new _t), this.boundingBox.setFromPoints(this.vertices) } computeBoundingSphere () { this.boundingSphere === null && (this.boundingSphere = new dn), this.boundingSphere.setFromPoints(this.vertices) } merge (t, e, n = 0) { if (!(t && t.isGeometry)) { console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t); return } let r, s = this.vertices.length, o = this.vertices, a = t.vertices, l = this.faces, u = t.faces, c = this.colors, h = t.colors; e !== void 0 && (r = new Xt().getNormalMatrix(e)); for (let d = 0, f = a.length; d < f; d++) { let m = a[d].clone(); e !== void 0 && m.applyMatrix4(e), o.push(m) } for (let d = 0, f = h.length; d < f; d++)c.push(h[d].clone()); for (let d = 0, f = u.length; d < f; d++) { let p = u[d], m, g, y = p.vertexNormals, v = p.vertexColors, x = new fh(p.a + s, p.b + s, p.c + s); x.normal.copy(p.normal), r !== void 0 && x.normal.applyMatrix3(r).normalize(); for (let b = 0, S = y.length; b < S; b++)m = y[b].clone(), r !== void 0 && m.applyMatrix3(r).normalize(), x.vertexNormals.push(m); x.color.copy(p.color); for (let b = 0, S = v.length; b < S; b++)g = v[b], x.vertexColors.push(g.clone()); x.materialIndex = p.materialIndex + n, l.push(x) } for (let d = 0, f = t.faceVertexUvs.length; d < f; d++) { let p = t.faceVertexUvs[d]; this.faceVertexUvs[d] === void 0 && (this.faceVertexUvs[d] = []); for (let m = 0, g = p.length; m < g; m++) { let y = p[m], v = []; for (let x = 0, b = y.length; x < b; x++)v.push(y[x].clone()); this.faceVertexUvs[d].push(v) } } } mergeMesh (t) { if (!(t && t.isMesh)) { console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t); return } t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix) } mergeVertices (t = 4) { let e = {}, n = [], r = [], s = Math.pow(10, t); for (let l = 0, u = this.vertices.length; l < u; l++) { let c = this.vertices[l], h = Math.round(c.x * s) + "_" + Math.round(c.y * s) + "_" + Math.round(c.z * s); e[h] === void 0 ? (e[h] = l, n.push(this.vertices[l]), r[l] = n.length - 1) : r[l] = r[e[h]] } let o = []; for (let l = 0, u = this.faces.length; l < u; l++) { let c = this.faces[l]; c.a = r[c.a], c.b = r[c.b], c.c = r[c.c]; let h = [c.a, c.b, c.c]; for (let d = 0; d < 3; d++)if (h[d] === h[(d + 1) % 3]) { o.push(l); break } } for (let l = o.length - 1; l >= 0; l--) { let u = o[l]; this.faces.splice(u, 1); for (let c = 0, h = this.faceVertexUvs.length; c < h; c++)this.faceVertexUvs[c].splice(u, 1) } let a = this.vertices.length - n.length; return this.vertices = n, a } setFromPoints (t) { this.vertices = []; for (let e = 0, n = t.length; e < n; e++) { let r = t[e]; this.vertices.push(new A(r.x, r.y, r.z || 0)) } return this } sortFacesByMaterialIndex () { let t = this.faces, e = t.length; for (let l = 0; l < e; l++)t[l]._id = l; function n (l, u) { return l.materialIndex - u.materialIndex } t.sort(n); let r = this.faceVertexUvs[0], s = this.faceVertexUvs[1], o, a; r && r.length === e && (o = []), s && s.length === e && (a = []); for (let l = 0; l < e; l++) { let u = t[l]._id; o && o.push(r[u]), a && a.push(s[u]) } o && (this.faceVertexUvs[0] = o), a && (this.faceVertexUvs[1] = a) } toJSON () { let t = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, this.name !== "" && (t.name = this.name), this.parameters !== void 0) { let p = this.parameters; for (let m in p) p[m] !== void 0 && (t[m] = p[m]); return t } let e = []; for (let p = 0; p < this.vertices.length; p++) { let m = this.vertices[p]; e.push(m.x, m.y, m.z) } let n = [], r = [], s = {}, o = [], a = {}, l = [], u = {}; for (let p = 0; p < this.faces.length; p++) { let m = this.faces[p], g = !0, y = !1, v = this.faceVertexUvs[0][p] !== void 0, x = m.normal.length() > 0, b = m.vertexNormals.length > 0, S = m.color.r !== 1 || m.color.g !== 1 || m.color.b !== 1, _ = m.vertexColors.length > 0, E = 0; if (E = c(E, 0, 0), E = c(E, 1, g), E = c(E, 2, y), E = c(E, 3, v), E = c(E, 4, x), E = c(E, 5, b), E = c(E, 6, S), E = c(E, 7, _), n.push(E), n.push(m.a, m.b, m.c), n.push(m.materialIndex), v) { let w = this.faceVertexUvs[0][p]; n.push(f(w[0]), f(w[1]), f(w[2])) } if (x && n.push(h(m.normal)), b) { let w = m.vertexNormals; n.push(h(w[0]), h(w[1]), h(w[2])) } if (S && n.push(d(m.color)), _) { let w = m.vertexColors; n.push(d(w[0]), d(w[1]), d(w[2])) } } function c (p, m, g) { return g ? p | 1 << m : p & ~(1 << m) } function h (p) { let m = p.x.toString() + p.y.toString() + p.z.toString(); return s[m] !== void 0 || (s[m] = r.length / 3, r.push(p.x, p.y, p.z)), s[m] } function d (p) { let m = p.r.toString() + p.g.toString() + p.b.toString(); return a[m] !== void 0 || (a[m] = o.length, o.push(p.getHex())), a[m] } function f (p) { let m = p.x.toString() + p.y.toString(); return u[m] !== void 0 || (u[m] = l.length / 2, l.push(p.x, p.y)), u[m] } return t.data = {}, t.data.vertices = e, t.data.normals = r, o.length > 0 && (t.data.colors = o), l.length > 0 && (t.data.uvs = [l]), t.data.faces = n, t } clone () { return new Fa().copy(this) } copy (t) { this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingBox = null, this.boundingSphere = null, this.name = t.name; let e = t.vertices; for (let d = 0, f = e.length; d < f; d++)this.vertices.push(e[d].clone()); let n = t.colors; for (let d = 0, f = n.length; d < f; d++)this.colors.push(n[d].clone()); let r = t.faces; for (let d = 0, f = r.length; d < f; d++)this.faces.push(r[d].clone()); for (let d = 0, f = t.faceVertexUvs.length; d < f; d++) { let p = t.faceVertexUvs[d]; this.faceVertexUvs[d] === void 0 && (this.faceVertexUvs[d] = []); for (let m = 0, g = p.length; m < g; m++) { let y = p[m], v = []; for (let x = 0, b = y.length; x < b; x++) { let S = y[x]; v.push(S.clone()) } this.faceVertexUvs[d].push(v) } } let s = t.morphTargets; for (let d = 0, f = s.length; d < f; d++) { let p = {}; if (p.name = s[d].name, s[d].vertices !== void 0) { p.vertices = []; for (let m = 0, g = s[d].vertices.length; m < g; m++)p.vertices.push(s[d].vertices[m].clone()) } if (s[d].normals !== void 0) { p.normals = []; for (let m = 0, g = s[d].normals.length; m < g; m++)p.normals.push(s[d].normals[m].clone()) } this.morphTargets.push(p) } let o = t.morphNormals; for (let d = 0, f = o.length; d < f; d++) { let p = {}; if (o[d].vertexNormals !== void 0) { p.vertexNormals = []; for (let m = 0, g = o[d].vertexNormals.length; m < g; m++) { let y = o[d].vertexNormals[m], v = {}; v.a = y.a.clone(), v.b = y.b.clone(), v.c = y.c.clone(), p.vertexNormals.push(v) } } if (o[d].faceNormals !== void 0) { p.faceNormals = []; for (let m = 0, g = o[d].faceNormals.length; m < g; m++)p.faceNormals.push(o[d].faceNormals[m].clone()) } this.morphNormals.push(p) } let a = t.skinWeights; for (let d = 0, f = a.length; d < f; d++)this.skinWeights.push(a[d].clone()); let l = t.skinIndices; for (let d = 0, f = l.length; d < f; d++)this.skinIndices.push(l[d].clone()); let u = t.lineDistances; for (let d = 0, f = u.length; d < f; d++)this.lineDistances.push(u[d]); let c = t.boundingBox; c !== null && (this.boundingBox = c.clone()); let h = t.boundingSphere; return h !== null && (this.boundingSphere = h.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this } toBufferGeometry () { let t = new Vw().fromGeometry(this), e = new Ce, n = new Float32Array(t.vertices.length * 3); if (e.setAttribute("position", Cy.call(new ze(n, 3), t.vertices)), t.normals.length > 0) { let r = new Float32Array(t.normals.length * 3); e.setAttribute("normal", Cy.call(new ze(r, 3), t.normals)) } if (t.colors.length > 0) { let r = new Float32Array(t.colors.length * 3); e.setAttribute("color", YP.call(new ze(r, 3), t.colors)) } if (t.uvs.length > 0) { let r = new Float32Array(t.uvs.length * 2); e.setAttribute("uv", XP.call(new ze(r, 2), t.uvs)) } if (t.uvs2.length > 0) { let r = new Float32Array(t.uvs2.length * 2); e.setAttribute("uv2", XP.call(new ze(r, 2), t.uvs2)) } e.groups = t.groups; for (let r in t.morphTargets) { let s = [], o = t.morphTargets[r]; for (let a = 0, l = o.length; a < l; a++) { let u = o[a], c = new _e(u.data.length * 3, 3); c.name = u.name, s.push(Cy.call(c, u.data)) } e.morphAttributes[r] = s } if (t.skinIndices.length > 0) { let r = new _e(t.skinIndices.length * 4, 4); e.setAttribute("skinIndex", QP.call(r, t.skinIndices)) } if (t.skinWeights.length > 0) { let r = new _e(t.skinWeights.length * 4, 4); e.setAttribute("skinWeight", QP.call(r, t.skinWeights)) } return t.boundingSphere !== null && (e.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (e.boundingBox = t.boundingBox.clone()), e } computeTangents () { console.error("THREE.Geometry: .computeTangents() has been removed.") } computeLineDistances () { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") } applyMatrix (t) { return console.warn("THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t) } dispose () { this.dispatchEvent({ type: "dispose" }) } static createBufferGeometryFromObject (t) { let e = new Ce, n = t.geometry; if (t.isPoints || t.isLine) { let r = new _e(n.vertices.length * 3, 3), s = new _e(n.colors.length * 3, 3); if (e.setAttribute("position", Cy.call(r, n.vertices)), e.setAttribute("color", YP.call(s, n.colors)), n.lineDistances && n.lineDistances.length === n.vertices.length) { let o = new _e(n.lineDistances.length, 1); e.setAttribute("lineDistance", dW.call(o, n.lineDistances)) } n.boundingSphere !== null && (e.boundingSphere = n.boundingSphere.clone()), n.boundingBox !== null && (e.boundingBox = n.boundingBox.clone()) } else t.isMesh && (e = n.toBufferGeometry()); return e } }; Fa.prototype.isGeometry = !0; var Vw = class { constructor() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingBox = null, this.boundingSphere = null, this.verticesNeedUpdate = !1, this.normalsNeedUpdate = !1, this.colorsNeedUpdate = !1, this.uvsNeedUpdate = !1, this.groupsNeedUpdate = !1 } computeGroups (t) { let e = [], n, r, s, o = t.faces; for (r = 0; r < o.length; r++) { let a = o[r]; a.materialIndex !== s && (s = a.materialIndex, n !== void 0 && (n.count = r * 3 - n.start, e.push(n)), n = { start: r * 3, materialIndex: s }) } n !== void 0 && (n.count = r * 3 - n.start, e.push(n)), this.groups = e } fromGeometry (t) { let e = t.faces, n = t.vertices, r = t.faceVertexUvs, s = r[0] && r[0].length > 0, o = r[1] && r[1].length > 0, a = t.morphTargets, l = a.length, u; if (l > 0) { u = []; for (let y = 0; y < l; y++)u[y] = { name: a[y].name, data: [] }; this.morphTargets.position = u } let c = t.morphNormals, h = c.length, d; if (h > 0) { d = []; for (let y = 0; y < h; y++)d[y] = { name: c[y].name, data: [] }; this.morphTargets.normal = d } let f = t.skinIndices, p = t.skinWeights, m = f.length === n.length, g = p.length === n.length; n.length > 0 && e.length === 0 && console.error("THREE.DirectGeometry: Faceless geometries are not supported."); for (let y = 0; y < e.length; y++) { let v = e[y]; this.vertices.push(n[v.a], n[v.b], n[v.c]); let x = v.vertexNormals; if (x.length === 3) this.normals.push(x[0], x[1], x[2]); else { let S = v.normal; this.normals.push(S, S, S) } let b = v.vertexColors; if (b.length === 3) this.colors.push(b[0], b[1], b[2]); else { let S = v.color; this.colors.push(S, S, S) } if (s === !0) { let S = r[0][y]; S !== void 0 ? this.uvs.push(S[0], S[1], S[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", y), this.uvs.push(new B, new B, new B)) } if (o === !0) { let S = r[1][y]; S !== void 0 ? this.uvs2.push(S[0], S[1], S[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", y), this.uvs2.push(new B, new B, new B)) } for (let S = 0; S < l; S++) { let _ = a[S].vertices; u[S].data.push(_[v.a], _[v.b], _[v.c]) } for (let S = 0; S < h; S++) { let _ = c[S].vertexNormals[y]; d[S].data.push(_.a, _.b, _.c) } m && this.skinIndices.push(f[v.a], f[v.b], f[v.c]), g && this.skinWeights.push(p[v.a], p[v.b], p[v.c]) } return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, t.boundingSphere !== null && (this.boundingSphere = t.boundingSphere.clone()), t.boundingBox !== null && (this.boundingBox = t.boundingBox.clone()), this } }, fh = class { constructor(t, e, n, r, s, o = 0) { this.a = t, this.b = e, this.c = n, this.normal = r && r.isVector3 ? r : new A, this.vertexNormals = Array.isArray(r) ? r : [], this.color = s && s.isColor ? s : new Le, this.vertexColors = Array.isArray(s) ? s : [], this.materialIndex = o } clone () { return new this.constructor().copy(this) } copy (t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (let e = 0, n = t.vertexNormals.length; e < n; e++)this.vertexNormals[e] = t.vertexNormals[e].clone(); for (let e = 0, n = t.vertexColors.length; e < n; e++)this.vertexColors[e] = t.vertexColors[e].clone(); return this } }; function dW (i) { return this.array.set(i), this } function YP (i) { let t = this.array, e = 0; for (let n = 0, r = i.length; n < r; n++) { let s = i[n]; s === void 0 && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), s = new Le), t[e++] = s.r, t[e++] = s.g, t[e++] = s.b } return this } function XP (i) { let t = this.array, e = 0; for (let n = 0, r = i.length; n < r; n++) { let s = i[n]; s === void 0 && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", n), s = new B), t[e++] = s.x, t[e++] = s.y } return this } function Cy (i) { let t = this.array, e = 0; for (let n = 0, r = i.length; n < r; n++) { let s = i[n]; s === void 0 && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), s = new A), t[e++] = s.x, t[e++] = s.y, t[e++] = s.z } return this } function QP (i) { let t = this.array, e = 0; for (let n = 0, r = i.length; n < r; n++) { let s = i[n]; s === void 0 && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), s = new qe), t[e++] = s.x, t[e++] = s.y, t[e++] = s.z, t[e++] = s.w } return this } var fW = ["a", "b", "c"]; function pW (i, t) { switch (t) { case "c": return i.c; case "b": return i.b; case "a": default: return i.a } } function Hw (i, t, e) { let n = Math.min(i, t), r = Math.max(i, t), s = n + "_" + r; return e.get(s) } function jw (i, t, e, n, r, s) { let o = Math.min(i, t), a = Math.max(i, t), l = o + "_" + a, u; if (n.has(l)) u = n.get(l); else { let c = e[o], h = e[a]; u = { a: c, b: h, newEdge: null, faces: [] }, n.set(l, u) } u.faces.push(r), s[i].edges.push(u), s[t].edges.push(u) } function mW (i, t, e, n) { let r, s, o; for (r = 0, s = i.length; r < s; r++)e[r] = { edges: [] }; for (r = 0, s = t.length; r < s; r++)o = t[r], jw(o.a, o.b, i, n, o, e), jw(o.b, o.c, i, n, o, e), jw(o.c, o.a, i, n, o, e) } function Py (i, t, e, n, r) { i.push(new fh(t, e, n, void 0, void 0, r)) } function ph (i, t) { return Math.abs(t - i) / 2 + Math.min(i, t) } function Iy (i, t, e, n) { i.push([t.clone(), e.clone(), n.clone()]) } var Dy = class { constructor(t = 1) { this.subdivisions = t } modify (t) { t instanceof Ce ? t = new Fa().fromBufferGeometry(t) : t = t.clone(), t.mergeVertices(); let e = this.subdivisions; for (; e-- > 0;)this._smooth(t); return t.computeFaceNormals(), t.computeVertexNormals(), t } _smooth (t) { let e = new A, n, r, s, o, a, l = t.vertices, u = t.faces, c = t.faceVertexUvs[0], h = c !== void 0 && c.length > 0, d = [], f = new Map; mW(l, u, d, f); let p = [], m, g, y, v, x, b, S; for (let K of Array.from(f.keys())) { for (g = f.get(K), y = new A, x = 3 / 8, b = 1 / 8, S = g.faces.length, S != 2 && (x = .5, b = 0, S != 1), y.addVectors(g.a, g.b).multiplyScalar(x), e.set(0, 0, 0), o = 0; o < S; o++) { for (v = g.faces[o], a = 0; a < 3 && (m = l[pW(v, fW[a])], !(m !== g.a && m !== g.b)); a++); m && e.add(m) } e.multiplyScalar(b), y.add(e), g.newEdge = p.length, p.push(y) } let _, E, w, M, T, I, C, P = []; for (r = 0, s = l.length; r < s; r++) { for (I = l[r], T = d[r].edges, n = T.length, n == 3 ? _ = 3 / 16 : n > 3 && (_ = 3 / (8 * n)), E = 1 - n * Number(_), w = _, n <= 2 && (n == 2 ? (E = 3 / 4, w = 1 / 8) : n == 1 || n == 0), C = I.clone().multiplyScalar(E), e.set(0, 0, 0), o = 0; o < n; o++)M = T[o], m = M.a !== I ? M.a : M.b, e.add(m); e.multiplyScalar(Number(w)), C.add(e), P.push(C) } let D = P.concat(p), L = P.length, H, U, V, G = [], z = [], $, F, j, X, q = new B, k = new B, Z = new B; for (r = 0, s = u.length; r < s; r++)v = u[r], H = Number(Hw(v.a, v.b, f).newEdge) + L, U = Number(Hw(v.b, v.c, f).newEdge) + L, V = Number(Hw(v.c, v.a, f).newEdge) + L, Py(G, H, U, V, v.materialIndex), Py(G, v.a, H, V, v.materialIndex), Py(G, v.b, U, H, v.materialIndex), Py(G, v.c, V, U, v.materialIndex), h && ($ = c[r], F = $[0], j = $[1], X = $[2], q.set(ph(F.x, j.x), ph(F.y, j.y)), k.set(ph(j.x, X.x), ph(j.y, X.y)), Z.set(ph(F.x, X.x), ph(F.y, X.y)), Iy(z, q, k, Z), Iy(z, F, q, Z), Iy(z, j, k, q), Iy(z, X, Z, k)); t.vertices = D, t.faces = G, h && (t.faceVertexUvs[0] = z) } }; var Yn = new A, KP = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = i.geometry ?? t?.geometry ?? new Ce().copy(new er(100, 100, 100)), n; t === void 0 ? (e.computeBoundingBox(), e.boundingBox.getSize(Yn), n = { width: Yn.x, height: Yn.y, depth: Yn.z, subdivisions: 0 }) : n = t.parameters; let r = { ...n, ...i.parameters }; return { parameters: { width: Math.abs(r.width), height: Math.abs(r.height), depth: Math.abs(r.depth), subdivisions: Math.abs(r.subdivisions) }, geometry: e } } static build (i) { let { width: t, height: e, depth: n, subdivisions: r } = i.parameters, s = i.geometry ?? new Ce().copy(new er(100, 100, 100)), o = s.userData.parameters; o === void 0 ? (s.computeBoundingBox(), s.boundingBox.getSize(Yn)) : Yn.set(o.width, o.height, o.depth), (t !== Yn.x || e !== Yn.y || n !== Yn.z) && s.scale(Yn.x === 0 ? 1 : t / Yn.x, Yn.y === 0 ? 1 : e / Yn.y, Yn.z === 0 ? 1 : n / Yn.z); let a = s.originalGeometry; try { r > 0 ? (a === void 0 || o?.subdivisions !== r) && (a === void 0 && (a = s), s = new Dy(r).modify(a).toBufferGeometry()) : (a !== void 0 && (s = a), a = void 0, s.getAttribute("normal") === void 0 && s.computeVertexNormals()) } catch { a !== void 0 && (s = a), a = void 0, s.getAttribute("normal") === void 0 && s.computeVertexNormals() } return a !== void 0 && Object.assign(s, { originalGeometry: a }), delete i.geometry, Object.assign(s, { userData: { ...i, type: "NonParametricGeometry" } }) } static loadFromUrl (i, t, e) { new Wc(e).load(i, r => { let s = this.normalizeInputs({ geometry: r }); r.boundingBox.getSize(Yn); let o = 100 / Yn.x; Object.assign(s.parameters, { width: 100, height: Yn.y * o, depth: Yn.z * o }), t(this.build(s)) }) } }; var Oy = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, depth: 0, spikes: 5, cornerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 3 }, i.parameters); return { shape: i.shape && i.shape instanceof Mt ? i.shape : new Mt, parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) } } static build (i) { let { width: t, height: e, spikes: n, cornerRadius: r, depth: s, extrudeBevelSize: o, extrudeBevelSegments: a } = i.parameters, l = i.shape, u = t * .5, c = e * .5, h = 0, d = 0, f = 2 * Math.PI / n; for (let m = 0; m < n; m++) { let g = f * m, y = h + Math.sin(g) * u, v = d + Math.cos(g) * c; l.addPoint(l.createPoint(y, v)) } l.isClosed = !0; for (let m = 0, g = l.points.length; m < g; m++)l.points[m].roundness = r; l.roundness = r, l.update(); let p = Kr.create({ shape: l, parameters: { roundness: r, depth: s, extrudeBevelSize: o, extrudeBevelSegments: a } }); return Object.assign(p, { userData: { ...i, type: "PolygonGeometry" } }) } }; var ZP = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, radialSegments: 4, heightSegments: 1, cornerRadius: 0, cornerSegments: 8, openEnded: !1 }, i.parameters); return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) } } static build (i) { let { width: t, height: e, depth: n, radialSegments: r, heightSegments: s, openEnded: o, cornerRadius: a, cornerSegments: l } = i.parameters, u = new qw(t * .5, e, r, s, o, a, l); return u.scale(1, 1, n / t), Object.assign(u, { userData: { ...i, type: "PyramidGeometry" } }) } }; function Gf (i, t, e) { e.x = i.x * t.x, e.y = i.y, e.z = i.x * t.y } function Ww (i, t, e, n, r, s) { let o = t.clone().sub(i), a = e.clone().sub(i), l = o.angleTo(a); if (o.normalize(), a.normalize(), n === r) { let u = o.add(a).normalize(); s.copy(i).addScaledVector(u, n / Math.sin(l / 2)) } else { let u = o.angleTo(a); s.copy(i), s.addScaledVector(o, r / Math.sin(u)), s.addScaledVector(a, n / Math.sin(u)) } } function gW (i, t, e) { let n = i.clone().sub(t), r = e.clone().sub(t); return n.projectOnVector(r), n.add(t) } var qw = class extends Ce { constructor(t = .5, e = 1, n = 4, r = 1, s = !1, o = 0, a = 4) { super(), n = Math.floor(Math.max(3, n)), r = Math.floor(r), a = Math.floor(a); let l = [], u = [], c = [], h = [], d = 0, f = e / 2, p = Math.PI / n, m = t * Math.cos(Math.PI / n), g = 2 * Math.PI / n, y = (n - 2) * Math.PI / n, v = Math.PI - y, x = new A(0, -f, 0), b = new A(0, f, 0), S = new B(t, -f), _ = new B(m, -f), E = new B(0, b.y).sub(_), w = new B(0, b.y).sub(S), M = new B(E.y, -E.x).normalize(), T = new B(w.y, -w.x).normalize(), C = t * Math.cos(Math.PI / n) * Math.tan((Math.PI - E.angle()) / 2) - 1e-8; o = Math.min(o, C); let P; { let z = new A(M.x, M.y, 0), $ = new A(Math.cos(g) * z.x, z.y, Math.sin(g) * z.x); P = z.angleTo($) } let D = o / Math.tan((Math.PI - E.angle()) / 2), L = o / Math.tan((Math.PI - P) / 2), H = new A; if (!s) { u.push(x.x, x.y, x.z), c.push(0, -1, 0), h.push(0, 0); let z = d++, $ = [], F = S.clone(), j = D / Math.cos(Math.PI / n); F.x -= j; for (let X = 0; X < n; X++) { let q = X / n * Math.PI * 2 + p, k = new B(Math.sin(q), Math.cos(q)); Gf(F, k, H), u.push(H.x, H.y, H.z), c.push(0, -1, 0), h.push(0, 0), $.push(d++) } for (let X = 0; X < $.length; X++)l.push($[X], z, $[(X + 1) % $.length]) } let U = []; { let z = new A, $ = new A, F = new A, j = new A, X = new A, q = new A; for (let k = 0; k < n; k++) { let Z = k / n * Math.PI * 2 + p, K = (k + .5) / n * Math.PI * 2 + p, Q = (k + 1) / n * Math.PI * 2 + p, W = new B(Math.sin(Z), Math.cos(Z)), ge = new B(Math.sin(K), Math.cos(K)), de = new B(Math.sin(Q), Math.cos(Q)); Gf(S, W, $), Gf(S, de, F), Gf(M, ge, z), Ww(b, $, F, L, L, j), u.push(j.x, j.y, j.z), Ww($, b, F, L, D, X), u.push(X.x, X.y, X.z), Ww(F, $, b, D, L, q), u.push(q.x, q.y, q.z), c.push(z.x, z.y, z.z), c.push(z.x, z.y, z.z), c.push(z.x, z.y, z.z), h.push(0, 0), h.push(0, 0), h.push(0, 0); let ie = d++, be = d++, ve = d++; if (l.push(ie, be, ve), o > 0) { { let Me = $.clone().add(F).multiplyScalar(.5), Se = b.clone().sub(Me).normalize(), ke = x.clone().sub(Me).normalize().add(Se).normalize().multiplyScalar(-1), R = q.clone().sub(X); V(Me, R, ke, E.angle()) } let Ie, Pe; { let Me = new A; Gf(T, de, Me); let Se = q.clone().add(j).multiplyScalar(.5); Se = gW(Se, F, b); let Fe = q.clone().sub(j);[Ie, Pe] = V(Se, Fe, Me, P, j.y) } { let Me = Ie, Se = Me.clone().setY(0).normalize(), Fe = new A(0, -1, 0), ke = Se.clone().cross(Fe); G(Me, Se, Fe, ke) } U.concat(Pe); { let Me = E.angle(), Se = Math.PI - Me, Fe = b.clone(); Fe.y -= o / Math.sin(Me - Math.PI / 2); let ke = new A, R = []; for (let ne = 0; ne < a; ne++) { let ce = [], pe = Math.PI / 2 - Se * ne / a, Te = Math.cos(pe), Ae = Math.sin(pe), we = K; for (let ae = 0; ae <= ne; ae++) { let Xe = Math.cos(we), Ne = Math.sin(we); z.x = Te * Ne, z.y = Ae, z.z = Te * Xe, ke.copy(Fe).addScaledVector(z, o), u.push(ke.x, ke.y, ke.z), c.push(z.x, z.y, z.z), h.push(0, 0), ce.push(d++), we += Math.PI * 2 / ne / n } R.push(ce) } Pe.reverse(), R.push(Pe); let O = R.length - 1; for (let ne = 0; ne < O; ne++) { let ce = R[ne], pe = R[ne + 1], Te = ce.length - 1; l.push(pe[1], ce[0], pe[0]); for (let Ae = 1; Ae <= Te; Ae++)l.push(ce[Ae], ce[Ae - 1], pe[Ae]), l.push(pe[Ae + 1], ce[Ae], pe[Ae]) } } } } } this.setIndex(l), this.setAttribute("position", new _e(u, 3)), this.setAttribute("normal", new _e(c, 3)), this.setAttribute("uv", new _e(h, 2)); function V (z, $, F, j, X) { let q = -j / 2, k = (Math.PI - j) / 2, Z = $.clone().normalize().cross(F); z.addScaledVector(F, -o / Math.sin(k)); let K = new A, Q = new A, W = 1, ge = d, de = []; for (let ie = 0; ie <= a; ie++) { let be = q + ie / a * j; Q.set(0, 0, 0), Q.addScaledVector(Z, Math.sin(be)), Q.addScaledVector(F, Math.cos(be)); for (let ve = 0; ve <= W; ve++) { let Ie = ve / W - .5; if (K.copy(z), K.addScaledVector($, Ie), K.addScaledVector(Q, o), X != null) { let Pe = Math.max(0, K.y - X); K.addScaledVector($, -Pe / $.y) } u.push(K.x, K.y, K.z), c.push(Q.x, Q.y, Q.z), h.push(0, 0), ve === 0 && de.push(d), d++ } } for (let ie = 0; ie < a; ie++)for (let be = 0; be < W; be++) { let ve = ge + be + (W + 1) * ie, Ie = ve + (W + 1), Pe = Ie + 1, Me = ve + 1; l.push(ve, Ie, Me), l.push(Ie, Pe, Me) } return [z.clone().addScaledVector($, .5), de] } function G (z, $, F, j) { let X = Math.PI / 2, q = w.angle() - X, k = [], Z = new A, K = new A; for (let W = 0; W <= a; W++) { let ge = [], de = W / a; for (let ie = 0; ie <= W; ie++) { let ve = ((W ? ie / W : 0) - .5) * v, Ie = Math.cos(ve), Pe = Math.sin(ve), Me = Math.atan(Math.tan(q) * Ie), Se = (X + Me) * de, Fe = Math.cos(Se), ke = Math.sin(Se); Z.set(0, 0, 0), Z.addScaledVector($, ke * Ie), Z.addScaledVector(F, Fe), Z.addScaledVector(j, ke * Pe), K.copy(z).addScaledVector(Z, o), u.push(K.x, K.y, K.z), c.push(Z.x, Z.y, Z.z), h.push(0, 0), ge.push(d++) } k.push(ge) } let Q = k.length - 1; for (let W = 0; W < Q; W++) { let ge = k[W], de = k[W + 1], ie = ge.length - 1; l.push(ge[0], de[1], de[0]); for (let be = 1; be <= ie; be++)l.push(ge[be - 1], ge[be], de[be]), l.push(ge[be], de[be + 1], de[be]) } } } }; var Ry = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, depth: 0, cornerRadius: [0, 0, 0, 0], cornerType: 1, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, i.parameters), n = Object.assign(t?.ui ?? { enabledIndieCorners: !1 }, i.ui); return { shape: i.shape && i.shape instanceof Mt ? i.shape : new Mt, parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }), ui: n } } static build (i) { let t = i.shape, { width: e, height: n, cornerRadius: r, cornerType: s, depth: o, extrudeBevelSize: a, extrudeBevelSegments: l } = i.parameters, u = { x: e * .5, y: n * .5 }, c = { x: -u.x, y: -u.y }, h = { x: u.x, y: u.y }; function d (b, S, _) { return S > e && _ > n ? Math.min(b * e / S, b * n / _) : S > e ? b * e / S : _ > n ? b * n / _ : b } let f = []; f[0] = r[0] === 0 ? 0 : d(r[0], r[0] + r[3], r[0] + r[1]), f[1] = r[1] === 0 ? 0 : d(r[1], r[1] + r[2], r[1] + r[0]), f[2] = r[2] === 0 ? 0 : d(r[2], r[2] + r[1], r[2] + r[3]), f[3] = r[3] === 0 ? 0 : d(r[3], r[3] + r[0], r[3] + r[2]); let p = c.x, m = h.x, g = h.y, y = c.y; t.addPoint(t.createPoint(p, g)), t.addPoint(t.createPoint(m, g)), t.addPoint(t.createPoint(m, y)), t.addPoint(t.createPoint(p, y)), t.isClosed = !0; let v = !0; for (let b = 0, S = t.points.length; b < S; b++)t.points[b].roundness = f[b], b > 0 && f[b] !== f[b - 1] && (v = !1); v && (t.roundness = f[0]), t.useCubicForRoundedCorners = s !== 1, t.update(); let x = Kr.create({ shape: t, parameters: { depth: o, extrudeBevelSize: a, extrudeBevelSegments: l } }); return Object.assign(x, { userData: { ...i, type: "RectangleGeometry" } }) } }; var JP = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, widthSegments: 64, heightSegments: 64, phiStart: 0, phiLength: 2 * Math.PI, thetaStart: 0, thetaLength: Math.PI }, i.parameters); return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) } } static build (i) { let { width: t = 100, height: e = t, depth: n = t, widthSegments: r = 64, heightSegments: s = 64, phiStart: o, phiLength: a, thetaStart: l, thetaLength: u } = i.parameters, c = new vl(.5 * t, r, s, o, a, l, u); return c.scale(1, e / t, n / t), Object.assign(c, { userData: { ...i, type: "SphereGeometry" } }) } }; var $P = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, depth: 0, widthSegments: 8, heightSegments: 8 }, i.parameters); return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: 0 }) } } static build (i) { let { width: t = 100, height: e = t, widthSegments: n = 8, heightSegments: r = 8 } = i.parameters, s = new mo(t, e, n, r); return s.scale(1, 1, 1), Object.assign(s, { userData: { ...i, type: "PlaneGeometry" } }) } }; var e2 = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, angle: 90, cornerRadius: 24, cornerSegments: 8 }, i.parameters); return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width) }) } } static build (i) { let { width: t, height: e, depth: n, angle: r, cornerRadius: s, cornerSegments: o } = i.parameters, a = new Yw(t, e, n, r, s, o); return Object.assign(a, { userData: { ...i, type: "BackdropGeometry" } }) } }, Yw = class extends Ce { constructor(t = 1, e = 1, n = 1, r = 90, s = 10, o = 24) { super(), this.type = "BackdropGeometry"; let a = [], l = [], u = [], c = .001; s == 0 && (o = 1), o = Math.max(1, Math.floor(o)), s = Math.min(s, 100), r = Math.min(180 - c, r), r *= Math.PI / 180; let h = [], d = Math.PI / 2, f = (K = 0, Q = 0, W = 0) => new A(K, Q, W), p = f(), m = f(), [g, y, v] = [e / 2, t / 2, n / 2], x = -y, b = +y, [S, _, E] = [f(x, -g, +v), f(x, -g, -v), f(x, +g, -v)], w = (K, Q = !1) => Math.sin(K - Math.PI / (1 + +Q)), M = (K, Q = !1) => Math.cos(K - Math.PI / (1 + +Q)); E.y = Math.sin(r) * e - g; let T = Math.cos(r) * e - v, I = S.z - c; r <= d ? (E.z = Math.min(T, I), E.z == I && (E.y -= (T - I) / Math.tan(d - r))) : _.z = Math.min(_.z - T - v, S.z - c), p.subVectors(S, _), m.subVectors(E, _); let C = Math.min(p.length(), m.length()) * s / 100, P = C * Math.tan(r / 2), D = C / Math.cos(r / 2), L = p.clone().normalize().add(m.normalize()).setLength(D).add(_); p.set(0, w(r, !0), M(r, !0)), h.push([E, p.clone()]); let H = (Math.PI - r) / o; for (let K = 0; K <= o; K++) { let Q = d + r + K * H; p.set(0, Math.sin(Q) * P, Math.cos(Q) * P), p.add(L), m.set(0, w(Q), M(Q)), h.push([p.clone(), m.clone()]) } h.push([S, f(0, 1, 0)]); let U = Math.sin(H / 2) * P * 2, V = h.length - 1, G = h[0][0].distanceTo(h[1][0]), z = h[V - 1][0].distanceTo(h[V][0]), $ = G + U * o + z; h[0].push(1); for (let K = 0; K <= o; K++)h[K + 1].push(1 - (G + K * U) / $); h[V].push(0); let [F, j, X] = h[0], q, k, Z; for (let K = 1; K < h.length; K++) [q, k, Z] = h[K], a.push(x, F.y, F.z, x, q.y, q.z, b, F.y, F.z, b, F.y, F.z, x, q.y, q.z, b, q.y, q.z), l.push(0, j.y, j.z, 0, k.y, k.z, 0, j.y, j.z, 0, j.y, j.z, 0, k.y, k.z, 0, k.y, k.z), u.push(0, X, 0, Z, 1, X, 1, X, 0, Z, 1, Z), [F, j, X] = [q, k, Z]; this.setAttribute("position", new _e(a, 3)), this.setAttribute("normal", new _e(l, 3)), this.setAttribute("uv", new _e(u, 2)) } }; var Ly = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, depth: 0, innerRadiusPercent: 38.19, spikes: 5, cornerRadius: 0, angle: 360, extrudeBevelSize: 0, extrudeBevelSegments: 1 }, i.parameters); return { shape: i.shape && i.shape instanceof Mt ? i.shape : new Mt, parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) } } static build (i) { let { width: t, height: e, innerRadiusPercent: n, spikes: r, cornerRadius: s, angle: o, depth: a, extrudeBevelSize: l, extrudeBevelSegments: u } = i.parameters, c = i.shape, h = t * .5, d = e * .5, f = 0, p = 0, m = o * Math.PI / 360 / r, g = Math.PI / 2 * 3 * -1, y = h * n / 100, v = d * n / 100; if (r === 3 && n === 50) { m = 2 * Math.PI / r; for (let b = 0; b < r; b++) { let S = m * b, _ = f + Math.sin(S) * h, E = p + Math.cos(S) * d; c.addPoint(c.createPoint(_, E)) } } else for (let b = 0; b < r; b++) { let S = f + Math.cos(g) * h, _ = p + Math.sin(g) * d; c.addPoint(c.createPoint(S, _)), g += m, S = f + Math.cos(g) * y, _ = p + Math.sin(g) * v, b <= r, c.addPoint(c.createPoint(S, _)), g += m } c.isClosed = !0; for (let b = 0, S = c.points.length; b < S; b++)c.points[b].roundness = s; c.roundness = s, c.update(); let x = Kr.create({ shape: c, parameters: { roundness: s, depth: a, extrudeBevelSize: l, extrudeBevelSegments: u } }); return Object.assign(x, { userData: { ...i, type: "StarGeometry" } }) } }; var t2 = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, depth: 0 }, i.parameters); return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? 0) }) } } static build (i) { let { width: t, height: e } = i.parameters, n = new mo(t, e); return Object.assign(n, { userData: { ...i, type: "TextFrameGeometry" } }) } }; var n2 = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, radialSegments: 32, tubularSegments: 64, arc: Math.PI * 2, cornerRadius: 30, cornerSegments: 8 }, i.parameters), n = Math.abs(e.width), r = Math.abs(e.height ?? e.width), s = Math.round(Math.abs(e.depth ?? e.width * .25)); return { parameters: Object.assign(e, { width: n, height: r, depth: s }) } } static build (i) { let { width: t, height: e, depth: n, radialSegments: r, tubularSegments: s, arc: o, cornerRadius: a, cornerSegments: l } = i.parameters, u = yW(t, e, n, t * .5, o, s, 0, 0, r, a, l); return u.scale(1, e / t, 1), Object.assign(u, { userData: { ...i, type: "TorusGeometry" } }) } }; function yW (i, t, e, n, r, s, o, a, l, u, c) { return [t, e] = [e, t], o = t / 2, r /= 2 * Math.PI, r == 1 && (u = 0), new Uf(!0, i, t, e, n, r, s, o, a, l, u, c) } var r2 = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, tubularSegments: 64, radialSegments: 32, p: 2, q: 3 }, i.parameters); return { parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width), depth: Math.abs(e.depth ?? e.width), tube: e.tube ?? e.width * .125 }) } } static build (i) { let { width: t, tube: e, tubularSegments: n, radialSegments: r, p: s, q: o } = i.parameters, a = t * .5; a !== e && (a -= e); let l = new kc(a, e, n, r, s, o); return Object.assign(l, { userData: { ...i, type: "TorusKnotGeometry" } }) } }; var i2 = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, depth: 0, spikes: 5, cornerRadius: 0, extrudeBevelSize: 0, extrudeBevelSegments: 1, isRect: !1 }, i.parameters); return { shape: i.shape && i.shape instanceof Mt ? i.shape : new Mt, parameters: Object.assign(e, { width: Math.abs(e.width), height: Math.abs(e.height ?? e.width * (e.isRect ? 1 : Math.sqrt(3) / 2)), depth: Math.abs(e.depth ?? 0) }) } } static build (i) { let { width: t = 100, height: e, cornerRadius: n, depth: r, extrudeBevelSize: s, extrudeBevelSegments: o, isRect: a } = i.parameters, l = i.shape, u = t * .5, c = e * .5; a ? (l.addPoint(l.createPoint(-u, c)), l.addPoint(l.createPoint(u, -c)), l.addPoint(l.createPoint(-u, -c))) : (l.addPoint(l.createPoint(0, c)), l.addPoint(l.createPoint(u, -c)), l.addPoint(l.createPoint(-u, -c))), l.isClosed = !0; for (let d = 0, f = l.points.length; d < f; d++)l.points[d].roundness = n; l.roundness = n, l.update(); let h = Kr.create({ shape: l, parameters: { roundness: n, depth: r, extrudeBevelSize: s, extrudeBevelSegments: o } }); return Object.assign(h, { userData: { ...i, type: "TriangleGeometry" } }) } }; function s2 (i, t) { let e = 2 * Math.PI; return (i % e + e) % e === (t % e + e) % e } var vW = new se, xW = new se; function bW (i, t, e) { let n = [new A, new A, new A], r = [new A, new A, new A]; return i.extractBasis(n[0], n[1], n[2]), t.extractBasis(r[0], r[1], r[2]), n.forEach((s, o) => { let a = r[o], l = Ge.lerp(s.length(), a.length(), e); s.lerp(a, e).setLength(l) }), new se().makeBasis(n[0], n[1], n[2]) } var o2 = class { static create (i) { return this.build(this.normalizeInputs(i)) } static normalizeInputs (i, t) { let e = Object.assign({}, t?.parameters ?? { width: 100, height: 100, depth: 1, subdivisions: 12, roundness: 0, extrudeBevelSize: 0, extrudeBevelSegments: 3 }, i.parameters), n = Math.abs(e.width), r = Math.abs(e.height ?? e.width), s = Math.abs(e.depth ?? 0), o = t?.shapeData ?? dh.create({ parameters: Yb }).userData.shape; return { path: i.path ?? Nu.defaultData(), parameters: Object.assign(e, { width: n, height: r, depth: s, extrusion: { ...Kg, ...e.extrusion } }), shapeData: o } } static build (i) { if (i.path.points.length >= 2) { let e = new Xw(i); return Object.assign(e, { userData: { ...i, type: "PathGeometry" } }) } else return Object.assign(new Ce, { userData: { ...i, type: "PathGeometry" } }) } }, Xw = class extends Ce { constructor(e) { super(); this.type = "PathExtrusionGeometry", this.inputs = e, this.build() } _isGeometryClosed () { return this.inputs.path.isClosed && this.inputs.parameters.extrusion.depth === 1 } _isOpenEnded () { let e = this.inputs.parameters.extrusion; return !(this.inputs.path.isClosed && e.depth === 1) || !s2(e.twist, 0) || e.startScale !== e.endScale } build () { let e = this._extractPathPoints(); if (e.length < 2) return; let n = this._computeBasisMatrices(e), { depth: r, offset: s } = this.inputs.parameters.extrusion, o = this.inputs.path.isClosed ? e.length : e.length - 1, a = Math.floor(s * o), l = this.inputs.path.isClosed ? Math.ceil((r + s) * o) : Math.ceil(Math.min(1, r + s) * o), u = Math.min(Math.max(2, l - a + 1), o + 2), c = [], h = []; for (let G = 0; G < u; G++) { let z = this.inputs.path.isClosed ? (G + a) % e.length : Math.min(G + a, e.length - 1); c.push(e[z].clone()), h.push(n[z].clone()) } let d = (G, z, $) => { c[G] = c[G].clone().lerp(c[z], $), h[G] = bW(h[G], h[z], $) }, f = 0, p = s * o % 1; (!this.inputs.path.isClosed || r <= 1) && (p || s === 0) && (f = p, d(0, 1, f)); let m = 0, g = (s + r) * o % 1; if ((this.inputs.path.isClosed && r <= 1 || !this.inputs.path.isClosed && s + r < 1) && g && (m = g, d(c.length - 1, c.length - 2, 1 - m)), r === 0) { let G = c.length - 1; c[G].copy(c[0]), h[G].copy(h[0]) } this._applyPathModifiers(h, f, m); let { bevel: y, bevelSides: v } = this.inputs.parameters.extrusion, x = y > 0 ? this.inputs.parameters.extrusion.capType : "flat", b = 5; this.inputs.parameters.extrusion.shape.type === "Custom" && (b = this.inputs.parameters.extrusion.shape.shapeQuality === "low" ? 5 : 12); let { regions: S, infos: _, vertices: E } = this._computeShapePoints(b), w = 0, M; x === "round" && (M = new Ba(this.inputs.shapeData, 2 * y, y, b, v, void 0, !0), w = M.getAttribute("position").count); let T = 0, I = 0; _.sort((G, z) => G.start - z.start), _.forEach(G => { G.verticesStart = T, G.verticesCount = G.continuous.reduce((z, $, F) => z + (F === 0 || !$ ? 2 : 1), 0), I += G.verticesCount, T = I }); let C = I * u, P, D = 0; if (this._isOpenEnded() && x === "flat") { try { P = ns({ windingRule: yt.ODD, elementType: ln.POLYGONS, polySize: 3, vertexSize: 2, strict: !0, contours: S }) } catch { P = Uw } D = P.vertexCount } let L = C + 2 * D + w * 2, H = C + 2 * D, U = { positions: new Float32Array(L * 3), normals: new Float32Array(L * 3), uvs: new Float32Array(L * 2) }, V = []; if (_.forEach(G => { this._extrudeRegion(G, E, h, c, U, V, this._isGeometryClosed() && !this._isOpenEnded()) }), P && (this._closeEnd(P, C, V, U, h[0], c[0], !1), this._closeEnd(P, C + D, V, U, h[h.length - 1], c[c.length - 1], !0)), M) { U.positions.set(M.getAttribute("position").array, H * 3), U.normals.set(M.getAttribute("normal").array, H * 3), U.uvs.set(M.getAttribute("uv").array, H * 2); let G = V.length; V.push(...M.getIndex().array.map(F => F + H)), H += w, U.positions.set(M.getAttribute("position").array, H * 3), U.normals.set(M.getAttribute("normal").array, H * 3), U.uvs.set(M.getAttribute("uv").array, H * 2); let z = V.length; V.push(...M.getIndex().array.map(F => F + H)), this.setAttribute("position", new ze(U.positions, 3)), this.setAttribute("normal", new ze(U.normals, 3)), this.setAttribute("uv", new ze(U.uvs, 2)), this.setIndex(V); let $ = vW; $.copy(h[h.length - 1]).setPosition(c[c.length - 1]), this.applyMatrix4OnRange($, H, L), $.copy(h[0]).setPosition(c[0]).multiply(xW.makeScale(1, 1, -1)), this.applyMatrix4OnRange($, H - w, H), this.reverseIndicesOnRange(G, z) } else this.setAttribute("position", new ze(U.positions, 3)), this.setAttribute("normal", new ze(U.normals, 3)), this.setAttribute("uv", new ze(U.uvs, 2)), this.setIndex(V) } _extractPathPoints () { let n = by(this.inputs.path).getPoints(this.inputs.path.subdivisions); if (n.length < 2) return []; let r = [n[0]]; return n.forEach(o => { r[r.length - 1].distanceToSquared(o) > .001 && r.push(o) }), this.inputs.path.isClosed && r[r.length - 1].distanceTo(r[0]) < .001 && r.pop(), r } _computeBasisMatrices (e) { let n = [], r = e.length, s = this.inputs.path.isClosed, o = new A, a = new A, l = new A, u = new A, c = new A(0, 1, 0); for (let g = 0; g < r; g++) { let y = e[g], v; g === 0 ? v = s ? e[e.length - 2] : y.clone().multiplyScalar(2).sub(e[1]) : v = e[g - 1]; let x; g === r - 1 ? x = s ? e[1] : y.clone().multiplyScalar(2).sub(e[g - 1]) : x = e[g + 1]; let b = y.clone().sub(v).normalize(), S = x.clone().sub(y).normalize(), _ = b.clone().add(S).normalize(); l.copy(_), g === 0 && (_.equals(c) || _.clone().negate().equals(c)) && c.set(0, 0, 1); let E = c.clone().cross(_).normalize(), w = _.clone().cross(E).normalize(); c.copy(w), u.copy(E), g === 0 && (o.copy(w), a.copy(_)); let M = new se().makeBasis(E, w, _); n.push(M) } let h = s ? a : l, d = s ? o : new A(0, 1, 0), f = h.clone().cross(u).normalize(), p = Math.acos(d.dot(f)); if (isNaN(p)) return n; let m = d.clone().cross(f); h.dot(m) > 0 && (p *= -1); for (let g = 1; g < n.length; g++) { let y = new se().makeRotationZ(p * g / n.length); n[g].multiply(y) } return n } _applyPathModifiers (e, n, r) { let s = e.length, { angle: o, twist: a, startScale: l, endScale: u } = this.inputs.parameters.extrusion, c = new se, h = new se; return e.forEach((d, f) => { let p = f === 0 ? 0 : f === s - 1 ? 1 : (f - n) / (s - (r === 0 ? 0 : 1) - (n + (1 - r))); c.makeRotationZ(Ge.lerp(o, o + a, p)); let m = Ge.lerp(l, u, p); h.makeScale(m, m, m), d.multiply(c).multiply(h) }), e } _computeShapePoints (e = 12, n = yt.ODD) { let r = this.inputs.shapeData, s = r.extractShapePointsToFlatArray([], e), o = r.shapeHoles.map(m => { let g = m.extractShapePointsToFlatArray([], e), y = []; for (let v = g.length - 1; v >= 1; v -= 2) { let x = g[v - 1], b = g[v - 0]; y.push(x, b) } return y }), a; try { a = ns({ windingRule: n, elementType: ln.BOUNDARY_CONTOURS, vertexSize: 2, strict: !0, contours: [s] }) } catch { a = kf } let l; try { l = ns({ windingRule: yt.ODD, elementType: ln.BOUNDARY_CONTOURS, vertexSize: 2, strict: !0, contours: [...o] }) } catch { l = kw } if (!a) throw new Error("error generating geometry"); let u = a.elementCount; if (l) { a.elementCount += l.elementCount; for (let m = 0; m < l.elements.length; m++) { let g = l.elements[m], y = m % 2 === 0 ? a.vertexCount : 0; a.elements.push(g + y) } for (let m = 0; m < l.vertexIndices.length; m++) { let g = l.vertexIndices[m], y = a.vertexCount; a.vertexIndices.push(g + y) } for (let m = 0; m < l.vertices.length; m++) { let g = l.vertices[m]; a.vertices.push(g) } } let c = 1 / 0, h = -1 / 0, d = 1 / 0, f = -1 / 0; for (let m = 0, g = a.vertexCount; m < g; m++) { let y = m * 2, v = a.vertices[y + 0], x = a.vertices[y + 1]; v < c && (c = v), v > h && (h = v), x < d && (d = x), x > f && (f = x) } let p = []; for (let m = a.elementCount - 1; m >= 0; m--) { let g = m >= u, y = m * 2, v = a.elements[y + 0], x = a.elements[y + 1], b = v + x, S = { start: v, count: x, normals: [], isHole: g, continuous: [], verticesStart: 0, verticesCount: 0 }; p.push(S); let _ = v, E = b - 1, w = v + 1, M = r.roundedCurves.length; do { let T = _ - v, I = a.vertices[E * 2 + 0], C = a.vertices[E * 2 + 1], P = a.vertices[_ * 2 + 0], D = a.vertices[_ * 2 + 1], L = a.vertices[w * 2 + 0], H = a.vertices[w * 2 + 1], U = P - I, V = D - C, G = Math.sqrt(U * U + V * V); U /= G, V /= G; let z = P - L, $ = D - H, F = Math.sqrt(z * z + $ * $); z /= F, $ /= F, S.normals[T * 2 + 0] = -$, S.normals[T * 2 + 1] = z; let j = a.vertexIndices[_]; if (Array.isArray(j)) S.continuous[T] = !1; else { let [X, q] = r.getCurveIndexFromVertexId(j - 1, !0); if (q > 0 && q < 1) S.continuous[T] = !0; else { let k = q === 1 ? X + 1 : X - 1; k = (k + M) % M; let Z = q === 1 ? 0 : 1, K = r.roundedCurves[X].getTangent(q), Q = r.roundedCurves[k].getTangent(Z); S.continuous[T] = K.dot(Q) > .95 } } g && (S.normals[T * 2 + 0] *= -1, S.normals[T * 2 + 1] *= -1), [E, _, w] = [_, w, w + 1], w >= b && (w -= x) } while (w !== v + 1) } return { regions: [s, ...o], infos: p, vertices: a.vertices } } _insertVertex (e, n, r, s, o) { let a = n * 2, l = n * 3; e.positions[l + 0] = r.x, e.positions[l + 1] = r.y, e.positions[l + 2] = r.z, e.normals[l + 0] = s.x, e.normals[l + 1] = s.y, e.normals[l + 2] = s.z, e.uvs[a + 0] = o.x, e.uvs[a + 1] = o.y } _extrudeRegion (e, n, r, s, o, a, l) { let u = new A, c = new A, h = new A, d = new A, f = new B; r.forEach((m, g) => { let y = s[g], v = e.verticesStart * r.length + e.verticesCount * g; for (let x = 0; x < e.count; x++) { let b = (e.start + x) * 2; if (u.set(n[b + 0], n[b + 1], 0), h.copy(u).applyMatrix4(m).add(y), e.continuous[x]) d.set(e.normals[x * 2 + 0], e.normals[x * 2 + 1], 0); else { let S = x === 0 ? (e.start + e.count - 1) * 2 : b - 2; c.set(n[S + 0], n[S + 1], 0), d.copy(u).sub(c), d.set(-d.y, d.x, 0), e.isHole || d.negate() } if (d.applyMatrix4(m).normalize(), f.set(x === 0 ? 1 : x / e.count, g / (r.length - 1)), this._insertVertex(o, v, h, d, f), v++, !e.continuous[x] || x === 0) { if (x === 0) d.set(e.normals[x * 2 + 0], e.normals[x * 2 + 1], 0), f.set(0, g / (r.length - 1)); else { let S = x === e.count - 1 ? e.start * 2 : b + 2; c.set(n[S + 0], n[S + 1], 0), d.copy(c).sub(u), d.set(-d.y, d.x, 0), e.isHole || d.negate() } d.applyMatrix4(m).normalize(), this._insertVertex(o, v, h, d, f), v++ } } }); let p = r.length - 1; for (let m = 0; m < p; m++) { let g = e.verticesStart * r.length + e.verticesCount * m, y = e.verticesStart * r.length + e.verticesCount * (m + 1), v = 0; for (let x = 0; x < e.count; x++) { (!e.continuous[x] || x === 0) && v++; let b = x === e.count - 1 ? 0 : v + 1, S = g + v, _ = g + b, E = y + b, w = y + v; e.isHole ? a.push(S, E, _, S, w, E) : a.push(S, _, E, S, E, w), v++ } } } _closeEnd (e, n, r, s, o, a, l) { let u = e.vertexCount, c = new A(0, 0, l ? -1 : 1).applyMatrix4(o), h = new A, d = new B; for (let p = 0; p < u; p++) { let m = 2 * p; h.set(e.vertices[m + 0], e.vertices[m + 1], 0).applyMatrix4(o).add(a), this._insertVertex(s, n + p, h, c, d) } let f = e.elements; for (let p = 0; p < e.elementCount; p++) { let m = 3 * p, g = f[m + 0] + n, y = f[m + (l ? 1 : 2)] + n, v = f[m + (l ? 2 : 1)] + n; r.push(g, y, v) } } applyMatrix4OnRange (e, n, r) { let s = e.elements, o = new Xt().getNormalMatrix(e).elements, a, l, u, c, h = this.attributes.position, d = this.attributes.normal; if (!h || !d) return; let f = h.array, p = d.array, m = h.itemSize; for (let g = n * m, y = r * m; g < y; g += m) { if (g === n) debugger; a = f[g + 0], l = f[g + 1], u = f[g + 2], c = 1 / (s[3] * a + s[7] * l + s[11] * u + s[15]), f[g + 0] = (s[0] * a + s[4] * l + s[8] * u + s[12]) * c, f[g + 1] = (s[1] * a + s[5] * l + s[9] * u + s[13]) * c, f[g + 2] = (s[2] * a + s[6] * l + s[10] * u + s[14]) * c, a = p[g + 0], l = p[g + 1], u = p[g + 2], p[g + 0] = o[0] * a + o[3] * l + o[6] * u, p[g + 1] = o[1] * a + o[4] * l + o[7] * u, p[g + 2] = o[2] * a + o[5] * l + o[8] * u } h.needsUpdate = !0, d.needsUpdate = !0 } reverseIndicesOnRange (e, n) { let r = this.index; if (r) { for (let s = e; s < n; s += 3) { let o = r.getX(s), a = r.getX(s + 1), l = r.getX(s + 2); r.setXYZ(s, l, a, o) } r.needsUpdate = !0 } } }; function a2 () { let i = new Ce; return i.setAttribute("position", new ze(new Float32Array([]), 3)), i.setIndex(new ze(new Uint16Array([]), 1)), i } var wW = a2().attributes, SW = 12, AW = 1, mh = class extends Ce { constructor(e, n) { super(); this.charWidths = []; this.charCoords = []; this.wrappedText = []; this.isLowResolution = !1; this.vectorShapes = []; Object.assign(this.attributes, wW), this.userData = { parameters: e, type: "TextGeometry" }; let r = n.getFont(e.font); r?.isLoaded ? (this.font = r, this.update(e)) : this.updateFont(e.font, n).then(() => { this.update(e), n?.requestRender() }) } async updateFont (e, n) { let r = n.getFont(e); r && (this.font = r, await r.loadingPromise) } update (e) { let n = this.font; if (this.userData = { parameters: e, type: "TextGeometry" }, !n?.isLoaded) { console.warn("Cannot update text because its font is not loaded"); return } let { width: r, height: s, depth: o, extrudeBevelSize: a, extrudeBevelSegments: l, text: u, textTransform: c } = e, h = c === 2 ? u.toUpperCase() : c === 3 ? u.toLowerCase() : u, d = _W(e, n, h), { shapes: f, charWidths: p, charCoords: m } = n.generateShapes(d, e), g = r * .5, y = s * .5, v = f.map(S => new Mt().fromShape(S)); this.vectorShapes = v; let x = v.map(S => Kr.create({ shape: S, parameters: { depth: o, extrudeBevelSegments: l, extrudeBevelSize: a, windingRule: o <= 0 ? yt.NONZERO : yt.ODD, subdivisions: this.isLowResolution && o > 0 ? AW : SW } })), b = x.length ? Ji(x) : a2(); b.translate(-g, y, 0), this.dispose(), this.wrappedText = d, this.charCoords = m, this.charWidths = p, this.deleteAttribute("extrudeNormal"), Object.entries(b.attributes).forEach(([S, _]) => { this.setAttribute(S, _) }), this.setIndex(b.index), this.computeBoundingSphere() } clone () { let e = Qi(new Ce, mh.prototype); return e.copy(this), console.log("CloneGeometry", this, e), e } copy (e) { return Object.entries(e.attributes).forEach(([n, r]) => { this.setAttribute(n, r) }), this.setIndex(e.index), this.userData = { parameters: { ...e.userData.parameters }, type: "TextGeometry" }, this } async setText (e) { this.font && await this.font.loadingPromise, await this.update({ ...this.userData.parameters, text: e }) } get text () { return this.userData.parameters.text ?? "" } }; function _W (i, t, e) {
	e = e ?? i.text; let n = [""], r = ""; for (let s of e) r += s, s === " " || s === `
`? (n[n.length - 1] += r, r = "", s === `
`&& n.push("")) : t.getTextWidth(n[n.length - 1] + r, i) > i.width && (n[n.length - 1].length && n.push(""), t.getTextWidth(n[n.length - 1] + r, i) > i.width && (r.length === 1 ? (n[n.length - 1] += r, r = "") : (n[n.length - 1] += r.slice(0, -1), r = r[r.length - 1], n.push("")))); return n[n.length - 1] += r, n
} var c2, gh = new Promise(i => { c2 = i }), l2 = !1; var Ny; function u2 () { if (l2) return; if (Ny) return Ny; async function i () { let e = !1 ? "." : "https://unpkg.com/@splinetool/modelling-wasm@0.9.437/build", r = import("./process.js"), [s, o] = await Promise.all([r, fetch(`${e}/process.wasm`).then(u => u.arrayBuffer())]), a = s.default, l = await a({ wasmBinary: o }); c2(l), l2 = !0 } return Ny = i(), Ny } function kl (i, t, e) { let n = { parameters: i, type: i.type }; if (i.type === "PathGeometry") n.path = i.path; else if (i.type === "VectorGeometry") { let s = Mt.createFromState(i.shape, i.width, i.height); n.shape = s } else if (i.type === "NonParametricGeometry") i.data.groups && i.data.groups.forEach(s => s.materialIndex = Math.max(s.materialIndex ?? 0, 0)), n.geometry = new Wc().parse(i); else { if (i.type === "SubdivGeometry") return new An(i, e); if (i.type === "TextGeometry") return new mh(i, t) } let r; try { r = Qw(n) } catch (s) { console.error(s) } if (!r) { let s = Mt.createFromState(Lu.defaultData(), 100, 100); n.shape = s, r = Qw(n) } return r } var EW = new se; function Vf (i, t, e, n) { let r = i.position.array, s = i.normal.array, o = EW.makeScale(t, e, n).invert().elements, a, l, u; for (var c = 0, h = r.length; c < h; c += 3)r[c] *= t, r[c + 1] *= e, r[c + 2] *= n, a = s[c], l = s[c + 1], u = s[c + 2], s[c] = o[0] * a + o[4] * l + o[8] * u, s[c + 1] = o[1] * a + o[5] * l + o[9] * u, s[c + 2] = o[2] * a + o[6] * l + o[10] * u; i.position.needsUpdate = !0, i.normal.needsUpdate = !0 } var By = new _t, yh = new A, $e; gh.then(i => { $e = i }); var h2 = new Float32Array([10, 10, 0, -10, 10, 0, -10, -10, 0, 10, -10, 0]), d2 = new Uint32Array([0, 1, 2, 3]), f2 = new Uint8Array([4]), An = class extends Ce { constructor(e, n) { super(); this.data = e; this.flatShading = n; this.subdivPointer = 0; this.rebuild(), this.freeSubdivPointer() } mutateDirectlyScaleBaked (e, n) { this.freeSubdivPointer(); let r = this.data.scaleBaked, s = Ts.div(n, r); this.subdividedGeometry && Vf(this.subdividedGeometry.attributes, ...s), this.originalGeometry && Vf(this.originalGeometry.attributes, ...s), this.data = e; let o = this.userData.parameters; this.userData.parameters = { width: o.width * s[0], height: o.height * s[1], depth: o.depth * s[2] }, this.originalGeometry.boundingSphere.center.multiply(yh.fromArray(s)); let a = yh.set(o.width, o.height, o.depth).length(); this.originalGeometry.boundingSphere.radius = a / 2 } ensureSubdivPointer () { return this.subdivPointer === 0 && this.rebuild(), this.subdivPointer } rebuild () { let e, n, r; try { ({ originalGeometry: e, subdividedGeometry: n, subdivPointer: r } = An.build(this.data, void 0, !this.flatShading, void 0)) } catch { e = new er(100, 100, 100), r = 0 } this.subdivPointer = r, this.originalGeometry = e, this.subdividedGeometry = n ?? void 0; let s = this.subdividedGeometry ?? this.originalGeometry; Object.assign(this, s), this.calcBoundingBox() } freeSubdivPointer () { this.subdivPointer && (An.freeSubdivPointer(this.subdivPointer), this.subdivPointer = 0) } dispose () { super.dispose(), this.freeSubdivPointer() } calcBoundingBox () { let e = this.originalGeometry; e.boundingSphere === null && (e.boundingSphere = new dn, this.subdividedGeometry && (this.subdividedGeometry.boundingSphere = e.boundingSphere)); let n = e.attributes.position, r = e.boundingSphere.center; By.setFromBufferAttribute(n), By.getCenter(r), e.boundingSphere.radius = r.distanceTo(By.max), isNaN(e.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), By.getSize(yh); let s = { width: yh.x, height: yh.y, depth: yh.z }; return this.userData.parameters = s, s } static build (e, n, r, s) { let o, a, l, u = e?.phongAngle ?? 35; r === !1 && (u = -1), n && ($e.free_bvh(n), $e.free_subdivision_surface(n)); try { o = An.allocate(e, s) } catch (c) { console.error(c, e), o = An.allocate({ positionWASM: h2, indexWASM: d2, verticesPerFaceWASM: f2 }, s) } if ($e.set_destination_refinement_level(o, 0), a = An.buildLevel(o, !0, u), e.subdivisions > 0) try { $e.set_destination_refinement_level(o, e.subdivisions), l = An.buildLevel(o, !1, u) } catch { try { $e.set_destination_refinement_level(o, e.subdivisions - 1), l = An.buildLevel(o, !1, u) } catch { l = null } } else l = null; return { subdivPointer: o, originalGeometry: a, subdividedGeometry: l } } static primitiveToQuads (e, n, r) { e.widthSegments > 16 && (e.widthSegments = 16), e.heightSegments > 16 && (e.heightSegments = 16), e.depthSegments > 16 && (e.depthSegments = 16), e.radialSegments > 16 && (e.radialSegments = 16), e.type === "DodecahedronGeometry" && (e.detail = 0); let s = e.shape !== void 0 || e.path !== void 0 ? n.geometry : kl(e, r, !1), o; e.type === "TorusGeometry" && e.arc === Math.PI * 2 ? o = s.getClosedTorusIndicesForBooleanOrSubdiv() : o = s.getIndex(); let a, l, u, c; ({ positions: a, triIndices: c } = Ul(s.getAttribute("position"), o)); let h; if (e.type === "CylinderGeometry" && e.cornerRadius === 0 && e.hollow === 0 && e.openEnded === !1) { let d = e.radialSegments * e.heightSegments * 3 * 2, f = d + e.radialSegments * 3; h = [d, f] } return { indices: l, verticesPerFace: u } = $w(a, c, s, h), { positions: a, indices: l, verticesPerFace: u } } static allocate (e, n) { let r, s, o, a = [], l = []; e.positionWASM && e.positionWASM.length > 0 ? (r = e.positionWASM, s = e.indexWASM, o = e.verticesPerFaceWASM) : (r = h2, s = d2, o = f2); let u = r.length, c = s.length, h = o.length, d = r.length + a.length + l.length, f = s.length + o.length, p = d * Float32Array.BYTES_PER_ELEMENT + f * Uint32Array.BYTES_PER_ELEMENT, m = d * Float32Array.BYTES_PER_ELEMENT, g = f * Uint32Array.BYTES_PER_ELEMENT, y = $e._malloc(p), v = new Float32Array($e.HEAPF32.buffer, y, d), x = new Uint32Array($e.HEAPU32.buffer, y + m, f); v.set(r, 0), v.set(a, r.length), v.set(l, r.length + a.length), x.set(s, 0), x.set(o, s.length); let b; e?.scaleBaked?.some(_ => _ !== 1) && (b = new se().makeScale(...e.scaleBaked)), n && (b ? b.premultiply(n) : b = n); let S = b ? $e.alloc_subdivision_surface2(y, u, y + m, c, y + m + s.length * Uint32Array.BYTES_PER_ELEMENT, h, b.elements) : $e.alloc_subdivision_surface(y, u, y + m, c, y + m + s.length * Uint32Array.BYTES_PER_ELEMENT, h); return $e._free(y), S } static buildLevel (e, n, r, s, o) { let a = o ? $e.get_mesh_data2(e, n ? $e.Level.CONTROL : $e.Level.REFINED, r, o.elements) : $e.get_mesh_data(e, n ? $e.Level.CONTROL : $e.Level.REFINED, r), l = 8, u = $e.HEAPU32.subarray(a >> 2, (a >> 2) + l), c = u.subarray(4, 4 + 4), h = 0, d = $e.HEAPU32[u[h] >> 2], f = $e.HEAPF32.subarray(d >> 2, (d >> 2) + c[h]); h++; let p = $e.HEAPU32[u[h] >> 2], m = $e.HEAPF32.subarray(p >> 2, (p >> 2) + c[h]); h++; let g = $e.HEAPU32[u[h] >> 2], y = $e.HEAPU32.subarray(g >> 2, (g >> 2) + c[h]); h++; let v = $e.HEAPU32[u[h] >> 2], x = $e.HEAPU32.subarray(v >> 2, (v >> 2) + c[h]); if (h++, s === void 0) { let b = new Ce; if (b.setIndex(new xs(x, 1)), b.setAttribute("position", new _e(f, 3)), b.setAttribute("normal", new _e(m, 3)), n) { b.setAttribute("faceMap", new xs(y, 1)); let S = new Float32Array(m.length / 3 * 4).fill(0); b.setAttribute("color", new ze(S, 4)) } return $e.free_mesh_data(a), b.userData.type = "SubdivGeometry", b } s.getAttribute("position").copyArray(f), s.getAttribute("normal").copyArray(m), s.attributes.position.needsUpdate = !0, s.attributes.normal.needsUpdate = !0, $e.free_mesh_data(a) } static freeSubdivPointer (e) { $e.free_bvh(e), $e.free_subdivision_surface(e) } static buildControlCageWireframe (e, n, r) { let s = $e.get_wireframe_data_for_base_level(e), o = 4, a = $e.HEAPU32.subarray(s >> 2, (s >> 2) + o), l = a.subarray(2, 2 + 2), u = 0, c = $e.HEAPU32[a[u] >> 2], h = $e.HEAPF32.subarray(c >> 2, (c >> 2) + l[u]); u++; let d = $e.HEAPU32[a[u] >> 2], f = $e.HEAPU32.subarray(d >> 2, (d >> 2) + l[u]); if (n === void 0) { let p = new Ce; p.setAttribute("position", new _e(h, 3)); let m = new Float32Array(h.length); for (let g = 0, y = h.length; g < y;)m[g++] = r.r, m[g++] = r.g, m[g++] = r.b; return p.setAttribute("color", new ze(m, 3)), p.setIndex(new xs(f, 1)), $e.free_wireframe_data_for_base_level(s), p } n.getAttribute("position").copyArray(h), n.attributes.position.needsUpdate = !0, $e.free_wireframe_data_for_base_level(s) } static updateCollabMesh (e, n, r) { let s = n === 0; s || $e.set_destination_refinement_level(e, n); let o = r ? $e.get_topological_data2(e, s ? $e.Level.CONTROL : $e.Level.REFINED, r.elements) : $e.get_topological_data(e, s ? $e.Level.CONTROL : $e.Level.REFINED), a = 6, l = $e.HEAPU32.subarray(o >> 2, (o >> 2) + a), u = l.subarray(3, 3 + 3), c = 0, h = $e.HEAPU32[l[c] >> 2], d = new Float32Array($e.HEAPF32.subarray(h >> 2, (h >> 2) + u[c])); c++; let f = $e.HEAPU32[l[c] >> 2], p = new Uint32Array($e.HEAPU32.subarray(f >> 2, (f >> 2) + u[c])); c++; let m = $e.HEAPU32[l[c] >> 2], g = new Uint8Array($e.HEAPU32.subarray(m >> 2, (m >> 2) + u[c])); return $e.free_topological_data(o), { positions: d, indices: p, verticesPerFace: g } } }; var p2 = ["getX", "getY", "getZ"]; function Ul (i, t) { let e = {}, n = t ? t.count : i.count, r = 0, s = [], o = [], a = 1e4; for (let u = 0; u < n; u++) { let c = t ? t.getX(u) : u, h = ""; for (let d = 0; d < 3; d++)h += `${~~(i[p2[d]](c) * a)},`; if (h in e) s.push(e[h]); else { for (let d = 0; d < 3; d++)o.push(i[p2[d]](c)); e[h] = r, s.push(r), r++ } } let l = []; for (let u = 0; u < s.length; u += 3)s[u] === s[u + 1] || s[u] === s[u + 2] || s[u + 1] === s[u + 2] || l.push(s[u], s[u + 1], s[u + 2]); return { positions: o, triIndices: l } } var Fy = new A, Kw = new A, Zw = new A, Jw = new A; function $w (i, t, e, n) { let r = [], s = []; if (e.userData.shape !== void 0 && e.userData.parameters.depth === 0 && e.userData.shape.shapeHoles.length === 0) { let l = e.userData.shape.extractShapePointsToFlatArray([]), u = e.userData.parameters.spikes; if (e.userData.type === "EllipseGeometry" && u <= 24 && u % 4 === 0 && e.userData.parameters.angle >= 360) { let d = l.length / 2 / u; l = l.filter((f, p) => Math.floor(p / 2) % d === 0) } let c = 0; for (let d = 0; d < l.length; d += 2)c += (l[d] - l[(d === 0 ? l.length : d) - 2]) * (l[d + 1] + l[(d === 0 ? l.length : d) - 1]); i.length = 0; let h = 0; if (c < 0) for (let d = 0; d < l.length; d += 2)i.push(l[d], l[d + 1], 0), r.push(h++); else for (let d = l.length - 2; d >= 0; d -= 2)i.push(l[d], l[d + 1], 0), r.push(h++); return s.push(h), { indices: r, verticesPerFace: s } } let o = new Float32Array([e.userData.parameters.depth])[0], a = 0; for (; a < t.length;) { if (e.useNgonForTopBottomFaceDuringBake) { let l = 0; if ((i[t[a] * 3 + 2] === o || i[t[a] * 3 + 2] === 0) && l++, (i[t[a + 1] * 3 + 2] === o || i[t[a + 1] * 3 + 2] === 0) && l++, (i[t[a + 2] * 3 + 2] === o || i[t[a + 2] * 3 + 2] === 0) && l++, l === 3) break } if (t[a + 1] === t[a + 3] && t[a + 2] === t[a + 5] || t[a + 0] === t[a + 3] && t[a + 2] === t[a + 4]) { Fy.set(i[t[a] * 3], i[t[a] * 3 + 1], i[t[a] * 3 + 2]), Kw.set(i[t[a + 1] * 3], i[t[a + 1] * 3 + 1], i[t[a + 1] * 3 + 2]), Zw.set(i[t[a + 4] * 3], i[t[a + 4] * 3 + 1], i[t[a + 4] * 3 + 2]), Jw.set(i[t[a + 5] * 3], i[t[a + 5] * 3 + 1], i[t[a + 5] * 3 + 2]), Kw.sub(Fy).normalize(), Zw.sub(Fy).normalize(), Jw.sub(Fy).normalize(); let l = Kw.cross(Zw).dot(Jw); Math.abs(l) > .005 || n && n.some((u, c) => c % 2 === 1 ? !1 : a >= n[c] && a < n[c + 1]) ? (r.push(t[a], t[a + 1], t[a + 2]), s.push(3), a += 3) : (r.push(t[a], t[a + 1], t[a + 4], t[a + 5]), s.push(4), a += 6) } else r.push(t[a], t[a + 1], t[a + 2]), s.push(3), a += 3 } if (e.useNgonForTopBottomFaceDuringBake) { let l = [], u = [], c = 0; for (let h = 0, d = 0; h < i.length; h += 3, d++)i[h + 2] === 0 && (l.push(d), c++), i[h + 2] === o && u.push(d); if (e.userData.parameters.extrudeBevelSize === 0) { let h = u[0]; u[0] = u[1], u[1] = h } l.reverse(), r.push(...l, ...u), s.push(c, c) } return { indices: r, verticesPerFace: s } } var Ii = {}; eR(Ii, { calcBoolean: () => CW, calcBooleanTopological: () => TW, freeMeshSet: () => OW, getMeshSet: () => PW, hasOpenEdges: () => IW, transformMeshSet: () => DW }); var m2, g2 = new Promise(i => { m2 = i }); var ky; function y2 () { if (ky) return ky; async function i () { let e = !1 ? "." : "https://unpkg.com/@splinetool/boolean-wasm@0.9.437/build", r = import("./boolean.js"), [s, o] = await Promise.all([r, fetch(`${e}/boolean.wasm`).then(u => u.arrayBuffer())]), a = s.default, l = await a({ wasmBinary: o }); m2(l) } return ky = i(), ky } var ut, vh; g2.then(i => ut = i); function MW (i, t, e) { let n, r; i.userData.parameters.type === "TorusGeometry" && i.userData.parameters.arc === Math.PI * 2 ? r = i.getClosedTorusIndicesForBooleanOrSubdiv() : r = i.getIndex(); let { positions: s, triIndices: o } = Ul(i.getAttribute("position"), r), a; if (t && e) { let { indices: l, verticesPerFace: u } = $w(s, o, i); a = u.length, n = []; for (let c = 0, h = 0; c < a; c++) { n.push(u[c]); for (let d = 0; d < u[c]; d++)n.push(l[h++]) } } else { let l = o.length; n = Array(l + l / 3), a = 0; for (let u = 0, c = 0; c < n.length;)n[c++] = 3, a++, n[c++] = o[u++], n[c++] = o[u++], n[c++] = o[u++] } return { positions: s, faceIndices: n, nFaces: a } } function v2 (i) { let t = i.length, e = t * Uint32Array.BYTES_PER_ELEMENT, n = t * Float32Array.BYTES_PER_ELEMENT, r = Number.isInteger(i[0]) ? e : n, s = ut._malloc(r); return (Number.isInteger(i[0]) ? new Uint32Array(ut.HEAPU32.buffer, s, t) : new Float32Array(ut.HEAPF32.buffer, s, t)).set(i, 0), s } function x2 (i) { switch (i) { case 0: return ut.OP.UNION; case 1: return ut.OP.INTERSECTION; case 2: return ut.OP.A_MINUS_B; case 3: return ut.OP.B_MINUS_A; case 4: return ut.OP.SYMMETRIC_DIFFERENCE; case 5: return ut.OP.ALL; default: throw new Error("Unknown boolean operation " + i) } } function TW (i, t) { vh === void 0 && (vh = ut.init_csg()); let e = v2(i), n = ut.csg_calc_topological(vh, e, i.length, x2(t)); ut._free(e); let r = 6, s = ut.HEAPU32.subarray(n >> 2, (n >> 2) + r), o = s.subarray(3, 3 + 3), a = 0, l = ut.HEAPU32[s[a] >> 2], u = new Float32Array(ut.HEAPF32.subarray(l >> 2, (l >> 2) + o[a])); a++; let c = ut.HEAPU32[s[a] >> 2], h = new Uint32Array(ut.HEAPU32.subarray(c >> 2, (c >> 2) + o[a])); a++; let d = ut.HEAPU32[s[a] >> 2], f = new Uint8Array(ut.HEAPU32.subarray(d >> 2, (d >> 2) + o[a])); return ut.free_mesh_data(n), { positions: u, indices: h, verticesPerFace: f } } function CW (i, t, e, n) { vh === void 0 && (vh = ut.init_csg()); let r = v2(i), s = ut.csg_calc(vh, r, i.length, n, x2(t)); ut._free(r); let o = 5, a = ut.HEAPU32.subarray(s >> 2, (s >> 2) + o), l = a.subarray(2, 2 + 3), u = 0, c = ut.HEAPU32[a[u] >> 2], h = ut.HEAPF32.subarray(c >> 2, (c >> 2) + l[u]); u++; let d = ut.HEAPU32[a[u] >> 2], f = ut.HEAPF32.subarray(d >> 2, (d >> 2) + l[u]); u++; let p = l[u]; e.setAttribute("position", new _e(h, 3)), e.setAttribute("normal", new _e(f, 3)); let m = ut.HEAPF32.subarray((s >> 2) + 5, (s >> 2) + 5 + 6); return e.boundingSphere === null && (e.boundingSphere = new dn), e.boundingSphere.center.set(m[0], m[1], m[2]), e.boundingSphere.radius = (m[3] ** 2 + m[4] ** 2 + m[5] ** 2) ** .5, e.userData.parameters = { width: m[3] * 2, height: m[4] * 2, depth: m[5] * 2 }, ut.free_mesh_data(s), p } function PW (i, t, e) { if (ut === void 0) return -1; let n, r, s; if (t && i.userData.positions !== void 0) { let g = i.userData; s = g.verticesPerFace.length, n = g.positions, r = Array(g.verticesPerFace.reduce((y, v) => y + v, 0) + s); for (let y = 0, v = 0, x = 0; y < g.verticesPerFace.length; y++) { r[x++] = g.verticesPerFace[y]; for (let b = 0; b < g.verticesPerFace[y]; b++)r[x++] = g.indices[v++] } } else ({ positions: n, faceIndices: r, nFaces: s } = MW(i, t, e)); let o = n.length, a = r.length, l = n.length, u = r.length, c = l * Float32Array.BYTES_PER_ELEMENT + u * Uint32Array.BYTES_PER_ELEMENT, h = l * Float32Array.BYTES_PER_ELEMENT, d = u * Uint32Array.BYTES_PER_ELEMENT, f = ut._malloc(c), p = new Float32Array(ut.HEAPF32.buffer, f, l), m = new Uint32Array(ut.HEAPU32.buffer, f + h, u); return p.set(n, 0), m.set(r, 0), ut.get_csg_mesh(f, o, f + h, a, s) } function IW (i) { return ut.has_open_edges(i) } function DW (i, t) { ut.transform_csg_mesh(i, t.elements) } function OW (i) { ut.free_csg_mesh(i) } var RW = { ConeGeometry: fP, CubeGeometry: pP, CylinderGeometry: wy, DodecahedronGeometry: mP, EllipseGeometry: dh, HelixGeometry: jP, IcosahedronGeometry: WP, LatheGeometry: qP, NonParametricGeometry: KP, PolygonGeometry: Oy, PyramidGeometry: ZP, RectangleGeometry: Ry, SphereGeometry: JP, PlaneGeometry: $P, BackdropGeometry: e2, StarGeometry: Ly, TextFrameGeometry: t2, TorusGeometry: n2, TorusKnotGeometry: r2, TriangleGeometry: i2, PathGeometry: o2, VectorGeometry: Kr }, Qw = i => RW[i.type].create(i); function Hf (i) { return i !== null && "booleanOp" in i } var xh = class extends ih(Rn) { constructor() { super(...arguments); this.booleanMeshSetAddress = -1; this.booleanWasTransformed = !1; this.booleanMatrixInvOld = new se } updateVisible () { super.updateVisible(), this.visible = !Hf(this.parent) && this.visible, Hf(this.parent) && this.parent.invalidateDownstreamBooleanData() } freeBooleanPointer () { this.booleanMeshSetAddress !== -1 && (Ii.freeMeshSet(this.booleanMeshSetAddress), this.booleanMeshSetAddress = -1) } invalidateDownstreamBooleanData (e = !1) { return e ? this.booleanWasTransformed = !0 : this.freeBooleanPointer(), Hf(this.parent) ? this.parent.invalidateDownstreamBooleanData() : this } invalidateUpstreamBooleanData () { this.freeBooleanPointer(); for (let e of this.children) e instanceof xh && (e.freeBooleanPointer(), Hf(e) && e.invalidateUpstreamBooleanData()) } updateTransformState (e) { let n = super.updateTransformState(e); return n && Hf(this.parent) && this.invalidateDownstreamBooleanData(!0), n } }; var Uy = new _t; function jf (i, t = 0, e = i.count, n, r) { let s = 1 / 0, o = 1 / 0, a = 1 / 0, l = -1 / 0, u = -1 / 0, c = -1 / 0; for (let h = t; h < e; h++) { let d = i.getX(h), f = i.getY(h), p = i.getZ(h); d < s && (s = d), f < o && (o = f), p < a && (a = p), d > l && (l = d), f > u && (u = f), p > c && (c = p) } Uy.min.set(s, o, a), Uy.max.set(l, u, c), Uy.getCenter(n), Uy.getSize(r).multiplyScalar(.5) } var LW = new Ce, NW = new po, Ht = class extends xh { constructor(t, e) { super(LW, NW), this.super_Entity(t, e) } updateState (t, e) { this.updateState_Entity(t, e) } updateEntityBoxSize (t, e) { let n = this.geometry.getAttribute("position"); n !== void 0 ? jf(n, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : n.count, t, e) : super.updateEntityBoxSize(t, e) } }; var Wf = class { constructor(t) { t = t ?? {}, this.name = t.name, this.type = t.type, this.node = t.node, this.size = t.size, this.needsUpdate = t.needsUpdate } get value () { return this.node.value } set value (t) { this.node.value = t } }; var lr = class { constructor(t) { this.hashProperties = void 0; this.isNode = !0; this.shortcuts = {}; this.uuid = Ge.generateUUID(), this.type = t, this.name = "" } analyze (t, e) { e = e ?? {}, t.analyzing = !0, this.build(t.addFlow(e.slot, e.cache, e.context), "v4"), t.clearVertexNodeCode(), t.clearFragmentNodeCode(), t.removeFlow(), t.analyzing = !1 } analyzeAndFlow (t, e, n) { return n = n ?? {}, this.analyze(t, n), this.flow(t, e, n) } flow (t, e, n) { n = n ?? {}, t.addFlow(n.slot, n.cache, n.context); let r = { result: this.build(t, e), code: t.clearNodeCode(), extra: t.context.extra }; return t.removeFlow(), r } build (t, e, n) { e = e ?? this.getType(t, e); let r = t.getNodeData(n ?? this); return t.analyzing && this.appendDepsNode(t, r, e), t.nodes.indexOf(this) === -1 && t.nodes.push(this), this.updateFrame !== void 0 && t.updaters.indexOf(this) === -1 && t.updaters.push(this), this.generate(t, e, n) } updateFrame (t) { } generateReadonly (t, e, n, r, s, o) { return "" } generate (t, e, n, r, s) { return "" } parse (t, e, n, r) { } appendDepsNode (t, e, n) { e.deps = (e.deps || 0) + 1; let r = t.getTypeLength(n); (r > (e.outputMax || 0) || this.getType(t, n)) && (e.outputMax = r, e.output = n) } setName (t) { this.name = t } getName () { return this.name } getType (t, e) { return e === "sampler2D" || e === "samplerCube" ? e : this.type } getHash () { let t = "{", e, n; for (e in this) n = this[e], n instanceof lr && (t += '"' + e + '":' + n.getHash() + ","); if (this.hashProperties) for (let r = 0; r < this.hashProperties.length; r++)e = this.hashProperties[r], n = this[e], t += '"' + e + '":"' + String(n) + '",'; return t += '"id":"' + this.uuid + '"}', t } }; var eS = class { constructor() { this.nodes = {}; this.keywords = {} } add (t) { this.nodes[t.name] = t } addKeyword (t, e, n) { n = n !== void 0 ? n : !0, this.keywords[t] = { callback: e, cache: n } } remove (t) { delete this.nodes[t.name] } removeKeyword (t) { delete this.keywords[t] } get (t) { return this.nodes[t] } getKeyword (t, e) { return this.keywords[t].callback(e) } getKeywordData (t) { return this.keywords[t] } contains (t) { return this.nodes[t] !== void 0 } containsKeyword (t) { return this.keywords[t] !== void 0 } }, Xn = new eS; var We = class extends lr { constructor(e, n) { super(e); this.scope = ""; n = n ?? {}, this.shared = n.shared !== void 0 ? n.shared : !0, this.unique = n.unique !== void 0 ? n.unique : !1 } build (e, n, r, s) { if (n = n ?? this.getType(e), this.getShared(e, n)) { let o = this.getUnique(e, n); o && this.uuid === void 0 && (this.uuid = Ge.generateUUID()), r = e.getUUID(r ?? this.getUUID(), !o); let a = e.getNodeData(r), l = a.output || this.getType(e); if (e.analyzing) return (a.deps || 0) > 0 || this.getLabel() ? (this.appendDepsNode(e, a, n), this.generate(e, n, r)) : super.build(e, n, r); if (o) return a.name = a.name || super.build(e, n, r), a.name; if (!this.getLabel() && (!this.getShared(e, l) || e.context.ignoreCache || a.deps === 1)) return super.build(e, n, r); r = this.getUUID(!1); let u = this.getTemp(e, r); if (u) return e.format(u, l, n); { u = super.generate(e, n, r, a.output, s); let c = this.generate(e, l, r); return e.addNodeCode(u + " = " + c + ";"), e.format(u, l, n) } } return super.build(e, n, r) } getShared (e, n) { return n !== "sampler2D" && n !== "samplerCube" && this.shared } getUnique (e, n) { return this.unique } setLabel (e) { return this.label = e, this } getLabel () { return this.label } getUUID (e) { let n = this.uuid; return typeof this.scope == "string" && (n = this.scope + "-" + n), n } getTemp (e, n) { n = n || this.uuid; let r = e.getVars()[n]; return r ? r.name : void 0 } generate (e, n, r, s, o) { return this.getShared(e, n) || console.error("TempNode is not shared"), r = r ?? this.uuid, e.getTempVar(r, s ?? this.getType(e), o, this.getLabel()).name } }; var Bt = class extends We { constructor(e, n) { n = n ?? {}, n.shared = n.shared !== void 0 ? n.shared : !1; super(e, n); this.readonly = !1 } setReadonly (e) { return this.readonly = e, this.hashProperties = this.readonly ? ["value"] : void 0, this } getReadonly () { return this.readonly } generate (e, n, r, s, o, a) { r = e.getUUID(r ?? this.getUUID()), s = s ?? this.getType(e); let l = e.getNodeData(r); return this.getReadonly() && this.generateReadonly !== void 0 ? this.generateReadonly(e, n, r, s, o, a) : e.isShader("vertex") ? (l.vertex || (l.vertex = e.createVertexUniform(s, this, o, a, this.getLabel())), e.format(l.vertex.name, s, n)) : (l.fragment || (l.fragment = e.createFragmentUniform(s, this, o, a, this.getLabel())), e.format(l.fragment.name, s, n)) } }; var cn = class extends Bt { constructor(e = 0, n) { super("v2"); this.nodeType = "Vector2"; this.value = e instanceof B ? e : new B(e, n) } get x () { return this.value.x } set x (e) { this.value.x = e } get y () { return this.value.y } set y (e) { this.value.y = e } generateReadonly (e, n, r, s, o, a) { return e.format("vec2(" + this.value.x + ", " + this.value.y + ")", s, n) } }; var wr = class extends Bt { constructor(e = 0, n, r) { super("v3"); this.nodeType = "Vector3"; this.value = e instanceof A ? e : new A(e, n, r) } get x () { return this.value.x } set x (e) { this.value.x = e } get y () { return this.value.y } set y (e) { this.value.y = e } get z () { return this.value.z } set z (e) { this.value.z = e } generateReadonly (e, n, r, s, o, a) { return e.format("vec3(" + this.value.x + ", " + this.value.y + ", " + this.value.z + ")", s, n) } }; var on = class extends Le { constructor(e, n, r, s) { super(e, n, r); this.isColorA = !0; this.a = s } setRGBA (e, n, r, s) { super.setRGB(e, n, r), this.a = s } copy (e) { return super.copy(e), this.a = "a" in e ? e.a : 1, this } clone () { return new this.constructor(this.r, this.g, this.b, this.a) } setStyle (e, n = "srgb") { let r; if (e === "transparent") return this.setRGBA(0, 0, 0, 0), this; if (r = /^((?:rgb|hsl)a?)\(([^)]*)\)/.exec(e)) { let s, o = r[1], a = r[2]; switch (o) { case "rgb": case "rgba": if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.a = o === "rgba" ? parseFloat(s[4]) : 1, super.setStyle(e, n); break; case "hsl": case "hsla": if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)%\s*,\s*(\d*\.?\d+)%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return this.a = o === "hsla" ? parseFloat(s[4]) : 1, super.setStyle(e, n); break } } return super.setStyle(e, n) } get x () { return this.r } get y () { return this.g } get z () { return this.b } get w () { return this.a } set x (e) { this.r = e } set y (e) { this.g = e } set z (e) { this.b = e } set w (e) { this.a = e } }; var Zr = class extends Bt { constructor(e) { super("v4"); this.nodeType = "Vector4"; this.value = e instanceof on ? e : new on(e.r, e.g, e.b, e.a) } generateReadonly (e, n, r, s, o, a) { return e.format("vec4(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ", " + this.value.a + ")", s, n) } }; var BW = /^\s*([a-z_0-9]+)\s([a-z_0-9]+)\s*\((.*?)\)/i, b2 = /[a-z_0-9]+/gi, me = class extends We { constructor(e, n, r, s, o) { super(o); this.src = ""; this.nodeType = "Function"; this.useKeywords = !0; this.includes = []; this.extensions = {}; this.keywords = {}; this.isMethod = o === void 0, this.isInterface = !1, this.parse(e, n, r, s) } getShared (e, n) { return !this.isMethod } getType (e) { return e.getTypeByFormat(this.type) } getInputByName (e) { if (this.inputs) { let n = this.inputs.length; for (; n--;)if (this.inputs[n].name === e) return this.inputs[n] } } getIncludeByName (e) { if (this.includes) { let n = this.includes.length; for (; n--;)if (this.includes[n].name === e) return this.includes[n] } } generate (e, n, r, s, o) { let a, l = 0, u = this.src; if (this.includes) for (let h = 0; h < this.includes.length; h++)e.include(this.includes[h], this); for (let h in this.extensions) e.extensions[h] = !0; let c = []; for (; a = b2.exec(this.src);)c.push(a); for (let h = 0; h < c.length; h++) { let d = c[h], f = d[0], p = this.isMethod ? !this.getInputByName(f) : !0, m = f; if (this.keywords[f] || this.useKeywords && p && Xn.containsKeyword(f)) { let g = this.keywords[f]; if (!g) { let y = Xn.getKeywordData(f); y.cache && (g = e.keywords[f]), g = g || Xn.getKeyword(f, e), y.cache && (e.keywords[f] = g) } m = g.build(e) } f !== m && u[d.index + l - 1] !== "." && (u = u.substring(0, d.index + l) + m + u.substring(d.index + f.length + l), l += m.length - f.length), this.getIncludeByName(m) === void 0 && Xn.contains(m) && e.include(Xn.get(m)) } return n === "source" ? u : this.isMethod ? (this.isInterface || e.include(this, void 0, u), this.name) : e.format("( " + u + " )", this.getType(e), n) } parse (e, n, r, s) { if (this.src = e || "", this.includes = n ?? [], this.extensions = r ?? {}, this.keywords = s ?? {}, this.isMethod) { let o = BW.exec(this.src); if (this.inputs = [], o && o.length == 4) { this.type = o[1], this.name = o[2]; let a = o[3].match(b2); if (a) { let l = 0; for (; l < a.length;) { let u = a[l++], c; u === "in" || u === "out" || u === "inout" ? c = a[l++] : (c = u, u = ""); let h = a[l++]; this.inputs.push({ name: h, type: c, qualifier: u }) } } this.isInterface = this.src.indexOf("{") === -1 } else this.type = "", this.name = "" } } }; var FW = /^([a-z_0-9]+)\s([a-z_0-9]+)\s?\=?\s?(.*?)(\;|$)/i, tS = class extends We { constructor(e = "", n) { super(); this.src = ""; this.useDefine = !1; this.nodeType = "Const"; this.parse(e || tS.PI, void 0, void 0, void 0, n) } getType (e) { return e.getTypeByFormat(this.type) } parse (e, n, r, s, o) { this.src = e || ""; let a, l, u = "", c = FW.exec(e); this.useDefine = o ?? this.src.charAt(0) === "#", c && c.length > 1 ? (l = c[1], a = c[2], u = c[3]) : (a = this.src, l = "f"), this.name = a, this.type = l, this.value = u } build (e, n) { if (n === "source") { if (this.value) return this.useDefine ? "#define " + this.name + " " + this.value : "const " + this.type + " " + this.name + " = " + this.value + ";"; if (this.useDefine) return this.src } return e.include(this), e.format(this.name, this.getType(e), n) } generate (e, n, r, s, o) { return e.format(this.name, this.getType(e), n) } }, Et = tS; Et.PI = "PI", Et.PI2 = "PI2", Et.RECIPROCAL_PI = "RECIPROCAL_PI", Et.RECIPROCAL_PI2 = "RECIPROCAL_PI2", Et.LOG2 = "LOG2", Et.EPSILON = "EPSILON"; var kW = new RegExp(`^structs*([a-z_0-9]+)s*{s*((.|
)*?)}`, "gim"), UW = new RegExp("s*(w*?)s*(w*?)(=|;)", "gim"), bh = class extends We { constructor(e = "") { super(); this.inputs = []; this.src = ""; this.nodeType = "Struct"; this.parse(e) } getType (e) { return e.getTypeByFormat(this.name) } getInputByName (e) { let n = this.inputs.length; for (; n--;)if (this.inputs[n].name === e) return this.inputs[n] } generate (e, n, r, s, o) { return n === "source" ? this.src + ";" : e.format("( " + this.src + " )", this.getType(e), n) } parse (e = "") { this.src = e, this.inputs = []; let n = kW.exec(e); if (n) { let r = n[2], s; for (; s = UW.exec(r);)this.inputs.push({ type: s[1], name: s[2] }); this.name = n[1] } else this.name = ""; this.type = this.name } }; var wh = class extends We { constructor(e) { super("v2", { shared: !1 }); this.nodeType = "UV"; this.index = e ?? 0 } generate (e, n) { e.requires.uv[this.index] = !0; let r = this.index > 0 ? this.index + 1 : "", s = e.isShader("vertex") ? "uv" + r : "vUv" + r; return e.format(s, this.getType(e), n) } }; Xn.addKeyword("uv", function () { return new wh }); Xn.addKeyword("uv2", function () { return new wh(1) }); var zl = class extends We { constructor(e, n) { super("v4"); this.nodeType = "ColorSpace"; this.input = e, this.method = n ?? zl.LINEAR_TO_LINEAR, this.hashProperties = ["method"] } static getEncodingComponents (e) { switch (e) { case li: return ["Linear"]; case Je: return ["sRGB"]; default: return [] } } generate (e, n) { let r = this.input.build(e, "v4"), s = this.getType(e), o = zl.Nodes[this.method], a = e.include(o); if (a === zl.LINEAR_TO_LINEAR) return e.format(r, s, n); if (o.inputs?.length === 2) { let l = this.factor.build(e, "f"); return e.format(a + "( " + r + ", " + l + " )", s, n) } else return e.format(a + "( " + r + " )", s, n) } fromEncoding (e) { let n = zl.getEncodingComponents(e); this.method = "LinearTo" + n[0], this.factor = n[1] } fromDecoding (e) { let n = zl.getEncodingComponents(e); this.method = n[0] + "ToLinear", this.factor = n[1] } }, zr = zl; zr.Nodes = {
	LinearToLinear: new me(["vec4 LinearToLinear( in vec4 value ) {", "	return value;", "}"].join(`
`)), sRGBToLinear: new me(["vec4 sRGBToLinear( in vec4 value ) {", "	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );", "}"].join(`
`)), LinearTosRGB: new me(["vec4 LinearTosRGB( in vec4 value ) {", "	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );", "}"].join(`
`))
}, zr.LINEAR_TO_LINEAR = "LinearToLinear", zr.SRGB_TO_LINEAR = "sRGBToLinear", zr.LINEAR_TO_SRGB = "LinearTosRGB"; var Tt = class extends me { constructor(e = "", n, r, s, o) { super(e, o, s, r, n); this.nodeType = "Expression" } }; var Gr = class extends Bt { constructor(e = new Qt, n, r, s) { super("v4", { shared: !0 }); this.nodeType = "Texture"; this.value = e, this.uv = n ?? new wh, this.bias = r, this.project = s !== void 0 ? s : !1 } getTexture (e, n) { return super.generate(e, n, this.value.uuid, "t") } generate (e, n) { if (n === "sampler2D") return this.getTexture(e, n); let r = this.getTexture(e, n), s = this.uv.build(e, this.project ? "v4" : "v2"), o = this.bias ? this.bias.build(e, "f") : void 0; o === void 0 && e.context.bias && (o = e.context.bias.setTexture(this).build(e, "f")); let a, l; this.project ? a = "texture2DProj" : a = o ? "tex2DBias" : "tex2D", o ? l = a + "( " + r + ", " + s + ", " + o + " )" : l = a + "( " + r + ", " + s + " )"; let u = { include: e.isShader("vertex"), ignoreCache: !0 }, c = this.getType(e); return e.addContext(u), this.colorSpace = this.colorSpace ?? new zr(new Tt("", c)), this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(l), l = this.colorSpace.build(e, c), e.removeContext(), e.format(l, c, n) } }; var Ee = class extends Bt { constructor(e) { super("f"); this.nodeType = "Float"; this.value = e ?? 0 } generateReadonly (e, n, r, s, o, a) { return e.format(this.value + (this.value % 1 ? "" : ".0"), s, n) } }; var qf = class extends We { constructor(e, n) { super(); this.inputs = []; this.nodeType = "FunctionCall"; this.value = e, this.inputs = n ?? [] } getFunction () { return this.value } getType (e) { return this.value.getType(e) } generate (e, n, r, s, o) { s = this.getType(e); let a = this.value, l = a.build(e, n) + "( ", u = []; if (a.inputs) { for (let c = 0; c < a.inputs.length; c++) { let h = a.inputs[c], d = this.inputs[c] || this.inputs[h.name]; u.push(d.build(e, e.getTypeByFormat(h.type))) } l += u.join(", ") + " )" } return e.format(l, s, n) } }; var nS = class extends We { constructor(e, n, r = nS.ADD) { super(); this.nodeType = "Operator"; this.type = e.type, this.a = e, this.b = n, this.op = r } getType (e) { let n = this.a.getType(e), r = this.b.getType(e); return e.isTypeMatrix(n) ? "v4" : e.getTypeLength(r) > e.getTypeLength(n) ? r : n } generate (e, n) { let r = this.getType(e); this.type = r; let s = this.a.build(e, r), o = this.b.build(e, r); return e.format("( " + s + " " + this.op + " " + o + " )", r, n) } }, cr = nS; cr.ADD = "+", cr.SUB = "-", cr.MUL = "*", cr.DIV = "/"; var Ft = class extends We { constructor(e, n = Ft.ABS, r, s) { super(); this.nodeType = "Math"; this.a = e, typeof n != "string" ? this.b = n : s = n, typeof r != "string" ? this.c = r : s = r, this.method = s, this.hashProperties = ["method"] } getNumInputs (e) { switch (this.method) { case Ft.MIX: case Ft.CLAMP: case Ft.REFRACT: case Ft.SMOOTHSTEP: case Ft.FACEFORWARD: return 3; case Ft.MIN: case Ft.MAX: case Ft.MOD: case Ft.STEP: case Ft.REFLECT: case Ft.DISTANCE: case Ft.DOT: case Ft.CROSS: case Ft.POW: return 2; default: return 1 } } getInputType (e) { let n = e.getTypeLength(this.a.getType(e)), r = this.b ? e.getTypeLength(this.b.getType(e)) : 0, s = this.c ? e.getTypeLength(this.c.getType(e)) : 0; return n > r && n > s ? this.a.getType(e) : r > s ? this.b.getType(e) : this.c.getType(e) } getType (e) { switch (this.method) { case Ft.LENGTH: case Ft.DISTANCE: case Ft.DOT: return "f"; case Ft.CROSS: return "v3" }return this.getInputType(e) } generate (e, n) { let r, s, o, a = this.a ? e.getTypeLength(this.a.getType(e)) : 0, l = this.b ? e.getTypeLength(this.b.getType(e)) : 0, u = this.c ? e.getTypeLength(this.c.getType(e)) : 0, c = this.getInputType(e), h = this.getType(e); switch (this.type = h, this.method) { case Ft.NEGATE: return e.format("( -" + this.a.build(e, c) + " )", c, n); case Ft.INVERT: return e.format("( 1.0 - " + this.a.build(e, c) + " )", c, n); case Ft.CROSS: r = this.a.build(e, "v3"), s = this.b.build(e, "v3"); break; case Ft.STEP: r = this.a.build(e, a === 1 ? "f" : c), s = this.b.build(e, c); break; case Ft.MIN: case Ft.MAX: case Ft.MOD: r = this.a.build(e, c), s = this.b.build(e, l === 1 ? "f" : c); break; case Ft.REFRACT: r = this.a.build(e, c), s = this.b.build(e, c), o = this.c.build(e, "f"); break; case Ft.MIX: r = this.a.build(e, c), s = this.b.build(e, c), o = this.c.build(e, u === 1 ? "f" : c); break; default: r = this.a.build(e, c), this.b && (s = this.b.build(e, c)), this.c && (o = this.c.build(e, c)); break }let d = []; d.push(r), s && d.push(s), o && d.push(o); let f = this.getNumInputs(e); if (d.length !== f) throw Error(`Arguments not match used in "${this.method}". Require ${f}, currently ${d.length}.`); return e.format(this.method + "( " + d.join(", ") + " )", h, n) } }, rt = Ft; rt.RAD = "radians", rt.DEG = "degrees", rt.EXP = "exp", rt.EXP2 = "exp2", rt.LOG = "log", rt.LOG2 = "log2", rt.SQRT = "sqrt", rt.INV_SQRT = "inversesqrt", rt.FLOOR = "floor", rt.CEIL = "ceil", rt.NORMALIZE = "normalize", rt.FRACT = "fract", rt.SATURATE = "saturate", rt.SIN = "sin", rt.COS = "cos", rt.TAN = "tan", rt.ASIN = "asin", rt.ACOS = "acos", rt.ARCTAN = "atan", rt.ABS = "abs", rt.SIGN = "sign", rt.LENGTH = "length", rt.NEGATE = "negate", rt.INVERT = "invert", rt.MIN = "min", rt.MAX = "max", rt.MOD = "mod", rt.STEP = "step", rt.REFLECT = "reflect", rt.DISTANCE = "distance", rt.DOT = "dot", rt.CROSS = "cross", rt.POW = "pow", rt.MIX = "mix", rt.CLAMP = "clamp", rt.REFRACT = "refract", rt.SMOOTHSTEP = "smoothstep", rt.FACEFORWARD = "faceforward"; var Sh = class extends We { constructor(e, n, r) { super("v4"); this.nodeType = "TextureCubeUV"; this.value = e, this.uv = n, this.bias = r } bilinearCubeUV (e, n, r, s) { let o = new qf(Sh.Nodes.bilinearCubeUV, [n, r, s]); this.colorSpaceTL = this.colorSpaceTL ?? new zr(new Tt("", "v4")), this.colorSpaceTL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTL.input.parse(o.build(e) + ".tl"), this.colorSpaceTR = this.colorSpaceTR ?? new zr(new Tt("", "v4")), this.colorSpaceTR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceTR.input.parse(o.build(e) + ".tr"), this.colorSpaceBL = this.colorSpaceBL ?? new zr(new Tt("", "v4")), this.colorSpaceBL.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBL.input.parse(o.build(e) + ".bl"), this.colorSpaceBR = this.colorSpaceBR ?? new zr(new Tt("", "v4")), this.colorSpaceBR.fromDecoding(e.getTextureEncodingFromMap(this.value.value)), this.colorSpaceBR.input.parse(o.build(e) + ".br"); let a = { include: e.isShader("vertex"), ignoreCache: !0 }; e.addContext(a), this.colorSpaceTLExp = new Tt(this.colorSpaceTL.build(e, "v4"), "v4"), this.colorSpaceTRExp = new Tt(this.colorSpaceTR.build(e, "v4"), "v4"), this.colorSpaceBLExp = new Tt(this.colorSpaceBL.build(e, "v4"), "v4"), this.colorSpaceBRExp = new Tt(this.colorSpaceBR.build(e, "v4"), "v4"), e.removeContext(); let l = new Tt("mix( mix( cubeUV_TL, cubeUV_TR, cubeUV.f.x ), mix( cubeUV_BL, cubeUV_BR, cubeUV.f.x ), cubeUV.f.y )", "v4"); return l.keywords.cubeUV_TL = this.colorSpaceTLExp, l.keywords.cubeUV_TR = this.colorSpaceTRExp, l.keywords.cubeUV_BL = this.colorSpaceBLExp, l.keywords.cubeUV_BR = this.colorSpaceBRExp, l.keywords.cubeUV = o, l } generate (e, n) { if (e.isShader("fragment")) { let r = this.uv, s = this.bias || e.context.roughness, o = new qf(Sh.Nodes.roughnessToMip, [s]), a = new rt(o, Sh.Nodes.m0, Sh.Nodes.cubeUV_maxMipLevel, rt.CLAMP), l = new rt(a, rt.FLOOR), u = new rt(a, rt.FRACT), c = this.bilinearCubeUV(e, this.value, r, l), h = this.bilinearCubeUV(e, this.value, r, new cr(l, new Ee(1).setReadonly(!0), cr.ADD)), d = new rt(c, h, u, rt.MIX); return e.format(d.build(e), "v4", n) } else return console.warn("TextureCubeUVNode is not compatible with " + e.shader + " shader."), e.format("vec4( 0.0 )", this.getType(e), n) } }, Ah = Sh; Ah.Nodes = function () {
	let e = new bh(`struct TextureCubeUVData {
			vec4 tl;
			vec4 tr;
			vec4 br;
			vec4 bl;
			vec2 f;
		}`), n = new Et("float cubeUV_maxMipLevel 8.0", !0), r = new Et("float cubeUV_minMipLevel 4.0", !0), s = new Et("float cubeUV_maxTileSize 256.0", !0), o = new Et("float cubeUV_minTileSize 16.0", !0), a = new me(`float getFace(vec3 direction) {
				vec3 absDirection = abs(direction);
				float face = -1.0;
				if (absDirection.x > absDirection.z) {
					if (absDirection.x > absDirection.y)
						face = direction.x > 0.0 ? 0.0 : 3.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				} else {
					if (absDirection.z > absDirection.y)
						face = direction.z > 0.0 ? 2.0 : 5.0;
					else
						face = direction.y > 0.0 ? 1.0 : 4.0;
				}
				return face;
		}`); a.useKeywords = !1; let l = new me(`vec2 getUV(vec3 direction, float face) {
				vec2 uv;
				if (face == 0.0) {
					uv = vec2(direction.z, direction.y) / abs(direction.x); // pos x
				} else if (face == 1.0) {
					uv = vec2(-direction.x, -direction.z) / abs(direction.y); // pos y
				} else if (face == 2.0) {
					uv = vec2(-direction.x, direction.y) / abs(direction.z); // pos z
				} else if (face == 3.0) {
					uv = vec2(-direction.z, direction.y) / abs(direction.x); // neg x
				} else if (face == 4.0) {
					uv = vec2(-direction.x, direction.z) / abs(direction.y); // neg y
				} else {
					uv = vec2(direction.x, direction.y) / abs(direction.z); // neg z
				}
				return 0.5 * (uv + 1.0);
		}`); l.useKeywords = !1; let u = new me(`TextureCubeUVData bilinearCubeUV(sampler2D envMap, vec3 direction, float mipInt) {
			float face = getFace(direction);
			float filterInt = max(cubeUV_minMipLevel - mipInt, 0.0);
			mipInt = max(mipInt, cubeUV_minMipLevel);
			float faceSize = exp2(mipInt);
			float texelSize = 1.0 / (3.0 * cubeUV_maxTileSize);
			vec2 uv = getUV(direction, face) * (faceSize - 1.0);
			vec2 f = fract(uv);
			uv += 0.5 - f;
			if (face > 2.0) {
				uv.y += faceSize;
				face -= 3.0;
			}
			uv.x += face * faceSize;
			if(mipInt < cubeUV_maxMipLevel){
				uv.y += 2.0 * cubeUV_maxTileSize;
			}
			uv.y += filterInt * 2.0 * cubeUV_minTileSize;
			uv.x += 3.0 * max(0.0, cubeUV_maxTileSize - 2.0 * faceSize);
			uv *= texelSize;
			vec4 tl = texture2D(envMap, uv);
			uv.x += texelSize;
			vec4 tr = texture2D(envMap, uv);
			uv.y += texelSize;
			vec4 br = texture2D(envMap, uv);
			uv.x -= texelSize;
			vec4 bl = texture2D(envMap, uv);
			return TextureCubeUVData( tl, tr, br, bl, f );
		}`, [e, a, l, n, r, s, o]); u.useKeywords = !1; let c = new Et("float r0 1.0", !0), h = new Et("float v0 0.339", !0), d = new Et("float m0 -2.0", !0), f = new Et("float r1 0.8", !0), p = new Et("float v1 0.276", !0), m = new Et("float m1 -1.0", !0), g = new Et("float r4 0.4", !0), y = new Et("float v4 0.046", !0), v = new Et("float m4 2.0", !0), x = new Et("float r5 0.305", !0), b = new Et("float v5 0.016", !0), S = new Et("float m5 3.0", !0), _ = new Et("float r6 0.21", !0), E = new Et("float v6 0.0038", !0), w = new Et("float m6 4.0", !0), M = [c, h, d, f, p, m, g, y, v, x, b, S, _, E, w], T = new me(`float roughnessToMip(float roughness) {
			float mip = 0.0;
			if (roughness >= r1) {
				mip = (r0 - roughness) * (m1 - m0) / (r0 - r1) + m0;
			} else if (roughness >= r4) {
				mip = (r1 - roughness) * (m4 - m1) / (r1 - r4) + m1;
			} else if (roughness >= r5) {
				mip = (r4 - roughness) * (m5 - m4) / (r4 - r5) + m4;
			} else if (roughness >= r6) {
				mip = (r5 - roughness) * (m6 - m5) / (r5 - r6) + m5;
			} else {
				mip = -2.0 * log2(1.16 * roughness);// 1.16 = 1.79^0.25
			}
			return mip;
		}`, M); return { bilinearCubeUV: u, roughnessToMip: T, m0: d, cubeUV_maxMipLevel: n }
}(); var Gl = class extends We { constructor(e) { super("v3"); this.nodeType = "Normal"; this.scope = e ?? Gl.VIEW } getShared () { return this.scope === Gl.WORLD } build (e, n, r, s) { let o = e.context[this.scope + "Normal"]; return o ? o.build(e, n, r, s) : super.build(e, n, r) } generate (e, n, r, s, o) { let a; switch (this.scope) { case Gl.VIEW: e.isShader("vertex") ? a = "transformedNormal" : a = "geometryNormal"; break; case Gl.LOCAL: e.isShader("vertex") ? a = "objectNormal" : (e.requires.normal = !0, a = "vObjectNormal"); break; case Gl.WORLD: e.isShader("vertex") ? a = "inverseTransformDirection( transformedNormal, viewMatrix ).xyz" : (e.requires.worldNormal = !0, a = "vWNormal"); break }return e.format(a, this.getType(e), n) } }, ur = Gl; ur.LOCAL = "local", ur.WORLD = "world", ur.VIEW = "view", ur.NORMAL = "normal"; Xn.addKeyword("viewNormal", function () { return new ur(ur.VIEW) }); Xn.addKeyword("localNormal", function () { return new ur(ur.NORMAL) }); Xn.addKeyword("worldNormal", function () { return new ur(ur.WORLD) }); var Bs = class extends We { constructor(e) { super("v3"); this.nodeType = "Position"; this.scope = e ?? Bs.LOCAL } getType () { switch (this.scope) { case Bs.PROJECTION: return "v4" }return this.type } getShader () { switch (this.scope) { case Bs.LOCAL: case Bs.WORLD: return !1 }return !0 } generate (e, n, r, s, o) { let a; switch (this.scope) { case Bs.LOCAL: e.isShader("vertex") ? a = "transformed" : (e.requires.position = !0, a = "vPosition"); break; case Bs.WORLD: if (e.isShader("vertex")) return "( modelMatrix * vec4( transformed, 1.0 ) ).xyz"; e.requires.worldPosition = !0, a = "vWPosition"; break; case Bs.VIEW: a = e.isShader("vertex") ? "-mvPosition.xyz" : "vViewPosition"; break; case Bs.PROJECTION: a = e.isShader("vertex") ? "( projectionMatrix * modelViewMatrix * vec4( position, 1.0 ) )" : "vec4( 0.0 )"; break }return e.format(a, this.getType(), n) } }, Jr = Bs; Jr.LOCAL = "local", Jr.WORLD = "world", Jr.VIEW = "view", Jr.PROJECTION = "projection"; Xn.addKeyword("position", function () { return new Jr }); Xn.addKeyword("worldPosition", function () { return new Jr(Jr.WORLD) }); Xn.addKeyword("viewPosition", function () { return new Jr(Jr.VIEW) }); var rs = class extends We { constructor(e) { super("v3"); this.nodeType = "Reflect"; this.scope = e ?? rs.CUBE } getUnique (e) { return !e.context.viewNormal } getType () { switch (this.scope) { case rs.SPHERE: return "v2" }return this.type } generate (e, n) { let r = this.getUnique(e); if (e.isShader("fragment")) { let s; switch (this.scope) { case rs.VECTOR: { let o = new ur(ur.VIEW), a = e.context.roughness, l = o.build(e, "v3"), u = new Jr(Jr.VIEW).build(e, "v3"), c = a ? a.build(e, "f") : void 0, h = `reflect( -normalize( ${u} ), ${l} )`; c && (h = `normalize( mix( ${h}, ${l}, ${c} * ${c} ) )`); let d = `inverseTransformDirection( ${h}, viewMatrix )`; r ? (e.addNodeCode(`vec3 reflectVec = ${d};`), s = "reflectVec") : s = d; break } case rs.CUBE: { let o = new rs(rs.VECTOR).build(e, "v3"), a = "vec3( -" + o + ".x, " + o + ".yz )"; r ? (e.addNodeCode(`vec3 reflectCubeVec = ${a};`), s = "reflectCubeVec") : s = a; break } case rs.SPHERE: { let a = "normalize( ( viewMatrix * vec4( " + new rs(rs.VECTOR).build(e, "v3") + ", 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) ).xy * 0.5 + 0.5"; r ? (e.addNodeCode(`vec2 reflectSphereVec = ${a};`), s = "reflectSphereVec") : s = a; break } }return e.format(s, this.getType(), n) } else return console.warn("ReflectNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.type, n) } }, Fs = rs; Fs.CUBE = "cube", Fs.SPHERE = "sphere", Fs.VECTOR = "vector"; var zy = class extends We { constructor(e = new Gr, n, r) { super("v4"); this.nodeType = "TextureCube"; this.value = e, this.radianceNode = new Ah(this.value, n ?? new Fs(Fs.VECTOR), r), this.irradianceNode = new Ah(this.value, new ur(ur.WORLD), new Ee(1).setReadonly(!0)) } generate (e, n) { return e.isShader("fragment") ? (e.require("irradiance"), e.context.bias && e.context.bias.setTexture(this.value), (e.slot === "irradiance" ? this.irradianceNode : this.radianceNode).build(e, n)) : (console.warn("TextureCubeNode is not compatible with " + e.shader + " shader."), e.format("vec4( 0.0 )", this.getType(e), n)) } }; var Gy = class extends Bt { constructor(e = new Cc, n, r) { super("v4", { shared: !0 }); this.nodeType = "CubeTexture"; this.value = e, this.uv = n ?? new Fs, this.bias = r } getTexture (e, n) { return super.generate(e, n, this.value.uuid, "tc") } generate (e, n) { if (n === "samplerCube") return this.getTexture(e, n); let r = this.getTexture(e, n), s = this.uv?.build(e, "v3"), o = this.bias ? this.bias.build(e, "f") : void 0; o === void 0 && e.context.bias && (o = e.context.bias.setTexture(this).build(e, "f")); let a; o ? a = "texCubeBias( " + r + ", " + s + ", " + o + " )" : a = "texCube( " + r + ", " + s + " )"; let l = { include: e.isShader("vertex"), ignoreCache: !0 }, u = this.getType(e); return e.addContext(l), this.colorSpace = this.colorSpace ?? new zr(new Tt("", u)), this.colorSpace.fromDecoding(e.getTextureEncodingFromMap(this.value)), this.colorSpace.input.parse(a), a = this.colorSpace.build(e, u), e.removeContext(), e.format(a, u, n) } }; var w2 = `
uniform int frameIndex;
uniform vec2 resolution;
uniform mat4 previousModelViewMatrix;
uniform mat4 previousProjectionMatrix;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
`, S2 = `
layout(location = 1) out vec4 gVelocity;

uniform int frameIndex;
uniform vec2 resolution;

varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;

const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {
  const float goldenAngle = 2.399963f; // radians
  float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));
  float theta = float(sampleIndex) * goldenAngle + angle;
  float sine = sin(theta);
  float cosine = cos(theta);
  return vec2(cosine, sine) * r;
}

// Derived from the interleaved gradient function from Jimenez 2014 http:goo.gl/eomGso
float getNoiseInterleavedGradient(vec2 screenPos) {
    vec3 magic = vec3(0.06711056f, 0.00583715f, 52.9829189f);
    return fract(magic.z * fract(dot(screenPos, magic.xy)));
}

`, A2 = `
// TODO: This could be generated CPU side and passed to the shader every frame
const vec2 haltonSequence[16] = vec2[16](
vec2( 0.000000,-0.333334),
vec2(-0.500000, 0.333334),
vec2( 0.500000,-0.777778),
vec2(-0.750000,-0.111112),
vec2( 0.250000, 0.555556),
vec2(-0.250000,-0.555556),
vec2( 0.750000, 0.111112),
vec2(-0.875000, 0.777778),
vec2(0.125000, -0.925926),
vec2(-0.375000, -0.259260),
vec2(0.625000, 0.407408),
vec2(-0.625000, -0.703704),
vec2(0.375000, -0.037038),
vec2(-0.125000, 0.629630),
vec2(0.875000, -0.481482),
vec2(-0.937500, 0.185186));

// TODO: Pass correct view size
vec2 offset = haltonSequence[frameIndex];
offset.x /= resolution.x;
offset.y /= resolution.y;

vec4 currentPosition = gl_Position;
vec4 currentPositionJittered = currentPosition + (vec4(offset.x, offset.y, 0.0, 0.0) * currentPosition.w);

// We want to calculate the velocity with unjittered positions
// so that things that are not moving get a velocity = 0
vCurrentPosition = currentPosition;
vPreviousPosition = previousProjectionMatrix * previousModelViewMatrix * vec4(transformed, 1.0);
#ifdef OUTLINE_COMPENSATION
vPreviousPosition.xy += OUTLINE_COMPENSATION;
#endif
gl_Position = currentPositionJittered;

`, _2 = `
vec2 oldPos = vPreviousPosition.xy;
    oldPos /= vPreviousPosition.w;
    oldPos.xy = (oldPos.xy+1.)/2.0;

vec2 newPos = vCurrentPosition.xy;
    newPos /= vCurrentPosition.w;
    newPos.xy = (newPos.xy+1.)/2.0;

vec2 velocity = (newPos - oldPos);

// Discard fully transparent pixels 
if (gl_FragColor.a <= 0.0) discard;

gVelocity = vec4(velocity, 0.0, 1.0);
`; var E2 = ["x", "y", "z", "w"], zW = ["float", "vec2", "vec3", "vec4"], GW = { float: "f", vec2: "v2", vec3: "v3", vec4: "v4", mat4: "v4", int: "i", bool: "b", "float[]": "f[]", "vec4[]": "v4[]" }, VW = { t: "sampler2D", tc: "samplerCube", b: "bool", i: "int", f: "float", c: "vec3", v2: "vec2", v3: "vec3", v4: "vec4", m3: "mat3", m4: "mat4", "f[]": "float[]", "v4[]": "vec4[]" }, Vy = class {
	constructor() {
		this.includes = { consts: {}, functions: {}, structs: {} }; this.cache = ""; this.slot = ""; this.shader = ""; this.context = {}; this.needsJitter = !0; this.getIncludesCode = function () {
			function t (e, n) { return e.deps.length - n.deps.length } return function (n, r) {
				let s = this.getIncludes(n, r); if (!s) return ""; let o = ""; s = s.sort(t); for (let a = 0; a < s.length; a++)s[a].src && (o += s[a].src + `
`); return o
			}
		}(); this.slots = [], this.caches = [], this.contexts = [], this.keywords = {}, this.nodeData = {}, this.fragmentVariables = {}, this.fragmentParsVariables = {}, this.vertexParsVariables = {}, this.requires = { uv: [], color: [], transparent: !1, irradiance: !1, position: !1, worldPosition: !1, normal: !1, worldNormal: !1, vWorldViewDir: !1, modelMatrix: !1, viewMatrix: !1, projectionMatrix: !1 }, this.includes = { consts: [], functions: [], structs: [] }, this.attributes = {}, this.prefixCode = ["#ifdef TEXTURE_LOD_EXT", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCubeLodEXT(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2DLodEXT(a, b, c)", "#else", "	#define texCube(a, b) textureCube(a, b)", "	#define texCubeBias(a, b, c) textureCube(a, b, c)", "	#define tex2D(a, b) texture2D(a, b)", "	#define tex2DBias(a, b, c) texture2D(a, b, c)", "#endif", `
			// NOTE: Include Spline's blending modes. This could be part of BlendNode
			#define SPE_BLENDING_NORMAL 0
			#define SPE_BLENDING_MULTIPLY 1
			#define SPE_BLENDING_SCREEN 2
			#define SPE_BLENDING_OVERLAY 3

			vec3 spe_normalBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, b, alpha );
			}

			vec3 spe_multiplyBlend( vec3 a, vec3 b, float alpha ) {
				return mix( a, a * b, alpha );
			}

			vec3 spe_screenBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = 1.0 - ( 1.0 - a ) * ( 1.0 - b );
				return mix( a, tmp, alpha );
			}

			vec3 spe_overlayBlend( vec3 a, vec3 b, float alpha ) {
				vec3 tmp = mix( 1. - 2. * (1. - a) * (1. - b), 2. * a * b, step( a, vec3(.5) ) );
				return clamp( mix( a, tmp, alpha ), 0.0, 1.0 );
			}

			vec3 spe_blend( vec3 a, vec3 b, float alpha, int mode ) {
				if ( mode == SPE_BLENDING_NORMAL ) return spe_normalBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_MULTIPLY ) return spe_multiplyBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_SCREEN ) return spe_screenBlend( a, b, alpha );
				else if ( mode == SPE_BLENDING_OVERLAY ) return spe_overlayBlend( a, b, alpha );
				return vec3( 1.0 );
			}
			`, "#include <packing>", "#include <common>"].join(`
`), this.parsCode = {
				vertex: ["float neighbor_offset = 0.0001;", ""].join(`
`), fragment: ["float accumAlpha = 0.0;", `void accumulateAlpha(float alpha) {
					accumAlpha += (1.0 - accumAlpha) * alpha;
				}`, ""].join(`
`)
			}, this.code = { vertex: "", fragment: "" }, this.nodeCode = { vertex: "", fragment: "" }, this.resultCode = { vertex: "", fragment: "" }, this.finalCode = { vertex: "", fragment: "" }, this.inputs = { uniforms: { list: [], vertex: [], fragment: [] }, arrayUniforms: { list: [], vertex: [], fragment: [] }, vars: { varying: [], vertex: [], fragment: [] } }, this.defines = {}, this.uniforms = {}, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.updaters = [], this.nodes = [], this.analyzing = !1
	} build (t, e) { this.addVertexParsCode(w2), this.addFragmentParsCode(S2), this.buildShader("vertex", t), this.buildShader("fragment", e); for (let n = 0; n < this.requires.uv.length; n++)if (this.requires.uv[n]) { let r = n > 0 ? n + 1 : ""; this.addVaryCode("varying vec2 vUv" + r + ";"), n > 0 && this.addVertexParsCode("attribute vec2 uv" + r + ";"), this.addVertexFinalCode("vUv" + r + " = uv" + r + ";") } return this.requires.color[0] && (this.addVaryCode("varying vec4 vColor;"), this.addVertexParsCode("attribute vec4 color;"), this.addVertexFinalCode("vColor = color;")), this.requires.color[1] && (this.addVaryCode("varying vec4 vColor2;"), this.addVertexParsCode("attribute vec4 color2;"), this.addVertexFinalCode("vColor2 = color2;")), this.requires.position && (this.addVaryCode("varying vec3 vPosition;"), this.addVertexFinalCode("vPosition = transformed;")), this.requires.worldPosition, this.requires.normal && (this.addVaryCode("varying vec3 vObjectNormal;"), this.addVertexFinalCode("vObjectNormal = normal;")), this.requires.modelMatrix && this.addFragmentParsCode("uniform mat4 modelMatrix;"), this.requires.viewMatrix && this.addFragmentParsCode("uniform mat4 viewMatrix;"), this.requires.projectionMatrix && this.addFragmentParsCode("uniform mat4 projectionMatrix;"), this.requires.worldNormal && (this.addVaryCode("varying vec3 vWNormal;"), this.addVertexFinalCode("vWNormal = inverseTransformDirection( transformedNormal, viewMatrix ).xyz;")), this.requires.vWorldViewDir && (this.addVaryCode("varying vec3 vWorldViewDir;"), this.addVertexFinalCode("vWorldViewDir = isPerspectiveMatrix( projectionMatrix ) ?  ( (modelMatrix * vec4(position, 1.0)).xyz - cameraPosition ) : vec3( -viewMatrix[0][2], -viewMatrix[1][2], -viewMatrix[2][2] );")), this.needsJitter && (this.addVertexFinalCode(A2), this.addFragmentFinalCode(_2)), this } buildShader (t, e) { this.resultCode[t] = e.build(this.setShader(t), "v4") } setMaterial (t, e) { return this.defines = {}, this } addFlow (t, e, n) { return this.addSlot(t).addCache(e).addContext(n) } removeFlow () { return this.removeSlot().removeCache().removeContext() } addCache (t) { return this.cache = t ?? "", this.caches.push(this.cache), this } removeCache () { return this.caches.pop(), this.cache = this.caches[this.caches.length - 1] || "", this } addContext (t) { return this.context = Object.assign({}, this.context, t), this.context.extra = this.context.extra || {}, this.contexts.push(this.context), this } removeContext () { return this.contexts.pop(), this.context = this.contexts[this.contexts.length - 1] || {}, this } addSlot (t) { return this.slot = t || "", this.slots.push(this.slot), this } removeSlot () { return this.slots.pop(), this.slot = this.slots[this.slots.length - 1] || "", this } addFragmentVariable (t, e) { this.fragmentVariables[t] === void 0 && (this.addFragmentCode(`${e} ${t};`), this.fragmentVariables[t] = "") } addFragmentParsVariable (t, e) { this.fragmentParsVariables[t] === void 0 && (this.addFragmentParsCode(`${e} ${t};`), this.fragmentParsVariables[t] = "") } addVertexParsVariable (t, e) { this.vertexParsVariables[t] === void 0 && (this.addVertexParsCode(`${e} ${t};`), this.vertexParsVariables[t] = "") } addVertexCode (t) { this.addCode(t, "vertex") } addFragmentCode (t) { this.addCode(t, "fragment") } addCode (t, e) {
		this.code[e ?? this.shader] += t + `
`} addVertexNodeCode (t) { this.addNodeCode(t, "vertex") } addFragmentNodeCode (t) { this.addNodeCode(t, "fragment") } addNodeCode (t, e) {
		this.nodeCode[e ?? this.shader] += t + `
`} clearNodeCode (t) { t = t ?? this.shader; let e = this.nodeCode[t]; return this.nodeCode[t] = "", e } clearVertexNodeCode () { return this.clearNodeCode("vertex") } clearFragmentNodeCode () { return this.clearNodeCode("fragment") } addVertexFinalCode (t) { this.addFinalCode(t, "vertex") } addFragmentFinalCode (t) { this.addFinalCode(t, "fragment") } addFinalCode (t, e) {
		this.finalCode[e ?? this.shader] += t + `
`} addVertexParsCode (t) { this.addParsCode(t, "vertex") } addFragmentParsCode (t) { this.addParsCode(t, "fragment") } addParsCode (t, e) {
		this.parsCode[e ?? this.shader] += t + `
`} addVaryCode (t) { this.addVertexParsCode(t), this.addFragmentParsCode(t) } isCache (t) { return this.caches.indexOf(t) !== -1 } isSlot (t) { return this.slots.indexOf(t) !== -1 } define (t, e) { this.defines[t] = e === void 0 ? 1 : e } require (t) { this.requires[t] = !0 } isDefined (t) { return this.defines[t] !== void 0 } getVar (t, e, n, r = "varying", s = "V", o = "") { let a = this.getVars(r), l = a[t]; if (!l) { let u = a.length; l = { name: n || "node" + s + u + (o ? "_" + o : ""), type: e }, a.push(l), a[t] = l } return l } getTempVar (t, e, n, r) { return this.getVar(t, e, n, this.shader, "T", r) } getAttribute (t, e) { if (!this.attributes[t]) { let n = this.getVar(t, e); this.addVertexParsCode("attribute " + e + " " + t + ";"), this.addVertexFinalCode(n.name + " = " + t + ";"), this.attributes[t] = { varying: n, name: t, type: e } } return this.attributes[t] } getCode (t) {
		return [this.prefixCode, this.parsCode[t], this.getVarListCode(this.getVars("varying"), "varying"), this.getVarListCode(this.inputs.uniforms[t], "uniform"), this.getVarListCode(this.inputs.arrayUniforms[t], "uniform"), this.getIncludesCode("consts", t), this.getIncludesCode("structs", t), this.getIncludesCode("functions", t), "void main() {", this.getVarListCode(this.getVars(t)), this.code[t], this.resultCode[t], this.finalCode[t], "}"].join(`
`)
	} getVarListCode (t, e) {
		e = e ?? ""; let n = ""; for (let r = 0, s = t.length; r < s; ++r) {
			let o = t[r], a = o.type, l = o.name, u = o.size, c = this.getFormatByType(a); if (c === void 0) throw new Error("Node pars " + c + " not found."); c.includes("[]") ? n += e + " " + c.substring(0, c.length - 2) + " " + l + `[${u}];
`: n += e + " " + c + " " + l + `;
`} return n
	} getVars (t) { return this.inputs.vars[t ?? this.shader] } getNodeData (t) { let e = t instanceof lr ? t.uuid : t; return this.nodeData[e] = this.nodeData[e] || {} } createUniform (t, e, n, r, s, o) { if (e.includes("[]")) { let a = this.inputs.arrayUniforms, l = a.list.length, u = new Wf({ type: e, size: n.size, name: r || "nodeUA" + l + (o ? "_" + o : ""), node: n, needsUpdate: s }); return a.list.push(u), a[t].push(u), a[t][u.name] = u, this.uniforms[u.name] = u, u } else { let a = this.inputs.uniforms, l = a.list.length, u = new Wf({ type: e, name: r || "nodeU" + l + (o ? "_" + o : ""), node: n, needsUpdate: s }); return a.list.push(u), a[t].push(u), a[t][u.name] = u, this.uniforms[u.name] = u, u } } createVertexUniform (t, e, n, r, s) { return this.createUniform("vertex", t, e, n, r, s) } createFragmentUniform (t, e, n, r, s) { return this.createUniform("fragment", t, e, n, r, s) } include (t, e, n) { let r; if (t = typeof t == "string" ? Xn.get(t) : t, this.context.include === !1) return t.name; t instanceof me ? r = this.includes.functions : t instanceof Et ? r = this.includes.consts : t instanceof bh && (r = this.includes.structs); let s = r[this.shader] = r[this.shader] || []; if (t) { let o = s[t.name]; if (o || (o = s[t.name] = { node: t, deps: [] }, s.push(o), o.src = t.build(this, "source")), t instanceof me && e && s[e.name] && s[e.name].deps.indexOf(t) === -1 && (s[e.name].deps.push(t), t.includes?.length)) { let a = 0; do this.include(t.includes[a++], e); while (a < t.includes.length) } return n && (o.src = n), t.name } else throw new Error("Include not found.") } colorToVectorProperties (t) { return t.replace("r", "x").replace("g", "y").replace("b", "z").replace("a", "w") } colorToVector (t) { return t.replace(/c/g, "v3") } getIncludes (t, e) { return this.includes[t][e || this.shader] } getConstructorFromLength (t) { return zW[t - 1] } isTypeMatrix (t) { return /^m/.test(t) } getTypeLength (t) { return t === "f" ? 1 : parseInt(this.colorToVector(t).substr(1)) } getTypeFromLength (t) { return t === 1 ? "f" : "v" + t } findNode (...t) { for (let e = 0; e < arguments.length; e++) { let n = t[e]; if (n?.isNode) return n } } resolve (...t) { for (let e = 0; e < arguments.length; e++) { let n = t[e]; if (n !== void 0) { if (n.isNode) return n; if (n.isTexture) switch (n.mapping) { case ta: case na: return new Gy(n); case Yc: return new zy(new Gr(n)); default: return new Gr(n) } else { if (n.isVector2) return new cn(n); if (n.isVector3) return new wr(n); if (n.isVector4) return new Zr(n) } } } } format (t, e, n) { switch (this.colorToVector(n + " <- " + e)) { case "f <- v2": return t + ".x"; case "f <- v3": return t + ".x"; case "f <- v4": return t + ".x"; case "f <- i": case "f <- b": return "float( " + t + " )"; case "v2 <- f": return "vec2( " + t + " )"; case "v2 <- v3": return t + ".xy"; case "v2 <- v4": return t + ".xy"; case "v2 <- i": case "v2 <- b": return "vec2( float( " + t + " ) )"; case "v3 <- f": return "vec3( " + t + " )"; case "v3 <- v2": return "vec3( " + t + ", 0.0 )"; case "v3 <- v4": return t + ".xyz"; case "v3 <- i": case "v3 <- b": return "vec2( float( " + t + " ) )"; case "v4 <- f": return "vec4( " + t + " )"; case "v4 <- v2": return "vec4( " + t + ", 0.0, 1.0 )"; case "v4 <- v3": return "vec4( " + t + ", 1.0 )"; case "v4 <- i": case "v4 <- b": return "vec4( float( " + t + " ) )"; case "i <- f": case "i <- b": return "int( " + t + " )"; case "i <- v2": return "int( " + t + ".x )"; case "i <- v3": return "int( " + t + ".x )"; case "i <- v4": return "int( " + t + ".x )"; case "b <- f": return "( " + t + " != 0.0 )"; case "b <- v2": return "( " + t + " != vec2( 0.0 ) )"; case "b <- v3": return "( " + t + " != vec3( 0.0 ) )"; case "b <- v4": return "( " + t + " != vec4( 0.0 ) )"; case "b <- i": return "( " + t + " != 0 )" }return t } getTypeByFormat (t) { return GW[t] || t } getFormatByType (t) { return VW[t] || t } getUUID (t, e) { return e = e !== void 0 ? e : !0, e && this.cache && (t = this.cache + "-" + t), t } getElementByIndex (t) { return E2[t] } getIndexByElement (t) { return E2.indexOf(t) } isShader (t) { return this.shader === t } setShader (t) { return this.shader = t, this } mergeDefines (t) { for (let e in t) this.defines[e] = t[e]; return this.defines } mergeUniform (t) { for (let e in t) this.uniforms[e] = t[e]; return this.uniforms } getTextureEncodingFromMap (t) { let e; return t ? t.isTexture && (e = t.encoding) : e = li, e === li && this.context.gamma && (e = Je), e }
}; var Rt = class extends Bt { constructor(e = 0, n, r, s) { super("c"); this.nodeType = "Color"; this.value = e instanceof on ? e : new on(e || 0, n, r, s) } setRGBA (e) { this.value.setRGBA(e.r, e.g, e.b, e.a) } generate (e, n, r, s, o, a) { r = e.getUUID(r ?? this.getUUID()), s = s ?? this.getType(e); let l = e.getNodeData(r), u = this.getReadonly() && this.generateReadonly !== void 0; if (this.alpha) { let c = this.alpha.build(e, "f"); e.addFragmentNodeCode(`accumAlpha += ( 1.0 - accumAlpha ) * ${c};`) } return u ? this.generateReadonly(e, n, r, s, o, a) : e.isShader("vertex") ? (l.vertex || (l.vertex = e.createVertexUniform(s, this, o, a, this.getLabel())), e.format(l.vertex.name, s, n)) : (l.fragment || (l.fragment = e.createFragmentUniform(s, this, o, a, this.getLabel())), e.format(l.fragment.name, s, n)) } generateReadonly (e, n, r, s, o, a) { return e.format("vec3(" + this.value.r + ", " + this.value.g + ", " + this.value.b + ")", s, n) } }; var pt = class extends Bt { constructor(e) { super("i"); this.nodeType = "Int"; this.value = Math.floor(e ?? 0) } generateReadonly (e, n, r, s, o, a) { return e.format(this.value.toString(), s, n) } }; var mn = class extends Bt { constructor(e) { super("b"); this.nodeType = "Bool"; this.value = e ?? !1 } generateReadonly (e, n, r, s) { return e.format(this.value ? "true" : "false", s, n) } }; var is = class extends Bt { constructor(e = 1, n) { super("f[]"); this.nodeType = "FloatArray"; this.size = e, this.value = Array.isArray(n) ? n : typeof n == "number" ? new Array(e).fill(n) : new Array(e).fill(0) } }; var ka = class extends Bt { }; var Hy = class extends ka { constructor(e) { super("v3"); this.image = e; this._value = new A } get value () { return this._value.x = this.image.isVideo ? this.image.img.videoWidth ?? 0 : this.image.img.width, this._value.y = this.image.isVideo ? this.image.img.videoHeight ?? 0 : this.image.img.height, this._value } }; var Vl = class extends ka { constructor(e, n) { super("t"); this.image = e; this.wrap = n } get value () { return this.image.getTexture(this.wrap) } }; var _h = class extends Bt { constructor(e) { super("m3"); this.nodeType = "Matrix3"; this.value = e ?? new Xt } generateReadonly (e, n, r, s, o, a) { return e.format("mat3(" + this.value.elements.join(", ") + ")", s, n) } get elements () { return this.value.elements } set elements (e) { this.value.fromArray(e) } }; var Sr = class extends Bt { constructor(e) { super("m4"); this.nodeType = "Matrix4"; this.value = e ?? new se } generateReadonly (e, n, r, s, o, a) { return e.format("mat4(" + this.value.elements.join(", ") + ")", s, n) } get elements () { return this.value.elements } set elements (e) { this.value.fromArray(e) } }; function M2 (i, t, e) { i.setUvTransform(e[0], e[1], t[0], t[1], 0, 0, 0) } var jy = class extends _h { constructor(e, n) { super(new Xt); this.repeat = e; this.offset = n; M2(this.value, e, n) } updateMatrix () { M2(this.value, this.repeat, this.offset) } }; var ss = class extends Bt { constructor(e = 1, n) { super("v4[]"); this.nodeType = "Vector4Array"; this.size = e, this.value = Array.isArray(n) ? n : n instanceof qe ? new Array(e).fill(n) : new Array(e).fill(new qe(0)) } }; var Eh = class extends We { constructor(e, n, r, s) { super("v3"); this.nodeType = "Blend"; this.a = e, this.b = n, this.alpha = r, this.mode = s } generate (e, n) { if (e.isShader("fragment")) { let r = []; return r.push(this.a.build(e, "c")), r.push(this.b.build(e, "c")), r.push(this.alpha.build(e, "f")), r.push(this.mode.build(e, "i")), e.format("spe_blend(" + r.join(",") + ")", this.getType(e), n) } else return console.warn("BlendNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), n) } }; var rS = class extends We { constructor(e, n) { super("v3"); this.nodeType = "CustomColor"; this.color = e, this.alpha = n, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) { if (e.isShader("fragment")) { let r = e.include(rS.Nodes.customColor); e.addFragmentVariable(this.calpha, "float"); let s = []; return s.push(this.color.build(e, "v3")), s.push(this.mask ? `luminance(${this.mask.build(e, "v3")})` : "1.0"), s.push(this.alpha.build(e, "f")), s.push(this.calpha), e.format(r + "(" + s.join(",") + ")", this.getType(e), n) } else return console.warn("CustomColorNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), n) } }, Hl = rS; Hl.Nodes = function () {
	return {
		customColor: new me(`vec3 customColor(vec3 color, float mask, float alpha, out float calpha) {
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color;
			}`)
	}
}(); var iS = class extends We { constructor(e, n) { super("v3"); this.nodeType = "CustomNormal"; this.cnormal = e, this.alpha = n, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) { if (e.isShader("fragment")) { let r = e.include(iS.Nodes.customNormal); e.addFragmentVariable(this.calpha, "float"); let s = []; return s.push(this.cnormal.build(e, "v3")), s.push("normal"), s.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), s.push(this.alpha.build(e, "f")), s.push(this.calpha), e.format(r + "(" + s.join(",") + ")", this.getType(e), n) } else return console.warn("CustomNormalNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), n) } }, Mh = iS; Mh.Nodes = function () {
	return {
		customNormal: new me(`vec3 customNormal(vec3 cnormal, vec3 norm, float mask, float alpha, out float calpha) {
				vec3 normal = packNormalToRGB( norm ).rgb;
				normal *= step( vec3(0.5), cnormal );

				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * lalpha;

				return normal;
			}`)
	}
}(); var Th = class extends We {
	constructor(e, n, r, s, o, a, l, u, c, h, d, f) { super("v3"); this.nodeType = "CustomTexture"; this.texture = e, this.textureSize = n, this.crop = r, this.projection = s, this.axis = o, this.side = a, this.size = l, this.blending = u, this.mat = c, this.isMask = f, this.alpha = h, this.mode = d, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) {
		e.require("position"), e.require("normal"), e.require("uv"), e.requires.uv = [!0], e.extensions.shaderTextureLOD = !0, e.extensions.derivatives = !0; let r = `g${this.uuid.toString().replace(/-/g, "")}`, s; switch (this.projection.value) {
			case 3: s = e.include(Th.Nodes.cylindrical); break; case 2: s = e.include(Th.Nodes.spherical); break; case 1: let a = ["vec3(1.0, 0.0, 0.0)", "vec3(0.0, 1.0, 0.0)", "vec3(0.0, 0.0, 1.0)"][this.axis.value], l = ["zy", "xz", "xy"][this.axis.value], u = new me(`
		vec3 ${r}_planarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
				vec2 projected = (1. + (position.${l})) / 2.;
				vec2 uvs = ( mat * vec3( (projected * 2. - 1.) / (size * .5), 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				${this.side.value === 2 ? "" : `lalpha *= step(0.0, ${this.side.value === 1 ? "-1.0 * " : ""}dot(vObjectNormal, mat * ${a}));`}

				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`); s = e.include(u); break; case 4: s = e.include(Th.Nodes.triplanar); break; default: s = e.include(Th.Nodes.uv); break
		}e.addFragmentVariable(this.calpha, "float"); let o = []; if (o.push("normal"), o.push(this.texture.generate(e, "t")), o.push(this.textureSize.build(e, "v2")), o.push(this.crop.build(e, "f")), o.push(this.mat.build(e, "mat3")), o.push(this.size.build(e, "v2")), o.push(this.blending.build(e, "f")), o.push(this.isMask.build(e, "b")), o.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), o.push(this.alpha.build(e, "f")), o.push(this.mode.build(e, "i")), o.push(this.calpha), this.projection.value === 4) { let a = `${r}_writeUvs`, l = a + "0", u = a + "1", c = a + "2", h = `${r}_triplanarWeights`; e.addFragmentVariable(l, "vec2"), e.addFragmentVariable(u, "vec2"), e.addFragmentVariable(c, "vec2"), e.addFragmentVariable(h, "vec3"), o.push(l), o.push(u), o.push(c), o.push(h) } else { let a = `${r}_writeUvs`; e.addFragmentVariable(a, "vec2"), o.push(a) } return e.format(s + "(" + o.join(",") + ")", this.getType(e), n)
	}
}, Ua = Th; Ua.Nodes = function () {
	let e = new me(`
vec3 cylindricalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
                vec3 posN = normalize(position);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float scaledHeight = position.y / (size.y * 0.5);
                float v =  (scaledHeight / 2.) + .5;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;

				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`), n = new me(`
vec3 sphericalTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
                vec3 posN = normalize(vPosition);
                float u = 0.5 + atan(posN.z, posN.x) / (2.*3.1415);
                float v = 0.5 + asin(posN.y) / 3.1415;

                vec2 calculatedUv = vec2(u,v);
				vec2 uvs = ( mat * vec3( calculatedUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

                vec2 df = fwidth(uvs);
               	if(df.x > 0.5) df.x = 0.;
				#ifdef GL_EXT_shader_texture_lod
                vec4 tmp = texture2DLodEXT(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#else
                vec4 tmp = textureLod(tex, uvs, log2(max(df.x, df.y)*min(textureSize.x, textureSize.y)));
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}
`), r = new me(`vec3 uvTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUv) {
				vec2 uvs = ( mat * vec3( vUv * 2. - 1., 1. ) / 2. + 0.5 ).xy;
				writeUv = uvs;

				vec4 tmp = texture2D( tex, uvs );

				vec3 col = tmp.rgb;

				float lalpha = alpha * tmp.a;
				if ( crop > 0.5 ) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						lalpha = 0.0;
					}
				}
				
				lalpha *= mask;

				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;
			}`), s = new me(`vec3 triplanarTexture(vec3 normal, sampler2D tex, vec2 textureSize, float crop, mat3 mat, vec2 size, float blending, bool isMask, float mask, float alpha, int mode, out float calpha, out vec2 writeUvs0, out vec2 writeUvs1, out vec2 writeUvs2, out vec3 writeWeights) {
				vec3 p = position;
				vec2 uv0 = (1.0 + p.xy) / 2.0;     
				vec2 uv1 = (1.0 + p.zy) / 2.0;		
				vec2 uv2 = (1.0 + p.xz) / 2.0;		
	
				uv0 = (mat * vec3((uv0 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv1 = (mat * vec3((uv1 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;
				uv2 = (mat * vec3((uv2 * 2.0 - 1.0) / (size * 0.5), 1.0) / 2.0 + 0.5).xy;

				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));

				// Write out all sets of UVs that we generated
				writeUvs0 = uv0;
				writeUvs1 = uv1;
				writeUvs2 = uv2;
				writeWeights = weights;

				// Derivatives for LOD
				vec2 df0 = fwidth(uv0);
				vec2 df1 = fwidth(uv1);
				vec2 df2 = fwidth(uv2);
				if (df0.x > 0.5) df0.x = 0.0;
				if (df1.x > 0.5) df1.x = 0.0;
				if (df2.x > 0.5) df2.x = 0.0;

				#ifdef GL_EXT_shader_texture_lod
                	vec4 tmp = 
						texture2DLodEXT(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						texture2DLodEXT(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						texture2DLodEXT(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#else
                	vec4 tmp = 
						textureLod(tex, uv0, log2(max(df0.x, df0.y)*min(textureSize.x, textureSize.y))) * weights.z + 
						textureLod(tex, uv1, log2(max(df1.x, df1.y)*min(textureSize.x, textureSize.y))) * weights.x + 
						textureLod(tex, uv2, log2(max(df2.x, df2.y)*min(textureSize.x, textureSize.y))) * weights.y;
				#endif

				vec3 col = tmp.rgb;
				float lalpha = alpha * tmp.a;

				// Apply cropping across all 3 planes
				if ( crop > 0.5 ) {
					if ( uv0.x < 0.0 || uv0.x > 1.0 || uv0.y < 0.0 || uv0.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv1.x < 0.0 || uv1.x > 1.0 || uv1.y < 0.0 || uv1.y > 1.0 )  {
						lalpha = 0.0;
					}
					if ( uv2.x < 0.0 || uv2.x > 1.0 || uv2.y < 0.0 || uv2.y > 1.0 )  {
						lalpha = 0.0;
					}
				}

				lalpha *= mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return col;//n * 0.5 + 0.5;
			}			
			`); return { cylindrical: e, spherical: n, uv: r, triplanar: s }
}(); var Ch = class extends We {
	constructor(e, n, r, s, o, a, l, u, c, h, d, f) { super("v3"); this.nodeType = "Depth"; this.gradientType = e, this.smooth = n, this.near = r, this.far = s, this.isVector = o, this.isWorldSpace = a, this.origin = l, this.direction = u, this.colors = c, this.steps = h, this.isMask = f, this.alpha = d, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) {
		let r = `g${this.uuid.toString().replace(/-/g, "")}`, s = new me(`vec3 ${r}_sdepth(float near, float far, vec3 origin, vec3 direction, vec4 colors[${r}_MAX_COLORS], float steps[${r}_MAX_COLORS], bool isMask, float mask, float alpha, out float calpha) {
               vec4 color = colors[0];
               #ifdef ${r}_IS_VECTOR
                   #ifdef ${r}_LINEAR
                       #ifdef ${r}_WORLDSPACE
                       float depth = vectorLinearWorldSpaceDepth(direction, origin, near, far);
                       #else
                       float depth = vectorLinearObjectSpaceDepth(direction, origin, near, far);
                       #endif
                   #else
                       #ifdef ${r}_WORLDSPACE
                           float depth = vectorSphericalWorldSpaceDepth(origin, near, far);
                       #else
                           float depth = vectorSphericalObjectSpaceDepth(origin, near, far);
                       #endif
                   #endif
               #else
                   float dist = length(vWPosition - cameraPosition);
			       float depth = ( dist - near ) / ( far - near );
               #endif


              float p;
              #ifdef ${r}_SMOOTH
				for ( int i = 1; i < ${r}_MAX_COLORS; i++ ) {
						p = clamp( ( depth - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}
              #else
                for ( int i = 1; i < ${r}_MAX_COLORS; i++ ) {
                   p = clamp(( depth - steps[i - 1] ) / ( steps[i] - steps[i - 1] ), 0.0, 1.0);
                   color = mix(color, colors[i], p);
                 }
              #endif

               float lalpha = alpha * color.a * mask;
               calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
			   accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
			   
               return color.rgb;
			}`, [Ch.Nodes.vectorLinearWorldSpaceDepth, Ch.Nodes.vectorLinearObjectSpaceDepth, Ch.Nodes.vectorSphericalObjectSpaceDepth, Ch.Nodes.vectorSphericalWorldSpaceDepth]); if (e.isShader("fragment")) { e.define(`${r}_MAX_COLORS`, this.colors.value.length), this.smooth.value && e.define(`${r}_SMOOTH`), this.isVector.value > .5 && e.define(`${r}_IS_VECTOR`), this.gradientType.value === 0 && e.define(`${r}_LINEAR`), this.isWorldSpace.value > .5 && e.define(`${r}_WORLDSPACE`), e.require("worldPosition"), e.addFragmentVariable(this.calpha, "float"); let o = e.include(s), a = []; return a.push(this.near.build(e, "f")), a.push(this.far.build(e, "f")), a.push(this.origin.build(e, "v3")), a.push(this.direction.build(e, "v3")), a.push(this.colors.build(e, "v4[]")), a.push(this.steps.build(e, "f[]")), a.push(this.isMask.build(e, "b")), a.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), a.push(this.alpha.build(e, "f")), a.push(this.calpha), e.format(o + "(" + a.join(",") + ")", this.getType(e), n) } else return console.warn("DepthNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), n)
	}
}, Ph = Ch; Ph.Nodes = function () {
	let e = new me(`float vectorLinearWorldSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(vWPosition.x - origin.x) + n.y*(vWPosition.y - origin.y) + n.z*(vWPosition.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`), n = new me(`float vectorLinearObjectSpaceDepth(vec3 direction, vec3 origin, float near, float far) {
               vec3 n = normalize(direction);
               float dist = (n.x*(position.x - origin.x) + n.y*(position.y - origin.y) + n.z*(position.z - origin.z));
               return ( dist - near ) / ( far - near );
            }`), r = new me(`float vectorSphericalWorldSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(vWPosition - origin);
               return ( dist - near ) / ( far - near );
            }`), s = new me(`float vectorSphericalObjectSpaceDepth(vec3 origin, float near, float far) {
               float dist = length(position - origin);
               return ( dist - near ) / ( far - near );
            }`); return { vectorLinearWorldSpaceDepth: e, vectorLinearObjectSpaceDepth: n, vectorSphericalWorldSpaceDepth: r, vectorSphericalObjectSpaceDepth: s }
}(); var Yf = class extends We {
	constructor(e, n, r, s, o, a, l, u) { super("v3"); this.nodeType = "Fresnel"; this.color = e, this.bias = n, this.scale = r, this.intensity = s, this.factor = o, this.isMask = u, this.alpha = a, this.mode = l, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) {
		if (e.require("vWorldViewDir"), e.require("worldNormal"), e.isShader("fragment")) {
			e.addFragmentVariable(this.calpha, "float"); let r = new me(`vec3 fresnel(vec3 color, float bias, float scale, float intensity, float factor, bool isMask, float mask, float alpha, int mode, out float calpha) {
					float fresnel = bias + scale * pow( abs( factor + dot( normalize( vWorldViewDir ), normalize( vWNormal ) ) ), intensity );

					float lalpha = clamp(fresnel, 0.0, 1.0) * alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return color;
				}`), s = e.include(r), o = []; return o.push(this.color.build(e, "c")), o.push(this.bias.build(e, "f")), o.push(this.scale.build(e, "f")), o.push(this.intensity.build(e, "f")), o.push(this.factor.build(e, "f")), o.push(this.isMask.build(e, "b")), o.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), o.push(this.alpha.build(e, "f")), o.push(this.mode.build(e, "i")), o.push(this.calpha), e.format(s + "(" + o.join(",") + ")", this.getType(e), n)
		} else return console.warn("FresnelNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), n)
	}
}; var sS = class extends We { constructor(e, n, r, s, o, a, l, u, c) { super("v3"); this.nodeType = "Gradient"; this.gradientType = e, this.smooth = n, this.colors = r, this.steps = s, this.offset = o, this.morph = a, this.angle = l, this.isMask = c, this.alpha = u, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) { if (e.isShader("fragment")) { e.define("GRAD_MAX", 10), e.require("uv"), e.requires.uv = [!0], e.addFragmentVariable(this.calpha, "float"); let r = e.include(sS.Nodes.gradient), s = []; return s.push(this.gradientType.build(e, "i")), s.push(this.smooth.build(e, "b")), s.push(this.colors.build(e, "v4[]")), s.push(this.steps.build(e, "f[]")), s.push(this.offset.build(e, "v2")), s.push(this.morph.build(e, "v2")), s.push(this.angle.build(e, "f")), s.push(this.isMask.build(e, "b")), s.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), s.push(this.alpha.build(e, "f")), s.push(this.calpha), e.format(r + "(" + s.join(",") + ")", this.getType(e), n) } else return console.warn("GradientNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), n) } }, Ih = sS; Ih.Nodes = function () {
	return {
		gradient: new me(`vec3 gradient(int gradientType, bool smoothed, vec4 colors[GRAD_MAX], float steps[GRAD_MAX], vec2 offset, vec2 morph, float angle, bool isMask, float mask, float alpha, out float calpha) {
				vec4 color = colors[0];
				vec2 m = morph / vUv.xy;
				vec2 rot = vec2( 0.5 + m.x, m.y );
				vec2 dt = vec2(
					cos( angle ) * rot.x - sin( angle ) * rot.y,
					sin( angle ) * rot.x + cos( angle ) * rot.y
				);
				vec2 pt = ( vUv - 0.5 + offset ) / 2.0 + dt / 2.0;
				float t = dot( pt, dt ) / dot( dt, dt );
				if ( gradientType == 1 ) {
					t = distance (
						( vUv + morph ) * 3.0,
						( vUv + offset ) + 1.0
					) + angle;
				} else if ( gradientType == 2 ) {
					float polar = atan(
						vUv.x + morph.x - 0.5 + offset.x,
						vUv.y + morph.y - 0.5 + offset.y
					) * -1.0;
					t = fract( ( angle / PI / -2.0 ) + 0.5 * ( polar / PI ) );
				}

				float p;
				if (smoothed) {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
					}

				} else {
					for ( int i = 1; i < GRAD_MAX; i++ ) {
						p = clamp( ( t - steps[i-1] ) / ( steps[i] - steps[i-1] ), 0.0, 1.0 );
						color = mix(color, colors[i], p);
					}
				}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
				
				return color.xyz;
			}`)
	}
}(); var oS = class extends We { constructor(e, n, r, s) { super("v3"); this.nodeType = "Matcap"; this.texture = e, this.isMask = s, this.alpha = n, this.mode = r, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) { if (e.isShader("fragment")) { e.addFragmentVariable(this.calpha, "float"); let r = e.include(oS.Nodes.matcap); e.require("normal"), e.requires.normal = !0; let s = []; return s.push(this.texture.generate(e, "t")), s.push("normal"), s.push(this.isMask.build(e, "b")), s.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), s.push(this.alpha.build(e, "f")), s.push(this.mode.build(e, "i")), s.push(this.calpha), e.format(r + "(" + s.join(",") + ")", this.getType(e), n) } else return console.warn("MatcapNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), n) } }, Dh = oS; Dh.Nodes = function () {
	return {
		matcap: new me(`vec3 matcap(sampler2D matcapTex, vec3 normal, bool isMask, float mask, float alpha, int mode, out float calpha) {
					vec3 viewDir = normalize( vViewPosition );
					vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
					vec3 y = cross( viewDir, x );
					vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5; // 0.495 to remove artifacts caused by undersized matcap disks
					vec4 matcapColor = texture2D( matcapTex, uv );

					float lalpha = alpha * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));
					
					return matcapColor.rgb;
            	}`)
	}
}(); var Xf = (o => (o.SIMPLEX = "simplex3d", o.SIMPLEX_FRACTAL = "simplex3dFractal", o.ASHIMA = "simplexAshima", o.FBM = "fbm", o.PERLIN = "perlin", o.VORONOI = "voronoi", o))(Xf || {}), hr = function () {
	let t = new me(`vec3 random3(vec3 c) {
			float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
			vec3 r;
			r.z = fract(512.0*j);
			j *= .125;
			r.x = fract(512.0*j);
			j *= .125;
			r.y = fract(512.0*j);
			return r-0.5;
		}`), e = new me(`float simplex3d(vec3 p) {
			 vec3 s = floor(p + dot(p, vec3(F3)));
			 vec3 x = p - s + dot(s, vec3(G3));
			 
			 vec3 e = step(vec3(0.0), x - x.yzx);
			 vec3 i1 = e*(1.0 - e.zxy);
			 vec3 i2 = 1.0 - e.zxy*(1.0 - e);
				
			 vec3 x1 = x - i1 + G3;
			 vec3 x2 = x - i2 + 2.0*G3;
			 vec3 x3 = x - 1.0 + 3.0*G3;
			 
			 vec4 w, d;
			 
			 w.x = dot(x, x);
			 w.y = dot(x1, x1);
			 w.z = dot(x2, x2);
			 w.w = dot(x3, x3);
			 
			 w = max(0.6 - w, 0.0);
			 
			 d.x = dot(random3(s), x);
			 d.y = dot(random3(s + i1), x1);
			 d.z = dot(random3(s + i2), x2);
			 d.w = dot(random3(s + 1.0), x3);
			 
			 w *= w;
			 w *= w;
			 d *= w;
			 
			 return dot(d, vec4(52.0));
		}`, [t]); e.keywords.F3 = new Et("float F3 0.3333333"), e.keywords.G3 = new Et("float G3 0.1666667"); let n = new me(`float simplex3dFractal(vec3 m) {
			mat3 rot1 = mat3(-0.37, 0.36, 0.85,-0.14,-0.93, 0.34,0.92, 0.01,0.4);
			mat3 rot2 = mat3(-0.55,-0.39, 0.74, 0.33,-0.91,-0.24,0.77, 0.12,0.63);
			mat3 rot3 = mat3(-0.71, 0.52,-0.47,-0.08,-0.72,-0.68,-0.7,-0.45,0.56);
			return 0.5333333 * simplex3d(m * rot1)
				 + 0.2666667 * simplex3d(2.0 * m * rot2)
				 + 0.1333333 * simplex3d(4.0 * m * rot3)
				 + 0.0666667 * simplex3d(8.0 * m);
		}`, [e]), r = new me("vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}"), s = new me("vec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}"), o = new me(`float simplexAshima(vec3 v) {
		  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
		  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
		  vec3 i  = floor(v + dot(v, C.yyy) );
		  vec3 x0 =   v - i + dot(i, C.xxx) ;
		  vec3 g = step(x0.yzx, x0.xyz);
		  vec3 l = 1.0 - g;
		  vec3 i1 = min( g.xyz, l.zxy );
		  vec3 i2 = max( g.xyz, l.zxy );
		  vec3 x1 = x0 - i1 + 1.0 * C.xxx;
		  vec3 x2 = x0 - i2 + 2.0 * C.xxx;
		  vec3 x3 = x0 - 1. + 3.0 * C.xxx;
		  i = mod(i, 289.0 ); 
		  vec4 p = permute( permute( permute( 
					 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
				   + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
				   + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
		  float n_ = 1.0/7.0; // N=7
		  vec3  ns = n_ * D.wyz - D.xzx;
		  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)
		  vec4 x_ = floor(j * ns.z);
		  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
		  vec4 x = x_ *ns.x + ns.yyyy;
		  vec4 y = y_ *ns.x + ns.yyyy;
		  vec4 h = 1.0 - abs(x) - abs(y);
		  vec4 b0 = vec4( x.xy, y.xy );
		  vec4 b1 = vec4( x.zw, y.zw );
		  vec4 s0 = floor(b0)*2.0 + 1.0;
		  vec4 s1 = floor(b1)*2.0 + 1.0;
		  vec4 sh = -step(h, vec4(0.0));
		  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
		  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
		  vec3 p0 = vec3(a0.xy,h.x);
		  vec3 p1 = vec3(a0.zw,h.y);
		  vec3 p2 = vec3(a1.xy,h.z);
		  vec3 p3 = vec3(a1.zw,h.w);
		  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
		  p0 *= norm.x;
		  p1 *= norm.y;
		  p2 *= norm.z;
		  p3 *= norm.w;
		  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
		  m = m * m;
		  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
										dot(p2,x2), dot(p3,x3) ) );
		}`, [r, s]), a = new me("vec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}"), l = new me("vec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}", [a]), u = new me(`float noise(vec3 p){
			vec3 a = floor(p);
			vec3 d = p - a;
			d = d * d * (3.0 - 2.0 * d);
			vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);
			vec4 k1 = perm(b.xyxy);
			vec4 k2 = perm(k1.xyxy + b.zzww);
			vec4 c = k2 + a.zzzz;
			vec4 k3 = perm(c);
			vec4 k4 = perm(c + 1.0);
			vec4 o1 = fract(k3 * (1.0 / 41.0));
			vec4 o2 = fract(k4 * (1.0 / 41.0));
			vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);
			vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);
			return o4.y * d.y + o4.x * (1.0 - d.y);
		}`, [l]), c = new me(`float fbm(vec3 x) {
			float v = 0.0;
			float a = 0.5;
			vec3 shift = vec3(100);
			for (int i = 0; i < NUM_OCTAVES; ++i) {
				v += a * noise(x);
				x = x * 2.0 + shift;
				a *= 0.5;
			}
			return v;
		}`, [u]); c.keywords.NUM_OCTAVES = new Et(`int NUM_OCTAVES ${5}`); let h = new me("vec3 fade(vec3 t) {return t*t*t*(t*(t*6.0-15.0)+10.0);}"), d = new me(`float perlin(vec3 P){
		  vec3 Pi0 = floor(P);
		  vec3 Pi1 = Pi0 + vec3(1.0);
		  Pi0 = mod(Pi0, 289.0);
		  Pi1 = mod(Pi1, 289.0);
		  vec3 Pf0 = fract(P);
		  vec3 Pf1 = Pf0 - vec3(1.0);
		  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
		  vec4 iy = vec4(Pi0.yy, Pi1.yy);
		  vec4 iz0 = Pi0.zzzz;
		  vec4 iz1 = Pi1.zzzz;
		  vec4 ixy = permute(permute(ix) + iy);
		  vec4 ixy0 = permute(ixy + iz0);
		  vec4 ixy1 = permute(ixy + iz1);
		  vec4 gx0 = ixy0 / 7.0;
		  vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
		  gx0 = fract(gx0);
		  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
		  vec4 sz0 = step(gz0, vec4(0.0));
		  gx0 -= sz0 * (step(0.0, gx0) - 0.5);
		  gy0 -= sz0 * (step(0.0, gy0) - 0.5);
		  vec4 gx1 = ixy1 / 7.0;
		  vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
		  gx1 = fract(gx1);
		  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
		  vec4 sz1 = step(gz1, vec4(0.0));
		  gx1 -= sz1 * (step(0.0, gx1) - 0.5);
		  gy1 -= sz1 * (step(0.0, gy1) - 0.5);
		  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);
		  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);
		  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);
		  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);
		  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);
		  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);
		  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);
		  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);
		  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
		  g000 *= norm0.x;
		  g010 *= norm0.y;
		  g100 *= norm0.z;
		  g110 *= norm0.w;
		  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
		  g001 *= norm1.x;
		  g011 *= norm1.y;
		  g101 *= norm1.z;
		  g111 *= norm1.w;
		  float n000 = dot(g000, Pf0);
		  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));
		  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
		  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));
		  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));
		  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
		  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));
		  float n111 = dot(g111, Pf1);
		  vec3 fade_xyz = fade(Pf0);
		  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
		  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
		  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); 
		  return 2.2 * n_xyz;
		}`, [r, s, h]), f = new me(`float hashwithoutsine13(vec3 p3)
		{
			p3  = fract(p3 * .1031);
			p3 += dot(p3, p3.yzx + 33.33);
			return fract((p3.x + p3.y) * p3.z);
		}`), p = new me(`vec3 hashwithoutsine33(vec3 p3)
		{
			p3 = fract(p3 * vec3(.1031, .1030, .0973));
			p3 += dot(p3, p3.yxz+33.33);
			return fract((p3.xxy + p3.yxx)*p3.zyx);
		}`), m = new me(`float metric(in vec3 p)
		{
			// L2 
			return length(p);

			// Chebyshev 
			// vec3 a = abs(p);
			// return max(a.x, max(a.y, a.z));
		}`), g = new me(`float smin( float a, float b, float k )
		{
			float h = smoothstep(0.0, 1.0, 0.5 + 0.5 * (b - a) / k);
			float correction = k * h * (1.0 - h);
			return mix(b, a, h) - correction;
		}`), y = new me(`float smax( float a, float b, float k )
		{
			float h = smoothstep(1.0, 0.0, 0.5 + 0.5 * (a - b) / k);
			float correction = k * h * (1.0 - h);
			return mix(a, b, h) + correction;
		}`), v = new me(`float remap(float value, float input_min, float input_max, float output_min, float output_max) {
			// Compute width of each interval
			float input_width = input_max - input_min;
			float output_width = output_max - output_min;
		
			// Convert input range into a 0-1 range 
			float scaled = (value - input_min) / input_width;
		
			// Convert the 0-1 range into a value in output range
			return output_min + (scaled * output_width);
		}`), x = new me(`float voronoi(in vec3 x, in int style, in float smoothness, in float seed, in int quality) 
		{
			// Integer and fractional parts of this point's coordinates
			ivec3 p = ivec3(floor(x));
			vec3 f = fract(x);

			// Different variables that we will use to construct noise:
			//
			// f1: distance to the closest feature point
			// f2: distance to the second closest feature point
			// e: distance to the closest edge (cell boundary)
			//
			// We also compute "smooth" versions of all of the above quantites, essentially
			// replacing "hard" minimums with "smooth" minimums (described by IQ)
			float f1_smooth = 8.0;
			float f1 = 8.0;
			float f2_smooth = 8.0;
			float f2 = 8.0;
			float e_smooth = 8.0;
			float e = 8.0;

			// Variables stored from closest cell
			ivec3 mb;
			vec3 mr; 

			int steps = quality;
			
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				ivec3 b = ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d = length(r);
				
				f1_smooth = smin(d, f1_smooth, smoothness);

				// Store un-smoothed distances too 
				if (d < f1) 
				{
					f2 = f1;
					f1 = d;

					mb = ivec3(x, y, z);
					mr = r;
				} 
				else if (d < f2) 
				{
					f2 = d;
				}
			}	
			
			float id = hashwithoutsine13(vec3(p + mb) + seed);

			// Second pass for edge distance  
			for (int x = -steps; x <= steps; x++) 
			for (int y = -steps; y <= steps; y++)
			for (int z = -steps; z <= steps; z++)
			{
				// Start search at the cell that contains the closest point to "x" (found in 1st pass)
				ivec3 b = mb + ivec3(x, y, z);
				vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
				float d1 = dot(0.5 * (mr + r), (r - mr)); 				// IQ normalizes "r - mr" but that breaks things for the smooth version?
				float d2 = dot(0.5 * (mr + r), normalize(r - mr));

				e_smooth = smin(d1, e_smooth, smoothness);

				e = min(e, d2);

				// Also compute a smooth version of F2 in this pass
				{
					ivec3 b = ivec3(x, y, z);
					if (b != mb) 
					{
						vec3 r = vec3(b) + hashwithoutsine33(vec3(p + b) + seed) - f;
						float d = length(r);

						f2_smooth = smin(d, f2_smooth, smoothness);
					}
				}
			}

			// Different visualization modes 
			if (style == 0) 
			{
				return f1_smooth;
			}
			if (style == 1) 
			{
				return f2_smooth;
			}
			if (style == 2) 
			{
				return f2_smooth - f1_smooth;
				
				// "Pebbles" also cool
				//return step(0.2, f2_smooth - f1_smooth);
			}
			if (style == 3) 
			{
				// This one is really good for rock / stone effects
				float a = f1; 
				float b = f2;
				float k = 3.0;
				float h = max(k - abs(a - b), 0.0) / k;
				float final = min(a, b) - h * h * k * (1.0 / 4.0);
				return final;
			}
			if (style == 4) 
			{
				// Some random adjustments to make this style stand out more 
				return exp(5.0 * e_smooth);
			}
			if (style == 5) 
			{
				return pow(f1_smooth, 3.0);
			}
			if (style == 6) 
			{				
				const float eps = 0.0125;

				// Thicker lines as the user increases the smoothness slider
				float thickness = smoothness * 0.25 + eps;

				// Blurrier lines as the user increases the smoothness slider
				float blur = pow(smoothness, 3.0) * 0.25 + eps;

				return smoothstep(
					thickness - thickness * blur, 
					thickness + thickness * blur, 
					e
				);
			}
			if (style == 7) 
			{
				return hashwithoutsine13(vec3(p + mb) + seed);
			}
		}
	`, [f, p, m, g, y, v]); return { simplex: e, simplexFractal: n, simplexAshima: o, fbm: c, perlin: d, voronoi: x }
}(); var Oh = class extends We {
	constructor(e, n, r, s, o, a, l, u, c, h, d, f, p, m, g, y, v, x, b) { super("v3"); this.nodeType = "Noise"; this.scale = e, this.size = n, this.move = r, this.fA = s, this.fB = o, this.distortion = a, this.colorA = l, this.colorB = u, this.colorC = c, this.colorD = h, this.noiseType = f, this.voronoiStyle = m, this.highCut = g, this.lowCut = y, this.smoothness = v, this.seed = x, this.quality = b, this.isMask = p, this.alpha = d, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n, r, s, o) {
		e.require("uv"), e.requires.uv = [!0], e.addFragmentVariable(this.calpha, "float"); let a = Object.values(Xf)[this.noiseType.value], l = a == "voronoi" ? `
		float v = ${a}(st + move, voronoiStyle, smoothness, seed, quality);

		// Apply clipping to colors
		v = remap(v, lowCut, highCut, 0.0, 1.0);
		v = smax(v, 0.0, smoothness * 0.25);
		v = smin(v, 1.0, smoothness * 0.25);

		// Note that the voronoi mode only uses colors "A" and "C" from the UI 
		vec4 color = mix(colorA, colorC, v); 
		`: `
		vec3 q = vec3(${a}(st),
					   ${a}(st + vec3(1.0)),
					   ${a}(st + vec3(1.0)));
		vec3 r = vec3(${a}(st + vec3(distortion, 1.0) * q + vec3(fA, 1.0) + move),
					  ${a}(st + vec3(distortion, 1.0) * q + vec3(fB, 1.0) + move), 
					  ${a}(st * q));
		float f = ${a}(st + r);
		vec4 color;
		color = mix(colorA, colorB, clamp((f * f) * 4.0, 0.0, 1.0));
		color = mix(color, colorC, clamp(length(q), 0.0, 1.0));
		color = mix(color, colorD, clamp(length(r.x), 0.0, 1.0));
		`, u = new me(`vec3 ${a}customNoise(float scale, vec3 size, float move, vec2 fA, vec2 fB, vec2 distortion, vec4 colorA, vec4 colorB, vec4 colorC, vec4 colorD, int voronoiStyle, float highCut, float lowCut, float smoothness, float seed, int quality, bool isMask, float mask, float alpha, out float calpha) 
			{
                // Prevent scale of zero 
				scale = max(abs(scale), 0.001);

				vec3 st = position / size;
				st /= scale;

				${l}

				float lalpha = alpha * color.a * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return clamp(color, 0.0, 1.0).rgb;
			}`, [hr.simplex, hr.simplexFractal, hr.simplexAshima, hr.fbm, hr.perlin, hr.voronoi]), c = e.include(u), h = []; return h.push(this.scale.build(e, "f")), h.push(this.size.build(e, "v3")), h.push(this.move.build(e, "f")), h.push(this.fA.build(e, "v2")), h.push(this.fB.build(e, "v2")), h.push(this.distortion.build(e, "v2")), h.push(this.colorA.build(e, "v4")), h.push(this.colorB.build(e, "v4")), h.push(this.colorC.build(e, "v4")), h.push(this.colorD.build(e, "v4")), h.push(this.voronoiStyle.build(e, "i")), h.push(this.highCut.build(e, "f")), h.push(this.lowCut.build(e, "f")), h.push(this.smoothness.build(e, "f")), h.push(this.seed.build(e, "f")), h.push(this.quality.build(e, "i")), h.push(this.isMask.build(e, "b")), h.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), h.push(this.alpha.build(e, "f")), h.push(this.calpha), e.format(c + "(" + h.join(",") + ")", this.getType(e), n)
	}
}; Oh.numOctaves = 5; var aS = class extends We {
	constructor(e, n, r, s, o, a, l, u, c, h, d, f, p, m, g, y) { super("v3"); this.nodeType = "Outline"; this.firstTime = !0, this.outlineColor = e, this.contourColor = n, this.outlineWidth = r, this.contourWidth = s, this.contourThreshold = o, this.outlineThreshold = a, this.contourFrequency = l, this.outlineSmoothing = u, this.contourDirection = c, this.positionalLines = h, this.compensation = d, this.resolution = f, this.normalMap = p, this.depthMap = m, this.pixelRatio = g, this.alpha = y, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) {
		let r = `g${this.uuid.toString().replace(/-/g, "")}`; if (e.require("vWorldViewDir"), e.require("worldNormal"), e.extensions.derivatives = !0, this.compensation.value && e.define("OUTLINE_COMPENSATION", `${r}_offset`), this.firstTime) {
			let s = this.outlineWidth.build(e, "f"), o = this.resolution.build(e, "v2"), a = this.compensation.build(e, "b"), l = this.pixelRatio.build(e, "f"); e.addVertexParsVariable("randomColor", "attribute vec3"), e.addVertexParsVariable("extrudeNormal", "attribute vec3"), e.addVertexParsVariable(s, "uniform float"), e.addVertexParsVariable(o, "uniform vec2"), e.addVertexParsVariable(a, "uniform bool"), e.addVertexParsVariable(l, "uniform float"), e.addVertexParsVariable("vID", "flat out float"), e.addFragmentParsVariable("vID", "flat in float"), e.addVertexFinalCode(`
                vID = randomColor.r;
                vec2 ${r}_offset = vec2(0.0);
                if (${a}) {
                    vec4 ${r}_clipPosition = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
                    // NOTE: For certain shapes, like spheres, we get incorrect extrusion when the
                    // normals face the camera directly. So we hackily fix this by offsetting the normal
                    // by a tiny amount.
                    vec3 ${r}_clipNormal = mat3(projectionMatrix) * (mat3(modelViewMatrix) * extrudeNormal) + 0.0000001;
                    ${r}_offset = normalize(${r}_clipNormal.xy) / ${o} * (${s} / 2.0) * ${r}_clipPosition.w * 2.0 * ${l};
                    ${r}_clipPosition.xy += ${r}_offset;
                    // TODO(MAX): To handle multiple outline layers, we only want to extrude
                    // if this offset is the biggest of all the potential offsets
                    gl_Position = ${r}_clipPosition;
                }
            `)
		} if (e.isShader("fragment")) { e.require("uv"), e.requires.uv = [!0], e.addFragmentVariable(this.calpha, "float"); let s = e.include(aS.Nodes.outline), o = []; return o.push(this.outlineColor.build(e, "c")), o.push(this.contourColor.build(e, "c")), o.push(this.outlineWidth.build(e, "f")), o.push(this.contourWidth.build(e, "f")), o.push(this.contourThreshold.build(e, "f")), o.push(this.outlineThreshold.build(e, "f")), o.push(this.contourFrequency.build(e, "f")), o.push(this.outlineSmoothing.build(e, "f")), o.push(this.contourDirection.build(e, "v3")), o.push(this.positionalLines.build(e, "b")), o.push(this.resolution.build(e, "v2")), o.push(this.normalMap.getTexture(e, "t")), o.push(this.depthMap.getTexture(e, "t")), o.push(this.pixelRatio.build(e, "f")), o.push(this.compensation.build(e, "b")), o.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), o.push(this.alpha.build(e, "f")), o.push(this.calpha), this.firstTime = !this.firstTime, e.format(s + "(" + o.join(",") + ")", this.getType(e), n) } else return console.warn("OutlineNode is not compatible with " + e.shader + " shader."), ""
	}
}, Rh = aS; Rh.Nodes = function () {
	let e = new me(`
float sobelSample(sampler2D t, sampler2D d, vec2 uv, vec2 resolution, float outlineWidth, float pixelRatio)
{
    vec2 halton = haltonSequence[frameIndex];
    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
    float temporalAngle  = temporalOffset * PI2;

    vec2 texelSize = (vec2(1.0) / resolution);
    vec2 offsetSize = texelSize * outlineWidth * pixelRatio;

    vec2 uvSamples[9];
    vec4 normalSamples[9];

	uvSamples[0] = uv + vec2( -offsetSize.x, -offsetSize.y) + (vogelDiskSample(0, 9, temporalAngle) * texelSize);
	uvSamples[1] = uv + vec2(0.0, -offsetSize.y) + (vogelDiskSample(1, 9, temporalAngle) * texelSize);
	uvSamples[2] = uv + vec2(  offsetSize.x, -offsetSize.y) + (vogelDiskSample(2, 9, temporalAngle) * texelSize);
	uvSamples[3] = uv + vec2( -offsetSize.x, 0.0) + (vogelDiskSample(3, 9, temporalAngle) * texelSize);
	uvSamples[4] = uv;
	uvSamples[5] = uv + vec2(  offsetSize.x, 0.0) + (vogelDiskSample(5, 9, temporalAngle) * texelSize);
	uvSamples[6] = uv + vec2( -offsetSize.x, offsetSize.y) + (vogelDiskSample(6, 9, temporalAngle) * texelSize);
	uvSamples[7] = uv + vec2(0.0, offsetSize.y) + (vogelDiskSample(7, 9, temporalAngle) * texelSize);
	uvSamples[8] = uv + vec2(  offsetSize.x, offsetSize.y) + (vogelDiskSample(8, 9, temporalAngle) * texelSize);


    normalSamples[0] = texture2D(t, uvSamples[0]);
    normalSamples[1] = texture2D(t, uvSamples[1]);
    normalSamples[2] = texture2D(t, uvSamples[2]);
    normalSamples[3] = texture2D(t, uvSamples[3]);
    normalSamples[4] = texture2D(t, uvSamples[4]);
    normalSamples[5] = texture2D(t, uvSamples[5]);
    normalSamples[6] = texture2D(t, uvSamples[6]);
    normalSamples[7] = texture2D(t, uvSamples[7]);
    normalSamples[8] = texture2D(t, uvSamples[8]);

    float depthBias = 0.0001;
    // TODO(MAX): Can we somehow reduce the number of conditionals here with MATH?!
    if (normalSamples[0].a != vID && normalSamples[0].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[0]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[1].a != vID && normalSamples[1].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[1]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[2].a != vID && normalSamples[2].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[2]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[3].a != vID && normalSamples[3].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[3]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }


    if (normalSamples[4].a != vID && normalSamples[4].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[4]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[5].a != vID && normalSamples[5].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[5]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[6].a != vID && normalSamples[6].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[6]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[7].a != vID && normalSamples[7].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[7]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    if (normalSamples[8].a != vID && normalSamples[8].a != 0.0) {
        float depthAtSample = texture2D(d, uvSamples[8]).r + depthBias;
        if (gl_FragCoord.z > depthAtSample) {
           return 0.0;
        }
    }

    vec3 sobel_edge_h = normalSamples[2].rgb + (2.0*normalSamples[5].rgb) + normalSamples[8].rgb - (normalSamples[0].rgb + (2.0*normalSamples[3].rgb) + normalSamples[6].rgb);
  	vec3 sobel_edge_v = normalSamples[0].rgb + (2.0*normalSamples[1].rgb) + normalSamples[2].rgb - (normalSamples[6].rgb + (2.0*normalSamples[7].rgb) + normalSamples[8].rgb);

    float edgeNormal = sqrt(dot(sobel_edge_h, sobel_edge_h) + dot(sobel_edge_v, sobel_edge_v));
    return edgeNormal;
}
`); return {
		outline: new me(`vec3 outline(vec3 outlineColor, vec3 contourColor, float outlineWidth, float contourWidth, float outlineThreshold, float contourThreshold, float outlineSmoothing, float contourFrequency, vec3 contourDirection, bool positionalLines, vec2 resolution, sampler2D normalMap, sampler2D depthMap, float pixelRatio, bool compensation, float mask, float alpha, out float calpha) {
                vec3 result = outlineColor;
                float resultAlpha = 0.0;

                vec3 N = normalize(vWNormal);
                vec2 nuv = (gl_FragCoord.xy / resolution);
                float sobelSample = compensation ? sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth / 2., pixelRatio) : sobelSample(normalMap, depthMap, nuv, resolution, outlineWidth, pixelRatio);
                resultAlpha = smoothstep(outlineThreshold - outlineSmoothing, outlineThreshold + outlineSmoothing, sobelSample);

                //resultAlpha = 1.0;
                //result = vec3(sobelSample);

                float t = 1.0 - contourThreshold;
                if(positionalLines) {
                    vec3 NDir = position * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float f  = fract(NT * contourFrequency * 0.01);
                    float df = fwidth(NT * contourFrequency);

                    float g = smoothstep(df * (contourWidth * 0.01), df * (contourWidth * 0.01 * 2.0), f);
                    if (g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0;
                    }
                 }
                 else {
                    vec3 NDir = N * contourDirection;
                    float NT = NDir.x + NDir.y + NDir.z;
                    float df = fwidth(NT * contourThreshold);
                    float f = sin(NT * 1.0 * contourFrequency);
                    float g = smoothstep(0.0, df * contourWidth, 1.0 - f);

                    if (df > (t * 0.5) && g < 1.0 && resultAlpha == 0.0) {
                        result = contourColor;
                        resultAlpha = 1.0 - g;
                    }
                 }

                 float lalpha = alpha * resultAlpha * mask;
                 calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
                 accumAlpha += ( 1.0 - accumAlpha ) * lalpha;
				 
                 return result;
             }`, [e])
	}
}(); var ks = class extends We {
	constructor(e, n, r, s, o, a, l, u, c, h, d, f, p, m, g, y, v, x) { super("v3"); this.nodeType = "Pattern"; this.style = e, this.projection = n, this.axis = r, this.blending = s, this.offset = o, this.colorA = a, this.colorB = l, this.frequency = u, this.size = c, this.variation = h, this.smoothness = d, this.zigzag = f, this.rotation = p, this.vertical = m, this.horizontal = g, this.sides = y, this.isMask = x, this.alpha = v, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) {
		if (e.isShader("fragment")) {
			e.require("position"), e.require("uv"), e.requires.uv = [!0], e.require("normal"), e.requires.normal = !0, e.addFragmentVariable(this.calpha, "float"); let r; switch (this.style.value) { case 0: r = "circle"; break; case 1: r = "ring"; break; case 2: r = "polygon"; break; case 3: r = "xcross"; break; case 4: r = "diamond"; break; case 5: r = "checkerboard"; break; case 6: r = "line"; break; case 7: r = "wave"; break; default: r = "circle"; break }let s = `g${this.uuid.toString().replace(/-/g, "")}`, o = new me(`float hashwithoutsine12(vec2 p)
				{
					vec3 p3 = fract(vec3(p.xyx) * .1031);
					p3 += dot(p3, p3.yzx + 33.33);
					return fract((p3.x + p3.y) * p3.z);
				}`), a = new me(`vec2 rotate_uv(in vec2 uv, float a, bool repeat) 
				{
					const float mid = 0.5;
					float radians = a * (PI / 180.0);
					vec2 rotated = vec2(
						cos(radians) * (uv.x - mid) + sin(radians) * (uv.y - mid) + mid,
						cos(radians) * (uv.y - mid) - sin(radians) * (uv.x - mid) + mid
					);
					return repeat ? fract(rotated): rotated;
				}`), l = ""; if (this.projection.value === 4) {
				let d = this.style.value === 2 ? `${r}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${r}(uv0, frequency, size, variation, smoothness_remapped, zigzag, rotation)`, f = this.style.value === 2 ? `${r}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${r}(uv1, frequency, size, variation, smoothness_remapped, zigzag, rotation)`, p = this.style.value === 2 ? `${r}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${r}(uv2, frequency, size, variation, smoothness_remapped, zigzag, rotation)`; l = `
				vec3 p = position;
				float factor = 0.0125;
				vec2 uv0 = fract(p.xy * factor);
				vec2 uv1 = fract(p.zy * factor);
				vec2 uv2 = fract(p.xz * factor);
				
				uv0 = rotate_uv(uv0 + offset, rotation, true);
				uv1 = rotate_uv(uv1 + offset, rotation, true);
				uv2 = rotate_uv(uv2 + offset, rotation, true);
	
				float d0 = ${d};
				float d1 = ${f};
				float d2 = ${p};
				
				// Range from 3 to 128 seems to be good
				float exponent = (1.0 - blending) * 125.0 + 3.0;

				vec3 n = vObjectNormal;
				vec3 weights = abs(normalize(n));
				weights = pow(weights, vec3(exponent));
				weights /= dot(weights, vec3(1.0));
				d0 *= weights.z;
				d1 *= weights.x;
				d2 *= weights.y;
				float draw = d0 + d1 + d2;
	
				vec2 custom_uv = uv0 * weights.z + uv1 * weights.x + uv2 * weights.y;
				`} else {
				let d = this.style.value === 2 ? `${r}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation, sides)` : `${r}(custom_uv, frequency, size, variation, smoothness_remapped, zigzag, rotation)`, f = ""; this.axis.value === 0 ? f = `float radius = length(p);
					float theta = atan(p.y, p.z);
					float phi = acos(p.x / radius);`: this.axis.value === 1 ? f = `float radius = length(p);
					float theta = atan(p.x, p.z);
					float phi = acos(p.y / radius);`: (this.axis.value, f = `float radius = length(p);
					float theta = atan(p.y, p.x);
					float phi = acos(p.z / radius);`); let p = ""; switch (this.projection.value) {
					case 0: p = "custom_uv = vUv.st;"; break; case 1: break; case 2: p = `
							vec3 p = position;
							${f}
							custom_uv = vec2(theta, phi);
							custom_uv /= PI;
							`; break; case 3: break; default: break
				}l = `
				vec2 custom_uv;
				${p}
	
				custom_uv += offset;
				custom_uv = fract(custom_uv);
				custom_uv = rotate_uv(custom_uv, rotation, true);
	
				float draw = ${d};
				`} let u = new me(`vec3 ${s}_pattern(vec3 normal, float blending, int style, vec2 offset, vec4 colorA, vec4 colorB, vec2 frequency, float size, float variation, float smoothness, float zigzag, float rotation, vec2 vertical, vec2 horizontal, int sides, bool isMask, float mask, float alpha, out float calpha) {
					const float TWO_PI = PI * 2.0;
					float smoothness_remapped = pow(smoothness, 5.0);	

					${l}

					// Construct final output color
					vec4 color = mix(colorA, colorB, draw);
					color.a = clamp(color.a, 0.0, 1.0);

					// Apply cuts
					color.a *= 
						step(vertical.x, custom_uv.y) * 
						step(custom_uv.y, vertical.y);
					color.a *= 
						step(horizontal.x, abs(custom_uv.x)) * 
						step(abs(custom_uv.x), horizontal.y);

					// Accumulate alpha 
					float lalpha = alpha * clamp(color.a, 0.0, 1.0) * mask;
					calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
					accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

					return clamp(color, 0.0, 1.0).rgb;
				}`, [a, o, ks.DrawFunctions.circle, ks.DrawFunctions.ring, ks.DrawFunctions.polygon, ks.DrawFunctions.cross, ks.DrawFunctions.diamond, ks.DrawFunctions.checkerboard, ks.DrawFunctions.line, ks.DrawFunctions.wave]), c = e.include(u), h = []; return h.push("normal"), h.push(this.blending.build(e, "f")), h.push(this.style.build(e, "i")), h.push(this.offset.build(e, "v2")), h.push(this.colorA.build(e, "v4")), h.push(this.colorB.build(e, "v4")), h.push(this.frequency.build(e, "v2")), h.push(this.size.build(e, "f")), h.push(this.variation.build(e, "f")), h.push(this.smoothness.build(e, "f")), h.push(this.zigzag.build(e, "f")), h.push(this.rotation.build(e, "f")), h.push(this.vertical.build(e, "v2")), h.push(this.horizontal.build(e, "v2")), h.push(this.sides.build(e, "i")), h.push(this.isMask.build(e, "b")), h.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), h.push(this.alpha.build(e, "f")), h.push(this.calpha), e.format(c + "(" + h.join(",") + ")", this.getType(e), n)
		} else return console.warn("PatterNode is not compatible with " + e.shader + " shader."), e.format("vec3(0.0)", this.getType(e), n)
	}
}, Lh = ks; Lh.DrawFunctions = function () {
	let e = new me(`float hashwithoutsine12(vec2 p) {
				vec3 p3 = fract(vec3(p.xyx) * 0.1031);
				p3 += dot(p3, p3.yzx + 33.33);
				return fract((p3.x + p3.y) * p3.z);
			}`), n = new me(`vec2 tile_and_center(in vec2 uv, in vec2 frequency, in float variation, in float zigzag, in float rotation) {
                // Create tiles in UV-space
                uv *= frequency;

                // Integer coords
                vec2 i = floor(uv);

                // Offset every other row based on zigzag param, then compute fractional coords
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = fract(uv);

				// Rotate the tile itself:
				// const float mid = 0.5;
				// f = vec2(
				// 	cos(rotation) * (f.x - mid) + sin(rotation) * (f.y - mid) + mid,
				// 	cos(rotation) * (f.y - mid) - sin(rotation) * (f.x - mid) + mid
				// );
				// f = fract(f);

                f = f * 2.0 - 1.0;

				// Recompute integer coords after shifting - then, random value per tile 
				i = floor(uv);
				float rand = (hashwithoutsine12(i) * 5.0 + 1.0);
				float jitter = mix(1.0, rand, variation);
				f *= jitter;

                return f;
            }`, [e]), r = new me(`float circle(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(
                    -smoothness, 
                     smoothness, 
                     length(f) - size
                );
            }`, [n]), s = new me(`float ring(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);

				float d = length(f);
                const float inner_width = 0.5;

                float outer = smoothstep(-smoothness, smoothness, d - size);
                float inner = smoothstep(-smoothness, smoothness, d - size * inner_width);
				return outer + (1.0 - inner);   
            }`, [n]), o = new me(`float sdf_ngon(in vec2 p, in float r, in int n) {
                float an = (PI * 2.0) / float(n);
                float he = r * tan(0.5 * an);
                
                // Rotate to first sector
                p = -p.yx; 
                float bn = an * floor((atan(p.y, p.x) + 0.5 * an) / an);
                vec2  cs = vec2(cos(bn), sin(bn));
                p = mat2(cs.x, -cs.y, cs.y, cs.x)*p;
            
                // Side of polygon
                return length(p - vec2(r, clamp(p.y, -he, he))) * sign(p.x - r);
            }
            
            float polygon(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation, in int sides) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_ngon(f, size, sides));
            }`, [n]), a = new me(`float sdf_cross(in vec2 p, in vec2 b, float r ) {
                p = abs(p); 
				p = (p.y > p.x) ? p.yx : p.xy;
                vec2  q = p - b;
                float k = max(q.y, q.x);
                vec2  w = (k > 0.0) ? q : vec2(b.y - p.x, -k);
                return sign(k) * length(max(w, 0.0)) + r;
            }
            
            // Avoid namespace conflicts 
            float xcross(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
                return smoothstep(-smoothness, smoothness, sdf_cross(f, vec2(size, size * 0.25), smoothness));
            }`, [n]), l = new me(`float ndot(vec2 a, vec2 b) { 
                return a.x*b.x - a.y*b.y; 
            }
            
            float sdf_diamond(in vec2 p, in vec2 b) {
                p = abs(p);
                float h = clamp(ndot(b - 2.0 * p, b) / dot(b, b), -1.0, 1.0);
                float d = length(p - 0.5 * b * vec2(1.0 - h, 1.0 + h));
                return d * sign(p.x * b.y + p.y * b.x - b.x * b.y);
            }

            float diamond(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, variation, zigzag, rotation);
	            return smoothstep(-smoothness, smoothness, sdf_diamond(f, vec2(size)));
            }`, [n]), u = new me(`float checkerboard(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                uv *= frequency;
                vec2 i = floor(uv);

                float offset = mod(i.y, 2.0);

                uv.x += offset + zigzag * offset;
                float x = floor(uv.x);
                
                return mod(x, 2.0);
            }`), c = new me(`float line(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                vec2 f = tile_and_center(uv, frequency, 0.0, zigzag, rotation);
				
				// Different approach for variation param here
				float row = floor(uv * frequency).y;
				float rand = hashwithoutsine12(vec2(row));
				float s = mix(size, size * rand, variation);

				return smoothstep(
					s - smoothness, 
					s + smoothness, 
					abs(f.y)
				);
            }`, [n]), h = new me(`// Uses bisection 
            float udf_cos(in vec2 p, in float a, in float b, in float c, in float d) {
                // Convert all data to a primitive cosine wave
                p = c * (p - vec2(d, a));
                
                const float TWO_PI = PI * 2.0;

                // Reduce to principal half cycle
                p.x = mod(p.x, TWO_PI); 
                if (p.x > PI) {
                    p.x = TWO_PI - p.x;
                }
            
                // Find zero of derivative (minimize distance)
                float xa = 0.0;
                float xb = TWO_PI;

                // 24 bit precision
                for (int i = 0; i < 24; i++) {
                    float x = 0.5 * (xa + xb);
                    float y = x - p.x + b * c * sin(x) * (p.y - b * c * cos(x));
                    if (y < 0.0) xa = x; 
                    else xb = x;
                }
                float x = 0.5 * (xa + xb);
                
                // Compute distance    
                vec2 q = vec2(x, b * c * cos(x));
                return length(p - q) / c;
            }

            float wave(in vec2 uv, in vec2 frequency, in float size, in float variation, in float smoothness, in float zigzag, in float rotation) {
                float repeat = frequency.x;
                uv *= repeat;
                vec2 i = floor(uv);
                float row_offset = mod(i.y, 2.0);
                uv.x += row_offset * zigzag;
                vec2 f = vec2(uv.x, fract(uv.y));

                // Generalized cosine: y(x) = a + b * cos(cx + d)
                const float amplitude = 0.125;
                float wave_frequency = frequency.y * 0.1;
                float distance_estimate = udf_cos(f, 0.50, amplitude, wave_frequency * (2.0 * PI), 0.0);

				// Different approach for variation param here
				float rand = hashwithoutsine12(vec2(i.y));
				float s = mix(size, size * rand, variation);

                return smoothstep(-smoothness, smoothness, distance_estimate - s * 0.5);
            }`); return { tileAndCenter: n, circle: r, ring: s, polygon: o, cross: a, diamond: l, checkerboard: u, line: c, wave: h }
}(); var lS = class extends We { constructor(e, n, r, s, o, a, l, u) { super("v3"); this.nodeType = "Rainbow"; this.filmThickness = e, this.movement = n, this.wavelengths = r, this.noiseStrength = s, this.noiseScale = o, this.offset = a, this.isMask = u, this.alpha = l, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) { if (e.require("vWorldViewDir"), e.require("worldNormal"), e.isShader("fragment")) { e.require("uv"), e.requires.uv = [!0], e.addFragmentVariable(this.calpha, "float"); let r = e.include(lS.Nodes.rainbow), s = []; return s.push(this.filmThickness.build(e, "f")), s.push(this.movement.build(e, "f")), s.push(this.wavelengths.build(e, "v3")), s.push(this.noiseStrength.build(e, "f")), s.push(this.noiseScale.build(e, "f")), s.push(this.offset.build(e, "v3")), s.push(this.isMask.build(e, "b")), s.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), s.push(this.alpha.build(e, "f")), s.push(this.calpha), e.format(r + "(" + s.join(",") + ")", this.getType(e), n) } else return console.warn("RainbowNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), n) } }, Nh = lS; Nh.Nodes = function () {
	let e = new me(`vec3 attenuation(vec3 wavelengths, float filmThickness, float movement, float noiseStrength, float noiseScale, vec3 offset) {
                 vec3 st = position / noiseScale;
				 vec3 q = vec3(simplex3d(st),
							  simplex3d(st + vec3(1.0)),
							  simplex3d(st + vec3(1.0)));

				 vec3 r = vec3(simplex3d(st + vec3(1.4, 1.3, 1.0) * q + vec3(1.7, 9.2, 1.0)),
							  simplex3d(st + vec3(2.0, 1.2, 1.0) * q + vec3(8.3, 2.8, 1.0)),
							  simplex3d(st * q));

                 float noise = simplex3d(st + r);

                 return .5 + .5 * cos((((filmThickness + (noise * noiseStrength)) / (vec3(wavelengths.r * 1.0, wavelengths.g * 0.8, wavelengths.b * 0.6) + 1.0)) * dot(normalize(vWorldViewDir + (offset * -0.001)), normalize(vWNormal))) + movement);
             }`, [hr.simplex]); return {
		rainbow: new me(`vec3 rainbow(float filmThickness, float movement, vec3 wavelengths, float noiseStrength, float noiseScale, vec3 offset, bool isMask, float mask, float alpha, out float calpha) {
				vec3 res = clamp(attenuation(wavelengths, filmThickness, movement, noiseStrength, noiseScale, offset), 0.0, 2.0);

				float rainbowContribution = clamp(res.r + res.g + res.b, 0.0, 1.0);

				float lalpha = alpha * rainbowContribution * mask;
				calpha = mix(lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0), lalpha, float(isMask));
				accumAlpha += (1.0 - accumAlpha) * lalpha * (1.0 - float(isMask));

				return res;
             }`, [e])
	}
}(); var cS = class extends We { constructor(e, n, r, s, o, a, l, u, c, h) { super("v3"); this.nodeType = "Toon"; this.positioning = e, this.colors = n, this.steps = r, this.source = s, this.isWorldSpace = o, this.noiseStrength = a, this.noiseScale = l, this.shadowColor = u, this.offset = c, this.alpha = h, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) { if (e.require("worldNormal"), e.require("worldPosition"), e.isShader("fragment")) { e.define("COLORS_MAX", 10), e.addFragmentVariable(this.calpha, "float"); let r = e.include(cS.Nodes.toon), s = []; return s.push(this.positioning.build(e, "i")), s.push(this.colors.build(e, "v4[]")), s.push(this.steps.build(e, "f[]")), s.push(this.source.build(e, "v3")), s.push(this.isWorldSpace.build(e, "b")), s.push(this.noiseStrength.build(e, "f")), s.push(this.noiseScale.build(e, "f")), s.push(this.shadowColor.build(e, "v4")), s.push(this.offset.build(e, "v3")), s.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), s.push(this.alpha.build(e, "f")), s.push(this.calpha), e.format(r + "(" + s.join(",") + ")", this.getType(e), n) } else return console.warn("ToonNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), n) } }, Bh = cS; Bh.Nodes = function () {
	let e = new me(`float rand(float n) {
				return fract(sin(n) * 43758.5453123);
			}`), n = new me(`float hash1(float p) { 
				p = fract(p * 0.011); 
				p *= p + 7.5; 
				p *= p + p; 
				return fract(p); 
			}`), r = new me(`float valueNoise(vec3 x) {
				const vec3 step = vec3(110, 241, 171);
			
				vec3 i = floor(x);
				vec3 f = fract(x);
			 
				// For performance, compute the base input to a 1D hash from the integer part of the argument and the 
				// incremental change to the 1D based on the 3D -> 1D wrapping
				float n = dot(i, step);
			
				vec3 u = f * f * (3.0 - 2.0 * f);
				return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),
						   mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),
							   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);
			}`, [n]), s = new me(`vec3 hash3(vec3 x) {
				x = vec3(dot(x,vec3(127.1, 311.7, 74.7)),
						 dot(x,vec3(269.5, 183.3, 246.1)),
						 dot(x,vec3(113.5, 271.9, 124.6)));
			
				return fract(sin(x)*43758.5453123);
			}`), o = new me(`vec3 voronoiNoise(in vec3 x)
			{
				vec3 p = floor(x);
				vec3 f = fract(x);

				float id = 0.0;
				vec2 res = vec2(100.0);

				for(int k=-1; k<=1; k++)
				for(int j=-1; j<=1; j++)
				for(int i=-1; i<=1; i++)
				{
					vec3 b = vec3(float(i), float(j), float(k));

					// Comment out the "+ hash(p + b);" part below to get "square" cells
					vec3 r = vec3(b) - f + hash3(p + b);
					float d = dot(r, r);

					if (d < res.x)
					{
						id = dot(p + b, vec3(1.0, 57.0, 113.0));
						res = vec2(d, res.x);			
					}
					else if (d < res.y)
					{
						res.y = d;
					}
				}

				return vec3(sqrt(res), abs(id));
			}
			`, [s]); return {
		toon: new me(`vec3 toon(int positioning, vec4 colors[COLORS_MAX], float steps[COLORS_MAX], vec3 source, bool isWorldSpace, float noiseStrength, float noiseScale, vec4 shadowColor, vec3 offset, float mask, float alpha, out float calpha) {
				float t = 0.0;
				float shadow = 1.0;

				if (positioning == 0) {

					// Can't do this mode if lighting is "none"
					#if (defined(PHONG) || defined(LAMBERT) || defined(STANDARD))

						// Algorithm from Chapter 10 of Graphics Shaders
						const vec3 weights = vec3(0.2125, 0.7154, 0.0721);
						vec3 lpos;
						vec3 l;
						float dproduct;

						#if (NUM_POINT_LIGHTS > 0)

							#if defined(USE_SHADOWMAP) && (NUM_POINT_LIGHT_SHADOWS > 0)
								PointLightShadow pointLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_POINT_LIGHTS; i++) {
								// Light positions are in view-space for some reason?
								lpos = (inverse(viewMatrix) * vec4(pointLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								
								// TODO: we want to use "intensity" but it isn't available in the shader code
								//dproduct += dot(pointLights[UNROLLED_LOOP_INDEX].color, weights);

								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS)
									pointLightShadow = pointLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getPointShadow( 
											pointShadowMap[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowMapSize, 
											pointLightShadow.shadowBias, 
											pointLightShadow.shadowRadius,
											vPointShadowCoord[UNROLLED_LOOP_INDEX], 
											pointLightShadow.shadowCameraNear, 
											pointLightShadow.shadowCameraFar);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_DIR_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_DIR_LIGHT_SHADOWS > 0)
								DirectionalLightShadow directionalLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_DIR_LIGHTS; i++) {
								// Use the direction vector for directional lights instead
								l = (inverse(viewMatrix) * vec4(directionalLights[UNROLLED_LOOP_INDEX].direction, 0.0)).xyz;
		
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS)
									directionalLightShadow = directionalLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow( 
										UNROLLED_LOOP_INDEX,
										directionalShadowMap[UNROLLED_LOOP_INDEX], 
										directionalLightShadow.shadowMapSize, 
										directionalLightShadow.shadowBias, 
										directionalLightShadow.shadowRadius, 
										vDirectionalShadowCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						#if NUM_SPOT_LIGHTS > 0 
							
							#if defined(USE_SHADOWMAP) && (NUM_SPOT_LIGHT_SHADOWS > 0)
								SpotLightShadow spotLightShadow;
							#endif 

							#pragma unroll_loop_start
							for (int i = 0; i < NUM_SPOT_LIGHTS; i++) {
								lpos = (inverse(viewMatrix) * vec4(spotLights[UNROLLED_LOOP_INDEX].position, 1.0)).xyz;
								l = normalize(lpos - worldPosition);
								
								dproduct = dot(l, normalize(worldNormal)) * 0.5 + 0.5;
								t = max(t, dproduct);

								// Accumulate shadow contribution
								#if defined(USE_SHADOWMAP) && (UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS)
									spotLightShadow = spotLightShadows[UNROLLED_LOOP_INDEX];
									shadow *= getShadow(
										UNROLLED_LOOP_INDEX,
										spotShadowMap[UNROLLED_LOOP_INDEX], 
										spotLightShadow.shadowMapSize, 
										spotLightShadow.shadowBias, 
										spotLightShadow.shadowRadius, 
										vSpotLightCoord[UNROLLED_LOOP_INDEX]);
								#endif
							}
							#pragma unroll_loop_end

						#endif

						t = clamp(t, 0.0, 1.0);
				
					#endif

				} else if (positioning == 1) {
					
					vec3 origin = mix(position, worldPosition, float(isWorldSpace));
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	

				} else {

					vec3 origin = worldPosition;
					vec3 source = cameraPosition - offset;
					vec3 direction = normalize(source - origin);
					t = dot(direction, normalize(worldNormal)) * 0.5 + 0.5;	
					
				}

				if (noiseStrength > 0.0) {
					// Distort with noise
					vec3 st = position / noiseScale;
					
					// Voronoi "smooth" noise
					float noise = 1.0 - voronoiNoise(st).x;

					// Voronoi cellular noise
					//float noise = 1.0 - rand(voronoiNoise(st).z);

					// Position warp noise
					// vec3 offset = vec3(
					// 	simplex3d(st),
					// 	simplex3d(st + vec3(111.1, 143.89, 217.19)),
					// 	simplex3d(st + vec3(171.1, 247.89, 117.23))
					// );
					// st += offset;
					// float noise = valueNoise(st);

					t += noise * noiseStrength;
				}

				t = clamp(t, 0.0, 1.0);

				// Compute ramp color
				float p;
				vec4 color = colors[0];
				for (int i = 1; i < COLORS_MAX; i++) {
					p = clamp((t - steps[i-1]) / (steps[i] - steps[i-1]), 0.0, 1.0);
					color = mix(color, colors[i], smoothstep(0.0, 1.0, p));
				}

				// Incorporate custom shadow color
				if (positioning == 0) {

					vec3 blendedShadow = mix(color.rgb, shadowColor.rgb, shadowColor.a);
					color.rgb = mix(blendedShadow, color.rgb, shadow);
				
				}

				// Accumulate alpha as usual
				float lalpha = alpha * color.a * mask;
				calpha =  lalpha / clamp(lalpha + accumAlpha, 0.00001, 1.0);
				accumAlpha += (1.0 - accumAlpha) * lalpha;

				return color.xyz;

            }`, [hr.simplex, e, r, o])
	}
}(); var T2 = function () {
	return {
		textureBicubic: new me(`float w0( float a ) {
            return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
        }
    
        float w1( float a ) {
            return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
        }
    
        float w2( float a ){
            return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
        }
    
        float w3( float a ) {
            return ( 1.0 / 6.0 ) * ( a * a * a );
        }
    
        // g0 and g1 are the two amplitude functions
        float g0( float a ) {
            return w0( a ) + w1( a );
        }
    
        float g1( float a ) {
            return w2( a ) + w3( a );
        }
    
        // h0 and h1 are the two offset functions
        float h0( float a ) {
            return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
        }
    
        float h1( float a ) {
            return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
        }
    
        vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
            uv = uv * texelSize.zw + 0.5;
    
            vec2 iuv = floor( uv );
            vec2 fuv = fract( uv );
    
            float g0x = g0( fuv.x );
            float g1x = g1( fuv.x );
            float h0x = h0( fuv.x );
            float h1x = h1( fuv.x );
            float h0y = h0( fuv.y );
            float h1y = h1( fuv.y );
    
            vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
            vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
            vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
            vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
    
            return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) + 
                   g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
        }

        vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
            vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
            vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
            vec2 fLodSizeInv = 1.0 / fLodSize;
            vec2 cLodSizeInv = 1.0 / cLodSize;
            vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
            vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
            return mix( fSample, cSample, fract( lod ) );
        }`)
	}
}(); function C2 (i, t) { return i >= t ? new B(t / i, 1) : new B(1, i / t) } var uS = class extends We { constructor(e, n, r, s, o, a, l, u) { super("v3"); this.nodeType = "Transmission"; this.thickness = e, this.ior = n, this.roughness = r, this.transmissionSamplerSize = s, this.transmissionSamplerMap = o, this.transmissionDepthMap = a, this.aspectRatio = l, this.alpha = u, this.calpha = `g${this.uuid.toString().replace(/-/g, "")}_calpha` } generate (e, n) { if (e.extensions.shaderTextureLOD = !0, e.extensions.derivatives = !0, e.isShader("fragment")) { e.define("NUM_SAMPLES", 6), e.define("BLUR_SLOD", Math.pow(2, Ve.transmissionLod.value)), e.require("worldPosition"), e.requires.worldNormal = !0, e.requires.modelMatrix = !0, e.requires.projectionMatrix = !0, e.addFragmentVariable(this.calpha, "float"); let r = e.include(uS.Nodes.transmission), s = []; return s.push(this.thickness.build(e, "f")), s.push(this.ior.build(e, "f")), s.push(this.roughness.build(e, "f")), s.push(this.transmissionSamplerSize.build(e, "v2")), s.push(this.transmissionSamplerMap.getTexture(e, "t")), s.push(this.transmissionDepthMap.getTexture(e, "t")), s.push(this.aspectRatio.build(e, "v2")), s.push("normal"), s.push(this.mask ? `luminance(${this.mask.flow(e, "v3").result})` : "1.0"), s.push(this.alpha.build(e, "f")), s.push(this.calpha), e.format(r + "(" + s.join(",") + ")", this.getType(e), n) } else return console.warn("TransmissionNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), n) } }, Fh = uS; Fh.Nodes = function () {
	let e = new me(`vec3 blur(sampler2D sp, vec2 U, vec2 scale, float lod, sampler2D dm, vec2 unrefractedU, vec2 aspectRatio) {
                // Slightly modified version of this:
                // https://www.shadertoy.com/view/ltScRG

				// Special case for blur == 0.0
				if (lod == 0.0) {
					#ifdef TEXTURE_LOD_EXT
					return texture2DLodEXT( sp, U, 0.0).rgb;
					#else
					return textureLod( sp, U, 0.0).rgb;
					#endif
				}
				
				vec2 texelSize = vec2(1.0) / resolution;
                vec2 halton = haltonSequence[frameIndex];
                float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
                float temporalAngle  = temporalOffset * PI2;
				vec3 res = vec3(0.0);
                vec2 uv = vec2(0.0);
                vec2 offset = vec2(0.0);
                vec2 vogelSample = vec2(0.0);
                for (int i = 0; i < NUM_SAMPLES; i++) {
                    vogelSample =  vogelDiskSample(i, NUM_SAMPLES, temporalAngle) * texelSize;
                    offset = vogelSample * scale * (lod * 10.0); // TODO: used to be hardcoded to 20
                    uv = U + offset;
                    float opaqueDepth = unpackRGBAToDepth(textureLod(dm, uv, lod));
                    if (opaqueDepth != 0.0 && opaqueDepth < gl_FragCoord.z) {
                        uv = unrefractedU;
                        lod = lod > 4.0 ? lod : lod / 2.0;
                    }
                    res += textureLod(sp, uv, lod).rgb;
                }
                return res / float(NUM_SAMPLES);
            }`), n = new me(`vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		        // Direction of refracted light.
		        vec3 refractionVector = refract( -v,  n, 1.0 / ior );
		        
				// Compute rotation-independant scaling of the model matrix.
		        vec3 modelScale;
		        modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		        modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		        modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

		        // The thickness is specified in local space
		        return normalize( refractionVector ) * thickness * modelScale;
	        }`), r = new me(`float applyIorToRoughness( float roughness, float ior ) {
				// Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
				// an IOR of 1.5 results in the default amount of microfacet refraction.
				return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
			}`), s = new me(`vec3 getTransmissionSample( vec2 fragCoord, float roughness, float ior, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 unrefractedCoords, vec2 aspectRatio) {
				// Threejs exports do not pass a depth map to this shader, so we have to fallback to the "Threejs method of blurring" - see
				// also the code in convertTransmission.ts, which runs during export
				#ifdef IS_THREEJS_EXPORT
					float lod = log2(transmissionSamplerSize.x) * applyIorToRoughness(roughness / 5.0, ior);
					return textureBicubic(transmissionSamplerMap, fragCoord.xy, lod).rgb;
				#else
					float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
					float lod = applyIorToRoughness(roughness, ior);
					return blur(transmissionSamplerMap, fragCoord, vec2(lod), min(framebufferLod / 5.5, 8.5), transmissionDepthMap, unrefractedCoords, aspectRatio);
				#endif
			}`, [T2.textureBicubic, r, e]), o = new me(`vec3 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;

				// Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
				vec4 ndcPos = projMatrix * viewMatrix *  vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;

				vec4 ndcPosUnrefracted = projMatrix * viewMatrix * vec4(position, 1.0 );
				vec2 unrefractedCoords = ndcPosUnrefracted.xy / ndcPosUnrefracted.w;
				unrefractedCoords += 1.0;
				unrefractedCoords /= 2.0;

				// Sample framebuffer to get pixel the refracted ray hits.
				return getTransmissionSample( refractionCoords, roughness, ior, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, unrefractedCoords, aspectRatio );
    		}`, [s, n]); return {
		transmission: new me(`vec3 transmission(float thickness, float ior, float roughness, vec2 transmissionSamplerSize, sampler2D transmissionSamplerMap, sampler2D transmissionDepthMap, vec2 aspectRatio, vec3 normal, float mask, float alpha, out float calpha) {
                vec3 v = vec3(0.);
                if (isOrthographic) {
                    v = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
                } else {
                    v = normalize(vWPosition - cameraPosition);
                }
                vec3 transmission = getIBLVolumeRefraction(vWNormal, -v, roughness,  vWPosition, modelMatrix, viewMatrix, projectionMatrix, ior, thickness, transmissionSamplerSize, transmissionSamplerMap, transmissionDepthMap, aspectRatio );
                
				float lalpha = alpha * mask;
				calpha =  lalpha / clamp( lalpha + accumAlpha, 0.00001, 1.0 );
				accumAlpha += ( 1.0 - accumAlpha ) * alpha;

				return transmission;
            }`, [o])
	}
}(); var hS = (e => (e.NOISE = "noise", e.MAP = "map", e))(hS || {}), dS = class extends We {
	constructor(e, n, r, s, o, a, l, u, c, h, d) { super("v3"); this.displacementTypeIndex = new pt(0); this.nodeType = "VertexDisplacement"; this.intensity = e, this.movementOrTexture = n, Object.values(hS)[this.displacementTypeIndex.value] === "map" && (this.mat = new _h(this.movementOrTexture.value.matrix)), this.cropOrOffset = r, this.scale = h, this.noiseFunctionIndex = d, this.voronoiStyle = s, this.smoothness = o, this.seed = a, this.highCut = l, this.lowCut = u, this.quality = c } generate (e, n) {
		if (e.isShader("vertex")) {
			e.define("USE_LAYER_DISPLACE"); let r, s = []; switch (s.push("displaced_position"), s.push("displaced_normal"), Object.values(hS)[this.displacementTypeIndex.value]) {
				case "map": { r = e.include(dS.Nodes.map), s.push(this.movementOrTexture.getTexture(e, "t")), s.push("uv"), s.push(this.cropOrOffset.build(e, "f")), this.mat && s.push(this.mat.build(e, "mat3")); break } case "noise": {
					let a = Object.values(Xf)[this.noiseFunctionIndex.value], l = new me(`vec3 orthogonal(vec3 v) {
							return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
						}`), u = a == "voronoi" ? `
					float v = ${a}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1), voronoiStyle, smoothness, seed, quality);
					v = remap(v, lowCut, highCut, 0.0, 1.0);
					v = smax(v, 0.0, smoothness * 0.25);
					v = smin(v, 1.0, smoothness * 0.25);

					return p + n * v * intensity;
					`: `
					return p + n * ${a}((p + offset) * scale * 0.001 + neighbour_offset + (movement * 0.1)) * intensity;
					`, c = new me(`vec3 distorted(vec3 p, vec3 n, float scale, float intensity, vec3 offset, float neighbour_offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality) {
							${u}
						}`, [hr.simplex, hr.simplexFractal, hr.simplexAshima, hr.fbm, hr.perlin, hr.voronoi]), h = new me(`vec3 vertexDisplacementNoise(vec3 position, vec3 normal, float scale, vec3 offset, float movement, int voronoiStyle, float smoothness, float seed, float highCut, float lowCut, int quality, float intensity, out vec3 displaced_normal) {
							vec3 displaced_position = distorted(position, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 tangent1 = orthogonal(normal);
							vec3 tangent2 = normalize(cross(normal, tangent1));

                            // TODO(Max): The distance to the neighbors was originally scaled by 0.1.
                            // This caused some small oval/circular visual artifacts in the lighting.
                            // For now, simply using neighbors further away betters the problem,
                            // but we should figure out the underlying cause when we have some time.
                            // Maybe its related to how we calculate the tangent and bitangent?
							vec3 nearby1 = position + tangent1;
							vec3 nearby2 = position + tangent2;
							vec3 distorted1 = distorted(nearby1, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							vec3 distorted2 = distorted(nearby2, normal, scale, intensity, offset, neighbor_offset, movement, voronoiStyle, smoothness, seed, highCut, lowCut, quality);
							displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
							return displaced_position;
						}`, [c, l]); r = e.include(h), s.push(this.scale.build(e, "f")), s.push(this.cropOrOffset.build(e, "v3")), s.push(this.movementOrTexture.build(e, "f")), s.push(this.voronoiStyle.build(e, "i")), s.push(this.smoothness.build(e, "f")), s.push(this.seed.build(e, "f")), s.push(this.highCut.build(e, "f")), s.push(this.lowCut.build(e, "f")), s.push(this.quality.build(e, "i")); break
				}
			}return s.push(this.intensity.build(e, "f")), s.push("displaced_normal"), e.format(r + "(" + s.join(",") + ")", this.getType(e), n)
		} else return console.warn("VertexDisplacementNode is not compatible with " + e.shader + " shader."), e.format("vec3( 0.0 )", this.getType(e), n)
	}
}, kh = dS; kh.Nodes = function () {
	let e = new me(`vec3 orthogonal(vec3 v) {
				return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0) : vec3(0.0, -v.z, v.y));
			}`), n = new me(`float displacementMapTexture(sampler2D tex, float crop, vec2 uv, mat3 mat, vec2 offset) {
				vec2 uvs = (mat * vec3(uv * 2.0 - 1.0, 1.0) / 2.0 + 0.5).xy + offset;
				vec4 tmp = texture2D(tex, uvs);
				vec3 col = tmp.rgb;
				if (crop > 0.5) {
					if ( uvs.x < 0.0 || uvs.x > 1.0 || uvs.y < 0.0 || uvs.y > 1.0 )  {
						return 0.0;
					}
				}
				return col.r;
			}`); return {
		map: new me(`vec3 vertexDisplacementMap(vec3 position, vec3 normal, sampler2D tex, vec2 uv, float crop, mat3 mat, float intensity, out vec3 displaced_normal) {
				vec3 displaced_position = position + normal * displacementMapTexture(tex, crop, uv, mat, vec2(0.0)) * intensity;
				vec3 tangent1 = normalize(orthogonal(normal));
				vec3 tangent2 = normalize(cross(normal, tangent1));
				vec3 nearby1 = position + tangent1 * 0.1;
				vec3 nearby2 = position + tangent2 * 0.1;
				vec3 distorted1 = nearby1 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				vec3 distorted2 = nearby2 + normal * displacementMapTexture(tex, crop, uv, mat, vec2(neighbor_offset)) * intensity;
				displaced_normal = normalize(cross(distorted1 - displaced_position, distorted2 - displaced_position));
				return displaced_position;
			}`, [e, n])
	}
}(); var Ve = { normalRenderTarget: new Gr, normalRenderTargetDepth: new Gr, transmissionRenderTarget: new Gr, aspectRatio: new cn, transmissionSize: new cn(2048, 2048), transmissionRenderTargetDepth: new Gr, aoRenderTarget: new Gr, aoEnabled: new mn, pixelRatioNode: new Ee(1), resolution: new cn, penumbraSize: new is(5, .5), frameIndex: new pt(0), transmissionLod: new pt(2) }; for (let i of Object.values(Ve)) i.isRenderGlobal = !0; var Wl = class extends lr {
	constructor() { super("basic"); this.nodeType = "Basic"; this.color = new Rt(qn), this.shadingAlpha = new Ee(1), this.shadingBlend = new pt(0), this.previousModelViewMatrix = new Sr, this.previouseProjectionMatrix = new Sr } get category () { return "phong" } generate (e) {
		let n; if (e.isShader("vertex")) {
			let r = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0; e.mergeUniform({ frameIndex: Ve.frameIndex }), e.mergeUniform({ resolution: Ve.resolution }), e.mergeUniform({ previousModelViewMatrix: this.previousModelViewMatrix }), e.mergeUniform({ previousProjectionMatrix: this.previouseProjectionMatrix }), e.mergeUniform(Yi.merge([xe.fog])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>"].join(`
`)); let s = ["#include <beginnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`]; r && s.push(r.code, r.result ? "displaced_position = " + r.result + ";" : ""), s.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "	vNormal = transformedNormal;", "#endif"), s.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>"), s.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), n = s.join(`
`)
		} else {
			this.color === void 0 && (this.color = new Rt(qn)), this.color.analyze(e, { slot: "color" }), this.alpha && this.alpha.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }); let r = this.color.flow(e, "c", { slot: "color" }), s = this.alpha ? this.alpha.flow(e, "f") : void 0, o = this.alphaOverride ? this.alphaOverride.flow(e, "f") : void 0, a = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0; e.requires.transparent = s !== void 0, e.addParsCode(["varying vec3 vWPosition;", "#include <fog_pars_fragment>", "#include <dithering_pars_fragment>", "varying vec3 vViewPosition;", "#include <normal_pars_fragment>"].join(`
`)); let l = ["#include <normal_fragment_begin>", r.code]; s && l.push(s.code, "#ifdef ALPHATEST", " if ( " + s.result + " <= ALPHATEST ) discard;", "#endif"), a ? l.push(a.code, `vec3 outgoingLight = ${r.result};`, `vec3 finalColor = spe_blend(outgoingLight, ${a.result}, 1.0, SPE_BLENDING_NORMAL);`) : l.push(`vec3 finalColor = ${r.result};`); let u = "1.0"; this.mask && (this.mask.analyze(e), u = `luminance(${this.mask.flow(e, "v3").result})`), s ? l.push(`gl_FragColor = vec4( finalColor, accumAlpha * ${s.result} * ${u} );`) : l.push("gl_FragColor = vec4(" + r.result + ", 1.0 );"), o && l.push(`gl_FragColor.a *= ${o.result};`), l.push("#include <fog_fragment>", "#include <dithering_fragment>"), n = l.join(`
`)
		} return n
	}
}; var Qf = class extends lr {
	constructor() { super("lambert"); this.nodeType = "Lambert"; this.color = new Rt(qn), this.emissive = new Rt(0), this.emissiveIntensity = new Ee(1), this.previousModelViewMatrix = new Sr, this.previouseProjectionMatrix = new Sr, this.shadingAlpha = new Ee(1), this.shadingBlend = new pt(0), this.occlusion = new mn(!0) } get category () { return "lambert" } build (e) {
		let n; if (e.define("LAMBERT"), e.requires.lights = !0, e.extensions.derivatives = !0, e.isShader("vertex")) {
			let r = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0; e.mergeUniform({ frameIndex: Ve.frameIndex }), e.mergeUniform({ resolution: Ve.resolution }), e.mergeUniform({ previousModelViewMatrix: this.previousModelViewMatrix }), e.mergeUniform({ previousProjectionMatrix: this.previouseProjectionMatrix }), e.mergeUniform(Yi.merge([xe.fog, xe.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef DOUBLE_SIDED", "   #define DOUBLE_SIDED", "#endif", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <color_pars_vertex>", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`)); let s = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`]; r && s.push(r.code, r.result ? "displaced_position = " + r.result + ";" : ""), s.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), s.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", `
					vec3 diffuse = vec3( 1.0 );
					GeometricContext geometry;
					geometry.position = mvPosition.xyz;
					geometry.normal = normalize( transformedNormal );
					geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
				`), s.push(`
					GeometricContext backGeometry;
					backGeometry.position = geometry.position;
					backGeometry.normal = -geometry.normal;
					backGeometry.viewDir = geometry.viewDir;
					vLightFront = vec3( 0.0 );
					vIndirectFront = vec3( 0.0 );
					#ifdef DOUBLE_SIDED
						vLightBack = vec3( 0.0 );
						vIndirectBack = vec3( 0.0 );
					#endif
					IncidentLight directLight;
					float dotNL;
					vec3 directLightColor_Diffuse;
					vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
					vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
					#ifdef DOUBLE_SIDED
						vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
						vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
					#endif
					#if NUM_POINT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
							getPointLightInfo( pointLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_SPOT_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
							getSpotLightInfo( spotLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_DIR_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
							getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
							dotNL = dot( geometry.normal, directLight.direction );
							directLightColor_Diffuse = directLight.color;
							vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
							#ifdef DOUBLE_SIDED
								vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;
							#endif
						}
						#pragma unroll_loop_end
					#endif
					#if NUM_HEMI_LIGHTS > 0
						#pragma unroll_loop_start
						for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
							vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
							#ifdef DOUBLE_SIDED
								vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
							#endif
						}
						#pragma unroll_loop_end
					#endif
				`, "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), s.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), n = s.join(`
`)
		} else {
			e.mergeUniform({ penumbraSize: Ve.penumbraSize }), e.mergeUniform({ frameIndex: Ve.frameIndex }), e.mergeUniform({ aoMap: Ve.aoRenderTarget }), e.mergeUniform({ aoEnabled: Ve.aoEnabled }), this.color === void 0 && (this.color = new Rt(qn)), this.color.analyze(e, { slot: "color" }), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e); let r = this.color.flow(e, "c", { slot: "color" }), s = this.emissive.flow(e, "c", { slot: "emissive" }), o = this.emissiveIntensity.flow(e, "f", { slot: "emissive" }), a = this.occlusion.flow(e, "b", { slot: "occlusion" }), l = this.shadingAlpha.flow(e, "f"), u = this.shadingBlend.flow(e, "i"), c = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, h = this.alpha ? this.alpha.flow(e, "f") : void 0, d = this.alphaOverride ? this.alphaOverride.flow(e, "f") : void 0; e.requires.transparent = h !== void 0, e.addParsCode([`uniform float penumbraSize[${5}];`, "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "varying vec3 vViewPosition;", "varying vec3 vWPosition;", "varying vec3 vLightFront;", "varying vec3 vIndirectFront;", "#ifndef DOUBLE_SIDED", "   #define DOUBLE_SIDED", "#endif", "#include <normal_pars_fragment>", "#ifdef DOUBLE_SIDED", "	varying vec3 vLightBack;", "	varying vec3 vIndirectBack;", "#endif", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <fog_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <shadowmask_pars_fragment>", "#include <clipping_planes_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`)); let f = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx, viewdy));
				bool isFrontFacing = (dot(normal, faceNormal) >= 0.0);
				`, "#include <clipping_planes_fragment>"]; f.push(r.code, "vec3 diffuseColor = " + r.result + ";", "ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );"), h && f.push(h.code, "#ifdef ALPHATEST", "if ( " + h.result + " <= ALPHATEST ) discard;", "#endif"), f.push("#ifdef DOUBLE_SIDED", "	reflectedLight.indirectDiffuse += ( isFrontFacing ) ? vIndirectFront : vIndirectBack;", "#else", "	reflectedLight.indirectDiffuse += vIndirectFront;", "#endif", "#include <lightmap_fragment>", "reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );", "#ifdef DOUBLE_SIDED", "	reflectedLight.directDiffuse = ( isFrontFacing ) ? vLightFront : vLightBack;", "#else", "	reflectedLight.directDiffuse = vLightFront;", "#endif", "reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();"), s && f.push(s.code, "reflectedLight.directDiffuse += " + s.result + " * " + o.result + ";"), f.push("vec3 ao = aoEnabled && " + a.result + " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = (reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) ;"); let p = "1.0"; this.mask && (this.mask.analyze(e), p = `luminance(${this.mask.flow(e, "v3").result})`), f.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * ${p} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result} * ${p}, ${u.result} );

					outgoingLight *= ao;
				}
				`), c && f.push(c.code, `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`), h ? f.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${h.result} );`) : f.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), d && f.push(`gl_FragColor.a *= ${d.result};`), f.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), n = f.join(`
`)
		} return n
	}
}; var Oo = function () {
	let i = new me(`vec2 dHdxy(sampler2D bumpMap, vec2 bumpMapUv, float bumpScale) {

            // Gradient of UVs w.r.t. X coordinate (in screen-space)
            vec2 dSTdx = dFdx(bumpMapUv);

            // Gradient of UVs w.r.t. Y coordinate (in screen-space)
            vec2 dSTdy = dFdy(bumpMapUv);
            
            // Forward differencing
            float Hll = bumpScale * luminance(texture(bumpMap, bumpMapUv).rgb);
            float dBx = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdx).rgb) - Hll;
            float dBy = bumpScale * luminance(texture(bumpMap, bumpMapUv + dSTdy).rgb) - Hll;
            
            return vec2( dBx, dBy );
        }`), t = new me(`vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
            vec3 vSigmaX = dFdx( surf_pos.xyz );
            vec3 vSigmaY = dFdy( surf_pos.xyz );
            vec3 vN = surf_norm; // normalized
            
            vN = normalize(vN);

            vec3 R1 = cross( vSigmaY, vN );
            vec3 R2 = cross( vN, vSigmaX );

            R1 = normalize(R1);
            R2 = normalize(R2);
    
            float fDet = dot( vSigmaX, R1 ) * faceDirection;
    
            vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
            return normalize( abs( fDet ) * vN - vGrad );
        }`); return { dHdxy: i, perturbNormalArb: t }
}(); var Kf = class extends lr {
	constructor() { super("phong"); this.nodeType = "Phong"; this.color = new Rt(qn), this.specular = new Rt(1118481), this.shininess = new Ee(30), this.previousModelViewMatrix = new Sr, this.previouseProjectionMatrix = new Sr, this.shadingAlpha = new Ee(1), this.shadingBlend = new pt(0), this.occlusion = new mn(!0) } get category () { return "phong" } build (e) {
		let n; if (e.define("PHONG"), e.requires.lights = !0, e.extensions.derivatives = !0, e.isShader("vertex")) {
			let r = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0; e.mergeUniform({ frameIndex: Ve.frameIndex }), e.mergeUniform({ resolution: Ve.resolution }), e.mergeUniform({ previousModelViewMatrix: this.previousModelViewMatrix }), e.mergeUniform({ previousProjectionMatrix: this.previouseProjectionMatrix }), e.mergeUniform(Yi.merge([xe.fog, xe.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <skinning_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`)); let s = ["#include <beginnormal_vertex>", `
				#include <skinbase_vertex>
				#include <skinnormal_vertex>
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif


				vec3 displaced_position = position;
				vec3 displaced_normal = objectNormal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`]; r && s.push(r.code, r.result ? "displaced_position = " + r.result + ";" : ""), s.push("transformed = displaced_position;", "#include <skinning_vertex>", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), s.push("	#include <project_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), s.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), n = s.join(`
`)
		} else {
			e.mergeUniform({ penumbraSize: Ve.penumbraSize }), e.mergeUniform({ frameIndex: Ve.frameIndex }), e.mergeUniform({ aoMap: Ve.aoRenderTarget }), e.mergeUniform({ aoEnabled: Ve.aoEnabled }), this.color === void 0 && (this.color = new Rt(qn)), this.color.analyze(e, { slot: "color" }), this.specular.analyze(e), this.shininess.analyze(e); let r = this.occlusion.flow(e, "b", { slot: "occlusion" }); this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e); let s = this.color.flow(e, "c", { slot: "color" }), o = this.specular.flow(e, "c"), a = this.shininess.flow(e, "f"), l = this.shadingAlpha.flow(e, "f"), u = this.shadingBlend.flow(e, "i"), c = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, h = this.alpha ? this.alpha.flow(e, "f") : void 0, d = this.alphaOverride ? this.alphaOverride.flow(e, "f") : void 0; e.requires.transparent = h !== void 0, e.addParsCode(["varying vec3 vWPosition;", "uniform vec3 emissive;", `uniform float penumbraSize[${5}];`, "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "#include <normal_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_phong_pars_fragment>", "#include <shadowmap_pars_fragment>", "#include <dithering_pars_fragment>"].join(`
`)); let f = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	BlinnPhongMaterial material;"]; if (this.bumpMap) {
				e.include(Oo.dHdxy), e.include(Oo.perturbNormalArb); let m = this.bumpMap.texture.flow(e, "t"), g = this.bumpMap.flow(e, "v3"), y = this.bumpMapIntensity ? this.bumpMapIntensity.flow(e, "f").result : "1.0", v = ""; this.bumpMap.projection.value === 4 ? v = `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${m.result}, uv0, ${y});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${m.result}, uv1, ${y});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${m.result}, uv2, ${y});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`: v = `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${m.result}, bumpMapCachedUv, ${y});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`, f.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${g.result};
					${v}
					`)
			} f.push(s.code, "	vec3 diffuseColor = " + s.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", "	vec3 totalEmissiveRadiance = emissive;", o.code, "	vec3 specular = " + o.result + ";", a.code, "	float shininess = max( 0.0001, " + a.result + " );", "	float specularStrength = 1.0;"), h && f.push(h.code, "#ifdef ALPHATEST", "if ( " + h.result + " <= ALPHATEST ) discard;", "#endif"), f.push("material.diffuseColor = diffuseColor;"), f.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), f.push("vec3 ao = aoEnabled && " + r.result + " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;"); let p = "1.0"; this.mask && (this.mask.analyze(e), p = `luminance(${this.mask.flow(e, "v3").result})`), f.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${l.result} * ${p} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${l.result} * ${p}, ${u.result} );
					
					outgoingLight *= ao;
				}
				`), c && f.push(c.code, `outgoingLight = spe_blend(outgoingLight, ${c.result}, 1.0, SPE_BLENDING_NORMAL);`), h ? f.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${h.result});`) : f.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), d && f.push(`gl_FragColor.a *= ${d.result};`), f.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), n = f.join(`
`)
		} return n
	}
}; var Zf = class extends lr {
	constructor() { super("standard"); this.nodeType = "Standard"; this.color = new Rt(qn), this.roughness = new Ee(.3), this.metalness = new Ee(0), this.reflectivity = new Ee(.5), this.previousModelViewMatrix = new Sr, this.previouseProjectionMatrix = new Sr, this.shadingAlpha = new Ee(1), this.shadingBlend = new pt(0), this.occlusion = new mn(!0) } get category () { return "physical" } build (e) {
		let n; if (e.define("STANDARD"), e.requires.lights = !0, e.extensions.derivatives = !0, e.extensions.shaderTextureLOD = !0, e.isShader("vertex")) {
			let r = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0; e.mergeUniform({ frameIndex: Ve.frameIndex }), e.mergeUniform({ resolution: Ve.resolution }), e.mergeUniform({ previousModelViewMatrix: this.previousModelViewMatrix }), e.mergeUniform({ previousProjectionMatrix: this.previouseProjectionMatrix }), e.mergeUniform(Yi.merge([xe.fog, xe.lights])), xe.LTC_1 && (e.uniforms.ltc_1 = { value: void 0 }, e.uniforms.ltc_2 = { value: void 0 }), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`)); let s = ["#include <beginnormal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#if defined( USE_LAYER_DISPLACE )
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#if !defined( USE_LAYER_DISPLACE )
					#include <begin_vertex>
				#endif /* !USE_LAYER_DISPLACE */
				`]; r && s.push(r.code, r.result ? "displaced_position = " + r.result + ";" : ""), s.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), s.push("#include <project_vertex>", "#include <fog_vertex>", "#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "#include <worldpos_vertex>", "#include <shadowmap_vertex>"), s.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), n = s.join(`
`)
		} else {
			e.mergeUniform({ penumbraSize: Ve.penumbraSize }), e.mergeUniform({ frameIndex: Ve.frameIndex }), e.mergeUniform({ aoMap: Ve.aoRenderTarget }), e.mergeUniform({ aoEnabled: Ve.aoEnabled }); let r = { gamma: !0 }; this.color === void 0 && (this.color = new Rt(qn)), this.color.analyze(e, { slot: "color", context: r }), this.roughness.analyze(e), this.metalness.analyze(e); let s = this.occlusion.flow(e, "b", { slot: "occlusion" }); this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e), this.reflectivity && this.reflectivity.analyze(e); let o = this.color.flow(e, "c", { slot: "color", context: r }), a = this.roughness.flow(e, "f"), l = this.metalness.flow(e, "f"), u = this.shadingAlpha.flow(e, "f"), c = this.shadingBlend.flow(e, "i"), h = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, d = this.alpha ? this.alpha.flow(e, "f") : void 0, f = this.alphaOverride ? this.alphaOverride.flow(e, "f") : void 0, p = this.reflectivity ? this.reflectivity.flow(e, "f") : void 0; e.requires.transparent = d !== void 0, e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", `uniform float penumbraSize[${5}];`, "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "#include <normal_pars_fragment>", "#include <dithering_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <lights_physical_pars_fragment>", "#include <shadowmap_pars_fragment>"].join(`
`)); let m = ["#include <clipping_planes_fragment>", "	#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	PhysicalMaterial material;", "	material.diffuseColor = vec3( 1.0 );"]; if (this.bumpMap) {
				e.include(Oo.dHdxy), e.include(Oo.perturbNormalArb); let y = this.bumpMap.texture.flow(e, "t"), v = this.bumpMap.flow(e, "v3"), x = this.bumpMapIntensity ? this.bumpMapIntensity.flow(e, "f").result : "1.0", b = ""; this.bumpMap.projection.value === 4 ? b = `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${y.result}, uv0, ${x});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${y.result}, uv1, ${x});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${y.result}, uv2, ${x});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`: b = `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${y.result}, bumpMapCachedUv, ${x});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`, m.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${v.result};
					${b}
					`)
			} if (m.push(o.code, "	vec3 diffuseColor = " + o.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", l.code, "	float metalnessFactor = " + l.result + ";"), this.roughnessMap) {
				let y = this.roughnessMap.texture.flow(e, "t"), v = this.roughnessMap.flow(e, "v3"), x = ""; this.roughnessMap.projection.value === 4 ? x = `
					float roughnessChange = 1.0;
					{
						vec2 uv0 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_triplanarWeights;

						float r0 = luminance(texture(${y.result}, uv0).rgb) * roughnessScale;
						float r1 = luminance(texture(${y.result}, uv1).rgb) * roughnessScale;
						float r2 = luminance(texture(${y.result}, uv2).rgb) * roughnessScale;

						roughnessChange = (r0 * weights.z + r1 * weights.x + r2 * weights.y);
					}
					float roughnessFactor = roughnessChange * ${a.result};
					`: x = `
					vec2 roughnessMapCachedUv = g${this.roughnessMap.uuid.toString().replace(/-/g, "")}_writeUvs;

					vec4 vals = texture(${y.result},  roughnessMapCachedUv);
					float roughnessFactor = luminance(vals.rgb) * ${a.result};
					`, m.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${v.result};

					const float roughnessScale = 1.0;

					${x}
				`)
			} else m.push(a.code, "	float roughnessFactor = " + a.result + ";"); d && m.push(d.code, "#ifdef ALPHATEST", "	if ( " + d.result + " <= ALPHATEST ) discard;", "#endif"), m.push("vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );"), m.push("material.diffuseColor = diffuseColor * ( 1.0 - metalnessFactor );", "material.roughness = max( roughnessFactor, 0.0525 );", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.roughness = clamp( roughnessFactor, 0.04, 1.0 );"), p ? m.push(p.code, "material.specularColor = mix( vec3( 0.16 * pow2( " + p.result + " ) ), diffuseColor, metalnessFactor );") : m.push("material.specularColor = mix( vec3( 0.04 ), diffuseColor, metalnessFactor );"), m.push("#include <lights_fragment_begin>"), m.push("#include <lights_fragment_end>"), m.push("vec3 ao = aoEnabled && " + s.result + " ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse)) + reflectedLight.directSpecular + reflectedLight.indirectSpecular;"); let g = "1.0"; this.mask && (this.mask.analyze(e), g = `luminance(${this.mask.flow(e, "v3").result})`), m.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${u.result} * ${g} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${u.result} * ${g}, ${c.result} );
					
					outgoingLight *= ao;
				}
				`), h && m.push(h.code, `outgoingLight = spe_blend(outgoingLight, ${h.result}, 1.0, SPE_BLENDING_NORMAL);`), d ? m.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${d.result} );`) : m.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), f && m.push(`gl_FragColor.a *= ${f.result};`), m.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), n = m.join(`
`)
		} return n
	}
}; var Jf = class extends lr {
	constructor() { super("toon"); this.nodeType = "Toon"; this.color = new Rt(qn), this.specular = new Rt(1118481), this.shininess = new Ee(30), this.previousModelViewMatrix = new Sr, this.previouseProjectionMatrix = new Sr, this.shadingAlpha = new Ee(1), this.shadingBlend = new pt(0) } get category () { return "toon" } build (e) {
		let n; if (e.define("TOON"), e.requires.lights = !0, e.extensions.derivatives = !0, e.isShader("vertex")) {
			let r = this.position ? this.position.analyzeAndFlow(e, "v3", { cache: "position" }) : void 0; e.mergeUniform({ frameIndex: Ve.frameIndex }), e.mergeUniform({ resolution: Ve.resolution }), e.mergeUniform({ previousModelViewMatrix: this.previousModelViewMatrix }), e.mergeUniform({ previousProjectionMatrix: this.previouseProjectionMatrix }), e.mergeUniform(Yi.merge([xe.fog, xe.lights])), e.addParsCode(["varying vec3 vViewPosition;", "varying vec3 vWPosition;", "#include <fog_pars_vertex>", "#include <normal_pars_vertex>", "#include <shadowmap_pars_vertex>", "#include <clipping_planes_pars_vertex>"].join(`
`)); let s = ["#include <beginnormal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <defaultnormal_vertex>
				#endif

				vec3 displaced_position = position;
				vec3 displaced_normal = normal;

				#ifdef USE_LAYER_DISPLACE
					vec3 transformed;
					vec3 transformedNormal;
				#endif
				`, "#include <normal_vertex>", `
				#ifndef USE_LAYER_DISPLACE
					#include <begin_vertex>
				#endif
				`]; r && s.push(r.code, r.result ? "displaced_position = " + r.result + ";" : ""), s.push("transformed = displaced_position;", "transformedNormal = normalMatrix * displaced_normal;", "#ifndef FLAT_SHADED", "    vNormal = transformedNormal;", "#endif"), s.push("	#include <project_vertex>", "	#include <fog_vertex>", "	#include <clipping_planes_vertex>", "	vViewPosition = - mvPosition.xyz;", "	#include <worldpos_vertex>", "	#include <shadowmap_vertex>", "	#include <fog_vertex>"), s.push("vWPosition = ( modelMatrix * vec4( transformed, 1.0 ) ).xyz;"), n = s.join(`
`)
		} else {
			e.mergeUniform({ penumbraSize: Ve.penumbraSize }), e.mergeUniform({ frameIndex: Ve.frameIndex }), e.mergeUniform({ aoMap: Ve.aoRenderTarget }), e.mergeUniform({ aoEnabled: Ve.aoEnabled }), this.color === void 0 && (this.color = new Rt(qn)), this.color.analyze(e, { slot: "color" }), this.specular.analyze(e), this.shininess.analyze(e), this.shadingAlpha.analyze(e), this.shadingBlend.analyze(e), this.afterColor && this.afterColor.analyze(e, { slot: "afterColor" }), this.alpha && this.alpha.analyze(e); let r = this.color.flow(e, "c", { slot: "color" }), s = this.specular.flow(e, "c"), o = this.shininess.flow(e, "f"), a = this.shadingAlpha.flow(e, "f"), l = this.shadingBlend.flow(e, "i"), u = this.afterColor ? this.afterColor.flow(e, "c", { slot: "afterColor" }) : void 0, c = this.alpha ? this.alpha.flow(e, "f") : void 0, h = this.alphaOverride ? this.alphaOverride.flow(e, "f") : void 0; e.requires.transparent = c !== void 0, e.addParsCode([`uniform float penumbraSize[${5}];`, "uniform sampler2D aoMap;", "uniform bool aoEnabled;", "varying vec3 vWPosition;", "#include <normal_pars_fragment>", "#include <gradientmap_pars_fragment>", "#include <fog_pars_fragment>", "#include <bsdfs>", "#include <lights_pars_begin>", "#include <dithering_pars_fragment>", `
					varying vec3 vViewPosition;
					struct ToonMaterial {
						vec3	diffuseColor;
						vec3	specularColor;
						float	specularShininess;
						float	specularStrength;
					};
					void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
			
						reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
						reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
					}
					void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
					}
					#define RE_Direct				RE_Direct_Toon
					#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
					#define Material_LightProbeLOD( material )	(0)
					`, "#include <shadowmap_pars_fragment>", "#include <bumpmap_pars_fragment>", "#include <normalmap_pars_fragment>"].join(`
`)); let d = ["#include <normal_fragment_begin>", `
				// NOTE: gl_FrontFacing alternative using face normal estimation.
				vec3 viewdx = dFdx(vViewPosition);
				vec3 viewdy = dFdy(vViewPosition);
				vec3 faceNormal = normalize(cross(viewdx,viewdy));
				if (dot(normal, faceNormal) < 0.0) {
					normal *= -1.0;
				}
				`, "	ToonMaterial material;"]; if (this.bumpMap) {
				e.include(Oo.dHdxy), e.include(Oo.perturbNormalArb); let p = this.bumpMap.texture.flow(e, "t"), m = this.bumpMap.flow(e, "v3"), g = this.bumpMapIntensity ? this.bumpMapIntensity.flow(e, "f").result : "1.0", y = ""; this.bumpMap.projection.value === 4 ? y = `
					vec3 bumpNormal = vec3(0.0);
					{
						vec2 uv0 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs0;
						vec2 uv1 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs1;
						vec2 uv2 = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs2;
						vec3 weights = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_triplanarWeights;

						vec2 grad0 = dHdxy(${p.result}, uv0, ${g});
						vec3 n0 = perturbNormalArb(-vViewPosition, normal, grad0, faceDirection);

						vec2 grad1 = dHdxy(${p.result}, uv1, ${g});
						vec3 n1 = perturbNormalArb(-vViewPosition, normal, grad1, faceDirection);

						vec2 grad2 = dHdxy(${p.result}, uv2, ${g});
						vec3 n2 = perturbNormalArb(-vViewPosition, normal, grad2, faceDirection);
						
						bumpNormal = n0 * weights.z + n1 * weights.x + n2 * weights.y;
						bumpNormal = normalize(bumpNormal);
					}

					normal = bumpNormal;
					`: y = `
					vec2 bumpMapCachedUv = g${this.bumpMap.uuid.toString().replace(/-/g, "")}_writeUvs;
					vec2 grad = dHdxy(${p.result}, bumpMapCachedUv, ${g});
					normal = perturbNormalArb( - vViewPosition, normal, grad, faceDirection );
					`, d.push(`// Call the Texture Layer's function once here so that it writes out its procedural UV coordinates
					${m.result};
					${y}
					`)
			} d.push(r.code, "	vec3 diffuseColor = " + r.result + ";", "	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );", s.code, "	vec3 specular = " + s.result + ";", o.code, "	float shininess = max( 0.0001, " + o.result + " );", "	float specularStrength = 1.0;"), c && d.push(c.code, "#ifdef ALPHATEST", "if ( " + c.result + " <= ALPHATEST ) discard;", "#endif"), d.push("material.diffuseColor = diffuseColor;"), d.push("material.specularColor = specular;", "material.specularShininess = shininess;", "material.specularStrength = specularStrength;", "#include <lights_fragment_begin>", "#include <lights_fragment_end>"), d.push("vec3 ao = aoEnabled ? tex2D(aoMap, gl_FragCoord.xy / resolution).rgb : vec3(1.0);", "vec3 outgoingLight = ((reflectedLight.directDiffuse + reflectedLight.indirectDiffuse) * ao) + reflectedLight.directSpecular;"); let f = "1.0"; this.mask && (this.mask.analyze(e), f = `luminance(${this.mask.flow(e, "v3").result})`), d.push(`
				if (outgoingLight != diffuseColor) {
					float lightAccu = clamp( length( reflectedLight.directSpecular + reflectedLight.indirectSpecular ), 0.0, 1.0 );
					accumAlpha += ( 1.0 - accumAlpha ) * ${a.result} * ${f} * lightAccu;
					outgoingLight = spe_blend( diffuseColor, outgoingLight, ${a.result} * ${f}, ${l.result} );
				}
				`), u && d.push(u.code, `outgoingLight = spe_blend(outgoingLight, ${u.result}, 1.0, SPE_BLENDING_NORMAL);`), c ? d.push(`gl_FragColor = vec4( outgoingLight, accumAlpha * ${c.result} );`) : d.push("gl_FragColor = vec4( outgoingLight, 1.0 );"), h && d.push(`gl_FragColor.a *= ${h.result};`), d.push("#include <encodings_fragment>", "#include <fog_fragment>", "#include <dithering_fragment>"), n = d.join(`
`)
		} return n
	}
}; var Wy = class { constructor(t = 1e3 * 10) { this.timeout = t; this.cache = new Map; this.head = { data: null, time: 0, src: null, next: null, prev: null }; this.tail = { data: null, time: 1 / 0, src: null, next: null, prev: null }; this.hasClean = !1; this.head.next = this.tail, this.tail.prev = this.head } log (...t) { } remove (t) { let e = this.cache.get(t); e && (this.dispose(t, e.data), this.cache.delete(t), e.prev.next = e.next, e.next.prev = e.prev) } scheduleCleanup () { this.hasClean || (this.log("scheduled cleanup"), this.hasClean = !0, setTimeout(() => { this.hasClean = !1, this.log("cleaning"); let t = Date.now(), e = this.head.next; for (; e.time < t - this.timeout;)this.dispose(e.src, e.data), this.cache.delete(e.src), e = e.next, e.prev = this.head, this.head.next = e; this.head.next !== this.tail ? this.scheduleCleanup() : this.log("no more cleanup") }, this.timeout + 1e3)) } has (t) { return this.cache.get(t)?.data } load (t) { let e = Date.now(), n = this.cache.get(t); return n === void 0 ? (n = { data: this.create(t), src: t, time: e, next: null, prev: null }, this.cache.set(t, n)) : (n.time = e, n.prev.next = n.next, n.next.prev = n.prev), n.prev = this.tail.prev, n.next = this.tail, this.tail.prev.next = n, this.tail.prev = n, this.scheduleCleanup(), n.data } }; var pS = class extends Wy { create (t) { return URL.createObjectURL(new Blob([t])) } dispose (t, e) { URL.revokeObjectURL(e) } }, fS; function P2 (i) { return typeof i == "string" ? i : (fS || (fS = new pS), fS.load(i)) } var qy = class { constructor(t, e) { this.data = t; this.cache = e; this.refCount = 0 } deref () { if (this.refCount === 0 && !1) throw new Error("ref count -1?"); this.refCount -= 1, this.refCount === 0 && (this.cache.remove(this), this.dispose()) } dispose () { if (this.refCount !== 0 && !1) throw new Error("ref count is not 0") } }, Yy = class { constructor() { this.cache = new Map } remove (t) { if (this.cache.delete(t.data) === !1 && !1) throw new Error("ref count remove non-exists") } load (t) { let e = this.cache.get(t); return e === void 0 && (e = this.create(t), this.cache.set(t, e)), e.refCount += 1, e } }; var Uh = class extends qy { constructor(e, n) { super(e, n.imageHolderCache); this.data = e; this.shared = n; this.loaded = !1; this.isVideo = !1; this.isVideo = e.type === "video", this.updateSrc(e.data) } async updateSrc (e) { if (typeof document > "u") return; this.disposeTextures(), this.loaded = !1; let n = () => { this.loaded = !0; let s = [1e3, 1001, 1002]; for (let o of s) { let a = this[o]; a && (a.image = this.img, a.needsUpdate = !0) } this.shared.requestRender() }; if (this.isVideo) { if (this.img = document.createElement("video"), this.img.preload = "auto", this.img.playsInline = !0, this.img.currentTime = .01, typeof e != "string") { var r = new FileReader; r.readAsDataURL(new Blob([e], { type: "video/mp4" })); let s; await new Promise(o => { r.onloadend = a => { s = a.target?.result, o(null) } }), this.img.src = s } else this.img.src = e; this.img.onloadeddata = () => { n() } } else this.img = new Image, this.img.src = P2(e), this.img.onload = n } getTexture (e) { let n = this[e]; if (n) return n; { let r; return this.isVideo ? r = new Am(this.img, void 0, e, e) : r = new Qt(this.img, void 0, e, e), this.loaded && (r.needsUpdate = !0), this[e] = r, r } } disposeTextures () { this[1e3]?.dispose(), this[1e3] = void 0, this[1001]?.dispose(), this[1001] = void 0, this[1002]?.dispose(), this[1002] = void 0 } dispose () { super.dispose(), this.disposeTextures() } }; 1e3, 1001, 1002; var Di = class extends Uh { }; function Ar (i, t) { return t.color(i) } function I2 (i, t) { switch (i.type) { case "fresnel": return WW(i, t); case "gradient": return qW(i); case "depth": return YW(i); case "normal": return XW(i); case "noise": return QW(i, t); case "rainbow": return KW(i); case "toon": return ZW(i, t); case "outline": return JW(i, t); case "transmission": return $W(i, t); case "color": return jW(i, t); case "pattern": return e6(i, t) } } function HW (i) { return { type: i.type } } function os (i) { let { alpha: t, mode: e, isMask: n } = i; return { ...HW(i), alpha: t, mode: e, isMask: n } } function jW (i, t) { return { ...os(i), color: Ar(i.color, t) } } function WW (i, t) { let { bias: e, scale: n, intensity: r, factor: s, color: o, isMask: a } = i; return { ...os(i), color: Ar(o, t), bias: e, scale: n, intensity: r, factor: s } } function qW (i) { let { gradientType: t, smooth: e, colors: n, steps: r, angle: s, offset: o, morph: a } = i; return { ...os(i), gradientType: t, smooth: e, colors: n.map(l => new qe(l[0], l[1], l[2], l[3])), num: n.length, steps: r, offset: new B(...o), morph: new B(...a), angle: s } } function YW (i) { let { gradientType: t, near: e, far: n, isVector: r, isWorldSpace: s, origin: o, direction: a, colors: l, steps: u, smooth: c } = i; return { ...os(i), gradientType: t, near: e, far: n, isVector: r, isWorldSpace: s, origin: new A(...o), direction: a ? new A(...a) : new A(1, 0, 0), colors: l.map(h => h !== void 0 ? new qe(h[0], h[1], h[2], h[3]) : new qe(0, 0, 0, 0)), steps: u.slice(0, l.length), smooth: c } } function XW (i) { let { cnormal: t } = i; return { ...os(i), cnormal: new A(t[0], t[1], t[2]) } } function QW (i, t) { return { ...os(i), scale: i.scale, move: i.move, fA: new B(...i.fA), fB: new B(...i.fB), size: new A(...i.size), distortion: new B(...i.distortion), colorA: Ar(i.colorA, t), colorB: Ar(i.colorB, t), colorC: Ar(i.colorC, t), colorD: Ar(i.colorD, t), noiseType: i.noiseType, voronoiStyle: i.voronoiStyle, highCut: i.highCut, lowCut: i.lowCut, smoothness: i.smoothness, seed: i.seed, quality: i.quality } } function KW (i) { return { ...os(i), filmThickness: i.filmThickness, movement: i.movement, wavelengths: new A(...i.wavelengths), noiseStrength: i.noiseStrength, noiseScale: i.noiseScale, offset: new A(...i.offset) } } function ZW (i, t) { return { ...os(i), positioning: i.positioning, colors: i.colors.map(e => new qe(e[0], e[1], e[2], e[3])), num: i.colors.length, steps: i.steps, source: new A(...i.source), isWorldSpace: i.isWorldSpace, noiseStrength: i.noiseStrength, noiseScale: i.noiseScale, shadowColor: Ar(i.shadowColor, t), offset: new A(...i.offset) } } function JW (i, t) { return { ...os(i), outlineColor: Ar(i.outlineColor, t), contourColor: Ar(i.contourColor, t), outlineWidth: i.outlineWidth, contourWidth: i.contourWidth, outlineThreshold: i.outlineThreshold, contourThreshold: i.contourThreshold, outlineSmoothing: i.outlineSmoothing, contourFrequency: i.contourFrequency, contourDirection: new A(...i.contourDirection), positionalLines: i.positionalLines, compensation: i.compensation } } function $W (i, t) { return { ...os(i), thickness: i.thickness, ior: i.ior, roughness: i.roughness } } function e6 (i, t) { return { ...os(i), style: i.style, projection: i.projection, axis: i.axis, blending: i.blending, offset: new B(...i.offset), colorA: Ar(i.colorA, t), colorB: Ar(i.colorB, t), frequency: new B(...i.frequency), size: i.size, variation: i.variation, smoothness: i.smoothness, zigzag: i.zigzag, rotation: i.rotation, vertical: new B(...i.vertical), horizontal: new B(...i.horizontal), sides: i.sides } } var za = class extends on { }; var mS = { noise: ["noiseType"], texture: ["projection", "axis", "side"], video: ["projection", "axis", "side"], displace: ["noiseType"], light: ["roughnessMap", "bumpMap"], depth: ["smooth", "isWorldSpace", "gradientType", "isVector"], pattern: ["style", "projection", "axis"] }, gS = { depth: ["colors"] }; function t6 (i, t, e) { if (t === "isMask") return !0; let n = mS[i.type], r = gS[i.type]; if (r !== void 0) { let s = i.color; if (r.includes(t)) { let o = s[t]?.value?.length; if (o !== void 0 && o !== e.length) return !0 } } return n !== void 0 ? n.includes(t) : !1 } function yS (i, t, e) { let n = e.uniforms[`f${e.id}_texture`]; if (!n) return !1; let r = !1, s = i; if ("image" in s) { let o = s.image, a = t.image(o), l = n; l.image instanceof Di || l.image.deref(), l.image = a } if ("video" in s) { let o = s.video, a = t.video(o), l = n; l.image instanceof Di || l.image.deref(), l.image = a } if ("wrapping" in s) { let o = n; o.wrap = s.wrapping } if ("repeat" in s || "offset" in s) { let o = "mat", a = e.uniforms[`f${e.id}_${o}`]; "repeat" in s && (a.repeat = s.repeat), "offset" in s && (a.offset = s.offset), a.updateMatrix() } return r } function D2 (i, t, e, n) { let r = !1; for (let [s, o] of Object.entries(i)) { if (s === "bumpMap" || s === "roughnessMap") { r = !0; continue } if (!s || o === void 0) continue; if (vS(s, e, n)) { s === "visible" && e.type === "light" && (r = !0); continue } e.visible = n.visible; let a = e.uniforms[`f${e.id}_${s}`]; if (!!a && !(a instanceof ka)) switch (r = r || t6(e, s, o), a.constructor) { case Rt: if (typeof o == "string") { let l = t.getColor(o); l && (a.value = l); break } else { let l = o; a.value instanceof za ? a.value = new on(l.r, l.g, l.b, l.a) : a.setRGBA(l); break } case Zr: if (typeof o == "string") { let l = t.getColor(o); l && (a.value = l); break } else { let l = o; a.value instanceof za ? a.value = new on(l.r, l.g, l.b, l.a) : a.value.setRGBA(l.r, l.g, l.b, l.a); break } case cn: { let l = o; a.value.setX(l[0]), a.value.setY(l[1]); break } case wr: { let l = o; a.value.setX(l[0]), a.value.setY(l[1]), a.value.setZ(l[2]); break } case Gr: { yS(o, t, e); break } case ss: { a.value = o.map(l => new qe(...l)); break } default: { a.value = o; break } } } return r } var Us = class { constructor(t, e, n, r) { this.id = t; this.uuid = e; this.data = n; this.uniforms = {}; for (let s in r) this.uniforms[`f${this.id}_${s}`] = r[s]; for (let s in n) vS(s, this, n) } get type () { return this.data.type } static create (t, e, n, r) { if (n.type === "light") return mi.createLigherLayer(t, e, n, r); if (n.type === "texture" || n.type === "video") { let s = n.type === "texture" ? r.image(n.texture.image) : r.video(n.texture.video), o = new Vl(s, n.texture.wrapping), a = new Hy(s), l = new jy(n.texture.repeat, n.texture.offset), u = new Ee(n.crop ? 1 : 0), c = new pt(n.projection ?? 0), h = new pt(["x", "y", "z"].indexOf(n.axis) ?? 0), d = new pt(n.side ?? 0), f = new cn(n.size ? new B(n.size[0], n.size[1]) : new B(100, 100)), p = new Ee(n.blending ?? 0), m = new Ee(n.alpha ?? 1), g = new pt(n.mode ?? 0), y = new mn(n.isMask ?? !1), v = new Ua(o, a, u, c, h, d, f, p, l, m, g, y), x = new Tt(v.calpha, "f"); return new $t(t, e, n, { texture: o, textureSize: a, crop: u, projection: c, axis: h, side: d, size: f, blending: p, mat: l, alpha: m, mode: g, isMask: y }, v, g, x, y) } else if (n.type === "matcap") { let s = r.image(n.texture.image), o = new Vl(s, n.texture.wrapping), a = new Ee(n.alpha ?? 1), l = new pt(n.mode ?? 0), u = new mn(n.isMask ?? !1), c = new Dh(o, a, l, u), h = new Tt(c.calpha, "f"); return new $t(t, e, n, { texture: o, alpha: a, mode: l, isMask: u }, c, l, h, u) } else if (n.type === "displace") if (n.displacementType === "noise") { let s = new wr(new A(...n.offset)), o = new Ee(n.scale ?? 10), a = new Ee(n.intensity ?? 8), l = new Ee(n.movement ?? 1), u = new pt(n.noiseType ?? 0), c = new pt(n.voronoiStyle ?? 0), h = new Ee(n.smoothness ?? .5), d = new Ee(n.seed ?? 0), f = new Ee(n.highCut ?? 1), p = new Ee(n.lowCut ?? 0), m = new pt(n.quality ?? 1), g = new kh(a, l, s, c, h, d, f, p, m, o, u); return new $f(t, e, n, { offset: s, scale: o, intensity: a, movement: l, noiseType: u, voronoiStyle: c, smoothness: h, seed: d, highCut: f, lowCut: p, quality: m }, g) } else throw new Error; else return i6(t, e, n, r) } updateByOp (t, e, n) { let r = t; if (r.path[0] === void 0) { if (r.type === 0) return "type" in r.props || "category" in r.props || "visible" in r.props ? (n.scene.markNeedsUpdateRendererDirty(), !0) : D2(r.props, n.shared, this, e) } else if (r.path[0] === "texture") return "texture" in e || "video" in e ? yS(r.props, n.shared, this) : !0; return !1 } dispose () { if (n6(this)) { let t = this.uniforms[`f${this.id}_texture`]; if (!t) return !1; let e = t; e.image instanceof Di || e.image.deref() } } hasValueByKey (t) { return this.uniforms[t] !== void 0 } hasValue (t) { return this.hasValueByKey(`f${this.id}_${t}`) } setValue (t, e) { let n = `f${this.id}_${t}`; this.hasValueByKey(n) && e !== void 0 && (this.uniforms[n].value = e) } getNode (t) { let e = `f${this.id}_${t}`; if (this.hasValueByKey(e)) return this.uniforms[e] } getValue (t) { let e = `f${this.id}_${t}`; if (this.hasValueByKey(e)) return this.uniforms[e].value } getName (t) { let n = /f\d+_(.*)/.exec(t); if (n && n.length > 1) return n[1]; console.log(`Layer.getName: error ${t}`) } getNames () { let t = []; for (let e in this.uniforms) { let n = this.getName(e); n && t.push(n) } return t } }, $t = class extends Us { constructor(e, n, r, s, o, a, l, u) { super(e, n, r, s); this.params = s; this.color = o; this.mode = a; this.alpha = l; this.isMask = u } }, $f = class extends Us { constructor(e, n, r, s, o) { super(e, n, r, s); this.position = o } }, mi = class extends Us { constructor(e, n, r, s, o) { super(e, n, r, o); this.node = s } static createLigherLayer (e, n, r, s) { let o, a = new Ee(r.alpha), l = new pt(r.mode), u = new Ee(r.bumpMapIntensity), c = new Ee(r.alphaOverride), h; if (!r.visible) o = new Wl, h = {}; else if (r.category === "lambert") { o = new Qf; let d = new Rt(s.color(r.emissive) ?? 0), f = new mn(r.occlusion ?? !0); h = { emissive: d, occlusion: f }, o.emissive = d, o.occlusion = f } else if (r.category === "toon") { o = new Jf; let d = new Ee(r.shininess ?? 30), f = new Rt(s.color(r.specular) ?? 1118481); h = { shininess: d, specular: f }, o.shininess = d, o.specular = f } else if (r.category === "physical") { o = new Zf; let d = new Ee(r.roughness ?? .3), f = new Ee(r.metalness ?? 0), p = new Ee(r.reflectivity ?? .5), m = new mn(r.occlusion ?? !0); h = { roughness: d, metalness: f, reflectivity: p, occlusion: m }, o.roughness = d, o.metalness = f, o.reflectivity = p, o.occlusion = m } else { o = new Kf; let d = new Ee(r.shininess ?? 30), f = new Rt(r.specular !== void 0 ? s.color(r.specular) ?? 1118481 : 1118481), p = new mn(r.occlusion ?? !0); h = { shininess: d, specular: f, occlusion: p }, o.shininess = d, o.specular = f, o.occlusion = p } return o.alpha = new Ee(1), o.shadingAlpha = a, o.shadingBlend = l, o.bumpMapIntensity = u, o.alphaOverride = c, h.alpha = o.shadingAlpha, h.mode = o.shadingBlend, h.bumpMapIntensity = o.bumpMapIntensity, h.alphaOverride = o.alphaOverride, new mi(e, n, r, o, h) } get category () { return this.node.category } }; function n6 (i) { let t = i instanceof Us ? i.type : i; return t === "texture" || t === "video" || t === "displace_map" || t === "matcap" } function Oi (i) { return { alpha: new Ee(i.alpha ?? 1), mode: new pt(i.mode ?? 0), isMask: new mn(i.isMask ?? !1) } } function r6 (i, t, e, n) { switch (i.type) { case "color": { let r = new Rt(n.color ?? qn), s = Oi(n), o = new Hl(r, s.alpha), a = new Tt(o.calpha, "f"); return new $t(t, e, i, { color: r, ...s }, o, s.mode, a, s.isMask) } case "fresnel": { let r = new Rt(n.color ?? 16777215), s = new Ee(n.bias ?? .1), o = new Ee(n.scale ?? 1), a = new Ee(n.intensity ?? 2), l = new Ee(n.factor ?? 1), u = Oi(n), c = new Yf(r, s, o, a, l, u.alpha, u.mode, u.isMask), h = new Tt(c.calpha, "f"); return new $t(t, e, i, { color: r, bias: s, scale: o, intensity: a, factor: l, ...u }, c, u.mode, h, u.isMask) } case "rainbow": { let r = new Ee(n.filmThickness ?? 30), s = new Ee(n.movement ?? 0), o = new wr(n.wavelengths ?? new A(0, 0, 0)), a = new Ee(n.noiseStrength ?? 0), l = new Ee(n.noiseScale ?? 1), u = new wr(n.offset ?? new A(0, 0, 0)), c = Oi(n), h = new Nh(r, s, o, a, l, u, c.alpha, c.isMask), d = new Tt(h.calpha, "f"); return new $t(t, e, i, { filmThickness: r, movement: s, wavelengths: o, noiseStrength: a, noiseScale: l, offset: u, ...c }, h, c.mode, d, c.isMask) } case "transmission": { let r = new Ee(n.thickness ?? 10), s = new Ee(n.ior ?? 1.5), o = new Ee(n.roughness ?? .5), a = Ve.transmissionSize, l = Ve.transmissionRenderTarget, u = Ve.transmissionRenderTargetDepth, c = window.innerWidth, h = window.innerHeight, d = c >= h ? new cn(h / c, 1) : new cn(1, c / h), f = Oi(n), p = new Fh(r, s, o, a, l, u, d, f.alpha), m = new Tt(p.calpha, "f"); return new $t(t, e, i, { thickness: r, ior: s, roughness: o, aspectRatio: d, ...f }, p, f.mode, m, f.isMask) } case "toon": { let r = new pt(n.positioning ?? 0), s; n.colors ? s = new ss(n.colors.length, n.colors) : (s = new ss(10, new qe(0, 0, 0, 1)), s.value[1] = new qe(1, 1, 1, 1)); let o; n.steps ? o = new is(n.steps.length, n.steps) : (o = new is(10, 1), o.value[0] = 0); let a = new wr(n.source ?? new A(0, 0, 0)), l = new mn(n.isWorldSpace ?? !0), u = new Ee(n.noiseStrength ?? 0), c = new Ee(n.noiseScale ?? 1), h = new Zr(n.shadowColor), d = new wr(n.offset ?? new A(0, 0, 0)), f = Oi(n), p = new Bh(r, s, o, a, l, u, c, h, d, f.alpha), m = new Tt(p.calpha, "f"); return new $t(t, e, i, { positioning: r, colors: s, steps: o, source: a, isWorldSpace: l, noiseStrength: u, noiseScale: c, shadowColor: h, offset: d, ...f }, p, f.mode, m, f.isMask) } case "outline": { let r = new Rt(n.outlineColor ?? 16777215), s = new Rt(n.contourColor ?? 16777215), o = new Ee(n.outlineWidth ?? .1), a = new Ee(n.contourWidth ?? .1), l = new Ee(n.outlineThreshold ?? .1), u = new Ee(n.contourThreshold ?? .1), c = new Ee(n.outlineSmoothing ?? .1), h = new Ee(n.contourFrequency ?? .1), d = new wr(n.contourDirection ?? new A(0, 1, 0)), f = new mn(n.positionalLines ?? !1), p = new mn(n.compensation ?? !0), m = Ve.normalRenderTarget, g = Ve.normalRenderTargetDepth, y = Ve.pixelRatioNode, v = Ve.resolution, x = Oi(n), b = new Rh(r, s, o, a, l, u, c, h, d, f, p, v, m, g, y, x.alpha), S = new Tt(b.calpha, "f"); return new $t(t, e, i, { outlineColor: r, contourColor: s, outlineWidth: o, contourWidth: a, outlineThreshold: l, contourThreshold: u, outlineSmoothing: c, contourFrequency: h, contourDirection: d, positionalLines: f, compensation: p, ...x }, b, x.mode, S, x.isMask) } case "depth": { let r = new pt(n.gradientType ?? 0), s = new mn(n.smooth ?? !1), o = new Ee(n.near ?? 50), a = new Ee(n.far ?? 200), l = new Ee(n.isVector ?? 1), u = new Ee(n.isWorldSpace ?? 0), c = new wr(n.origin ?? new A), h = new wr(n.direction ?? new A), d; n.colors ? d = new ss(n.colors.length, n.colors) : (d = new ss(2, new qe(0, 0, 0, 1)), d.value[1] = new qe(1, 1, 1, 1)); let f; n.steps ? f = new is(n.steps.length, n.steps) : (f = new is(2, 1), f.value[0] = 0); let p = Oi(n), m = new Ph(r, s, o, a, l, u, c, h, d, f, p.alpha, p.isMask), g = new Tt(m.calpha, "f"); return new $t(t, e, i, { gradientType: r, smooth: s, near: o, far: a, isVector: l, isWorldSpace: u, origin: c, direction: h, colors: d, steps: f, ...p }, m, p.mode, g, p.isMask) } case "noise": { let r = new Ee(n.scale ?? 1), s = new wr(n.size ?? new A(100, 100, 100)), o = new Ee(n.move ?? 1), a = new cn(n.fA ?? new B(1.7, 9.2)), l = new cn(n.fB ?? new B(8.3, 2.8)), u = new cn(n.distortion ?? new B(1, 1)), c = new Zr(n.colorA), h = new Zr(n.colorB), d = new Zr(n.colorC), f = new Zr(n.colorD), p = new pt(n.noiseType ?? 0), m = new pt(n.voronoiStyle ?? 0), g = new Ee(n.highCut ?? 1), y = new Ee(n.lowCut ?? 0), v = new Ee(n.smoothness ?? .5), x = new Ee(n.seed ?? .5), b = new pt(n.quality ?? 1), S = Oi(n), _ = new Oh(r, s, o, a, l, u, c, h, d, f, S.alpha, p, S.isMask, m, g, y, v, x, b), E = new Tt(_.calpha, "f"); return new $t(t, e, i, { scale: r, size: s, move: o, fA: a, fB: l, distortion: u, colorA: c, colorB: h, colorC: d, colorD: f, noiseType: p, ...S, voronoiStyle: m, highCut: g, lowCut: y, smoothness: v, seed: x, quality: b }, _, S.mode, E, S.isMask) } case "normal": { let r = new wr(n.cnormal ?? new A(1, 1, 1)), s = Oi(n), o = new Mh(r, s.alpha), a = new Tt(o.calpha, "f"); return new $t(t, e, i, { cnormal: r, ...s }, o, s.mode, a, s.isMask) } case "gradient": { let r = new pt(n.gradientType ?? 0), s = new mn(n.smooth ?? !1), o; n.colors ? o = new ss(n.colors.length, n.colors) : (o = new ss(10, new qe(0, 0, 0, 1)), o.value[1] = new qe(1, 1, 1, 1)); let a; n.steps ? a = new is(n.steps.length, n.steps) : (a = new is(10, 1), a.value[0] = 0); let l = new cn(n.offset ?? new B(0, 0)), u = new cn(n.morph ?? new B(0, 0)), c = new Ee(n.angle ?? 0), h = Oi(n), d = new Ih(r, s, o, a, l, u, c, h.alpha, h.isMask), f = new Tt(d.calpha, "f"); return new $t(t, e, i, { gradientType: r, smooth: s, colors: o, steps: a, offset: l, morph: u, angle: c, ...h }, d, h.mode, f, h.isMask) } case "pattern": { let r = new pt(n.style ?? 0), s = new pt(n.projection ?? 0), o = new pt(["x", "y", "z"].indexOf(n.axis) ?? 0), a = new Ee(n.blending ?? 0), l = new cn(n.offset ?? new B(0, 0)), u = new Zr(n.colorA), c = new Zr(n.colorB), h = new cn(n.frequency ?? new B(10, 10)), d = new Ee(n.size ?? .5), f = new Ee(n.variation ?? 0), p = new Ee(n.smoothness ?? .5), m = new Ee(n.zigzag ?? 0), g = new Ee(n.rotation ?? 0), y = new cn(n.vertical ?? new B(0, 1)), v = new cn(n.horizontal ?? new B(0, 1)), x = new pt(n.sides ?? 6), b = Oi(n), S = new Lh(r, s, o, a, l, u, c, h, d, f, p, m, g, y, v, x, b.alpha, b.isMask), _ = new Tt(S.calpha, "f"); return new $t(t, e, i, { style: r, projection: s, axis: o, blending: a, offset: l, colorA: u, colorB: c, frequency: h, size: d, variation: f, smoothness: p, zigzag: m, rotation: g, vertical: y, horizontal: v, sides: x, ...b }, S, b.mode, _, b.isMask) } default: { let r = new Rt(1, 0, 0, 1), s = Oi(n), o = new Hl(r, s.alpha), a = new Tt(o.calpha, "f"); return new $t(t, e, i, { color: r, ...s }, o, s.mode, a, s.isMask) } } } function i6 (i, t, e, n) { let r = I2(e, n); return r6(e, i, t, r) } function vS (i, t, e) { if (e.type === "displace" && (i === "intensity" || i === "visible")) { let n = t.uniforms[`f${t.id}_intensity`]; return n ? (n.value = e.intensity * (e.visible ? 1 : 0), n) : void 0 } if (e.type !== "displace" && (i === "alpha" || i === "visible")) { let n = t.uniforms[`f${t.id}_alpha`]; if (!n) return; if (n.value = e.alpha * (e.visible ? 1 : 0), e.type === "outline" && i === "visible") { let r = t.uniforms[`f${t.id}_compensation`]; r && (r.value = e.compensation && e.visible) } return n } } function ep (i, t) { let e = 0, n = i.layers.find(r => r.data.type === "light"); if (n && n.data.alphaOverride < 1) return !0; for (let r of i.layers) { if (r.data.type !== "displace" && r.data.isMask) return !0; if (r.data.type !== "displace" && "alpha" in r.data && r.data.type !== "light" && r.data.type !== "fresnel" && r.data.type !== "texture" && r.data.type !== "matcap" && r.data.type !== "rainbow" && r.data.type !== "outline" && r.data.type !== "pattern") { let s = r.data.visible ? r.data.alpha : 0; if (s === 1 && r.data.type === "depth" || r.data.type === "gradient") { for (let o of r.data.colors) if (o[3] < 1) { s = o[3]; break } } else if (s === 1 && r.data.type === "noise") { let o = t.color(r.data.colorA).a, a = t.color(r.data.colorB).a, l = t.color(r.data.colorC).a, u = t.color(r.data.colorD).a, c = Math.min(o, Math.min(a, Math.min(l, u))); c < 1 && (s = c) } e += (1 - e) * s } } return e < 1 } var $r = class extends it { constructor() { super(void 0); this.flatShading = !1; this.needsJitter = !0; this.cacheKey = ""; this.fog = !0, this.dithering = !0, this.vertexColors = !0, this.transparent = !0 } customProgramCacheKey () { return this.cacheKey } }, Xy = class extends $r { constructor(e, n, r, s) { super(); this.flatShading = e; this.side = n; this.wireframe = r; this.root = s } updateAfterBuild () { let e = this.root; this.lights = e.lights, this.vertexShader = e.vertexShader, this.fragmentShader = e.fragmentShader, this.defines = e.defines, this.uniforms = e.uniforms, this.extensions = e.extensions, this.transparent = e.transparent, this.cacheKey = e.customProgramCacheKey() + "flat" + this.flatShading + this.side } onBeforeCompile (e, n) { this.root.onBeforeCompile(e) } get data () { return this.root.data } get category () { return this.root.category } get hasAO () { return this.root.hasAO } getFlavor (e, n, r) { return this.root.getFlavor(e, n, r) } get layers () { return this.root.layers } get fragment () { return this.root.fragment } getLayersOfType (e) { return this.root.getLayersOfType(e) } getLayerByUuid (e) { return this.root.getLayerByUuid(e) } updateByOp (e, n, r) { this.root.updateByOp(e, n, r) } nodeMaterialDispose () { this.root.nodeMaterialDispose() } }, Ro = class extends $r { constructor(e, n) { super(); this.data = e; this.layerIdGen = 0; this.flavors = []; this.masks = {}; this.type = "NodeMaterial"; this.updaters = [], this.reset0(e, n) } get nodeMaterial () { return this } getFlavor (e, n, r) { let s = r ? 6 : (e ? 3 : 0) + n; if (s === 0) return this; this.flavors === void 0 && (this.flavors = []), s -= 1; let o = this.flavors[s]; return o === void 0 && (o = new Xy(e, n, r, this), this.flavors[s] = o, o.flatShading = e, o.side = n, o.updateAfterBuild()), o } get fragment () { return this.lightLayer.node } get category () { return this.lightLayer.category } get hasAO () { return this.lightLayer.getNode("occlusion")?.value ?? !1 } reset (e, n) { this.data !== e && this.reset0(e, n) } reset0 (e, n) { this.data = e; let r = e.layers ?? Sn.defaultTwoLayerData("phong").layers; try { this.layers = r.map(s => Us.create(this.layerIdGen++, s.id, s.data, n.shared)) } catch { this.layers = [] } this.layers.reverse(), this.name = e.name ?? "Untitled Material", this.onUpdate(), this.transparent = ep(e, n.shared) } getLayersOfType (e) { return this.layers.filter(n => n.type === e) } getLayerByUuid (e) { return this.layers.find(n => n.uuid === e) } onUpdate () { this.cacheKey = this.computeCacheKey(), this.lightLayer = this.layers.find(e => e instanceof mi), this.lightLayer === void 0 && (this.lightLayer = new mi(0, "", { ...ar.defaultData("light", "phong"), visible: !1 }, new Wl, {})), this.dispose(); for (let e of this.flavors) e && e.dispose(); this.applyTextureMaps(), this.applyMasks(), this.blendColors(), this.blendAfterColors(), this.blendPositions() } applyTextureMaps () { let e = this.layers.find(o => o instanceof mi); if (!e) return; let n = e.data, r = n.bumpMap, s = n.roughnessMap; e.node.bumpMap = void 0, e.node.roughnessMap = void 0; for (let o = 0; o < this.layers.length; ++o) { let a = this.layers[o]; a instanceof $t && a.color instanceof Ua && (a.uuid === r && (e.node.bumpMap = a.color), a.uuid === s && (e.node.roughnessMap = a.color)) } } updateByOp (e, n, r) { if (n !== void 0 ? this.data = n : n = this.data, this.transparent = ep(n, r.shared), e.path[0] === "layers") { this.data = n; let s = r.shared, o = e.path[1]; if (o === void 0) { if (this.layers.reverse(), e.type === 4) { let a = Us.create(this.layerIdGen++, e.id, e.data, r.shared); this.layers.splice(e.localIndex, 0, a), r.scene.markNeedsUpdateRendererDirty() } else if (e.type === 5) this.layers.splice(e.localIndex, 1)[0].dispose(), r.scene.markNeedsUpdateRendererDirty(); else if (e.type === 6) { let a = this.layers.findIndex(u => u.uuid === e.id), l = this.layers[a]; this.layers.splice(a, 1), this.layers.splice(e.localIndex, 0, l), r.scene.markNeedsUpdateRendererDirty() } this.layers.reverse(), this.onUpdate() } else { e.type === 0 && e.props.occlusion !== void 0 && r.scene.markNeedsUpdateRendererDirty(); let a = this.layers.find(l => l.uuid === o); if (a) { let l = n.layers.data(o); if (a.updateByOp({ ...e, path: e.path.slice(2) }, l, r)) { let c = Us.create(this.layerIdGen++, o, l, s); this.layers.splice(this.layers.findIndex(h => h.uuid === o), 1, c), this.onUpdate() } } } } else this.reset(n, r) } applyMasks () { for (let e = 0; e < this.layers.length; ++e) { let n = this.layers[e]; n instanceof $t ? n.color.mask = void 0 : n instanceof mi && (n.node.mask = void 0) } for (let e = 0; e < this.layers.length; ++e) { let n = this.layers[e]; if (n instanceof $t && n.isMask.value && n.data.visible && e > 0) { let r = e - 1, s = this.layers[r]; s instanceof mi ? s.node.mask = new cr(n.color, n.alpha, cr.MUL) : s instanceof $t && (s.isMask.value || (s.color.mask = new cr(n.color, n.alpha, cr.MUL))) } } } blendColors () { let e = this.layers.findIndex(r => r instanceof $t), n = this.layers.findIndex(r => r instanceof mi); if (e !== -1 && e < n) { let r = this.layers[e].color; for (let s = e + 1; s < n; ++s) { let o = this.layers[s]; if (o instanceof $t) { if (o.isMask.value) continue; r = new Eh(r, o.color, o.alpha, o.mode) } } this.fragment.color = r } else this.fragment.color = void 0 } blendAfterColors () { let e = new Tt("outgoingLight", "f"), n = this.layers.findIndex(r => r instanceof mi); if (this.layers.length > n + 1) { for (let r = n + 1; r < this.layers.length; ++r) { let s = this.layers[r]; if (s instanceof $t) { if (s.isMask.value) continue; e = new Eh(e, s.color, s.alpha, s.mode) } } this.fragment.afterColor = e } else this.fragment.afterColor = void 0 } blendPositions () { let e = this.layers.filter(n => n instanceof $f); if (e.length > 0) { let n = e[0].position; for (let r = 1; r < e.length; ++r)e[r] && (n = new cr(n, e[r].position, cr.ADD), n = new cr(n, new Ee(.5).setReadonly(!0), cr.MUL)); this.fragment.position = n } else this.fragment.position = void 0 } getDefines () { return this.defines } getUniforms () { return this.uniforms } getVertexShader () { return this.vertexShader } getFragmentShader () { return this.fragmentShader } onBeforeCompile (e) { this.build(), e.defines = this.defines, e.uniforms = this.uniforms, e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, e.extensionDerivatives = this.extensions.derivatives === !0, e.extensionFragDepth = this.extensions.fragDepth === !0, e.extensionDrawBuffers = this.extensions.drawBuffers === !0, e.extensionShaderTextureLOD = this.extensions.shaderTextureLOD === !0 } clampUniformsForPreview (e, n) { let r = (s, o, a) => Math.min(Math.max(s, o), a); for (let s of this.layers) if (s.type === "displace") { let o = r(s.uniforms[`f${s.id}_intensity`].value, e, n); s.uniforms[`f${s.id}_intensity`].value = o } } computeCacheKey () { let e = "["; for (let { data: n } of this.data.layers) if (n.type === "light") e += `"${n.visible ? n.category.toUpperCase() : "Basic"}"`; else { let r = (mS[n.type] ?? []).map(u => n[u]), s = (gS[n.type] ?? []).map(u => n[u]?.length ?? 0), o = [...r, ...s], a = "isMask" in n && n.isMask, l = `"${n.type}-${n.visible}-${a}"`; o.length ? e += `[${l}, "${o.join('","')}"],` : e += l } return e = e.slice(0, -1) + "]", e } updateFrame (e) { for (let n = 0; n < this.updaters.length; ++n)e.updateNode(this.updaters[n]) } build () { let e = new Vy; e.needsJitter = this.needsJitter, this.lights = this.lightLayer.data.visible, e.build(this.fragment, this.fragment), this.vertexShader = e.getCode("vertex"), this.fragmentShader = e.getCode("fragment"), this.defines = e.defines, this.uniforms = e.uniforms, this.extensions = e.extensions, this.updaters = e.updaters; for (let n of this.flavors) n && n.updateAfterBuild(); return this } nodeMaterialDispose () { this.layers.forEach(e => e.dispose()), super.dispose(); for (let e of this.flavors) e && e.dispose() } assetsLoaded () { for (let e of this.layers) if (e instanceof $t) { let n = e.params.texture; if (n instanceof Vl && !n.image.loaded) return !1 } return !0 } getHash () { let e = "{"; return e += '"fragment":' + this.fragment.getHash(), e += "}", e } }; Object.defineProperties($r.prototype, { properties: { get: function () { return this.fragment.properties } } }); var ql = class extends Ro { }; var N2 = sc(O2()); var R2 = new Map; function L2 (i) { if (typeof i == "string") return i; let t = R2.get(i); return t || (t = { url: URL.createObjectURL(new Blob([i])) }, R2.set(i, t)), t.url } var Lo = class { constructor({ src: t, volume: e, delay: n, loop: r }) { this._volume = 1; this.delay = 0; this._loop = 1; this.loopsRemaining = 0; this._status = "stopped"; this.onEnd = () => { this.loopsRemaining === 1 / 0 ? this.replay() : this.loopsRemaining > 1 ? (this.replay(), this.loopsRemaining--) : (this._status = "stopped", this.loopsRemaining = this._loop) }; let s; typeof t == "string" ? s = { src: t } : s = { src: L2(t), format: "wav" }, this.sound = new N2.Howl(s), this.sound.on("end", this.onEnd), this.src = t, e !== void 0 && (this.volume = e), n !== void 0 && (this.delay = n), r !== void 0 && (this.loop = r) } get status () { return this._status } get volume () { return this._volume } set volume (t) { this._volume = t, this.sound.volume(t) } get loop () { return this._loop } set loop (t) { this._loop = t, this.loopsRemaining = t } replay () { this.clearDelay(), this.delayTimerId = window.setTimeout(() => { this.sound.play(), this.clearDelay() }, this.delay) } fade (t, e = 1e3) { t ? (this.sound.volume(this._volume), this.clearFade(), this.fadeTimerId = window.setTimeout(() => { this.sound.fade(this._volume, 0, e), this.clearFade() }, t)) : this.sound.fade(this._volume, 0, e) } on (t, e, n) { this.sound.on(t, e, n) } off (t, e, n) { this.sound.off(t, e, n) } play () { this._status === "playing" || this.sound.playing() || (this._status === "paused" ? (this.sound.seek() === 0 ? this.replay() : this.sound.play(), this._status = "playing") : this._status === "stopped" && (this.replay(), this._status = "playing")) } pause () { this._status === "playing" && (this.sound.pause(), this.clearFade(), this.clearDelay(), this._status = "paused") } stop () { this.sound.stop(), this.loopsRemaining = this._loop, this.clearFade(), this.clearDelay(), this._status = "stopped" } clearFade () { this.fadeTimerId && (clearTimeout(this.fadeTimerId), delete this.fadeTimerId) } clearDelay () { this.delayTimerId && (clearTimeout(this.delayTimerId), delete this.delayTimerId) } dispose (t = !1) { this.off(), this.stop(), this.clearFade(), this.clearDelay() } }; var Ky = class { constructor() { this.type = "ShapePath"; this.color = new Le; this.subPaths = []; this.currentPath = null } moveTo (t, e) { return this.currentPath = new ml, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e), this } lineTo (t, e) { return this.currentPath?.lineTo(t, e), this } quadraticCurveTo (t, e, n, r) { return this.currentPath?.quadraticCurveTo(t, e, n, r), this } bezierCurveTo (t, e, n, r, s, o) { return this.currentPath?.bezierCurveTo(t, e, n, r, s, o), this } splineThru (t) { return this.currentPath?.splineThru(t), this } toShapes () { let e = { ORIGIN: 0, DESTINATION: 1, BETWEEN: 2, LEFT: 3, RIGHT: 4, BEHIND: 5, BEYOND: 6 }, n = { loc: e.ORIGIN, t: 0 }; function r (m, g, y, v) { let x = m.x, b = g.x, S = y.x, _ = v.x, E = m.y, w = g.y, M = y.y, T = v.y, I = (_ - S) * (E - M) - (T - M) * (x - S), C = (b - x) * (E - M) - (w - E) * (x - S), P = (T - M) * (b - x) - (_ - S) * (w - E), D = I / P, L = C / P; if (P === 0 && I !== 0 || D <= 0 || D >= 1 || L < 0 || L > 1) return null; if (I === 0 && P === 0) { for (let H = 0; H < 2; H++)if (s(H === 0 ? y : v, m, g), n.loc === e.ORIGIN) { let U = H === 0 ? y : v; return { x: U.x, y: U.y, t: n.t } } else if (n.loc === e.BETWEEN) { let U = +(x + n.t * (b - x)).toPrecision(10), V = +(E + n.t * (w - E)).toPrecision(10); return { x: U, y: V, t: n.t } } return null } else { for (let V = 0; V < 2; V++)if (s(V === 0 ? y : v, m, g), n.loc === e.ORIGIN) { let G = V === 0 ? y : v; return { x: G.x, y: G.y, t: n.t } } let H = +(x + D * (b - x)).toPrecision(10), U = +(E + D * (w - E)).toPrecision(10); return { x: H, y: U, t: D } } } function s (m, g, y) { let v = y.x - g.x, x = y.y - g.y, b = m.x - g.x, S = m.y - g.y, _ = v * S - b * x; if (m.x === g.x && m.y === g.y) { n.loc = e.ORIGIN, n.t = 0; return } if (m.x === y.x && m.y === y.y) { n.loc = e.DESTINATION, n.t = 1; return } if (_ < -Number.EPSILON) { n.loc = e.LEFT; return } if (_ > Number.EPSILON) { n.loc = e.RIGHT; return } if (v * b < 0 || x * S < 0) { n.loc = e.BEHIND; return } if (Math.sqrt(v * v + x * x) < Math.sqrt(b * b + S * S)) { n.loc = e.BEYOND; return } let E; v !== 0 ? E = b / v : E = S / x, n.loc = e.BETWEEN, n.t = E } function o (m, g) { let y = [], v = []; for (let x = 1; x < m.length; x++) { let b = m[x - 1], S = m[x]; for (let _ = 1; _ < g.length; _++) { let E = g[_ - 1], w = g[_], M = r(b, S, E, w); M !== null && y.find(T => T.t <= M.t + Number.EPSILON && T.t >= M.t - Number.EPSILON) === void 0 && (y.push(M), v.push(new B(M.x, M.y))) } } return v } function a (m, g, y) { let v = new B; g.getCenter(v); let x = []; return y.forEach(b => { b.boundingBox.containsPoint(v) && o(m, b.points).forEach(_ => { x.push({ identifier: b.identifier, isCW: b.isCW, point: _ }) }) }), x.sort((b, S) => b.point.x - S.point.x), x } function l (m, g, y, v, x) { (x == null || x === "") && (x = "nonzero"); let b = new B; m.boundingBox.getCenter(b); let S = [new B(y, b.y), new B(v, b.y)], _ = a(S, m.boundingBox, g); _.sort((C, P) => C.point.x - P.point.x); let E = [], w = []; _.forEach(C => { C.identifier === m.identifier ? E.push(C) : w.push(C) }); let M = E[0].point.x, T = [], I = 0; for (; I < w.length && w[I].point.x < M;)T.length > 0 && T[T.length - 1] === w[I].identifier ? T.pop() : T.push(w[I].identifier), I++; if (T.push(m.identifier), x === "evenodd") { let C = T.length % 2 === 0, P = T[T.length - 2]; return { identifier: m.identifier, isHole: C, for: P } } else if (x === "nonzero") { let C = !0, P = null, D = null; for (let L = 0; L < T.length; L++) { let H = T[L]; g[H] && (C ? (D = g[H].isCW, C = !1, P = H) : D !== g[H].isCW && (D = g[H].isCW, C = !0)) } return { identifier: m.identifier, isHole: C, for: P } } else console.warn('fill-rule: "' + x + '" is currently not implemented.') } let u = 0, c = 999999999, h = -999999999, d = []; this.subPaths.forEach(m => { let g = m.getPoints(), y = -999999999, v = 999999999, x = -999999999, b = 999999999; for (let S = 0; S < g.length; S++) { let _ = g[S]; _.y > y && (y = _.y), _.y < v && (v = _.y), _.x > x && (x = _.x), _.x < b && (b = _.x) } h <= x && (h = x + 1), c >= b && (c = b - 1), g.length && d.push({ curves: m.curves, points: g, isCW: Bc.isClockWise(g), identifier: u++, boundingBox: new Om(new B(b, v), new B(x, y)) }) }); let f = d.map(m => l(m, d, c, h, this.userData?.style.fillRule)), p = []; return d.forEach(m => { let g = f[m.identifier]; if (g && !g.isHole) { let y = new yo; y.curves = m.curves, f.filter(x => x?.isHole && x.for === m.identifier).forEach(x => { if (x) { let b = d[x.identifier], S = new ml; S.curves = b.curves, y.holes.push(S) } }), p.push(y) } }), p } }; var F2, xS = new Promise(i => { F2 = i }), B2 = !1; var Zy; function k2 () { if (B2) return; if (Zy) return Zy; async function i () { let e = await import("./opentype.js"); F2(e), B2 = !0 } return Zy = i(), Zy } var tp = class { async load (t, e, n = () => { }) { let { load: r } = await xS; r(t, (s, o) => { s || !o ? n(s ?? "Something went wrong") : e(o) }) } async parse (t) { let { parse: e, Bidi: n } = await xS; try { let r = e(t), s = new n, o = a => r.charToGlyphIndex(a.char); return s.registerModifier("glyphIndex", null, o), s.applyFeatures(r, r.defaultRenderOptions.features), { font: r, bidi: s } } catch (r) { console.error(r) } } }; async function s6 (i) { return await (await fetch(i)).arrayBuffer() } var o6 = new tp; async function bS (i) { let t, e, n = !1; if (i.url ? (t = await s6(i.url), e = i.url, n = i.url.startsWith("/")) : i.data && (t = i.data.buffer.slice(i.data.byteOffset, i.data.byteOffset + i.data.byteLength)), t) { let r = await o6.parse(t); if (r) return { font: r.font, url: e, intercepted: n, arr: t, bidi: r.bidi } } } function a6 (i, t) { return t.state.glyphIndex === i || t.state.fina === i || t.state.medi === i || t.state.init === i } var Jy = class {
	constructor(t) { this._arrayBuffer = new ArrayBuffer(1); this._isLoaded = !1; this._intercepted = !1; this._isUserFont = t.isUserFont ?? !1, this._loadingPromise = bS(t).then(e => { e && (this._arrayBuffer = e.arr, this._url = e.url, this.font = e.font, this._intercepted = e.intercepted, this._isLoaded = !0, this._bidi = e.bidi) }) } update (t) { this._isLoaded = !1, this._isUserFont = t.isUserFont ?? !1, this._loadingPromise = bS(t).then(e => { e && (this._arrayBuffer = e.arr, this._url = e.url, this.font = e.font, this._intercepted = e.intercepted, this._isLoaded = !0, this._bidi = e.bidi) }) } get url () { return this._url } get intercepted () { return this._intercepted } get isLoaded () { return this._isLoaded } get loadingPromise () { return this._loadingPromise } reverseLigaturesTable (t, e, n) { if (!this._bidi) return []; let r = this._bidi; r.getTextGlyphs(e); let s = r.tokenizer.tokens, o = [], a = 0, l = n.length === s.length; for (let u = 0; u < n.length; u++) { let c = n[u].index, h = String.fromCharCode(n[u].unicode), d = s[a]; if (a6(c, d) || l) o.push({ char: h, index: c, replacements: [d.state.glyphIndex], replacementChars: [d.char] }), a++; else { let f = d.char, p = "", m = [d.state.glyphIndex], g = [], y = !1; for (; !y;)a++, p = e.charAt(a), f += p, m.push(t.charToGlyphIndex(p)), g = t.stringToGlyphs(f), g.length === 1 && g[0].index === c && (y = !0), a > e.length && (y = !0); o.push({ char: h, index: c, replacements: m, replacementChars: Array.from(f) }), a++ } } return o } generateShapes (t, e) {
		if (!this._isLoaded) return; let n = this.font, r = e.fontSize / this.unitsPerEm, s = e.fontSize * e.lineHeight, o = t.map(v => this.getTextWidth(v, e)), a = e.width, l = this.getCharWidth(`
`, e), u = e.horizontalAlign === 1 ? l : 0, c = this.computeSpaceWidthForLine(t, 0, e), h = this.getLineInitialOffsetX(o[0], a, e.horizontalAlign, t[0], l), d = this.getLineInitialOffsetY(s, t.length, e.height, r, e.verticalAlign), f = [], p = t.map(v => []), m = t.map(v => []), g; for (let v = 0; v < t.length; v++) {
			let x = t[v], b = { features: { liga: !0 } }, S = []; try { S = n.stringToGlyphs(x, b) } catch (E) { console.warn(E) } h = this.getLineInitialOffsetX(o[v], a, e.horizontalAlign, x, l); let _ = []; try { _ = this.reverseLigaturesTable(n, x, S) } catch (E) { console.warn(E) } c = this.computeSpaceWidthForLine(t, v, e); for (let E = 0; E < S.length; E++) {
				let w = S[E], M = w.index === 0 ? `
`: w.unicode ? String.fromCharCode(w.unicode) : void 0, T = _[E], I = 0, C = 0; E === 0 && e.horizontalAlign === 2 && w.leftSideBearing !== void 0 && (C = -w.leftSideBearing * r), g && (I = n.getKerningValue(w, g) * r), h += C + I; let P = 0; if (M === `
`) P = u; else if (M === " ") P = c; else { let D = this.createPath(w, r, h, d, e); D && (P = D.offsetX - (I + C), f.push(D.path)) } if (T.replacements.length === 1) m[v].push([h, d]), p[v].push(P); else { let D = T.replacements.map(V => (n.glyphs.get(V).advanceWidth ?? 0) * r), L = D.reduce((V, G) => V += G, 0), H = D.map(V => V / L), U = h; for (let V = 0; V < H.length; V++) { let G = P * H[V]; m[v].push([U, d]), p[v].push(G), U += G } } h += P, g = w
			} d -= s
		} let y = []; for (let v = 0, x = f.length; v < x; v++)y.push(...f[v].toShapes()); return { shapes: y, charWidths: p, lineWidths: o, charCoords: m }
	} get isUserFont () { return this._isUserFont } get arrayBuffer () { return this._arrayBuffer } get ascender () { return this.font?.ascender ?? 0 } get descender () { return this.font?.descender ?? 0 } get familyName () { return this.font?.names.fontFamily ?? "" } get subfamilyName () { return this.font?.names.fontSubfamily ?? "" } get unitsPerEm () { return this.font?.unitsPerEm ?? 1 } getLineInitialOffsetX (t, e, n, r, s) {
		return (n === 3 || n === 2) && r.indexOf(`
`) >= 0 && (t -= s), n === 3 ? e * .5 - t * .5 : n === 2 ? e - t : 0
	} getLineInitialOffsetY (t, e, n, r, s) { let o = e * t, a = Math.abs(this.ascender - this.descender) * r, l = t - a, u = -this.ascender * r - l / 2; return s === 3 ? -(n - o - u) : s === 2 ? -(n * .5 - o * .5 - u) : u } createPath (t, e, n, r, s) { let o = t.getPath(n, -r, s.fontSize, { kerning: !1, letterSpacing: s.letterSpacing }); if (!o) { console.error('THREE.Font: character "' + t + '" does not exists in font family ' + this.familyName + "."); return } let a = new Ky, l = (t.advanceWidth ?? 1) * e; if (t) for (let u of o.commands) { let c = a.currentPath?.currentPoint; if (!(c && u.type !== "Z" && c.x === u.x && -c.y === u.y)) switch (u.type) { case "M": a.moveTo(u.x, -u.y); break; case "L": a.lineTo(u.x, -u.y); break; case "Q": a.quadraticCurveTo(u.x1, -u.y1, u.x, -u.y); break; case "C": a.bezierCurveTo(u.x1, -u.y1, u.x2, -u.y2, u.x, -u.y); break } } return a.subPaths.forEach(u => { let c = l6(u.curves); c !== void 0 && u.currentPoint.distanceTo(c) > 0 && u.lineTo(c.x, c.y) }), { offsetX: l + s.fontSize * s.letterSpacing, path: a } } getCharWidth (t, e) { return this.font?.getAdvanceWidth(t, e.fontSize, { kerning: !0, letterSpacing: e.letterSpacing }) ?? 0 } getTextWidth (t, e) { return this.font?.getAdvanceWidth(t, e.fontSize, { kerning: !0, letterSpacing: e.letterSpacing }) ?? 0 } computeSpaceWidthForLine (t, e, n) { let r = this.getCharWidth(" ", n), s = t[e]; if (s) { let o = this.countSpaces(s.trimEnd()); if (n.horizontalAlign === 4 && e < t.length - 1 && o) { let a = n.width, l = this.getTextWidth(s, n); return (a - (l - o * r)) / o } } return r } countSpaces (t) { return (t.match(/ /g) || []).length }
}; function l6 (i) { if (i.length) { let t = i[0]; if (t instanceof Cr) return t.v1; if (t instanceof Tr || t instanceof ci) return t.v0 } } var wS = class { constructor() { this.objects = new Map; this.unreachable = new Set } getCached (t) { return this.objects.get(t) } get size () { return this.objects.size } get (t, e) { let n = this.objects.get(t); return n === void 0 ? (n = this.createObject(t, e), this.objects.set(t, n)) : n.isShared = !0, n } mutateIfUnique (t, e) { let n = this.objects.get(t); if (n && n.isShared !== !0) return this.objects.delete(t), this.objects.set(e, n), n } startGc () { this.unreachable = new Set(this.objects.keys()) } markAsReachable (t, e) { let n = this.objects.get(t); e === n ? this.unreachable.delete(t) : !1 && console.warn("Reachable but deleted", t) } endGc () { this.unreachable.forEach(t => { this.disposeObject(this.objects.get(t)), this.objects.delete(t) }), this.unreachable.clear() } dispose () { this.objects.forEach(t => { this.disposeObject(t) }), this.objects.clear() } }, np = class extends wS { constructor(e) { super(); this.flatShading = e } disposeObject (e) { e.dispose() } createObject (e, n) { let r = kl(e, n, this.flatShading); return r.computeBoundingSphere(), r } }; var U2 = { markNeedsUpdateRendererDirty: () => { } }; var SS = class extends Yy { constructor(e) { super(); this.shared = e } create (e) { return new Uh(e, this.shared) } }, Yl = class { constructor(t, e = {}) { this.geometryCache = new np(!0); this.geometryCache2 = new np(!1); this.imageHolderCache = new SS(this); this.thisContext = { scene: U2, shared: this }; this.deletedMaterial = new ql(Sn.defaultTwoLayerData("phong"), this.thisContext); this.deletedImage = new Di(zu.emptyImage, this); this.deletedVideo = new Di(Ru.defaultVideo, this); this.materials = {}; this.images = {}; this.videos = {}; this.colors = {}; this.audios = {}; this.fonts = {}; this.requestRender = () => { this._requestRender && this._requestRender() }; if (e.images) for (let [n, r] of Object.entries(e.images)) this.addImage(n, r); if (e.videos) for (let [n, r] of Object.entries(e.videos)) this.addVideo(n, r); if (e.audios) for (let [n, r] of Object.entries(e.audios)) this.addAudio(n, r.data); this.reset(t) } setRequestRender (t) { this._requestRender = t } reset (t) { for (let [e, n] of Object.entries(t.images)) this.addImage(e, n); for (let [e, n] of Object.entries(t.videos)) this.addVideo(e, n); for (let [e, n] of Object.entries(t.colors)) this.addColor(e, n); for (let [e, n] of Object.entries(t.materials)) this.addMaterial(e, new ql(n, this.thisContext)); for (let [e, n] of Object.entries(t.audios)) this.addAudio(e, n.data); for (let [e, n] of Object.entries(t.fonts)) this.addFont(e, n) } addMaterial (t, e) { e.uuid = t, this.materials[t] ? (this.materials[t].reset(e.data, this.thisContext), e.dispose()) : this.materials[t] = e } deleteMaterial (t) { this.materials[t] && (this.materials[t].nodeMaterialDispose(), delete this.materials[t]) } getMaterial (t) { let e = this.materials[t]; return e } getMaterialOrDeletedPlaceholder (t) { return this.materials[t] ?? this.deletedMaterial } material (t) { return typeof t == "string" ? this.getMaterialOrDeletedPlaceholder(t) : t == null ? (console.error("material is undefined or null"), this.deletedMaterial) : new Ro(t, this.thisContext) } getMaterials () { return this.materials } addImage (t, e) { return this.images[t] ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(), this.images[t].updateSrc(e.data), !0) : (this.images[t] = new Di(e, this), !1) } deleteImage (t) { let e = this.images[t]; e && (e.dispose(), delete this.images[t]) } getDefaultImage () { return this.images.image_0 } getImage (t) { return this.images[t] ?? this.deletedImage } image (t) { return typeof t == "string" ? this.getImage(t) : this.imageHolderCache.load(t) } addVideo (t, e) { return this.videos[t] ? (this.videos[t].updateSrc(e.data), !0) : (this.videos[t] = new Di(e, this), !1) } deleteVideo (t) { let e = this.videos[t]; e && (e.dispose(), delete this.videos[t]) } getVideo (t) { return this.videos[t] ?? this.deletedVideo } video (t) { return typeof t == "string" ? this.getVideo(t) : this.imageHolderCache.load(t) } addColor (t, e) { return this.colors[t] ? (this.onColorOrImageUpdate && this.onColorOrImageUpdate(), "a" in e ? this.colors[t].setRGBA(e.r, e.g, e.b, e.a) : this.colors[t].setRGBA(e.r, e.g, e.b, 1), !0) : ("a" in e ? this.colors[t] = new za(e.r, e.g, e.b, e.a) : this.colors[t] = new za(e.r, e.g, e.b, 1), !1) } updateColor (t, e) { if (this.colors[t]) { this.onColorOrImageUpdate && this.onColorOrImageUpdate(); let n = this.colors[t]; return this.colors[t].r = e.r ?? n.r, this.colors[t].g = e.g ?? n.g, this.colors[t].b = e.b ?? n.b, this.colors[t].a = e.a ?? n.a, !0 } return !1 } deleteColor (t) { this.colors[t] && delete this.colors[t] } getColor (t) { return this.colors[t] } color (t) { let e; if (typeof t == "string") { let n = this.getColor(t); n ? e = n : (console.warn("Tried to create color layer params with a color key that does not exist in the assets manager"), e = new on(0, 0, 0, 0)) } else return "a" in t ? new on(t.r, t.g, t.b, t.a) : new on(t.r, t.g, t.b, 1); return e } addAudio (t, e) { this.audios[t] = e } getAudio (t) { let e = this.audios[t]; if (e instanceof Lo) return e; { let n = new Lo({ src: e }); return this.audios[t] = n, n } } deleteAudio (t) { let e = this.audios[t]; e && (e instanceof Lo && e.dispose(), delete this.audios[t]) } addFont (t, e) { this.fonts[t] = new Jy(e), this.fonts[t].loadingPromise.then(() => this.requestRender()) } getFont (t) { return this.fonts[t] } deleteFont (t) { this.fonts[t] && delete this.fonts[t] } dispose () { Object.keys(this.materials).forEach(e => this.deleteMaterial(e)), this._requestRender = void 0, Object.values(this.audios).forEach(e => { e instanceof Lo && e.dispose() }), this.audios = {}, this.geometryCache.dispose(), this.geometryCache2.dispose() } }, Cbe = new Yl(ry.emptyData()); var Ri = class extends Ht { updateByPatchedOp (e, n, r) { if (super.updateByPatchedOp(e, n, r), HT(e.path, ["materials"]) !== null && e.type === 0 && Array.isArray(this.material)) for (let [s, o] of Object.entries(e.props)) { let a = r.shared.material(o); this.material[Number(s)] = a } else if (Pr(e.path, ["material"]) && this.material instanceof $r) "material" in n && typeof n.material != "string" && this.material.updateByOp(xr.drop(e, 1), n.material, r); else if (Pr(e.path, ["materials", "*"]) && Array.isArray(this.material)) { let s = e.path[1]; if ("materials" in n && s < this.material.length) { let o = n.materials[s]; typeof o != "string" && this.material[s].updateByOp(xr.drop(e, 2), o, r) } } } get needsAO () { return this.material !== void 0 ? (Array.isArray(this.material) ? this.material[0] : this.material).hasAO : !1 } updateState (e, n) { super.updateState(e, n), e.castShadow !== void 0 && (this.castShadow = e.castShadow), e.receiveShadow !== void 0 && (this.receiveShadow = e.receiveShadow); let r = this.dataPatched; if (e.geometry?.type !== "NonParametricGeometry" && "material" in e && e.material !== void 0 && (this.disposeMaterial(), this.material = n.shared.material(e.material).getFlavor(r.flatShading, r.side, r.wireframe), n.scene.markNeedsUpdateRendererDirty()), e.geometry?.type === "NonParametricGeometry" && ("materials" in e && e.materials !== void 0 ? (this.disposeMaterial(), this.material = e.materials.map(s => n.shared.material(s).getFlavor(r.flatShading, r.side, r.wireframe)), n.scene.markNeedsUpdateRendererDirty()) : "material" in e && e.material !== void 0 && (this.disposeMaterial(), this.material = [n.shared.material(e.material).getFlavor(r.flatShading, r.side, r.wireframe)], n.scene.markNeedsUpdateRendererDirty())), e.flatShading !== void 0 || e.wireframe !== void 0 || e.side !== void 0) if (Array.isArray(this.material)) for (let s = 0; s < this.material.length; s++)this.material[s] = this.material[s].getFlavor(r.flatShading, r.side, r.wireframe); else this.material = this.material.getFlavor(r.flatShading, r.side, r.wireframe) } disposeMaterial () { this.material && pg(this.material).forEach(e => { e instanceof $r && (e instanceof ql || e.nodeMaterialDispose()) }) } dispose () { this.disposeMaterial(), super.dispose() } }; var z2 = new A, G2 = new qe, V2 = new qe, c6 = new A, H2 = new se, jt = class extends Ri { constructor(e, n, r) { super(e, n); this.data = n; this.localGeometry = void 0, n.bindMode && n.bindMatrix && (this.isSkinnedMesh = !0, this.bindMode = n.bindMode, this.bindMatrix = new se().fromArray(n.bindMatrix), this.bindMatrixInverse = new se) } chooseGeoemtryCache (e) { return e.geometryCache } markGeometryAsReachable (e) { this.geometryCreateDeleyed instanceof Ce && this.chooseGeoemtryCache(e).markAsReachable(this.dataPatched.geometry, this.geometryCreateDeleyed) } get geometry () { if (this.localGeometry !== void 0) return this.localGeometry; if (this.geometryCreateDeleyed instanceof Yl) { let e = this.geometryCreateDeleyed, n = this.chooseGeoemtryCache(e); this.geometryCreateDeleyed = n.get(this.dataPatched.geometry, e) } return this.geometryCreateDeleyed } set geometry (e) { this.localGeometry = e } get is2DAndNoDepth () { let e = this.dataPatched.geometry; return Sf.is2DParametricMesh(e.type) && e.depth === 0 } get is2DType () { return Sf.is2DParametricMesh(this.geometry.userData.type) } get isNonParametric () { return this.geometry.userData.type === "NonParametricGeometry" } updateByPatchedOp (e, n, r) { super.updateByPatchedOp(e, n, r), Pr(e.path, ["geometry"]) && this.updateByPatchedOpGeometry(xr.drop(e, 1), n.geometry, r) } removeInteractionGeometry () { this.localGeometry?.dispose(), this.localGeometry = void 0 } updateGeometryInteractions (e, n) { this.invalidateDownstreamBooleanData(); let r = this.data.geometry.type; if (r === "NonParametricGeometry" || r === "SubdivGeometry") { let s = e; if (this.localGeometry === void 0) { let c = { ...this.data.geometry, ...s }; this.localGeometry = kl(c, n, this.data.flatShading) } let o, a, l; s.scaleBaked ? [o, a, l] = s.scaleBaked : { width: o, height: a, depth: l } = s; let u = this.localGeometry.userData; u.sxPrev !== void 0 && Vf(this.localGeometry.attributes, o / u.sxPrev, a / u.syPrev, l / u.szPrev), u.sxPrev = o, u.syPrev = a, u.szPrev = l } else { let s = { ...this.data.geometry, ...e }; this.localGeometry?.dispose(), this.localGeometry = kl(s, n, this.data.flatShading) } } refreshAttachedCloners (e) { for (let n of this.attachedSurfaceCloners) e.scene.addPendingUpdateCloner(n.object) } refreshAttachedPaths (e) { for (let n of this.attachedPaths) e.scene.addPendingCommand(() => n.updateShape()) } createGeometryDelayed (e) { this.geometryCreateDeleyed = e.shared, this.refreshAttachedCloners(e), this.refreshAttachedPaths(e) } updateByPatchedOpGeometry (e, n, r) { let s = !1; e.type === 0 && e.path.length === 0 && El(["scaleBaked"], Object.keys(e.props)) && this.geometryCreateDeleyed instanceof An && this.chooseGeoemtryCache(r.shared).mutateIfUnique(this.geometryCreateDeleyed.data, n) === this.geometryCreateDeleyed && (s = !0, this.geometryCreateDeleyed.mutateDirectlyScaleBaked(n, e.props.scaleBaked), this.refreshAttachedCloners(r), this.refreshAttachedPaths(r)), s || (r.scene?.markGeometryCacheDirty(), this.createGeometryDelayed(r)), this.resetBBoxNeedsUpdate(), this.invalidateDownstreamBooleanData() } updateGeometryOnStateUpdate (e, n) { this.createGeometryDelayed(n) } updateState (e, n) { e.geometry !== void 0 && this.updateGeometryOnStateUpdate(e.geometry, n), super.updateState(e, n) } updateGeometryGroupsIfNeeded () { Array.isArray(this.material) && this.geometry.groups.length === 0 && this.geometry.addGroup(0, Math.max(this.geometry.getIndex()?.count ?? 0, this.geometry.getAttribute("position").count), 0) } updateEntityBoxSize (e, n) { let r = this.geometry.userData.parameters; this.is2DType ? e.set(0, 0, r.depth * .5) : this.isNonParametric ? (e.setScalar(0), this.geometry.boundingSphere && e.copy(this.geometry.boundingSphere.center), n.set(r.width, r.height, r.depth ?? 0).multiplyScalar(.5)) : e.setScalar(0), n.set(r.width, r.height, r.depth ?? 0).multiplyScalar(.5) } updateMatrixWorld (e) { super.updateMatrixWorld(e), this.bindMode === "attached" ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === "detached" && this.bindMatrixInverse.copy(this.bindMatrix).invert() } bind (e, n) { this.skeleton = e, n === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), n = this.matrixWorld), this.bindMatrix.copy(n), this.bindMatrixInverse.copy(n).invert() } pose () { this.skeleton.pose() } normalizeSkinWeights (e) { let n = new qe, r = this.geometry.attributes.skinWeight; for (let s = 0, o = r.count; s < o; s++) { n.fromBufferAttribute(r, s); let a = 1 / n.manhattanLength(); a !== 1 / 0 ? n.multiplyScalar(a) : n.set(1, 0, 0, 0), r.setXYZW(s, n.x, n.y, n.z, n.w) } } boneTransform (e, n) { let r = this.skeleton; if (r === void 0) return; let s = this.geometry; G2.fromBufferAttribute(s.attributes.skinIndex, e), V2.fromBufferAttribute(s.attributes.skinWeight, e), z2.copy(n).applyMatrix4(this.bindMatrix), n.set(0, 0, 0); for (let o = 0; o < 4; o++) { let a = V2.getComponent(o); if (a !== 0) { let l = G2.getComponent(o); H2.multiplyMatrices(r.bones[l].matrixWorld, r.boneInverses[l]), n.addScaledVector(c6.copy(z2).applyMatrix4(H2), a) } } return n.applyMatrix4(this.bindMatrixInverse) } }; function u6 (i) { if (i.geometry.attributes.extrudeNormal || !i.geometry.attributes.position || !i.geometry.attributes.normal) return; let t = new Map, e = i.geometry.attributes, n = e.position.array, r = e.normal.array, s = new Float32Array(n.length); for (let o = 0; o < n.length; o += 3) { let a = `${n[o]}_${n[o + 1]}_${n[o + 2]}`, l = new A(r[o], r[o + 1], r[o + 2]); t.has(a) ? t.get(a)?.normals.push(l) : t.set(a, { normals: [l], result: new A }) } t.forEach((o, a) => { for (let l of o.normals) o.result.add(l); o.result.divideScalar(o.normals.length) }); for (let o = 0; o < n.length; o += 3) { let a = `${n[o]}_${n[o + 1]}_${n[o + 2]}`, l = t.get(a)?.result; l && (s[o] = l.x, s[o + 1] = l.y, s[o + 2] = l.z) } i.geometry.setAttribute("extrudeNormal", new _e(s, 3)) } function h6 (i) { if (i.geometry.attributes.extrudeNormals || !i.geometry.attributes.position) return; let e = i.geometry.attributes.position.array, n = new Float32Array(e.length), r = new A; for (let s = 0; s < e.length; s += 3)r.set(e[s], e[s + 1], e[s + 2]).normalize(), n[s] = r.x, n[s + 1] = r.y, n[s + 2] = r.z; i.geometry.setAttribute("extrudeNormal", new _e(n, 3)) } function zh (i) { if (Array.isArray(i.material)) { for (let t of i.material) if (t.getLayersOfType("outline").length === 0) return } else if (!(i.material instanceof $r) || i.material.getLayersOfType("outline").length === 0) return; i instanceof jt && i.is2DAndNoDepth ? h6(i) : u6(i) } function Gh (i) { if (!i.geometry.attributes.position) return; let e = i.geometry.attributes.position.array, n = new Float32Array(e.length), r = parseInt(i.uuid.replace(/\D/g, "")), s = [Ge.seededRandom(r), Ge.seededRandom(r + 1e4), Ge.seededRandom(r + 2e4)]; for (let o = 0; o < e.length; o++)n[o] = s[o % 3]; i.geometry.setAttribute("randomColor", new ze(n, 3)) } var d6; gh.then(i => { d6 = i }); var zs = new _t, rp = new A; function j2 (i) { let t = !1; return i.scene.objects.traverse((e, n) => { n.type === "Mesh" && n.geometry.type === "SubdivGeometry" && (t = !0) }), t } var as = class extends jt { constructor(e, n, r) { super(e, n, r); this.data = n; this.hiddenMatrixOld = new se; this.smoothShading = !0; this.skipReactionUpdate = !1 } chooseGeoemtryCache (e) { return this.dataPatched.flatShading ? e.geometryCache : e.geometryCache2 } get subdivPointerNew () { return this.localGeometry !== void 0 ? this.subdivPointer : this.geometry.ensureSubdivPointer() } get originalGeometryNew () { return this.localGeometry !== void 0 ? this.originalGeometry : this.geometry.originalGeometry } get phongAngle () { return this.data.geometry.phongAngle ?? 45 } updateEntityBoxSize (e, n) { let r = this.geometry.userData.parameters; e.copy(this.originalGeometryNew.boundingSphere.center), n.set(r.width, r.height, r.depth ?? 0).multiplyScalar(.5) } createGeometryByControls (e) { if (this.skipReactionUpdate === !0) return; let n = this.localGeometry?.uuid, { originalGeometry: r, subdividedGeometry: s, subdivPointer: o } = An.build(e, this.subdivPointer, this.smoothShading, this.hasNonUniformScale ? this.shearScale : void 0); this.subdivPointer = o, r !== void 0 && (this.originalGeometry?.dispose(), this.originalGeometry = r), s !== void 0 && (this.subdividedGeometry?.dispose(), this.subdividedGeometry = s ?? void 0), this.localGeometry = this.subdividedGeometry ?? this.originalGeometry, zh(this), Gh(this), this.calcBoundingBox(), n && (this.localGeometry.uuid = n) } updateState (e, n) { if (super.updateState(e, n), e.flatShading !== void 0) { let r = this.material; this.material = r.getFlavor(!1, r.side, r.wireframe), this.smoothShading = !e.flatShading, this.createGeometryDelayed(n) } } updateMesh (e = !1) { An.buildLevel(this.subdivPointer, !0, this.smoothShading ? this.phongAngle : -1, this.originalGeometry, e && this.hasNonUniformScale ? this.shearScaleInv : void 0), this.subdividedGeometry && An.buildLevel(this.subdivPointer, !1, this.smoothShading ? this.phongAngle : -1, this.subdividedGeometry, e && this.hasNonUniformScale ? this.shearScaleInv : void 0) } updateTopology () { this.originalGeometry.dispose(), this.originalGeometry = An.buildLevel(this.subdivPointer, !0, this.smoothShading ? this.phongAngle : -1), this.subdividedGeometry && (this.subdividedGeometry.dispose(), this.subdividedGeometry = An.buildLevel(this.subdivPointer, !1, this.smoothShading ? this.phongAngle : -1)), this.localGeometry = this.subdividedGeometry ?? this.originalGeometry } raycast (e, n) { let r = this.localGeometry; this.localGeometry = this.originalGeometryNew, Ht.prototype.raycast.call(this, e, n), this.localGeometry = r } activateSVDCompensation () { !this.hasNonUniformScale || (this.matrix.copy(this.matrixWorldRigid), this.hiddenMatrixOld.copy(this.hiddenMatrix), this.hiddenMatrix.copy(this.parent.matrixWorld).invert()) } deactivateSVDCompensation () { !this.hasNonUniformScale || (this.updateMatrix(), this.hasNonUniformScale = void 0, this.hiddenMatrix.copy(this.hiddenMatrixOld)) } calcBoundingBox () { let e = this.originalGeometry; e.boundingSphere === null && (e.boundingSphere = new dn, this.subdividedGeometry && (this.subdividedGeometry.boundingSphere = e.boundingSphere)); let n = e.attributes.position, r = e.boundingSphere.center; zs.setFromBufferAttribute(n), zs.getCenter(r), e.boundingSphere.radius = r.distanceTo(zs.max), isNaN(e.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this), zs.getSize(rp), this.hasNonUniformScale && rp.divide(this.scale); let s = { width: rp.x, height: rp.y, depth: rp.z }; return this.geometry.userData.parameters = s, s } updateBoundingSphere (e) { let n = this.originalGeometry; zs.min.set(e[0], e[2], e[4]), zs.max.set(e[1], e[3], e[5]), this.hasNonUniformScale && (zs.min.applyMatrix4(this.shearScaleInv), zs.max.applyMatrix4(this.shearScaleInv)), n.boundingSphere === null && (n.boundingSphere = new dn); let r = n.boundingSphere.center; zs.getCenter(r), n.boundingSphere.radius = r.distanceTo(zs.max) } freeSubdivPointer () { this.subdivPointer && (An.freeSubdivPointer(this.subdivPointer), this.subdivPointer = 0), this.localGeometry = void 0, this.originalGeometry?.dispose(), this.subdividedGeometry?.dispose() } dispose () { super.dispose(), this.freeSubdivPointer() } updateByPatchedOpGeometry (e, n, r) { super.updateByPatchedOpGeometry(e, n, r), this.localGeometry && this.createGeometryByControls(n) } }; var W2 = -1, f6 = 1, q2 = { x: [1, 0, 0], "-x": [-1, 0, 0], y: [0, 1, 0], "-y": [0, -1, 0], z: [0, 0, 1], "-z": [0, 0, -1] }, Y2 = { polygon_center: 0, edge: 1, vertex: 2 }, ip = (i, t) => (e, n) => !t || e === 0 || i === 0 ? 0 : i * n / 100, st = (i, t) => { let e = Math.abs(t), n = e * -1; return (i - W2) * (e - n) / (f6 - W2) + n }; function X2 (i) { let t = [], e = {}; for (var n = 0, r = i.length; n < r; n++) { var s = JSON.stringify(i[n].pos.map(o => Math.round(o * 1e4) / 1e4)); e[s] || (t.push(i[n]), e[s] = !0) } return t } var p6 = new A, $y = new A, m6 = new A, g6 = new A; function Vh (i, t) { let e = m6.fromArray(i), n = g6.fromArray(t); $y.copy(n).sub(e); let r = $y.length(); return $y.normalize().multiplyScalar(r * .5), p6.copy(e).add($y).toArray() } var Li = new nn, ev = new A, tv = new A, Xl = new A; function Q2 (i) { let t = []; for (let e = 0; e <= i.index.count; e++)if (ev.fromArray(i.index.array, e * 3), Li.setFromAttributeAndIndices(i.attributes.position, ev.x, ev.y, ev.z), Li.getNormal(tv), Li.getMidpoint(Xl), !(isNaN(Xl.x) || isNaN(Xl.y) || isNaN(Xl.z))) { let { a: n, b: r, c: s } = Li, o = n.toArray(), a = r.toArray(), l = s.toArray(), u = n.distanceTo(r), c = r.distanceTo(s), h = s.distanceTo(n), d = Vh(o, a), f = Vh(a, l), p = Vh(l, o), m = [u, c, h], g = Math.max(...m), y = m.filter(b => Math.round(b) === Math.round(g)).length > 1, v = [], x = Li.getMidpoint(Xl).toArray(); g === u && !y && (v = [f, p, p], x = d), g === c && !y && (v = [d, p, p], x = f), g === h && !y && (v = [d, f, f], x = p), y && (v = [d, f, p]), t.push({ vertices: [o, a, l], faceCenters: v, midpoint: x, norm: Li.getNormal(tv).toArray() }) } return t } function K2 (i) { let t = [], { position: e } = i.attributes; for (let n = 0; n < e.count; n++) { Li.setFromAttributeAndIndices(e, n * 3, n * 3 + 1, n * 3 + 2), Li.getNormal(tv), Li.getMidpoint(Xl); let r = Li.a.toArray(), s = Li.b.toArray(), o = Li.c.toArray(); t.push({ vertices: [r, s, o], faceCenters: [Vh(r, s), Vh(s, o), Vh(o, r)], midpoint: Xl.toArray(), norm: tv.toArray() }) } return t } var y6 = 4, v6 = .5, AS = i => .5 * (1 - Math.cos(i * Math.PI)), _S = class { constructor() { this.perlin = new Array(4095 + 1) } noise (t, e = 0, n = 0) { if (this.perlin == null) { this.perlin = new Array(4095 + 1); for (let y = 0; y < 4095 + 1; y++)this.perlin[y] = Math.random() } t < 0 && (t = -t), e < 0 && (e = -e), n < 0 && (n = -n); let r = Math.floor(t), s = Math.floor(e), o = Math.floor(n), a = t - r, l = e - s, u = n - o, c, h, d = 0, f = .5, p, m, g; for (let y = 0; y < y6; y++) { let v = r + (s << 4) + (o << 8); c = AS(a), h = AS(l), p = this.perlin[v & 4095], p += c * (this.perlin[v + 1 & 4095] - p), m = this.perlin[v + 16 & 4095], m += c * (this.perlin[v + 16 + 1 & 4095] - m), p += h * (m - p), v += 256, m = this.perlin[v & 4095], m += c * (this.perlin[v + 1 & 4095] - m), g = this.perlin[v + 16 & 4095], g += c * (this.perlin[v + 16 + 1 & 4095] - g), m += h * (g - m), p += AS(u) * (m - p), d += p * f, f *= v6, r <<= 1, a *= 2, s <<= 1, l *= 2, o <<= 1, u *= 2, a >= 1 && (r++, a--), l >= 1 && (s++, l--), u >= 1 && (o++, u--) } return d } noiseSeed (t) { let e = (() => { let o, a; return { setSeed (l) { a = o = (l ?? Math.random() * 4294967296) >>> 0 }, getSeed () { return o }, rand () { return a = (1664525 * a + 1013904223) % 4294967296, a / 4294967296 } } })(); e.setSeed(t), this.perlin = new Array(4095 + 1); for (let n = 0; n < 4095 + 1; n++)this.perlin[n] = e.rand() } }, Z2 = _S; var J2 = new A, $2 = new se, eI = new Wi; function ES (i) { let t = !1; return i.scene.objects.traverse((e, n) => { n.type === "Mesh" && n.geometry.type === "TextGeometry" && (t = !0) }), t } var Hh = class extends jt { constructor(e, n, r) { super(e, n, r); this.data = n } get textGeometry () { return this.geometry } get charWidths () { return this.textGeometry.charWidths } get charCoords () { return this.textGeometry.charCoords } get wrappedText () { return this.textGeometry.wrappedText } get font () { return this.textGeometry.font } get initialOffsetY () { let e = this.dataPatched; return this.font?.getLineInitialOffsetY(this.lineHeight, this.wrappedText.length, e.geometry.height, this.fontScale, e.geometry.verticalAlign) ?? 0 } get fontScale () { let e = this.dataPatched; return this.font ? e.geometry.fontSize / this.font.unitsPerEm : 1 } get AD () { return Math.abs(this.ascender - this.descender) } get ascender () { return (this.font?.ascender ?? 1) * this.fontScale } get descender () { return (this.font?.descender ?? 1) * this.fontScale } get lineHeight () { let e = this.dataPatched; return e.geometry.fontSize * e.geometry.lineHeight } raycast (e, n) { let { matrixWorld: r } = this; if (!(isNaN(e.ray.origin.x) || this.scale.x === 0 || this.scale.y === 0 || this.scale.z === 0) && ($2.copy(r).invert(), eI.copy(e.ray).applyMatrix4($2), eI.intersectBox(this.singleBBox, J2))) { let s = J2.applyMatrix4(r), o = e.ray.origin.distanceTo(s); n.push({ distance: o, point: s.clone(), object: this }) } } }; var Vr = 1e-4, Gs, rI, iI, sI, tI = new A, nI = new A; gh.then(i => { Gs = i, rI = [Gs.get_face_center, Gs.get_edge_midpoint, Gs.get_vertex_position], iI = [Gs.get_face_normal, Gs.get_edge_normal, Gs.get_vertex_normal], sI = [Gs.face_count, Gs.edge_count, Gs.vertex_count] }); var x6 = new se, b6 = new se, Ga = new A, Ql = new A, sp = new A, MS = new A, w6 = new A, S6 = new A; var No = new Z2, dr = class extends nh(ft) { constructor(e, n) { super(); this.parameters = n; this.objectForSample = void 0; this._pendingMediaLoad = !1; this.object = e } resetOnMove () { this.removeFromParent(), this.parent = null } expandClones (e) { if (this.parent === null) this.updateState(this.parameters, e); else for (let n of this.children) n instanceof sn && n.expand() } invalidateTransform (e) { this.matrixWorldNeedsUpdate = !0, this.traverse(n => { n instanceof sn && n.object === e && (n.matrixWorldNeedsUpdate = !0) }) } onObjUpdateMatrix () { this.parameters.type !== "toObject" && (this.matrixWorldNeedsUpdate = !0) } update () { switch (this._updateCount(), this.parameters.type) { case "radial": this._updateRadial(this.parameters); break; case "linear": this._updateLinear(this.parameters); break; case "grid": this._updateGrid(this.parameters); break; case "toObject": this._updateToObject(this.parameters) }for (let e of this.children) e.updateMatrix(), e.hasNonUniformScale && (e.updateMatrixWorld(), e.updateMatrixWorldSVD()) } _updateCount (e) { let n; if (e !== void 0 ? n = e : n = this.parameters.type === "grid" ? Math.round(this.parameters.grid.count[0]) * Math.round(this.parameters.grid.count[1]) * Math.round(this.parameters.grid.count[2]) : this.parameters.count, this.parameters.type === "toObject" && !this.parameters.toObject.object && (n = 0), this.parameters.type === "toObject" && this.objectForSample) { for (let s = 0, o = this.children.length; s < o; ++s)this.remove(this.children[0]); let r = this.children; if (r.length === n) return; if (r.length < n) for (let s = 0, o = n - r.length; s < o; ++s) { let a = new sn(this.object); a.expand(), this.add(a) } else for (let s = 0, o = r.length - n; s < o; ++s)this.remove(r[s]) } else { if (this.children.length === n) return; if (this.children.length < n) for (let r = 0, s = n - this.children.length; r < s; ++r) { let o = new sn(this.object); o.expand(), this.add(o) } else for (let r = 0, s = this.children.length - n; r < s; ++r)this.remove(this.children[0]) } } _updateRadial (e) { let n = e.radial, r = n.start * Ge.DEG2RAD, s = n.end * Ge.DEG2RAD, o = r - s, a = new Gt(n.rotation[0], n.rotation[1], n.rotation[2]), l; switch (n.axis) { case "z": l = new A(0, 0, 1); break; case "y": l = new A(0, 1, 0); break; default: case "x": l = new A(1, 0, 0); break }let u = e.randomnessObject ?? Cs.defaultData([1, 1, 1]).randomnessObject, c = u.noiseType === "perlin"; No.noiseSeed(u.seed); let h = yy((0, jh.default)(u.seed)), d = ip(u.strength, this.parameters.randomness); for (let [f, p] of this.children.entries()) { let m = f * (u.freqScale / 10) + u.movement, g = c ? No.noise(m) : h(m, m), y = f + 1; p.scale.x = n.scale[0] + d(y, st(g, u.scale[0])) || Vr, p.scale.y = n.scale[1] + d(y, st(g, u.scale[1])) || Vr, p.scale.z = n.scale[2] + d(y, st(g, u.scale[2])) || Vr, p.position.setScalar(0); let v = o / e.count * f - r; switch (n.axis) { case "x": p.rotation.set(0, v, 0); break; case "y": p.rotation.set(0, 0, v); break; case "z": p.rotation.set(v, 0, 0); break }p.translateOnAxis(l, n.radius), p.position.x += n.position[0] + d(y, st(g, u.position[0])), p.position.y += n.position[1] + d(y, st(g, u.position[1])), p.position.z += n.position[2] + d(y, st(g, u.position[2])); let x = d(y, st(g, u.rotation[0])), b = d(y, st(g, u.rotation[1])), S = d(y, st(g, u.rotation[2])); n.alignment === !0 ? (p.rotation.x += a.x + x, p.rotation.y += a.y + b, p.rotation.z += a.z + S) : p.rotation.set(a.x + x, a.y + b, a.z + S) } } _updateLinear (e) { if (e.type !== "linear") throw new Error; let n = e.linear, r = new Gt(n.rotation[0], n.rotation[1], n.rotation[2]), s = e.randomnessObject ?? Cs.defaultData([1, 1, 1]).randomnessObject, o = s.noiseType === "perlin"; No.noiseSeed(s.seed); let a = yy((0, jh.default)(s.seed)), l = ip(s.strength, this.parameters.randomness); for (let [u, c] of this.children.entries()) { let h = u * (s.freqScale / 10) + s.movement, d = o ? No.noise(h) : a(h, h), f = u + 1, p = l(f, st(d, s.rotation[0])), m = l(f, st(d, s.rotation[1])), g = l(f, st(d, s.rotation[2])); c.scale.x = 1 + (n.scale[0] - 1) * u + l(f, st(d, s.scale[0])) || Vr, c.scale.y = 1 + (n.scale[1] - 1) * u + l(f, st(d, s.scale[1])) || Vr, c.scale.z = 1 + (n.scale[2] - 1) * u + l(f, st(d, s.scale[2])) || Vr, c.rotation.x = r.x * u + p, c.rotation.y = r.y * u + m, c.rotation.z = r.z * u + g, c.position.x = n.position[0] * u + l(f, st(d, s.position[0])), c.position.y = n.position[1] * u + l(f, st(d, s.position[1])), c.position.z = n.position[2] * u + l(f, st(d, s.position[2])) } } _updateGrid (e) { let n = 0, r = e.grid, s = e.randomnessObject ?? Cs.defaultData([1, 1, 1]).randomnessObject, o = ip(s.strength, this.parameters.randomness), a = s.noiseType === "perlin"; No.noiseSeed(s.seed); let l = oP((0, jh.default)(s.seed)); if (r.useCenter === !0) { let u = { x: r.count[0] % 2 === 0 ? 2 : 1, y: r.count[1] % 2 === 0 ? 2 : 1, z: r.count[2] % 2 === 0 ? 2 : 1 }, c = new A(r.size[0] * (r.count[0] - u.x) * .5, r.size[1] * (r.count[1] - u.y) * .5, r.size[2] * (r.count[2] - u.z) * .5); for (let h = 0; h < r.count[0]; h++)for (let d = 0; d < r.count[1]; d++)for (let f = 0; f < r.count[2]; f++) { let p = [(h + 1) * (s.freqScale / 10) + s.movement, (d + 1) * (s.freqScale / 10) + s.movement, (f + 1) * (s.freqScale / 10) + s.movement], m = a ? No.noise(...p) : l(...p), g = this.children[n++]; g.scale.x = 1 + o(n, st(m, s.scale[0])) || Vr, g.scale.y = 1 + o(n, st(m, s.scale[1])) || Vr, g.scale.z = 1 + o(n, st(m, s.scale[2])) || Vr; let y = o(n, st(m, s.rotation[0])), v = o(n, st(m, s.rotation[1])), x = o(n, st(m, s.rotation[2])); g.rotation.set(y, v, x), g.position.x = r.size[0] * h - c.x + o(n, st(m, s.position[0])), g.position.y = r.size[1] * d - c.y + o(n, st(m, s.position[1])), g.position.z = r.size[2] * f - c.z + o(n, st(m, s.position[2])) } } else for (let u = 0; u < r.count[0]; u++)for (let c = 0; c < r.count[1]; c++)for (let h = 0; h < r.count[2]; h++) { let d = [(u + 1) * (s.freqScale / 10) + s.movement, (c + 1) * (s.freqScale / 10) + s.movement, (h + 1) * (s.freqScale / 10) + s.movement], f = a ? No.noise(...d) : l(...d), p = this.children[n++]; p.scale.x = 1 + o(n, st(f, s.scale[0])) || Vr, p.scale.y = 1 + o(n, st(f, s.scale[1])) || Vr, p.scale.z = 1 + o(n, st(f, s.scale[2])) || Vr; let m = o(n, st(f, s.rotation[0])), g = o(n, st(f, s.rotation[1])), y = o(n, st(f, s.rotation[2])); p.rotation.set(m, g, y), p.position.x = r.size[0] * u + o(n, st(f, s.position[0])), p.position.y = -r.size[1] * c + o(n, st(f, s.position[1])), p.position.z = -r.size[2] * h + o(n, st(f, s.position[2])) } } _updateToObject (e) { if (e.type !== "toObject") throw new Error; let { toObject: n } = e, r = new Gt(n.rotation[0], n.rotation[1], n.rotation[2]), s = e.randomnessObject ?? Cs.defaultData([1, 1, 1]).randomnessObject, o = s.noiseType === "perlin"; No.noiseSeed(s.seed); let a = yy((0, jh.default)(s.seed)), l = ip(s.strength, this.parameters.randomness); if (!n.object) { for (let [, y] of this.children.entries()) y.position.set(0, 0, 0), y.scale.setScalar(1), y.rotation.set(0, 0, 0); this.objectForSample = void 0; return } if (!this.objectForSample) return; if (this.objectForSample instanceof Hh) if (!this.objectForSample.font?.isLoaded || this.objectForSample.geometry.attributes.position === void 0) { this._pendingMediaLoad = !0; return } else this._pendingMediaLoad = !1; if (this.objectForSample.geometry === void 0 && this.objectForSample.isAncestorOf(this.object.uuid)) { console.warn(`Oh no! The object "${this.object.name}" (${this.object.uuid}) seem to be a child/descendant of the object it's being cloned to. Please re-parent it so that they are siblings instead.`); return } let u = this.getSubdivData(), c = [], h = y => { let v = y.length, x = y.map(_ => _[0]).reduce((_, E) => _ + E, 0), b = y.map(_ => _[1]).reduce((_, E) => _ + E, 0), S = y.map(_ => _[2]).reduce((_, E) => _ + E, 0); return [x / v, b / v, S / v] }, d = y => Math.round(y * 1e6) / 1e6; u.forEach(y => { let v = u.filter(x => d(y.pos[0]) === d(x.pos[0]) && d(y.pos[1]) === d(x.pos[1]) && d(y.pos[2]) === d(x.pos[2])); v.length > 1 ? c.push({ pos: y.pos, norm: h(v.map(x => x.norm)) }) : c.push(y) }); let f = X2(c); if (u.length > 0) { let y = Math.round(f.length * n.count / 100); this._updateCount(y) } this.objectForSample.updateMatrixWorld(); let p = new vy(this.objectForSample).build(), m = q2[n.axis], g = this.children; p.setRandomGenerator((0, jh.default)(this.object.uuid + n.seed)); for (let [y, v] of g.entries()) { let x = y * (s.freqScale / 10) + s.movement, b = o ? No.noise(x) : a(x, x), S = y + 1, _ = l(S, st(b, s.rotation[0])), E = l(S, st(b, s.rotation[1])), w = l(S, st(b, s.rotation[2])); n.spreadType === "random" ? p.sample(sp, MS) : (f.length && (sp.fromArray(f[y].pos), MS.fromArray(f[y].norm)), this.objectForSample instanceof as && sp.applyMatrix4(x6.copy(this.objectForSample.matrixWorld).invert())), sp.applyMatrix4(this.object.hiddenMatrix.clone().invert()), v.position.copy(sp), Ga.fromArray(m); let M = n.align === "normal" ? MS : this.object.getWorldDirection(S6), T = Ql.fromArray(n.position); Ql.x += Ql.x + l(S, st(b, s.position[0])), Ql.y += Ql.y + l(S, st(b, s.position[1])), Ql.z += Ql.z + l(S, st(b, s.position[2])); let I = Math.acos(M.dot(Ga)), C = w6.crossVectors(Ga, M).normalize(), P = b6.makeRotationAxis(C, I), D = M.clone().cross(this.object.up).normalize(), L = D.clone().cross(M).normalize(), H = new se().makeBasis(D, M, L), U = new A(Ga.y, Ga.z, Ga.x).normalize(), V = U.clone().cross(Ga).normalize(), G = new se().makeBasis(U, Ga, V).invert(), z = new se().multiplyMatrices(H, G); v.rotation.setFromRotationMatrix(z), T.applyMatrix4(P), v.position.add(T), v.rotation.x = v.rotation.x + r.x + _, v.rotation.y = v.rotation.y + r.y + E, v.rotation.z = v.rotation.z + r.z + w, v.scale.setScalar(1), v.scale.x = v.scale.x + n.scale[0] + l(S, st(b, s.scale[0])) || Vr, v.scale.y = v.scale.y + n.scale[1] + l(S, st(b, s.scale[1])) || Vr, v.scale.z = v.scale.z + n.scale[2] + l(S, st(b, s.scale[2])) || Vr, v.scale.multiply(this.object.scale), v.hiddenMatrix = this.object.hiddenMatrix } } getSubdivData () { if (!this.objectForSample) return []; let e = this.parameters.toObject.spreadType; if (e === "random") return []; if (this.objectForSample instanceof as) { let n = this.objectForSample, r = Y2[e], s = sI[r], o = rI[r], a = iI[r], l = [], u = s(n.subdivPointerNew); for (let c = 0; c <= u - 1; c++) { let h = o(n.subdivPointerNew, c), d = a(n.subdivPointerNew, c); tI.fromArray(h).applyMatrix4(n.matrixWorld), nI.fromArray(d), l.push({ pos: tI.toArray(), norm: nI.toArray() }) } return l } else return (this.objectForSample.geometry.index ? Q2(this.objectForSample.geometry) : K2(this.objectForSample.geometry)).map((r, s) => e === "polygon_center" ? { pos: r.midpoint, norm: r.norm } : e === "vertex" ? [{ pos: r.vertices[0], norm: r.norm }, { pos: r.vertices[1], norm: r.norm }, { pos: r.vertices[2], norm: r.norm }] : e === "edge" ? [{ pos: r.faceCenters[0], norm: r.norm }, { pos: r.faceCenters[1], norm: r.norm }, { pos: r.faceCenters[2], norm: r.norm }] : []).flat() } updateState (e, n) { if (this.parameters = Ao(e), this.parameters.type !== "toObject") (this.parent === null || this.parent !== this.object) && (this.removeFromParent(), this.object.parent?.add(this), this.matrix = this.object.matrix, this.hiddenMatrix = this.object.hiddenMatrix, this.matrixWorldNeedsUpdate = !0, this.matrixAutoUpdate = !1); else if (this.parent === null || this.parent.uuid !== this.parameters.toObject.object) { this.removeFromParent(); let r = n.find(this.parameters.toObject.object); r instanceof Ht ? this.objectForSample = r : this.objectForSample = void 0, this.matrix = new se, this.hiddenMatrix = new se, this.matrixWorldNeedsUpdate = !0, this.matrixAutoUpdate = !1, r && r.add(this) } this.update() } get pendingMediaLoad () { return this._pendingMediaLoad } }; var Vs = i => { var t; return t = class extends i { }, t.geometryHelper = new er(30, 30, 30), t }; var nv = new Wi, TS = new dn, oI = new se, Hs = (i, t, e, n, r = !1) => { let s = t, o = i.matrixWorld; if (s.boundingSphere === null && s.computeBoundingSphere(), TS.copy(s.boundingSphere), TS.applyMatrix4(o), e.ray.intersectsSphere(TS) === !1 || (oI.copy(o).invert(), nv.copy(e.ray).applyMatrix4(oI), s.boundingBox !== null && nv.intersectsBox(s.boundingBox) === !1)) return; let a, l, u, c, h = s.index, d = s.attributes.position, f = s.drawRange, p, m; if (r === !1) { let y = Math.max(0, f.start), v = Math.min(h.count, f.start + f.count); for (p = y, m = v; p < m; p += 3)if (l = h.getX(p), u = h.getX(p + 1), c = h.getX(p + 2), a = g(i, e, nv, d, l, u, c), a) { a.faceIndex = Math.floor(p / 3), n.push(a); return } } else { let v = s.attributes.position, x = new A, b = new A, S = new A, _ = new A, E = 2, M = 1 / ((i.scale.x + i.scale.y + i.scale.z) / 3), T = M * M, I = Math.max(0, f.start), C = Math.min(v.count, f.start + f.count); for (let P = I, D = C - 1; P < D; P += E) { if (x.fromBufferAttribute(v, P), b.fromBufferAttribute(v, P + 1), nv.distanceSqToSegment(x, b, _, S) > T) continue; _.applyMatrix4(i.matrixWorld); let H = e.ray.origin.distanceTo(_); H < e.near || H > e.far || n.push({ distance: H, point: S.clone().applyMatrix4(i.matrixWorld), object: i }) } } function g (y, v, x, b, S, _, E) { let w = new A, M = new A, T = new A, I = new A, C = new A; if (w.fromBufferAttribute(b, S), M.fromBufferAttribute(b, _), T.fromBufferAttribute(b, E), x.intersectTriangle(w, M, T, !1, I) === null) return null; C.copy(I), C.applyMatrix4(y.matrixWorld); let D = v.ray.origin.distanceTo(C); return D < v.near || D > v.far ? null : { faceIndex: 1, distance: D, point: C.clone(), object: y } } }; var rv = new A, Ni = new qi, CS = class extends sa { constructor(e) { let n = new Ce, r = new Si({ color: 16777215, vertexColors: !0, toneMapped: !1 }), s = [], o = [], a = {}, l = new Le(15711266), u = new Le(15711266), c = new Le(2857471); h("n1", "n2", l), h("n2", "n4", l), h("n4", "n3", l), h("n3", "n1", l), h("f1", "f2", l), h("f2", "f4", l), h("f4", "f3", l), h("f3", "f1", l), h("n1", "f1", l), h("n2", "f2", l), h("n3", "f3", l), h("n4", "f4", l), h("p", "n1", u), h("p", "n2", u), h("p", "n3", u), h("p", "n4", u), h("u1", "u2", c), h("u2", "u3", c), h("u3", "u1", c); function h (f, p, m) { d(f, m), d(p, m) } function d (f, p) { s.push(0, 0, 0), o.push(p.r, p.g, p.b), a[f] === void 0 && (a[f] = []), a[f].push(s.length / 3 - 1) } n.setAttribute("position", new _e(s, 3)), n.setAttribute("color", new _e(o, 3)); super(n, r); this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update() } update () { let e = this.geometry, n = this.pointMap, r = !0; Ni.projectionMatrixInverse.elements = [.5112609807824982, -0, -0, -0, -0, .41421356237309503, -0, -0, -0, -0, -0, -.099999, -0, -0, -1.0000000000000002, .100001]; let s = 1, o = 1, a = r ? .8 : 1e-4; ls("n1", n, e, Ni, -s, -o, a), ls("n2", n, e, Ni, s, -o, a), ls("n3", n, e, Ni, -s, o, a), ls("n4", n, e, Ni, s, o, a); let l = a; ls("f1", n, e, Ni, -s, -o, l), ls("f2", n, e, Ni, s, -o, l), ls("f3", n, e, Ni, -s, o, l), ls("f4", n, e, Ni, s, o, l); let u = l, c = .5; ls("u1", n, e, Ni, s * .7 * c, o * 1.1, u), ls("u2", n, e, Ni, -s * .7 * c, o * 1.1, u), ls("u3", n, e, Ni, 0, o * (1.1 + .9 * c), u), e.getAttribute("position").needsUpdate = !0 } dispose () { this.geometry.dispose(), this.material.dispose() } }; function ls (i, t, e, n, r, s, o) { rv.set(r, s, o).unproject(n); let a = t[i]; if (a !== void 0) { let l = e.getAttribute("position"); for (let u = 0, c = a.length; u < c; u++)l.setXYZ(a[u], rv.x, rv.y, rv.z) } } var iv = class extends Vs(CS) { constructor(e) { super(e); this.object = e; this.object = e, this.name = `CombinedCameraHelper: ${e.uuid}` } updateMatrixWorld (e) { super.updateMatrixWorld(e), this.updateTarget() } updateTarget () { let e = this.object.getTarget(); this.updateWorldMatrix(!0, !1), this.worldToLocal(e) } raycast (e, n) { Hs(this.object, this.geometry, e, n, !0) } }; var sv; (t => t.is = e => "objectHelper" in e)(sv || (sv = {})); var js = (i, t) => class extends ih(i) { constructor() { super(...arguments); this.objectHelper = new t(this); this.gizmos = {} } get geometryHelper () { return t.geometryHelper } raycast (r, s) { this.objectHelper.raycast(r, s) } showGizmos () { for (let r in this.gizmos) { let s = this.gizmos[r]; s instanceof ua && (s.visible = !0) } } updateEntityBoxSize (r, s) { this.objectHelper.visible && this.geometryHelper instanceof er ? (r.setScalar(0), s.set(this.geometryHelper.parameters.width, this.geometryHelper.parameters.height, this.geometryHelper.parameters.height).multiplyScalar(.5)) : super.updateEntityBoxSize(r, s) } hideGizmos () { for (let r in this.gizmos) { let s = this.gizmos[r]; s instanceof ua && (s.visible = !1) } } }; var ov = 790, Wh = new A, PS = new A, IS = new Ye, DS = new A, op = new A, OS = new A, Wt = class extends js(qi, iv) { constructor(e = "", n = { ...Ol.defaultData, name: "" }) { super(); this._cameraType = "OrthographicCamera"; this.targetOffset = Aa.DefaultTargetOffset; this.isUpVectorFlipped = !1; this.angleOffsetFromUp = 0; this.wasMovedByUser = !1; this.wasMovedBySwitchCameraAction = !1; this.super_Entity(e, n), this.previousProjectionMatrix = new se, this.matrixAutoUpdate = !0, this.width = window.innerWidth, this.height = window.innerHeight; let r = this.width, s = this.height; this.orthoCamera = new Pc(r * -.5, r * .5, s * .5, s * -.5, -5e4, 1e4), this.perspCamera = new xn(45, r / s, 50, 1e4), this.left = this.orthoCamera.left, this.right = this.orthoCamera.right, this.top = this.orthoCamera.top, this.bottom = this.orthoCamera.bottom, this.far = this.orthoCamera.far, this.view = this.orthoCamera.view, this.aspect = this.perspCamera.aspect, this.focus = this.perspCamera.focus, this.filmGauge = this.perspCamera.filmGauge, this.filmOffset = this.perspCamera.filmOffset, this.objectHelper.update() } get isPerspectiveCamera () { return this.cameraType === "PerspectiveCamera" } get isOrthographicCamera () { return !this.isPerspectiveCamera } get cameraType () { return this._cameraType } set fov (e) { this.perspCamera.fov = e } get fov () { return this.perspCamera.fov } setNear (e, n) { e === "PerspectiveCamera" ? this.perspCamera.near = n : this.orthoCamera.near = n } setZoom (e, n) { n >= 0 && (e === "PerspectiveCamera" ? this.perspCamera.zoom = n : this.orthoCamera.zoom = n) } set cameraType (e) { e === "PerspectiveCamera" ? this.toPerspective() : e === "OrthographicCamera" && this.toOrthographic() } get near () { return this._cameraType === "PerspectiveCamera" ? this.perspCamera.near : this.orthoCamera.near } set near (e) { this._cameraType === "PerspectiveCamera" ? this.perspCamera.near = e : this.orthoCamera.near = e } get zoom () { return this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom : this.orthoCamera.zoom } set zoom (e) { e >= 0 && (this._cameraType === "PerspectiveCamera" ? this.perspCamera.zoom = e : this.orthoCamera.zoom = e) } lookAt (e, n, r) { typeof e == "number" && (e = new A(e, n, r)), super.lookAt(e), this.getWorldPosition(Wh), this.targetOffset = Wh.distanceTo(e) } getTarget (e = new A) { return this.getWorldDirection(PS), this.getWorldPosition(Wh), PS.multiplyScalar(this.targetOffset), e.copy(Wh).add(PS), e } getDistanceToTarget () { let e = this.getTarget(); return this.getWorldPosition(Wh), Wh.distanceTo(e) } updateUp () { this.getWorldQuaternion(IS), DS.set(0, 0, 1).applyQuaternion(IS), op.copy(ft.DEFAULT_UP), this.isUpVectorFlipped && op.negate(), op.applyQuaternion(IS), OS.copy(ft.DEFAULT_UP).projectOnPlane(DS), this.angleOffsetFromUp = OS.angleTo(op), this.angleOffsetFromUp *= OS.cross(op).dot(DS) >= 0 ? 1 : -1 } updateTransformState (e) { let n = super.updateTransformState(e); return e.isUpVectorFlipped !== void 0 && (this.isUpVectorFlipped = e.isUpVectorFlipped), this.updateUp(), n } getViewFrontToObject (e) { let n = e.getWorldPosition(new A), s = e.getWorldDirection(new A).multiplyScalar(this.targetOffset); return { position: n.clone().add(s), target: n } } getViewToTarget (e) { let r = this.getWorldDirection(new A).multiplyScalar(this.targetOffset); return { position: e.clone().sub(r), target: e } } getViewToObject (e) { let n = new A, r = e.getWorldPosition(n); return this.getViewToTarget(n) } setViewplaneSize (e, n, r = !1) { if (this.aspect = e / n, r) { let s = e > n ? this.aspect : 1, o = e > n ? 1 : this.aspect; this.left = -ov * .5 * s, this.right = ov * .5 * s, this.top = ov * .5 * (1 / o), this.bottom = -ov * .5 * (1 / o) } else this.left = -e * .5, this.right = e * .5, this.top = n * .5, this.bottom = -n * .5; this.updateProjectionMatrix() } copyViewPlaneSize (e) { this.aspect = e.aspect, this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.updateProjectionMatrix() } toOrthographic () { this.orthoCamera.left = this.left, this.orthoCamera.right = this.right, this.orthoCamera.top = this.top, this.orthoCamera.bottom = this.bottom, this.orthoCamera.view = this.view, this.orthoCamera.far = this.far, this.orthoCamera.updateProjectionMatrix(), this.projectionMatrix = this.orthoCamera.projectionMatrix, this.projectionMatrixInverse = this.orthoCamera.projectionMatrixInverse, this._cameraType = "OrthographicCamera", this.objectHelper && this.objectHelper.update() } toPerspective () { this.perspCamera.aspect = this.aspect, this.perspCamera.fov = this.fov, this.perspCamera.view = this.view, this.perspCamera.far = this.far, this.perspCamera.updateProjectionMatrix(), this.projectionMatrix = this.perspCamera.projectionMatrix, this.projectionMatrixInverse = this.perspCamera.projectionMatrixInverse, this._cameraType = "PerspectiveCamera", this.objectHelper && this.objectHelper.update() } setFocalLength (e) { this.perspCamera.setFocalLength(e), this.toPerspective() } getFocalLength () { return this.perspCamera.getFocalLength() } getEffectiveFOV () { return this.perspCamera.getEffectiveFOV() } getFilmWidth () { return this.perspCamera.getFilmWidth() } getFilmHeight () { return this.perspCamera.getFilmHeight() } setViewOffset (e, n, r, s, o, a) { this._cameraType === "PerspectiveCamera" ? this.perspCamera.setViewOffset(e, n, r, s, o, a) : this.orthoCamera.setViewOffset(e, n, r, s, o, a) } clearViewOffset () { this._cameraType === "PerspectiveCamera" ? (this.perspCamera.clearViewOffset(), this.toPerspective()) : (this.orthoCamera.clearViewOffset(), this.toOrthographic()) } copyHistory () { this.previousProjectionMatrix && this.previousProjectionMatrix.copy(this.projectionMatrix) } updateProjectionMatrix () { this._cameraType === "PerspectiveCamera" ? this.toPerspective() : this._cameraType === "OrthographicCamera" && this.toOrthographic() } updateMatrixWorld (e) { super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert() } updateWorldMatrix (e, n) { super.updateWorldMatrix(e, n), this.matrixWorldInverse.copy(this.matrixWorld).invert() } copy (e, n) { return super.copy(e, n), this.parent = e.parent, this.orthoCamera.copy(e.orthoCamera), this.perspCamera.copy(e.perspCamera), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.far = e.far, this.view = e.view === null ? null : Object.assign({}, e.view), this._cameraType = e._cameraType, this.aspect = e.aspect, this.fov = e.fov, this.focus = e.focus, this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this.targetOffset = e.targetOffset, this.updateProjectionMatrix(), this } toCameraState (e = []) { let n = { type: this.cameraType, far: this.far, orthographic: { near: this.orthoCamera.near, zoom: this.orthoCamera.zoom }, perspective: { near: this.perspCamera.near, fov: this.perspCamera.fov, zoom: this.perspCamera.zoom }, up: this.up.toArray(), targetOffset: this.targetOffset, isUpVectorFlipped: this.isUpVectorFlipped }; return Au(n, e) } updateCameraSubtype (e, n) { let r = e === "perspective" ? "PerspectiveCamera" : "OrthographicCamera"; n.zoom !== void 0 && this.setZoom(r, n.zoom), n.near !== void 0 && this.setNear(r, n.near), n.fov !== void 0 && r === "PerspectiveCamera" && (this.fov = n.fov) } updateState (e, n) { this.updateCameraState(e, n) } updateCameraState (e, n) { this.updateState_Entity(e, n), e.far !== void 0 && (this.far = e.far), e.orthographic !== void 0 && this.updateCameraSubtype("orthographic", e.orthographic), e.perspective !== void 0 && this.updateCameraSubtype("perspective", e.perspective), e.type !== void 0 && (this.cameraType = e.type), e.up !== void 0 && this.up.fromArray(e.up), e.targetOffset !== void 0 && (this.targetOffset = e.targetOffset), e.isUpVectorFlipped !== void 0 && (this.isUpVectorFlipped = e.isUpVectorFlipped), this.updateProjectionMatrix() } updateByPatchedOp (e, n, r) { super.updateByPatchedOp(e, n, r), e.path.length === 1 && e.type === 0 && this.updateCameraSubtype(e.path[0], e.props) } toState (e) { return { ...super.toState(e), ...this.toCameraState(e), type: this.cameraType } } }; var qh = new se, _6 = new se; function RS (i) { let t = !1; return i.scene.objects.traverse((e, n) => { n.geometry?.type === "BooleanGeometry" && (t = !0) }), t } var Bi = class extends Ri { constructor(e, n, r) { super(e, n); this.data = n; this.meshSetAddresses = []; this.needsTransformForDownstream = !1; this.geometry = new Ce; this.onAfterRender = (e, n, r, s, o, a) => { super.onAfterRender(e, n, r, s, o, a), this.recomputeBoolean() }; this.geometry.userData.parameters = { width: 0, height: 0, depth: 0 } } get booleanOp () { return this.data.geometry.operation } get phongAngle () { return this.data.geometry.phongAngle ?? 45 } get isLOD () { return this.recomputeBoolean(), !1 } updateByPatchedOp (e, n, r) { super.updateByPatchedOp(e, n, r), e.path.length === 1 && e.path[0] === "geometry" && e.type === 0 && e.props.operation !== void 0 && (this.freeBooleanPointer(), this.resetBBoxNeedsUpdate()) } freeBooleanPointer () { super.freeBooleanPointer(), this.geometry.dispose() } recomputeBoolean (e, n = !0) { if (this.booleanMeshSetAddress !== -1 && !e) return; for (let s = 0; s < this.children.length; s++) { let o = this.children[s]; o instanceof Bi && o.dataPatched.visible === !0 && o.recomputeBoolean(e === !0, n) } this.meshSetAddresses = []; for (let s = 0; s < this.children.length; s++) { let o = this.children[s]; if (o instanceof Ht && o.dataPatched.visible === !0 && o.geometry.attributes.position?.count > 0 && o.geometry.drawRange.count > 0) { if (qh.multiplyMatrices(o.hiddenMatrix, o.matrix), o.booleanMeshSetAddress === -1) { if ((o.geometry.index ?? o.geometry.getAttribute("position")).count / 3 < 15e5 && (o.booleanMeshSetAddress = Ii.getMeshSet(o.geometry, e === !0, n)), o.booleanMeshSetAddress === -1) return; Ii.transformMeshSet(o.booleanMeshSetAddress, qh), o.booleanMatrixInvOld.copy(qh).invert(), o.booleanWasTransformed = !1 } else o instanceof Bi && o.needsTransformForDownstream === !0 ? (Ii.transformMeshSet(o.booleanMeshSetAddress, qh), o.needsTransformForDownstream = !1) : o.booleanWasTransformed === !0 && (Ii.transformMeshSet(o.booleanMeshSetAddress, _6.multiplyMatrices(qh, o.booleanMatrixInvOld)), o.booleanMatrixInvOld.copy(qh).invert(), o.booleanWasTransformed = !1); Ii.hasOpenEdges(o.booleanMeshSetAddress) === !1 || s === this.children.length - 1 && this.booleanOp === 2 ? (this.meshSetAddresses.push(o.booleanMeshSetAddress), o.geometry.userData.wasFilteredFromBoolean = !1) : o.geometry.userData.wasFilteredFromBoolean = !0 } } if (this.meshSetAddresses.length === 0) { this.geometry.setAttribute("position", new _e([], 0)), this.geometry.setDrawRange(0, 0); return } if (e === !0) return Ii.calcBooleanTopological(this.meshSetAddresses, this.booleanOp); let r = this.geometry; r.dispose(), this.geometry = new Ce, this.geometry.userData = r.userData, this.geometry.boundingSphere = r.boundingSphere; try { this.booleanMeshSetAddress = Ii.calcBoolean(this.meshSetAddresses, this.booleanOp, this.geometry, this.phongAngle) } catch (s) { this.booleanMeshSetAddress = 0, console.error(s) } this.booleanMatrixInvOld.copy(this.matrix).invert(), this.needsTransformForDownstream = !0, zh(this), Gh(this) } dispose () { super.dispose(), this.geometry.dispose() } }; var av; (t => { function i (e) { return ct.is(e) && e instanceof la } t.is = i })(av || (av = {})); var Yh = (i, t) => class extends js(i, t) { updateState_Light (n, r) { this.updateState_Entity(n, r), n.color !== void 0 && (this.color = r.shared.color(n.color)), n.intensity !== void 0 && (this.intensity = n.intensity), n.depth !== void 0 && (this.shadow.camera.far = n.depth, this.shadow.needsUpdate = !0), n.shadows !== void 0 && (this.castShadow = n.shadows) } }; var Ir = i => i instanceof Ht, Hr = i => i !== null && i instanceof Bi, aI = i => i instanceof Wt, lI = i => av.is(i), ap = i => sv.is(i); var Ws = class extends Vs(Bm) { constructor(e, n = 15) { super(n); this.object = e; this.object.updateMatrixWorld(), this.name = `EmptyObjectHelper: ${e.uuid}`, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.object.isBone && (this.visible = !1) } raycast (e, n) { Hs(this.object, Ws.geometryHelper, e, n) } update () { } }; var Bo = class extends js(vs, Ws) { constructor(t, e) { super(), this.super_Entity(t, e), this.objectHelper.update() } updateState (t, e) { this.updateState_Entity(t, e) } }; var mI = { RED: 0, GREEN: 1, BLUE: 2, ALPHA: 3 }; var lp = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}"; var E6 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;
#if PASS == 1
uniform vec4 kernel64[32];
#else
uniform vec4 kernel16[8];
#endif
varying vec2 vUv;void main(){
#ifdef FOREGROUND
vec2 CoCNearFar=texture2D(cocBuffer,vUv).rg;float CoC=CoCNearFar.r*scale;
#else
float CoC=texture2D(cocBuffer,vUv).g*scale;
#endif
if(CoC==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{
#ifdef FOREGROUND
vec2 step=texelSize*max(CoC,CoCNearFar.g*scale);
#else
vec2 step=texelSize*CoC;
#endif
#if PASS == 1
vec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;
#else
vec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;
#endif
}}`, lv = class extends it { constructor(i = !1, t = !1) { super({ name: "BokehMaterial", defines: { PASS: i ? "2" : "1" }, uniforms: { kernel64: new oe(null), kernel16: new oe(null), inputBuffer: new oe(null), cocBuffer: new oe(null), texelSize: new oe(new B), scale: new oe(1) }, blending: Ot, depthWrite: !1, depthTest: !1, fragmentShader: E6, vertexShader: lp }), this.toneMapped = !1, t && (this.defines.FOREGROUND = "1"), this.generateKernel() } set inputBuffer (i) { this.uniforms.inputBuffer.value = i } setInputBuffer (i) { this.uniforms.inputBuffer.value = i } set cocBuffer (i) { this.uniforms.cocBuffer.value = i } setCoCBuffer (i) { this.uniforms.cocBuffer.value = i } get scale () { return this.uniforms.scale.value } set scale (i) { this.uniforms.scale.value = i } getScale (i) { return this.uniforms.scale.value = i } setScale (i) { this.uniforms.scale.value = i } generateKernel () { let i = 2.39996323, t = new Float32Array(128), e = new Float32Array(32), n = 0, r = 0; for (let a = 0; a < 80; ++a) { let l = a * i, u = Math.sqrt(a) / Math.sqrt(80), c = u * Math.cos(l), h = u * Math.sin(l); a % 5 === 0 ? (e[r++] = c, e[r++] = h) : (t[n++] = c, t[n++] = h) } let s = [], o = []; for (let a = 0; a < 128;)s.push(new qe(t[a++], t[a++], t[a++], t[a++])); for (let a = 0; a < 32;)o.push(new qe(e[a++], e[a++], e[a++], e[a++])); this.uniforms.kernel64.value = s, this.uniforms.kernel16.value = o } setTexelSize (i, t) { this.uniforms.texelSize.value.set(i, t) } setSize (i, t) { this.uniforms.texelSize.value.set(1 / i, 1 / t) } }; function cI (i, t, e) { return i * (t - e) - t } function kS (i, t, e) { return Math.min(Math.max((i + t) / (t - e), 0), 1) } var M6 = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}void main(){float depth=readDepth(vUv);
#ifdef PERSPECTIVE_CAMERA
float viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);
#else
float linearDepth=depth;
#endif
float signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}`, T6 = class extends it { constructor(i) { super({ name: "CircleOfConfusionMaterial", defines: { DEPTH_PACKING: "0" }, uniforms: { depthBuffer: new oe(null), focusDistance: new oe(0), focusRange: new oe(0), cameraNear: new oe(.3), cameraFar: new oe(1e3) }, blending: Ot, depthWrite: !1, depthTest: !1, fragmentShader: M6, vertexShader: lp }), this.toneMapped = !1, this.uniforms.focalLength = this.uniforms.focusRange, this.adoptCameraSettings(i) } get near () { return this.uniforms.cameraNear.value } get far () { return this.uniforms.cameraFar.value } set depthBuffer (i) { this.uniforms.depthBuffer.value = i } set depthPacking (i) { this.defines.DEPTH_PACKING = i.toFixed(0), this.needsUpdate = !0 } setDepthBuffer (i, t = tr) { this.depthBuffer = i, this.depthPacking = t } get focusDistance () { return this.uniforms.focusDistance.value } set focusDistance (i) { this.uniforms.focusDistance.value = i } get worldFocusDistance () { return -cI(this.focusDistance, this.near, this.far) } set worldFocusDistance (i) { this.focusDistance = kS(-i, this.near, this.far) } getFocusDistance (i) { this.uniforms.focusDistance.value = i } setFocusDistance (i) { this.uniforms.focusDistance.value = i } get focalLength () { return this.focusRange } set focalLength (i) { this.focusRange = i } get focusRange () { return this.uniforms.focusRange.value } set focusRange (i) { this.uniforms.focusRange.value = i } get worldFocusRange () { return -cI(this.focusRange, this.near, this.far) } set worldFocusRange (i) { this.focusRange = kS(-i, this.near, this.far) } getFocalLength (i) { return this.focusRange } setFocalLength (i) { this.focusRange = i } adoptCameraSettings (i) { i && (this.uniforms.cameraNear.value = i.near, this.uniforms.cameraFar.value = i.far, i instanceof xn ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } }, C6 = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <encodings_fragment>
#include <dithering_fragment>
}`, P6 = "uniform vec2 texelSize;uniform vec2 halfTexelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize*vec2(kernel)+halfTexelSize)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}", uI = class extends it { constructor(i = new B) { super({ name: "KawaseBlurMaterial", uniforms: { inputBuffer: new oe(null), texelSize: new oe(new B), halfTexelSize: new oe(new B), kernel: new oe(0), scale: new oe(1) }, blending: Ot, depthWrite: !1, depthTest: !1, fragmentShader: C6, vertexShader: P6 }), this.toneMapped = !1, this.setTexelSize(i.x, i.y) } set inputBuffer (i) { this.uniforms.inputBuffer.value = i } setInputBuffer (i) { this.inputBuffer = i } get scale () { return this.uniforms.scale.value } set scale (i) { this.uniforms.scale.value = i } getScale () { return this.uniforms.scale.value } setScale (i) { this.uniforms.scale.value = i } getKernel () { return null } get kernel () { return this.uniforms.kernel.value } set kernel (i) { this.uniforms.kernel.value = i } setKernel (i) { this.kernel = i } setTexelSize (i, t) { this.uniforms.texelSize.value.set(i, t), this.uniforms.halfTexelSize.value.set(i, t).multiplyScalar(.5) } setSize (i, t) { let e = this.uniforms; e.texelSize.value.set(1 / i, 1 / t), e.halfTexelSize.value.copy(e.texelSize.value).multiplyScalar(.5) } }, I6 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <encodings_fragment>
}`, D6 = class extends it { constructor() { super({ name: "CopyMaterial", uniforms: { inputBuffer: new oe(null), opacity: new oe(1) }, blending: Ot, depthWrite: !1, depthTest: !1, fragmentShader: I6, vertexShader: lp }), this.toneMapped = !1 } set inputBuffer (i) { this.uniforms.inputBuffer.value = i } setInputBuffer (i) { this.uniforms.inputBuffer.value = i } getOpacity (i) { return this.uniforms.opacity.value } setOpacity (i) { this.uniforms.opacity.value = i } }; var O6 = `varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
#if EDGE_DETECTION_MODE == 1
#include <common>
#endif
#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}
#elif PREDICATION_MODE == 2
uniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}
#endif
#if PREDICATION_MODE != 0
vec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}
#endif
#if EDGE_DETECTION_MODE != 0
uniform sampler2D inputBuffer;
#endif
void main(){
#if EDGE_DETECTION_MODE == 0
const vec2 threshold=vec2(DEPTH_THRESHOLD);
#elif PREDICATION_MODE != 0
vec2 threshold=calculatePredicatedThreshold();
#else
const vec2 threshold=vec2(EDGE_THRESHOLD);
#endif
#if EDGE_DETECTION_MODE == 0
vec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 1
float l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#elif EDGE_DETECTION_MODE == 2
vec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);
#endif
}`, R6 = `uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;
#if EDGE_DETECTION_MODE != 0
varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;
#endif
void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);
#if EDGE_DETECTION_MODE != 0
vUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);
#endif
gl_Position=vec4(position.xy,1.0,1.0);}`, Xh = { DEPTH: 0, LUMA: 1, COLOR: 2 }, L6 = { DISABLED: 0, DEPTH: 1, CUSTOM: 2 }, N6 = class extends it { constructor(i = new B, t = Xh.COLOR) { super({ name: "EdgeDetectionMaterial", defines: { THREE_REVISION: vo.replace(/\D+/g, ""), LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0", EDGE_THRESHOLD: "0.1", DEPTH_THRESHOLD: "0.01", PREDICATION_MODE: "0", PREDICATION_THRESHOLD: "0.01", PREDICATION_SCALE: "2.0", PREDICATION_STRENGTH: "1.0", DEPTH_PACKING: "0" }, uniforms: { inputBuffer: new oe(null), depthBuffer: new oe(null), predicationBuffer: new oe(null), texelSize: new oe(i) }, blending: Ot, depthWrite: !1, depthTest: !1, fragmentShader: O6, vertexShader: R6 }), this.toneMapped = !1, this.edgeDetectionMode = t } set depthBuffer (i) { this.uniforms.depthBuffer.value = i } set depthPacking (i) { this.defines.DEPTH_PACKING = i.toFixed(0), this.needsUpdate = !0 } setDepthBuffer (i, t = tr) { this.depthBuffer = i, this.depthPacking = t } get edgeDetectionMode () { return Number(this.defines.EDGE_DETECTION_MODE) } set edgeDetectionMode (i) { this.defines.EDGE_DETECTION_MODE = i.toFixed(0), this.needsUpdate = !0 } getEdgeDetectionMode () { return this.edgeDetectionMode } setEdgeDetectionMode (i) { this.edgeDetectionMode = i } get localContrastAdaptationFactor () { return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR) } set localContrastAdaptationFactor (i) { this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = i.toFixed("6"), this.needsUpdate = !0 } getLocalContrastAdaptationFactor () { return this.localContrastAdaptationFactor } setLocalContrastAdaptationFactor (i) { this.localContrastAdaptationFactor = i } get edgeDetectionThreshold () { return Number(this.defines.EDGE_THRESHOLD) } set edgeDetectionThreshold (i) { this.defines.EDGE_THRESHOLD = i.toFixed("6"), this.defines.DEPTH_THRESHOLD = (i * .1).toFixed("6"), this.needsUpdate = !0 } getEdgeDetectionThreshold () { return this.edgeDetectionThreshold } setEdgeDetectionThreshold (i) { this.edgeDetectionThreshold = i } get predicationMode () { return Number(this.defines.PREDICATION_MODE) } set predicationMode (i) { this.defines.PREDICATION_MODE = i.toFixed(0), this.needsUpdate = !0 } getPredicationMode () { return this.predicationMode } setPredicationMode (i) { this.predicationMode = i } set predicationBuffer (i) { this.uniforms.predicationBuffer.value = i } setPredicationBuffer (i) { this.uniforms.predicationBuffer.value = i } get predicationThreshold () { return Number(this.defines.PREDICATION_THRESHOLD) } set predicationThreshold (i) { this.defines.PREDICATION_THRESHOLD = i.toFixed("6"), this.needsUpdate = !0 } getPredicationThreshold () { return this.predicationThreshold } setPredicationThreshold (i) { this.predicationThreshold = i } get predicationScale () { return Number(this.defines.PREDICATION_SCALE) } set predicationScale (i) { this.defines.PREDICATION_SCALE = i.toFixed("6"), this.needsUpdate = !0 } getPredicationScale () { return this.predicationScale } setPredicationScale (i) { this.predicationScale = i } get predicationStrength () { return Number(this.defines.PREDICATION_STRENGTH) } set predicationStrength (i) { this.defines.PREDICATION_STRENGTH = i.toFixed("6"), this.needsUpdate = !0 } getPredicationStrength () { return this.predicationStrength } setPredicationStrength (i) { this.predicationStrength = i } setSize (i, t) { this.uniforms.texelSize.value.set(1 / i, 1 / t) } }, B6 = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#if THREE_REVISION >= 137
vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}
#endif
float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}FRAGMENT_HEADvoid main(){FRAGMENT_MAIN_UVvec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGEgl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <encodings_fragment>
#endif
#include <dithering_fragment>
}`, F6 = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEADvoid main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORTgl_Position=vec4(position.xy,1.0,1.0);}", cs = { FRAGMENT_HEAD: "FRAGMENT_HEAD", FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV", FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE", VERTEX_HEAD: "VERTEX_HEAD", VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT" }, US = class extends it { constructor(i, t, e, n, r = !1) { super({ name: "EffectMaterial", defines: { THREE_REVISION: vo.replace(/\D+/g, ""), DEPTH_PACKING: "0", ENCODE_OUTPUT: "1" }, uniforms: { inputBuffer: new oe(null), depthBuffer: new oe(null), resolution: new oe(new B), texelSize: new oe(new B), cameraNear: new oe(.3), cameraFar: new oe(1e3), aspect: new oe(1), time: new oe(0) }, blending: Ot, depthWrite: !1, depthTest: !1, dithering: r }), this.toneMapped = !1, i && this.setShaderParts(i), t && this.setDefines(t), e && this.setUniforms(e), this.adoptCameraSettings(n) } set inputBuffer (i) { this.uniforms.inputBuffer.value = i } setInputBuffer (i) { this.uniforms.inputBuffer.value = i } get depthBuffer () { return this.uniforms.depthBuffer.value } set depthBuffer (i) { this.uniforms.depthBuffer.value = i } get depthPacking () { return Number(this.defines.DEPTH_PACKING) } set depthPacking (i) { this.defines.DEPTH_PACKING = i.toFixed(0), this.needsUpdate = !0 } setDepthBuffer (i, t = tr) { this.depthBuffer = i, this.depthPacking = t } setShaderParts (i) { return this.fragmentShader = B6.replace(cs.FRAGMENT_HEAD, i.get(cs.FRAGMENT_HEAD)).replace(cs.FRAGMENT_MAIN_UV, i.get(cs.FRAGMENT_MAIN_UV)).replace(cs.FRAGMENT_MAIN_IMAGE, i.get(cs.FRAGMENT_MAIN_IMAGE)), this.vertexShader = F6.replace(cs.VERTEX_HEAD, i.get(cs.VERTEX_HEAD)).replace(cs.VERTEX_MAIN_SUPPORT, i.get(cs.VERTEX_MAIN_SUPPORT)), this.needsUpdate = !0, this } setDefines (i) { for (let t of i.entries()) this.defines[t[0]] = t[1]; return this.needsUpdate = !0, this } setUniforms (i) { for (let t of i.entries()) this.uniforms[t[0]] = t[1]; return this } setExtensions (i) { this.extensions = {}; for (let t of i) this.extensions[t] = !0; return this } get encodeOutput () { return this.defines.ENCODE_OUTPUT !== void 0 } set encodeOutput (i) { this.encodeOutput !== i && (i ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0) } isOutputEncodingEnabled (i) { return this.encodeOutput } setOutputEncodingEnabled (i) { this.encodeOutput = i } get time () { return this.uniforms.time.value } set time (i) { this.uniforms.time.value = i } setDeltaTime (i) { this.uniforms.time.value += i } adoptCameraSettings (i) { i && (this.uniforms.cameraNear.value = i.near, this.uniforms.cameraFar.value = i.far, i instanceof xn ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0) } setSize (i, t) { let e = this.uniforms; e.resolution.value.set(i, t), e.texelSize.value.set(1 / i, 1 / t), e.aspect.value = i / t } static get Section () { return cs } }; var k6 = `#include <common>
#if THREE_REVISION < 143
#define luminance(v) linearToRelativeLuminance(v)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l);
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*l,l);
#else
gl_FragColor=vec4(l);
#endif
}`, U6 = class extends it { constructor(i = !1, t = null) { super({ name: "LuminanceMaterial", defines: { THREE_REVISION: vo.replace(/\D+/g, "") }, uniforms: { inputBuffer: new oe(null), threshold: new oe(0), smoothing: new oe(1), range: new oe(null) }, blending: Ot, depthWrite: !1, depthTest: !1, fragmentShader: k6, vertexShader: lp }), this.toneMapped = !1, this.colorOutput = i, this.luminanceRange = t } set inputBuffer (i) { this.uniforms.inputBuffer.value = i } setInputBuffer (i) { this.uniforms.inputBuffer.value = i } get threshold () { return this.uniforms.threshold.value } set threshold (i) { this.smoothing > 0 || i > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = i } getThreshold () { return this.threshold } setThreshold (i) { this.threshold = i } get smoothing () { return this.uniforms.smoothing.value } set smoothing (i) { this.threshold > 0 || i > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = i } getSmoothingFactor () { return this.smoothing } setSmoothingFactor (i) { this.smoothing = i } get useThreshold () { return this.threshold > 0 || this.smoothing > 0 } set useThreshold (i) { } get colorOutput () { return this.defines.COLOR !== void 0 } set colorOutput (i) { i ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0 } isColorOutputEnabled (i) { return this.colorOutput } setColorOutputEnabled (i) { this.colorOutput = i } get useRange () { return this.luminanceRange !== null } set useRange (i) { this.luminanceRange = null } get luminanceRange () { return this.uniforms.range.value } set luminanceRange (i) { i !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = i, this.needsUpdate = !0 } getLuminanceRange () { return this.luminanceRange } setLuminanceRange (i) { this.luminanceRange = i } }, z6 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef MASK_PRECISION_HIGH
uniform mediump sampler2D maskTexture;
#else
uniform lowp sampler2D maskTexture;
#endif
#if MASK_FUNCTION != 0
uniform float strength;
#endif
varying vec2 vUv;void main(){
#if COLOR_CHANNEL == 0
float mask=texture2D(maskTexture,vUv).r;
#elif COLOR_CHANNEL == 1
float mask=texture2D(maskTexture,vUv).g;
#elif COLOR_CHANNEL == 2
float mask=texture2D(maskTexture,vUv).b;
#else
float mask=texture2D(maskTexture,vUv).a;
#endif
#if MASK_FUNCTION == 0
#ifdef INVERTED
mask=step(mask,0.0);
#else
mask=1.0-step(mask,0.0);
#endif
#else
mask=clamp(mask*strength,0.0,1.0);
#ifdef INVERTED
mask=1.0-mask;
#endif
#endif
#if MASK_FUNCTION == 2
gl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);
#else
gl_FragColor=mask*texture2D(inputBuffer,vUv);
#endif
}`, gI = { DISCARD: 0, MULTIPLY: 1, MULTIPLY_RGB_SET_ALPHA: 2 }, G6 = class extends it { constructor(i = null) { super({ name: "MaskMaterial", uniforms: { maskTexture: new oe(i), inputBuffer: new oe(null), strength: new oe(1) }, blending: Ot, depthWrite: !1, depthTest: !1, fragmentShader: z6, vertexShader: lp }), this.toneMapped = !1, this.setColorChannel(mI.RED), this.setMaskFunction(gI.DISCARD) } set inputBuffer (i) { this.uniforms.inputBuffer.value = i } setInputBuffer (i) { this.uniforms.inputBuffer.value = i } set maskTexture (i) { this.uniforms.maskTexture.value = i, delete this.defines.MASK_PRECISION_HIGH, i.type !== Zt && (this.defines.MASK_PRECISION_HIGH = "1"), this.needsUpdate = !0 } setMaskTexture (i) { this.maskTexture = i } set colorChannel (i) { this.defines.COLOR_CHANNEL = i.toFixed(0), this.needsUpdate = !0 } setColorChannel (i) { this.colorChannel = i } set maskFunction (i) { this.defines.MASK_FUNCTION = i.toFixed(0), this.needsUpdate = !0 } setMaskFunction (i) { this.maskFunction = i } get inverted () { return this.defines.INVERTED !== void 0 } set inverted (i) { this.inverted && !i ? delete this.defines.INVERTED : i && (this.defines.INVERTED = "1"), this.needsUpdate = !0 } isInverted () { return this.inverted } setInverted (i) { this.inverted = i } get strength () { return this.uniforms.strength.value } set strength (i) { this.uniforms.strength.value = i } getStrength () { return this.strength } setStrength (i) { this.strength = i } }; var V6 = `#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)
#if __VERSION__ < 300
#define round(v) floor(v + 0.5)
#endif
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);
#endif
}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){
#if !defined(DISABLE_CORNER_DETECTION)
vec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);
#endif
}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){
#if !defined(DISABLE_DIAG_DETECTION)
weights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){
#endif
vec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);
#if !defined(DISABLE_DIAG_DETECTION)
}else{e.r=0.0;}
#endif
}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}`, H6 = "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}", j6 = class extends it { constructor(i = new B, t = new B) { super({ name: "SMAAWeightsMaterial", defines: { MAX_SEARCH_STEPS_INT: "16", MAX_SEARCH_STEPS_FLOAT: "16.0", MAX_SEARCH_STEPS_DIAG_INT: "8", MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0", CORNER_ROUNDING: "25", CORNER_ROUNDING_NORM: "0.25", AREATEX_MAX_DISTANCE: "16.0", AREATEX_MAX_DISTANCE_DIAG: "20.0", AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))", AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)", SEARCHTEX_SIZE: "vec2(66.0, 33.0)", SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)" }, uniforms: { inputBuffer: new oe(null), searchTexture: new oe(null), areaTexture: new oe(null), resolution: new oe(t), texelSize: new oe(i) }, blending: Ot, depthWrite: !1, depthTest: !1, fragmentShader: V6, vertexShader: H6 }), this.toneMapped = !1 } set inputBuffer (i) { this.uniforms.inputBuffer.value = i } setInputBuffer (i) { this.uniforms.inputBuffer.value = i } get searchTexture () { return this.uniforms.searchTexture.value } set searchTexture (i) { this.uniforms.searchTexture.value = i } get areaTexture () { return this.uniforms.areaTexture.value } set areaTexture (i) { this.uniforms.areaTexture.value = i } setLookupTextures (i, t) { this.searchTexture = i, this.areaTexture = t } get orthogonalSearchSteps () { return Number(this.defines.MAX_SEARCH_STEPS_INT) } set orthogonalSearchSteps (i) { let t = Math.min(Math.max(i, 0), 112); this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1"), this.needsUpdate = !0 } setOrthogonalSearchSteps (i) { this.orthogonalSearchSteps = i } get diagonalSearchSteps () { return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT) } set diagonalSearchSteps (i) { let t = Math.min(Math.max(i, 0), 20); this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0"), this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1"), this.needsUpdate = !0 } setDiagonalSearchSteps (i) { this.diagonalSearchSteps = i } get diagonalDetection () { return this.defines.DISABLE_DIAG_DETECTION === void 0 } set diagonalDetection (i) { i ? delete this.defines.DISABLE_DIAG_DETECTION : this.defines.DISABLE_DIAG_DETECTION = "1", this.needsUpdate = !0 } isDiagonalDetectionEnabled () { return this.diagonalDetection } setDiagonalDetectionEnabled (i) { this.diagonalDetection = i } get cornerRounding () { return Number(this.defines.CORNER_ROUNDING) } set cornerRounding (i) { let t = Math.min(Math.max(i, 0), 100); this.defines.CORNER_ROUNDING = t.toFixed("4"), this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4"), this.needsUpdate = !0 } setCornerRounding (i) { this.cornerRounding = i } get cornerDetection () { return this.defines.DISABLE_CORNER_DETECTION === void 0 } set cornerDetection (i) { i ? delete this.defines.DISABLE_CORNER_DETECTION : this.defines.DISABLE_CORNER_DETECTION = "1", this.needsUpdate = !0 } isCornerRoundingEnabled () { return this.cornerDetection } setCornerRoundingEnabled (i) { this.cornerDetection = i } setSize (i, t) { let e = this.uniforms; e.texelSize.value.set(1 / i, 1 / t), e.resolution.value.set(i, t) } }; var W6 = new qi, Va = null; function q6 () { if (Va === null) { let i = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]), t = new Float32Array([0, 0, 2, 0, 0, 2]); Va = new Ce, Va.setAttribute !== void 0 ? (Va.setAttribute("position", new ze(i, 3)), Va.setAttribute("uv", new ze(t, 2))) : (Va.addAttribute("position", new ze(i, 3)), Va.addAttribute("uv", new ze(t, 2))) } return Va } var Fn = class { constructor(i = "Pass", t = new yr, e = W6) { this.name = i, this.renderer = null, this.scene = t, this.camera = e, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0 } get renderToScreen () { return !this.rtt } set renderToScreen (i) { if (this.rtt === i) { let t = this.getFullscreenMaterial(); t !== null && (t.needsUpdate = !0), this.rtt = !i } } setRenderer (i) { this.renderer = i } isEnabled () { return this.enabled } setEnabled (i) { this.enabled = i } get fullscreenMaterial () { return this.screen !== null ? this.screen.material : null } set fullscreenMaterial (i) { let t = this.screen; t !== null ? t.material = i : (t = new Rn(q6(), i), t.frustumCulled = !1, this.scene === null && (this.scene = new yr), this.scene.add(t), this.screen = t) } getFullscreenMaterial () { return this.fullscreenMaterial } setFullscreenMaterial (i) { this.fullscreenMaterial = i } getDepthTexture () { return null } setDepthTexture (i, t = tr) { } render (i, t, e, n, r) { throw new Error("Render method not implemented!") } setSize (i, t) { } initialize (i, t, e) { } dispose () { for (let i of Object.keys(this)) { let t = this[i]; if (t !== null && typeof t.dispose == "function") { if (t instanceof yr || t === this.renderer) continue; this[i].dispose() } } } }, cp = class extends Fn { constructor(i, t = !0) { super("CopyPass"), this.fullscreenMaterial = new D6, this.needsSwap = !1, this.renderTarget = i, i === void 0 && (this.renderTarget = new at(1, 1, { minFilter: Ke, magFilter: Ke, stencilBuffer: !1, depthBuffer: !1 }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = t } get resize () { return this.autoResize } set resize (i) { this.autoResize = i } get texture () { return this.renderTarget.texture } getTexture () { return this.renderTarget.texture } setAutoResizeEnabled (i) { this.autoResize = i } render (i, t, e, n, r) { this.fullscreenMaterial.inputBuffer = t.texture, i.setRenderTarget(this.renderToScreen ? null : this.renderTarget), i.render(this.scene, this.camera) } setSize (i, t) { this.autoResize && this.renderTarget.setSize(i, t) } initialize (i, t, e) { e !== void 0 && (this.renderTarget.texture.type = e, e !== Zt ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : i.outputEncoding === Je && (this.renderTarget.texture.encoding = Je)) } }; var yI = class extends Fn { constructor() { super("ClearMaskPass", null, null), this.needsSwap = !1 } render (i, t, e, n, r) { let s = i.state.buffers.stencil; s.setLocked(!1), s.setTest(!1) } }, LS = new Le, zS = class extends Fn { constructor(i = !0, t = !0, e = !1) { super("ClearPass", null, null), this.needsSwap = !1, this.color = i, this.depth = t, this.stencil = e, this.overrideClearColor = null, this.overrideClearAlpha = -1 } setClearFlags (i, t, e) { this.color = i, this.depth = t, this.stencil = e } getOverrideClearColor () { return this.overrideClearColor } setOverrideClearColor (i) { this.overrideClearColor = i } getOverrideClearAlpha () { return this.overrideClearAlpha } setOverrideClearAlpha (i) { this.overrideClearAlpha = i } render (i, t, e, n, r) { let s = this.overrideClearColor, o = this.overrideClearAlpha, a = i.getClearAlpha(), l = s !== null, u = o >= 0; l ? (LS.copy(i.getClearColor(LS)), i.setClearColor(s, u ? o : a)) : u && i.setClearAlpha(o), i.setRenderTarget(this.renderToScreen ? null : t), i.clear(this.color, this.depth, this.stencil), l ? i.setClearColor(LS, a) : u && i.setClearAlpha(a) } }, Ha = -1, ei = class extends kt { constructor(i, t = Ha, e = Ha, n = 1) { super(), this.resizable = i, this.base = new B(1, 1), this.preferred = new B(t, e), this.target = this.preferred, this.s = n } get width () { let { base: i, preferred: t, scale: e } = this, n; return t.width !== Ha ? n = t.width : t.height !== Ha ? n = Math.round(t.height * (i.width / Math.max(i.height, 1))) : n = Math.round(i.width * e), n } set width (i) { this.preferredWidth = i } get height () { let { base: i, preferred: t, scale: e } = this, n; return t.height !== Ha ? n = t.height : t.width !== Ha ? n = Math.round(t.width / Math.max(i.width / Math.max(i.height, 1), 1)) : n = Math.round(i.height * e), n } set height (i) { this.preferredHeight = i } getWidth () { return this.width } getHeight () { return this.height } get scale () { return this.s } set scale (i) { this.s !== i && (this.s = i, this.preferred.setScalar(Ha), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.base.width, this.base.height)) } getScale () { return this.scale } setScale (i) { this.scale = i } get baseWidth () { return this.base.width } set baseWidth (i) { this.base.width !== i && (this.base.width = i, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.base.width, this.base.height)) } getBaseWidth () { return this.base.width } setBaseWidth (i) { this.base.width !== i && (this.base.width = i, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.base.width, this.base.height)) } get baseHeight () { return this.base.height } set baseHeight (i) { this.base.height !== i && (this.base.height = i, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.base.width, this.base.height)) } getBaseHeight () { return this.baseHeight } setBaseHeight (i) { this.baseHeight = i } setBaseSize (i, t) { (this.base.width !== i || this.base.height !== t) && (this.base.set(i, t), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.base.width, this.base.height)) } get preferredWidth () { return this.preferred.width } set preferredWidth (i) { this.preferred.width !== i && (this.preferred.width = i, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.base.width, this.base.height)) } getPreferredWidth () { return this.preferredWidth } setPreferredWidth (i) { this.preferredWidth = i } get preferredHeight () { return this.preferred.height } set preferredHeight (i) { this.preferred.height !== i && (this.preferred.height = i, this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.base.width, this.base.height)) } getPreferredHeight () { return this.preferredHeight } setPreferredHeight (i) { this.preferredHeight = i } setPreferredSize (i, t) { (this.preferred.width !== i || this.preferred.height !== t) && (this.preferred.set(i, t), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.base.width, this.base.height)) } copy (i) { this.base.set(i.getBaseWidth(), i.getBaseHeight()), this.preferred.set(i.getPreferredWidth(), i.getPreferredHeight()), this.dispatchEvent({ type: "change" }), this.resizable.setSize(this.base.width, this.base.height) } static get AUTO_SIZE () { return Ha } }, NS = !1, hI = class { constructor(i = null) { this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(i), this.meshCount = 0, this.replaceMaterial = t => { if (t.isMesh) { let e; if (t.material.flatShading) switch (t.material.side) { case Nr: e = this.materialsFlatShadedDoubleSide; break; case Ln: e = this.materialsFlatShadedBackSide; break; default: e = this.materialsFlatShaded; break } else switch (t.material.side) { case Nr: e = this.materialsDoubleSide; break; case Ln: e = this.materialsBackSide; break; default: e = this.materials; break }this.originalMaterials.set(t, t.material), t.isSkinnedMesh ? t.material = e[2] : t.isInstancedMesh ? t.material = e[1] : t.material = e[0], ++this.meshCount } } } setMaterial (i) { if (this.disposeMaterials(), this.material = i, i !== null) { let t = this.materials = [i.clone(), i.clone(), i.clone()]; for (let e of t) e.uniforms = Object.assign({}, i.uniforms), e.side = ai; t[2].skinning = !0, this.materialsBackSide = t.map(e => { let n = e.clone(); return n.uniforms = Object.assign({}, i.uniforms), n.side = Ln, n }), this.materialsDoubleSide = t.map(e => { let n = e.clone(); return n.uniforms = Object.assign({}, i.uniforms), n.side = Nr, n }), this.materialsFlatShaded = t.map(e => { let n = e.clone(); return n.uniforms = Object.assign({}, i.uniforms), n.flatShading = !0, n }), this.materialsFlatShadedBackSide = t.map(e => { let n = e.clone(); return n.uniforms = Object.assign({}, i.uniforms), n.flatShading = !0, n.side = Ln, n }), this.materialsFlatShadedDoubleSide = t.map(e => { let n = e.clone(); return n.uniforms = Object.assign({}, i.uniforms), n.flatShading = !0, n.side = Nr, n }) } } render (i, t, e) { let n = i.shadowMap.enabled; if (i.shadowMap.enabled = !1, NS) { let r = this.originalMaterials; this.meshCount = 0, t.traverse(this.replaceMaterial), i.render(t, e); for (let s of r) s[0].material = s[1]; this.meshCount !== r.size && r.clear() } else { let r = t.overrideMaterial; t.overrideMaterial = this.material, i.render(t, e), t.overrideMaterial = r } i.shadowMap.enabled = n } disposeMaterials () { if (this.material !== null) { let i = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide); for (let t of i) t.dispose() } } dispose () { this.originalMaterials.clear(), this.disposeMaterials() } static get workaroundEnabled () { return NS } static set workaroundEnabled (i) { NS = i } }, Y6 = class extends Fn { constructor(i, t, e = null) { super("RenderPass", i, t), this.needsSwap = !1, this.clearPass = new zS, this.overrideMaterialManager = e === null ? null : new hI(e), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null } get renderToScreen () { return super.renderToScreen } set renderToScreen (i) { super.renderToScreen = i, this.clearPass.renderToScreen = i } get overrideMaterial () { let i = this.overrideMaterialManager; return i !== null ? i.material : null } set overrideMaterial (i) { let t = this.overrideMaterialManager; i !== null ? t !== null ? t.setMaterial(i) : this.overrideMaterialManager = new hI(i) : t !== null && (t.dispose(), this.overrideMaterialManager = null) } getOverrideMaterial () { return this.overrideMaterial } setOverrideMaterial (i) { this.overrideMaterial = i } get clear () { return this.clearPass.enabled } set clear (i) { this.clearPass.enabled = i } getSelection () { return this.selection } setSelection (i) { this.selection = i } isBackgroundDisabled () { return this.ignoreBackground } setBackgroundDisabled (i) { this.ignoreBackground = i } isShadowMapDisabled () { return this.skipShadowMapUpdate } setShadowMapDisabled (i) { this.skipShadowMapUpdate = i } getClearPass () { return this.clearPass } render (i, t, e, n, r) { let s = this.scene, o = this.camera, a = this.selection, l = o.layers.mask, u = s.background, c = i.shadowMap.autoUpdate, h = this.renderToScreen ? null : t; a !== null && o.layers.set(a.getLayer()), this.skipShadowMapUpdate && (i.shadowMap.autoUpdate = !1), (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (s.background = null), this.clearPass.enabled && this.clearPass.render(i, t), i.setRenderTarget(h), this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(i, s, o) : i.render(s, o), o.layers.mask = l, s.background = u, i.shadowMap.autoUpdate = c } }, GS = class extends Fn { constructor(i, t, { resolutionScale: e = 1, width: n = ei.AUTO_SIZE, height: r = ei.AUTO_SIZE, renderTarget: s } = {}) { super("DepthPass"), this.needsSwap = !1, this.renderPass = new Y6(i, t, new Wd({ depthPacking: Yx })); let o = this.renderPass; o.skipShadowMapUpdate = !0, o.ignoreBackground = !0; let a = o.getClearPass(); a.overrideClearColor = new Le(16777215), a.overrideClearAlpha = 1, this.renderTarget = s, this.renderTarget === void 0 && (this.renderTarget = new at(1, 1, { minFilter: Dt, magFilter: Dt, stencilBuffer: !1 }), this.renderTarget.texture.name = "DepthPass.Target"); let l = this.resolution = new ei(this, n, r, e); l.addEventListener("change", u => this.setSize(l.baseWidth, l.baseHeight)) } get texture () { return this.renderTarget.texture } getTexture () { return this.renderTarget.texture } getResolution () { return this.resolution } getResolutionScale () { return this.resolution.scale } setResolutionScale (i) { this.resolution.scale = i } render (i, t, e, n, r) { let s = this.renderToScreen ? null : this.renderTarget; this.renderPass.render(i, s) } setSize (i, t) { let e = this.resolution; e.setBaseSize(i, t), this.renderTarget.setSize(e.width, e.height) } }; var R1e = new Float32Array([255 / 256 / 256 ** 3, 255 / 256 / 256 ** 2, 255 / 256 / 256, 255 / 256]); var ht = { SKIP: 0, ADD: 1, ALPHA: 2, AVERAGE: 3, COLOR_BURN: 4, COLOR_DODGE: 5, DARKEN: 6, DIFFERENCE: 7, EXCLUSION: 8, LIGHTEN: 9, MULTIPLY: 10, DIVIDE: 11, NEGATION: 12, NORMAL: 13, OVERLAY: 14, REFLECT: 15, SCREEN: 16, SOFT_LIGHT: 17, SUBTRACT: 18 }, X6 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}", Q6 = "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}", K6 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}", Z6 = "float blend(const in float x,const in float y){return(y==0.0)?y:max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", J6 = "float blend(const in float x,const in float y){return(y==1.0)?y:min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", $6 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}", e8 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}", t8 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}", n8 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}", r8 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}", i8 = "float blend(const in float x,const in float y){return(y>0.0)?min(x/y,1.0):1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", s8 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}", o8 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}", a8 = "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", l8 = "float blend(const in float x,const in float y){return(y==1.0)?y:min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", c8 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}", u8 = "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}", h8 = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}", d8 = new Map([[ht.SKIP, null], [ht.ADD, X6], [ht.ALPHA, Q6], [ht.AVERAGE, K6], [ht.COLOR_BURN, Z6], [ht.COLOR_DODGE, J6], [ht.DARKEN, $6], [ht.DIFFERENCE, e8], [ht.EXCLUSION, t8], [ht.LIGHTEN, n8], [ht.MULTIPLY, r8], [ht.DIVIDE, i8], [ht.NEGATION, s8], [ht.NORMAL, o8], [ht.OVERLAY, a8], [ht.REFLECT, l8], [ht.SCREEN, c8], [ht.SOFT_LIGHT, u8], [ht.SUBTRACT, h8]]), f8 = class extends kt { constructor(i, t = 1) { super(), this.f = i, this.opacity = new oe(t) } getOpacity () { return this.opacity.value } setOpacity (i) { this.opacity.value = i } get blendFunction () { return this.f } set blendFunction (i) { this.f = i, this.dispatchEvent({ type: "change" }) } getBlendFunction () { return this.blendFunction } setBlendFunction (i) { this.blendFunction = i } getShaderCode () { return d8.get(this.blendFunction) } }, qs = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 }; var Ys = class extends kt { constructor(i, t, { attributes: e = qs.NONE, blendFunction: n = ht.SCREEN, defines: r = new Map, uniforms: s = new Map, extensions: o = null, vertexShader: a = null } = {}) { super(), this.name = i, this.renderer = null, this.attributes = e, this.fragmentShader = t, this.vertexShader = a, this.defines = r, this.uniforms = s, this.extensions = o, this.blendMode = new f8(n), this.blendMode.addEventListener("change", l => this.setChanged()) } getName () { return this.name } setRenderer (i) { this.renderer = i } getDefines () { return this.defines } getUniforms () { return this.uniforms } getExtensions () { return this.extensions } getBlendMode () { return this.blendMode } getAttributes () { return this.attributes } setAttributes (i) { this.attributes = i, this.setChanged() } getFragmentShader () { return this.fragmentShader } setFragmentShader (i) { this.fragmentShader = i, this.setChanged() } getVertexShader () { return this.vertexShader } setVertexShader (i) { this.vertexShader = i, this.setChanged() } setChanged () { this.dispatchEvent({ type: "change" }) } setDepthTexture (i, t = tr) { } update (i, t, e) { } setSize (i, t) { } initialize (i, t, e) { } dispose () { for (let i of Object.keys(this)) { let t = this[i]; if (t !== null && typeof t.dispose == "function") { if (t instanceof yr || t === this.renderer) continue; this[i].dispose() } } } }; function dI (i, t, e) { for (let n of t) { let r = "$1" + i + n.charAt(0).toUpperCase() + n.slice(1), s = new RegExp("([^\\.])(\\b" + n + "\\b)", "g"); for (let o of e.entries()) o[1] !== null && e.set(o[0], o[1].replace(s, r)) } } function p8 (i, t, e, n, r, s, o) {
	let a = new Map([["fragment", t.getFragmentShader()], ["vertex", t.getVertexShader()]]), l = a.get("fragment") !== void 0 && /mainImage/.test(a.get("fragment")), u = a.get("fragment") !== void 0 && /mainUv/.test(a.get("fragment")), c = [], h = [], d = !1, f = !1; if (a.get("fragment") === void 0) console.error("Missing fragment shader", t); else if (u && (o & qs.CONVOLUTION) !== 0) console.error("Effects that transform UV coordinates are incompatible with convolution effects", t); else if (!l && !u) console.error("The fragment shader contains neither a mainImage nor a mainUv function", t); else {
		let p = /(?:\w+\s+(\w+)\([\w\s,]*\)\s*{[^}]+})/g, m = US.Section; if (u) {
			let y = `	${i}MainUv(UV);
`; e.set(m.FRAGMENT_MAIN_UV, e.get(m.FRAGMENT_MAIN_UV) + y), d = !0
		} if (a.get("vertex") !== null && /mainSupport/.test(a.get("vertex"))) {
			let y = `	${i}MainSupport(`; y += /mainSupport *\([\w\s]*?uv\s*?\)/.test(a.get("vertex")) ? `vUv);
`: `);
`, e.set(m.VERTEX_MAIN_SUPPORT, e.get(m.VERTEX_MAIN_SUPPORT) + y), c = c.concat([...a.get("vertex").matchAll(/(?:varying\s+\w+\s+(\w*))/g)].map(v => v[1])), h = h.concat(c).concat([...a.get("vertex").matchAll(p)].map(v => v[1]))
		} h = h.concat([...a.get("fragment").matchAll(p)].map(y => y[1])), h = h.concat([...t.defines.keys()].map(y => y.replace(/\([\w\s,]*\)/g, ""))), h = h.concat([...t.uniforms.keys()]), t.uniforms.forEach((y, v) => s.set(i + v.charAt(0).toUpperCase() + v.slice(1), y)), t.defines.forEach((y, v) => r.set(i + v.charAt(0).toUpperCase() + v.slice(1), y)), dI(i, h, r), dI(i, h, a); let g = t.blendMode; if (n.set(g.blendFunction, g), l) {
			let y = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/, v = `${i}MainImage(color0, UV, `; (o & qs.DEPTH) !== 0 && y.test(a.get("fragment")) && (v += "depth, ", f = !0), v += `color1);
	`; let x = i + "BlendOpacity"; s.set(x, g.opacity), v += `color0 = blend${g.blendFunction}(color0, color1, ${x});

	`, e.set(m.FRAGMENT_MAIN_IMAGE, e.get(m.FRAGMENT_MAIN_IMAGE) + v), v = `uniform float ${x};

`, e.set(m.FRAGMENT_HEAD, e.get(m.FRAGMENT_HEAD) + v)
		} e.set(m.FRAGMENT_HEAD, e.get(m.FRAGMENT_HEAD) + a.get("fragment") + `
`), a.get("vertex") !== null && e.set(m.VERTEX_HEAD, e.get(m.VERTEX_HEAD) + a.get("vertex") + `
`)
	} return { varyings: c, transformedUv: d, readDepth: f }
} var Kl = class extends Fn {
	constructor(i, ...t) { super("EffectPass"), this.fullscreenMaterial = new US(null, null, null, i), this.effects = t.sort((e, n) => n.attributes - e.attributes), this.skipRendering = !1, this.uniformCount = 0, this.varyingCount = 0, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY } get encodeOutput () { return this.fullscreenMaterial.encodeOutput } set encodeOutput (i) { this.fullscreenMaterial.encodeOutput = i } get dithering () { return this.fullscreenMaterial.dithering } set dithering (i) { let t = this.fullscreenMaterial; t.dithering = i, t.needsUpdate = !0 } verifyResources () { let i = this.renderer.capabilities, t = Math.min(i.maxFragmentUniforms, i.maxVertexUniforms); this.uniformCount > t && console.warn("The current rendering context doesn't support more than " + t + " uniforms, but " + this.uniformCount + " were defined"), t = i.maxVaryings, this.varyingCount > t && console.warn("The current rendering context doesn't support more than " + t + " varyings, but " + this.varyingCount + " were defined") } updateMaterial () {
		let i = US.Section, t = new Map([[i.FRAGMENT_HEAD, ""], [i.FRAGMENT_MAIN_UV, ""], [i.FRAGMENT_MAIN_IMAGE, ""], [i.VERTEX_HEAD, ""], [i.VERTEX_MAIN_SUPPORT, ""]]), e = new Map, n = new Map, r = new Map, s = new Set, o = 0, a = 0, l = 0, u = !1, c = !1; for (let d of this.effects) if (d.blendMode.blendFunction === ht.SKIP) l |= d.getAttributes() & qs.DEPTH; else if ((l & d.getAttributes() & qs.CONVOLUTION) !== 0) console.error("Convolution effects cannot be merged", d); else { l |= d.getAttributes(); let f = "e" + o++, p = p8(f, d, t, e, n, r, l); if (a += p.varyings.length, u = u || p.transformedUv, c = c || p.readDepth, d.extensions !== null) for (let m of d.extensions) s.add(m) } let h = /\bblend\b/g; for (let d of e.values()) {
			let f = d.getShaderCode().replace(h, `blend${d.blendFunction}`); t.set(i.FRAGMENT_HEAD, t.get(i.FRAGMENT_HEAD) + f + `
`)
		} if ((l & qs.DEPTH) !== 0) {
			if (c) {
				let d = `float depth = readDepth(UV);

	`; t.set(i.FRAGMENT_MAIN_IMAGE, d + t.get(i.FRAGMENT_MAIN_IMAGE))
			} this.needsDepthTexture = this.getDepthTexture() === null
		} else this.needsDepthTexture = !1; if (u) {
			let d = `vec2 transformedUv = vUv;
`; t.set(i.FRAGMENT_MAIN_UV, d + t.get(i.FRAGMENT_MAIN_UV)), n.set("UV", "transformedUv")
		} else n.set("UV", "vUv"); t.forEach((d, f, p) => p.set(f, d.trim().replace(/^#/, `
#`))), this.uniformCount = r.size, this.varyingCount = a, this.skipRendering = o === 0, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderParts(t).setExtensions(s).setUniforms(r).setDefines(n)
	} recompile () { this.updateMaterial(), this.verifyResources() } getDepthTexture () { return this.fullscreenMaterial.depthBuffer } setDepthTexture (i, t = tr) { this.fullscreenMaterial.depthBuffer = i, this.fullscreenMaterial.depthPacking = t; for (let e of this.effects) e.setDepthTexture(i, t) } render (i, t, e, n, r) { for (let s of this.effects) s.update(i, t, n); if (!this.skipRendering || this.renderToScreen) { let s = this.fullscreenMaterial; s.inputBuffer = t.texture, s.time += n, i.setRenderTarget(this.renderToScreen ? null : e), i.render(this.scene, this.camera) } } setSize (i, t) { this.fullscreenMaterial.setSize(i, t); for (let e of this.effects) e.setSize(i, t) } initialize (i, t, e) { this.renderer = i; for (let n of this.effects) n.initialize(i, t, e), n.addEventListener("change", r => this.handleEvent(r)); this.updateMaterial(), this.verifyResources(), e !== void 0 && e !== Zt && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } dispose () { super.dispose(); for (let i of this.effects) i.dispose() } handleEvent (i) { switch (i.type) { case "change": this.recompile(); break } }
}, m8 = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])], vI = class extends Fn { constructor({ resolutionScale: i = .5, width: t = ei.AUTO_SIZE, height: e = ei.AUTO_SIZE, kernelSize: n = VS.LARGE } = {}) { super("KawaseBlurPass"), this.renderTargetA = new at(1, 1, { minFilter: Ke, magFilter: Ke, stencilBuffer: !1, depthBuffer: !1 }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B"; let r = this.resolution = new ei(this, t, e, i); r.addEventListener("change", s => this.setSize(r.baseWidth, r.baseHeight)), this.blurMaterial = new uI, this.ditheredBlurMaterial = new uI, this.ditheredBlurMaterial.uniforms.scale = this.blurMaterial.uniforms.scale, this.ditheredBlurMaterial.dithering = !0, this.dithering = !1, this.kernelSize = n } getResolution () { return this.resolution } get width () { return this.resolution.width } set width (i) { this.resolution.preferredWidth = i } get height () { return this.resolution.height } set height (i) { this.resolution.preferredHeight = i } get scale () { return this.blurMaterial.scale } set scale (i) { this.blurMaterial.scale = i } getScale () { return this.blurMaterial.scale } setScale (i) { this.blurMaterial.scale = i } getKernelSize () { return this.kernelSize } setKernelSize (i) { this.kernelSize = i } getResolutionScale () { return this.resolution.scale } setResolutionScale (i) { this.resolution.scale = i } render (i, t, e, n, r) { let s = this.scene, o = this.camera, a = this.renderTargetA, l = this.renderTargetB, u = m8[this.kernelSize], c = this.blurMaterial, h = t, d, f; for (this.fullscreenMaterial = c, d = 0, f = u.length - 1; d < f; ++d) { let p = (d & 1) === 0 ? a : l; c.kernel = u[d], c.inputBuffer = h.texture, i.setRenderTarget(p), i.render(s, o), h = p } this.dithering && (c = this.ditheredBlurMaterial, this.fullscreenMaterial = c), c.kernel = u[d], c.inputBuffer = h.texture, i.setRenderTarget(this.renderToScreen ? null : e), i.render(s, o) } setSize (i, t) { let e = this.resolution; e.setBaseSize(i, t); let n = e.width, r = e.height; this.renderTargetA.setSize(n, r), this.renderTargetB.setSize(n, r), this.blurMaterial.setSize(n, r), this.ditheredBlurMaterial.setSize(n, r) } initialize (i, t, e) { e !== void 0 && (this.renderTargetA.texture.type = e, this.renderTargetB.texture.type = e, e !== Zt ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.ditheredBlurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : i.outputEncoding === Je && (this.renderTargetA.texture.encoding = Je, this.renderTargetB.texture.encoding = Je)) } static get AUTO_SIZE () { return ei.AUTO_SIZE } }; var g8 = class extends Fn { constructor({ width: i = ei.AUTO_SIZE, height: t = ei.AUTO_SIZE, renderTarget: e, luminanceRange: n, colorOutput: r } = {}) { super("LuminancePass"), this.fullscreenMaterial = new U6(r, n), this.needsSwap = !1, this.renderTarget = e, this.renderTarget === void 0 && (this.renderTarget = new at(1, 1, { minFilter: Ke, magFilter: Ke, stencilBuffer: !1, depthBuffer: !1 }), this.renderTarget.texture.name = "LuminancePass.Target", this.renderTarget.texture.generateMipmaps = !1); let s = this.resolution = new ei(this, i, t); s.addEventListener("change", o => this.setSize(s.baseWidth, s.baseHeight)) } get texture () { return this.renderTarget.texture } getTexture () { return this.renderTarget.texture } getResolution () { return this.resolution } render (i, t, e, n, r) { let s = this.fullscreenMaterial; s.inputBuffer = t.texture, i.setRenderTarget(this.renderToScreen ? null : this.renderTarget), i.render(this.scene, this.camera) } setSize (i, t) { let e = this.resolution; e.setBaseSize(i, t), this.renderTarget.setSize(e.width, e.height) } initialize (i, t, e) { e !== void 0 && e !== Zt && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } }, xI = class extends Fn { constructor(i, t) { super("MaskPass", i, t), this.needsSwap = !1, this.clearPass = new zS(!1, !1, !0), this.inverse = !1 } get inverted () { return this.inverse } set inverted (i) { this.inverse = i } get clear () { return this.clearPass.enabled } set clear (i) { this.clearPass.enabled = i } getClearPass () { return this.clearPass } isInverted () { return this.inverted } setInverted (i) { this.inverted = i } render (i, t, e, n, r) { let s = i.getContext(), o = i.state.buffers, a = this.scene, l = this.camera, u = this.clearPass, c = this.inverted ? 0 : 1, h = 1 - c; o.color.setMask(!1), o.depth.setMask(!1), o.color.setLocked(!0), o.depth.setLocked(!0), o.stencil.setTest(!0), o.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), o.stencil.setFunc(s.ALWAYS, c, 4294967295), o.stencil.setClear(h), o.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? u.render(i, null) : (u.render(i, t), u.render(i, e))), this.renderToScreen ? (i.setRenderTarget(null), i.render(a, l)) : (i.setRenderTarget(t), i.render(a, l), i.setRenderTarget(e), i.render(a, l)), o.color.setLocked(!1), o.depth.setLocked(!1), o.stencil.setLocked(!1), o.stencil.setFunc(s.EQUAL, 1, 4294967295), o.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), o.stencil.setLocked(!0) } }; var Fi = class extends Fn { constructor(i, t = "inputBuffer") { super("ShaderPass"), this.fullscreenMaterial = i, this.inputBufferUniform = null, this.setInput(t) } setInput (i) { if (this.inputBufferUniform = null, this.fullscreenMaterial !== null) { let t = this.fullscreenMaterial.uniforms; t !== void 0 && t[i] !== void 0 && (this.inputBufferUniform = t[i]) } } render (i, t, e, n, r) { this.inputBufferUniform !== null && t !== null && (this.inputBufferUniform.value = t.texture), i.setRenderTarget(this.renderToScreen ? null : e), i.render(this.scene, this.camera) } initialize (i, t, e) { e !== void 0 && e !== Zt && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") } }, BS = 1 / 1e3, y8 = 1e3, bI = class { constructor() { this.previousTime = 0, this.currentTime = 0, this.delta = 0, this.fixedDelta = 1e3 / 60, this.elapsed = 0, this.timescale = 1, this.fixedDeltaEnabled = !1, this.autoReset = !1 } setFixedDeltaEnabled (i) { return this.fixedDeltaEnabled = i, this } isAutoResetEnabled (i) { return this.autoReset } setAutoResetEnabled (i) { return typeof document < "u" && document.hidden !== void 0 && (i ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this.autoReset = i), this } getDelta () { return this.delta * BS } getFixedDelta () { return this.fixedDelta * BS } setFixedDelta (i) { return this.fixedDelta = i * y8, this } getElapsed () { return this.elapsed * BS } getTimescale () { return this.timescale } setTimescale (i) { return this.timescale = i, this } update (i) { return this.fixedDeltaEnabled ? this.delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = i !== void 0 ? i : performance.now(), this.delta = this.currentTime - this.previousTime), this.delta *= this.timescale, this.elapsed += this.delta, this } reset () { return this.delta = 0, this.elapsed = 0, this.currentTime = performance.now(), this } handleEvent (i) { document.hidden || (this.currentTime = performance.now()) } dispose () { this.setAutoResetEnabled(!1) } }; var VS = { VERY_SMALL: 0, SMALL: 1, MEDIUM: 2, LARGE: 3, VERY_LARGE: 4, HUGE: 5 }; var v8 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=clamp(texture2D(map,uv)*intensity,0.0,1.0);}`, wI = class extends Ys { constructor({ blendFunction: i = ht.SCREEN, luminanceThreshold: t = .9, luminanceSmoothing: e = .025, resolutionScale: n = .5, intensity: r = 1, width: s = ei.AUTO_SIZE, height: o = ei.AUTO_SIZE, kernelSize: a = VS.LARGE } = {}) { super("BloomEffect", v8, { blendFunction: i, uniforms: new Map([["map", new oe(null)], ["intensity", new oe(r)]]) }), this.renderTarget = new at(1, 1, { minFilter: Ke, magFilter: Ke, stencilBuffer: !1, depthBuffer: !1 }), this.renderTarget.texture.name = "Bloom.Target", this.renderTarget.texture.generateMipmaps = !1, this.uniforms.get("map").value = this.renderTarget.texture, this.luminancePass = new g8({ renderTarget: this.renderTarget, colorOutput: !0 }), this.luminanceMaterial.threshold = t, this.luminanceMaterial.smoothingFactor = e, this.blurPass = new vI({ resolutionScale: n, width: s, height: o, kernelSize: a }); let l = this.blurPass.getResolution(); l.addEventListener("change", u => this.setSize(l.baseWidth, l.baseHeight)) } get texture () { return this.renderTarget.texture } getTexture () { return this.renderTarget.texture } get resolution () { return this.blurPass.resolution } getResolution () { return this.blurPass.resolution } getBlurPass () { return this.blurPass } getLuminancePass () { return this.luminancePass } get luminanceMaterial () { return this.luminancePass.fullscreenMaterial } getLuminanceMaterial () { return this.luminancePass.fullscreenMaterial } get width () { return this.resolution.width } set width (i) { this.resolution.preferredWidth = i } get height () { return this.resolution.height } set height (i) { this.resolution.preferredHeight = i } get dithering () { return this.blurPass.dithering } set dithering (i) { this.blurPass.dithering = i } get kernelSize () { return this.blurPass.kernelSize } set kernelSize (i) { this.blurPass.kernelSize = i } get distinction () { return console.warn(this.name, "distinction was removed"), 1 } set distinction (i) { console.warn(this.name, "distinction was removed") } get intensity () { return this.uniforms.get("intensity").value } set intensity (i) { this.uniforms.get("intensity").value = i } getIntensity () { return this.intensity } setIntensity (i) { this.intensity = i } getResolutionScale () { return this.resolution.scale } setResolutionScale (i) { this.resolution.scale = i } update (i, t, e) { let n = this.renderTarget; this.luminancePass.enabled ? (this.luminancePass.render(i, t, n), this.blurPass.render(i, n, n)) : this.blurPass.render(i, t, n) } setSize (i, t) { let e = this.resolution; e.setBaseSize(i, t), this.renderTarget.setSize(e.width, e.height), this.luminancePass.resolution.copy(e) } initialize (i, t, e) { this.blurPass.initialize(i, t, e), e !== void 0 && (this.renderTarget.texture.type = e, i.outputEncoding === Je && (this.renderTarget.texture.encoding = Je)) } }; var x8 = "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(min(color+vec3(0.5),1.0),inputColor.a);}", SI = class extends Ys { constructor({ blendFunction: i = ht.NORMAL, brightness: t = 0, contrast: e = 0 } = {}) { super("BrightnessContrastEffect", x8, { blendFunction: i, uniforms: new Map([["brightness", new oe(t)], ["contrast", new oe(e)]]) }) } get brightness () { return this.uniforms.get("brightness").value } set brightness (i) { this.uniforms.get("brightness").value = i } getBrightness (i) { return this.brightness } setBrightness (i) { this.brightness = i } get contrast () { return this.uniforms.get("contrast").value } set contrast (i) { this.uniforms.get("contrast").value = i } getContrast (i) { return this.contrast } setContrast (i) { this.contrast = i } }, b8 = "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(vec3(average(inputColor.rgb)),inputColor.a);}", AI = class extends Ys { constructor(i = ht.NORMAL) { super("ColorAverageEffect", b8, { blendFunction: i }) } }; var w8 = "varying vec2 vUvR;varying vec2 vUvB;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec2 ra=texture2D(inputBuffer,vUvR).ra;vec2 ba=texture2D(inputBuffer,vUvB).ba;outputColor=vec4(ra.x,inputColor.g,ba.x,max(max(ra.y,ba.y),inputColor.a));}", S8 = "uniform vec2 offset;varying vec2 vUvR;varying vec2 vUvB;void mainSupport(const in vec2 uv){vec2 shift=offset*vec2(1.0,aspect);vUvR=uv+shift;vUvB=uv-shift;}", _I = class extends Ys { constructor({ blendFunction: i = ht.NORMAL, offset: t = new B(.001, 5e-4) } = {}) { super("ChromaticAberrationEffect", w8, { vertexShader: S8, blendFunction: i, attributes: qs.CONVOLUTION, uniforms: new Map([["offset", new oe(t)]]) }) } get offset () { return this.uniforms.get("offset").value } set offset (i) { this.uniforms.get("offset").value = i } getOffset () { return this.offset } setOffset (i) { this.offset = i } }; var A8 = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;
#else
uniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;
#endif
uniform lowp sampler2D nearCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);float CoCNear=texture2D(nearCoCBuffer,uv).r;CoCNear=min(CoCNear*scale,1.0);vec4 result=inputColor*(1.0-colorFar.a)+colorFar;result=mix(result,colorNear,CoCNear);outputColor=result;}`, EI = class extends Ys { constructor(i, { blendFunction: t = ht.NORMAL, worldFocusDistance: e, worldFocusRange: n, focusDistance: r = 0, focalLength: s = .1, focusRange: o = s, bokehScale: a = 1, width: l = ei.AUTO_SIZE, height: u = ei.AUTO_SIZE } = {}) { super("DepthOfFieldEffect", A8, { blendFunction: t, attributes: qs.DEPTH, uniforms: new Map([["nearColorBuffer", new oe(null)], ["farColorBuffer", new oe(null)], ["nearCoCBuffer", new oe(null)], ["scale", new oe(1)]]) }), this.camera = i, this.renderTarget = new at(1, 1, { minFilter: Ke, magFilter: Ke, stencilBuffer: !1, depthBuffer: !1 }), this.renderTarget.texture.name = "DoF.Intermediate", this.renderTarget.texture.generateMipmaps = !1, this.renderTargetMasked = this.renderTarget.clone(), this.renderTargetMasked.texture.name = "DoF.Masked.Far", this.renderTargetNear = this.renderTarget.clone(), this.renderTargetNear.texture.name = "DoF.Bokeh.Near", this.uniforms.get("nearColorBuffer").value = this.renderTargetNear.texture, this.renderTargetFar = this.renderTarget.clone(), this.renderTargetFar.texture.name = "DoF.Bokeh.Far", this.uniforms.get("farColorBuffer").value = this.renderTargetFar.texture, this.renderTargetCoC = this.renderTarget.clone(), this.renderTargetCoC.texture.name = "DoF.CoC", this.renderTargetCoCBlurred = this.renderTargetCoC.clone(), this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred", this.uniforms.get("nearCoCBuffer").value = this.renderTargetCoCBlurred.texture, this.cocPass = new Fi(new T6(i)); let c = this.cocMaterial; c.focusDistance = r, c.focusRange = o, e !== void 0 && (c.worldFocusDistance = e), n !== void 0 && (c.worldFocusRange = n), this.blurPass = new vI({ kernelSize: VS.MEDIUM, width: l, height: u }); let h = this.blurPass.getResolution(); h.addEventListener("change", f => this.setSize(h.getBaseWidth(), h.getBaseHeight())), this.maskPass = new Fi(new G6(this.renderTargetCoC.texture)); let d = this.maskPass.fullscreenMaterial; d.maskFunction = gI.MULTIPLY, d.colorChannel = mI.GREEN, this.bokehNearBasePass = new Fi(new lv(!1, !0)), this.bokehNearBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehNearFillPass = new Fi(new lv(!0, !0)), this.bokehNearFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoCBlurred.texture, this.bokehFarBasePass = new Fi(new lv(!1, !1)), this.bokehFarBasePass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.bokehFarFillPass = new Fi(new lv(!0, !1)), this.bokehFarFillPass.fullscreenMaterial.cocBuffer = this.renderTargetCoC.texture, this.target = null, this.bokehScale = a } get cocTexture () { return this.renderTargetCoC.texture } get cocMaterial () { return this.cocPass.fullscreenMaterial } get circleOfConfusionMaterial () { return this.cocMaterial } getCircleOfConfusionMaterial () { return this.circleOfConfusionMaterial } getBlurPass () { return this.blurPass } get resolution () { return this.blurPass.getResolution() } getResolution () { return this.blurPass.getResolution() } get bokehScale () { return this.uniforms.get("scale").value } set bokehScale (i) { let t = [this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass]; for (let e of t) e.fullscreenMaterial.setScale(i); this.maskPass.fullscreenMaterial.setStrength(i), this.uniforms.get("scale").value = i } getBokehScale () { return this.bokehScale } setBokehScale (i) { this.bokehScale = i } getTarget () { return this.target } setTarget (i) { this.target = i } calculateFocusDistance (i) { let t = this.camera, e = t.position.distanceTo(i); return kS(-e, t.near, t.far) } setDepthTexture (i, t = tr) { this.circleOfConfusionMaterial.depthBuffer = i, this.circleOfConfusionMaterial.depthPacking = t } update (i, t, e) { let n = this.renderTarget, r = this.renderTargetCoC, s = this.renderTargetCoCBlurred, o = this.renderTargetMasked; if (this.target !== null) { let a = this.calculateFocusDistance(this.target); this.circleOfConfusionMaterial.focusDistance = a } this.cocPass.render(i, null, r), this.blurPass.render(i, r, s), this.maskPass.render(i, t, o), this.bokehFarBasePass.render(i, o, n), this.bokehFarFillPass.render(i, n, this.renderTargetFar), this.bokehNearBasePass.render(i, t, n), this.bokehNearFillPass.render(i, n, this.renderTargetNear) } setSize (i, t) { let e = this.resolution; e.setBaseSize(i, t); let n = e.width, r = e.height, s = [this.cocPass, this.blurPass, this.maskPass, this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass]; s.push(this.renderTargetCoC, this.renderTargetMasked), s.forEach(a => a.setSize(i, t)), s = [this.renderTarget, this.renderTargetNear, this.renderTargetFar, this.renderTargetCoCBlurred], s.forEach(a => a.setSize(n, r)), [this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass].forEach(a => a.fullscreenMaterial.setSize(n, r)) } initialize (i, t, e) { [this.cocPass, this.maskPass, this.bokehNearBasePass, this.bokehNearFillPass, this.bokehFarBasePass, this.bokehFarFillPass].forEach(r => r.initialize(i, t, e)), this.blurPass.initialize(i, t, Zt), e !== void 0 && (this.renderTarget.texture.type = e, this.renderTargetNear.texture.type = e, this.renderTargetFar.texture.type = e, this.renderTargetMasked.texture.type = e, i.outputEncoding === Je && (this.renderTarget.texture.encoding = Je, this.renderTargetNear.texture.encoding = Je, this.renderTargetFar.texture.encoding = Je, this.renderTargetMasked.texture.encoding = Je)) } }; var W1e = new A, q1e = new se; var _8 = "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}", MI = class extends Ys { constructor({ blendFunction: i = ht.NORMAL, hue: t = 0, saturation: e = 0 } = {}) { super("HueSaturationEffect", _8, { blendFunction: i, uniforms: new Map([["hue", new oe(new A)], ["saturation", new oe(e)]]) }), this.hue = t } get saturation () { return this.uniforms.get("saturation").value } set saturation (i) { this.uniforms.get("saturation").value = i } getSaturation () { return this.saturation } setSaturation (i) { this.saturation = i } get hue () { let i = this.uniforms.get("hue").value; return Math.acos((i.x * 3 - 1) / 2) } set hue (i) { let t = Math.sin(i), e = Math.cos(i); this.uniforms.get("hue").value.set((2 * e + 1) / 3, (-Math.sqrt(3) * t - e + 1) / 3, (Math.sqrt(3) * t - e + 1) / 3) } getHue () { return this.hue } setHue (i) { this.hue = i } }; var Q1e = new Le; var E8 = `void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*time));
#ifdef PREMULTIPLY
outputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);
#else
outputColor=vec4(noise,inputColor.a);
#endif
}`, TI = class extends Ys { constructor({ blendFunction: i = ht.SCREEN, premultiply: t = !1 } = {}) { super("NoiseEffect", E8, { blendFunction: i }), this.premultiply = t } get premultiply () { return this.defines.has("PREMULTIPLY") } set premultiply (i) { this.premultiply !== i && (i ? this.defines.set("PREMULTIPLY", "1") : this.defines.delete("PREMULTIPLY"), this.setChanged()) } isPremultiplied () { return this.premultiply } setPremultiplied (i) { this.premultiply = i } }; var M8 = "uniform bool active;uniform vec2 d;void mainUv(inout vec2 uv){if(active){uv=vec2(d.x*(floor(uv.x/d.x)+0.5),d.y*(floor(uv.y/d.y)+0.5));}}", CI = class extends Ys { constructor(i = 30) { super("PixelationEffect", M8, { uniforms: new Map([["active", new oe(!1)], ["d", new oe(new B)]]) }), this.resolution = new B, this.d = 0, this.granularity = i } get granularity () { return this.d } set granularity (i) { let t = Math.floor(i); t % 2 > 0 && (t += 1), this.d = t, this.uniforms.get("active").value = t > 0, this.setSize(this.resolution.width, this.resolution.height) } getGranularity () { return this.granularity } setGranularity (i) { this.granularity = i } setSize (i, t) { this.resolution.set(i, t), this.uniforms.get("d").value.setScalar(this.d).divide(this.resolution) } }; var J1e = Math.PI * .5, $1e = new A, eAe = new A; var fI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC", pI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC", T8 = "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}", C8 = "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}", Fo = { LOW: 0, MEDIUM: 1, HIGH: 2, ULTRA: 3 }, uv = class extends Ys { constructor({ preset: i = Fo.MEDIUM, edgeDetectionMode: t = Xh.COLOR, predicationMode: e = L6.DISABLED } = {}) { super("SMAAEffect", T8, { vertexShader: C8, blendFunction: ht.NORMAL, attributes: qs.CONVOLUTION | qs.DEPTH, uniforms: new Map([["weightMap", new oe(null)]]) }); let n, r; arguments.length > 1 && (n = arguments[0], r = arguments[1], arguments.length > 2 && (i = arguments[2]), arguments.length > 3 && (t = arguments[3])), this.renderTargetEdges = new at(1, 1, { minFilter: Ke, stencilBuffer: !1, depthBuffer: !1 }), this.renderTargetEdges.texture.name = "SMAA.Edges", this.renderTargetWeights = this.renderTargetEdges.clone(), this.renderTargetWeights.texture.name = "SMAA.Weights", this.uniforms.get("weightMap").value = this.renderTargetWeights.texture, this.clearPass = new zS(!0, !1, !1), this.clearPass.overrideClearColor = new Le(0), this.clearPass.overrideClearAlpha = 1, this.edgeDetectionPass = new Fi(new N6), this.edgeDetectionMaterial.edgeDetectionMode = t, this.edgeDetectionMaterial.predicationMode = e, this.weightsPass = new Fi(new j6); let s = new Jd; s.onLoad = () => { let o = new Qt(n); o.name = "SMAA.Search", o.magFilter = Dt, o.minFilter = Dt, o.generateMipmaps = !1, o.needsUpdate = !0, o.flipY = !0, this.weightsMaterial.searchTexture = o; let a = new Qt(r); a.name = "SMAA.Area", a.magFilter = Ke, a.minFilter = Ke, a.generateMipmaps = !1, a.needsUpdate = !0, a.flipY = !1, this.weightsMaterial.areaTexture = a, this.dispatchEvent({ type: "load" }) }, s.itemStart("search"), s.itemStart("area"), n !== void 0 && r !== void 0 ? (s.itemEnd("search"), s.itemEnd("area")) : typeof Image < "u" && (n = new Image, r = new Image, n.addEventListener("load", () => s.itemEnd("search")), r.addEventListener("load", () => s.itemEnd("area")), n.src = fI, r.src = pI), this.applyPreset(i) } get edgesTexture () { return this.renderTargetEdges.texture } getEdgesTexture () { return this.edgesTexture } get weightsTexture () { return this.renderTargetWeights.texture } getWeightsTexture () { return this.weightsTexture } get edgeDetectionMaterial () { return this.edgeDetectionPass.fullscreenMaterial } get colorEdgesMaterial () { return this.edgeDetectionMaterial } getEdgeDetectionMaterial () { return this.edgeDetectionMaterial } get weightsMaterial () { return this.weightsPass.fullscreenMaterial } getWeightsMaterial () { return this.weightsMaterial } setEdgeDetectionThreshold (i) { this.edgeDetectionMaterial.edgeDetectionThreshold = i } setOrthogonalSearchSteps (i) { this.weightsMaterial.orthogonalSearchSteps = i } applyPreset (i) { let t = this.edgeDetectionMaterial, e = this.weightsMaterial; switch (i) { case Fo.LOW: t.edgeDetectionThreshold = .15, e.orthogonalSearchSteps = 4, e.diagonalDetection = !1, e.cornerDetection = !1; break; case Fo.MEDIUM: t.edgeDetectionThreshold = .1, e.orthogonalSearchSteps = 8, e.diagonalDetection = !1, e.cornerDetection = !1; break; case Fo.HIGH: t.edgeDetectionThreshold = .1, e.orthogonalSearchSteps = 16, e.diagonalSearchSteps = 8, e.cornerRounding = 25, e.diagonalDetection = !0, e.cornerDetection = !0; break; case Fo.ULTRA: t.edgeDetectionThreshold = .05, e.orthogonalSearchSteps = 32, e.diagonalSearchSteps = 16, e.cornerRounding = 25, e.diagonalDetection = !0, e.cornerDetection = !0; break } } setDepthTexture (i, t = tr) { this.edgeDetectionMaterial.depthBuffer = i, this.edgeDetectionMaterial.depthPacking = t } update (i, t, e) { this.clearPass.render(i, this.renderTargetEdges), this.edgeDetectionPass.render(i, t, this.renderTargetEdges), this.weightsPass.render(i, this.renderTargetEdges, this.renderTargetWeights) } setSize (i, t) { this.edgeDetectionMaterial.setSize(i, t), this.weightsMaterial.setSize(i, t), this.renderTargetEdges.setSize(i, t), this.renderTargetWeights.setSize(i, t) } dispose () { let { searchTexture: i, areaTexture: t } = this.weightsMaterial; i !== null && t !== null && (i.dispose(), t.dispose()), super.dispose() } static get searchImageDataURL () { return fI } static get areaImageDataURL () { return pI } }; var P8 = `uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;
#if VIGNETTE_TECHNIQUE == 0
float d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));
#else
vec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));
#endif
outputColor=vec4(color,inputColor.a);}`, cv = { DEFAULT: 0, ESKIL: 1 }, PI = class extends Ys { constructor({ blendFunction: i = ht.NORMAL, technique: t = cv.DEFAULT, eskil: e = !1, offset: n = .5, darkness: r = .5 } = {}) { super("VignetteEffect", P8, { blendFunction: i, defines: new Map([["VIGNETTE_TECHNIQUE", t.toFixed(0)]]), uniforms: new Map([["offset", new oe(n)], ["darkness", new oe(r)]]) }) } get technique () { return Number(this.defines.get("VIGNETTE_TECHNIQUE")) } set technique (i) { this.technique !== i && (this.defines.set("VIGNETTE_TECHNIQUE", i.toFixed(0)), this.setChanged()) } get eskil () { return this.technique === cv.ESKIL } set eskil (i) { this.technique = i ? cv.ESKIL : cv.DEFAULT } getTechnique () { return this.technique } setTechnique (i) { this.technique = i } get offset () { return this.uniforms.get("offset").value } set offset (i) { this.uniforms.get("offset").value = i } getOffset () { return this.offset } setOffset (i) { this.offset = i } get darkness () { return this.uniforms.get("darkness").value } set darkness (i) { this.uniforms.get("darkness").value = i } getDarkness () { return this.darkness } setDarkness (i) { this.darkness = i } }, rAe = [new Float32Array(3), new Float32Array(3)], iAe = [new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3)], sAe = [[new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1])], [new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1])]]; var oAe = [new Float32Array(2), new Float32Array(2)]; var aAe = new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]), lAe = [new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125])], cAe = [new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4])], uAe = [new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3])]; var hAe = new Map([[Dr(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])], [Dr(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])], [Dr(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])], [Dr(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])], [Dr(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])], [Dr(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])], [Dr(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])], [Dr(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])], [Dr(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])], [Dr(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])], [Dr(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])], [Dr(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])], [Dr(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])], [Dr(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])], [Dr(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])], [Dr(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]]); function FS (i, t, e) { return i + (t - i) * e } function Dr (i, t, e, n) { let r = FS(i, t, .75), s = FS(e, n, 1 - .25); return FS(r, s, 1 - .125) } var _n = class { constructor(t, e) { this.enabled = !1; this.effect = new t(e), Object.defineProperty(this, "opacity", { enumerable: !0, set (n) { this.effect.blendMode.opacity.value = n }, get () { return this.effect.blendMode.opacity.value } }), Object.defineProperty(this, "blendFunction", { enumerable: !0, set (n) { this.effect.blendMode.setBlendFunction(Number(n)) }, get () { return this.effect.blendMode.blendFunction } }), this.blendFunction = ht.NORMAL } }; var Qh = class extends _n { constructor() { super(wI), this.blendFunction = ht.SCREEN } set intensity (t) { this.effect.intensity = t } get intensity () { return this.effect.intensity } set luminanceThreshold (t) { this.effect.luminanceMaterial.threshold = t } get luminanceThreshold () { return this.effect.luminanceMaterial.threshold } set luminanceSmoothing (t) { this.effect.luminanceMaterial.smoothing = t } get luminanceSmoothing () { return this.effect.luminanceMaterial.smoothing } set blurScale (t) { this.effect.blurPass.scale = t } get blurScale () { return this.effect.blurPass.scale } set kernelSize (t) { this.effect.blurPass.kernelSize = t } get kernelSize () { return this.effect.blurPass.kernelSize } }; var Kh = class extends _n { constructor() { super(SI) } set contrast (t) { this.effect.uniforms.get("contrast").value = t } get contrast () { return this.effect.uniforms.get("contrast").value } set brightness (t) { this.effect.uniforms.get("brightness").value = t } get brightness () { return this.effect.uniforms.get("brightness").value } }; var Zh = class extends _n { constructor() { super(_I), this.effect.offset = new B(.01, .01) } set offset (t) { this.effect.offset.set(t[0] / 1e3, t[1] / 1e3) } get offset () { return [this.effect.offset.x * 1e3, this.effect.offset.y * 1e3] } }; var Jh = class extends _n { constructor() { super(AI) } }; var $h = class extends _n { constructor() { super(MI); this._hue = 0 } set hue (e) { this._hue = e, this.effect.setHue(e) } get hue () { return this._hue } set saturation (e) { this.effect.uniforms.get("saturation").value = e } get saturation () { return this.effect.uniforms.get("saturation").value } }; var ed = class extends _n { constructor() { super(TI), this.blendFunction = ht.OVERLAY } }; var td = class extends _n { constructor() { super(PI) } get eskil () { return this.effect.eskil } set eskil (t) { this.effect.eskil = t } get darkness () { return this.effect.uniforms.get("darkness").value } set darkness (t) { this.effect.uniforms.get("darkness").value = t } get offset () { return this.effect.uniforms.get("offset").value } set offset (t) { this.effect.uniforms.get("offset").value = t } }; var nd = class extends _n { constructor(t) { super(EI, t) } set focalLength (t) { this.effect.circleOfConfusionMaterial.uniforms.focalLength.value = t } get focalLength () { return this.effect.circleOfConfusionMaterial.uniforms.focalLength.value } set focusDistance (t) { this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value = t } get focusDistance () { return this.effect.circleOfConfusionMaterial.uniforms.focusDistance.value } get bokehScale () { return this.effect.bokehScale } set bokehScale (t) { this.effect.bokehScale = t } }; var rd = class extends _n { constructor() { super(CI) } get granularity () { return this.effect.getGranularity() } set granularity (t) { this.effect.setGranularity(t) } }; var II = `#define GLSLIFY 1
varying vec2 vUv;varying vec2 vTexCoords[9];uniform vec2 resolution;void main(){vUv=position.xy*0.5+0.5;vec2 texelSize=vec2(1.0)/resolution;vTexCoords[0]=vUv+vec2(-texelSize.x,-texelSize.y);vTexCoords[1]=vUv+vec2(0.0,-texelSize.y);vTexCoords[2]=vUv+vec2(texelSize.x,-texelSize.y);vTexCoords[3]=vUv+vec2(-texelSize.x,0.0);vTexCoords[4]=vUv+vec2(0.0,0.0);vTexCoords[5]=vUv+vec2(texelSize.x,0.0);vTexCoords[6]=vUv+vec2(-texelSize.x,texelSize.y);vTexCoords[7]=vUv+vec2(0.0,texelSize.y);vTexCoords[8]=vUv+vec2(texelSize.x,texelSize.y);gl_Position=vec4(position.xy,1.0,1.0);}`; var DI = `#define GLSLIFY 1
#include <common>
varying vec2 vUv;varying vec2 vTexCoords[9];uniform sampler2D inputBuffer;uniform sampler2D historyBuffer;uniform sampler2D velocityBuffer;uniform sampler2D depthBuffer;uniform vec2 resolution;
#define USE_YCOCG
#define USE_CATMULL_ROM
const float feedback_min=0.5;const float feedback_max=0.95;vec3 RGB_YCoCg(vec3 c){return vec3(c.x/4.0+c.y/2.0+c.z/4.0,c.x/2.0-c.z/2.0,-c.x/4.0+c.y/2.0-c.z/4.0);}vec3 YCoCg_RGB(vec3 c){return clamp(vec3(c.x+c.y-c.z,c.x+c.z,c.x-c.y-c.z),vec3(0.0),vec3(1.0));}vec4 sample_color(sampler2D tex,vec2 uv){
#ifdef USE_YCOCG
vec4 c=texture(tex,uv);return vec4(RGB_YCoCg(c.rgb),c.a);
#else
return texture(tex,uv);
#endif
}vec4 sample_catmull_rom(sampler2D tex,vec2 uv,vec2 texSize){vec2 samplePos=uv*texSize;vec2 texPos1=floor(samplePos-0.5)+0.5;vec2 f=samplePos-texPos1;vec2 w0=f*(-0.5+f*(1.0-0.5*f));vec2 w1=1.0+f*f*(-2.5+1.5*f);vec2 w2=f*(0.5+f*(2.0-1.5*f));vec2 w3=f*f*(-0.5+0.5*f);vec2 w12=w1+w2;vec2 offset12=w2/(w1+w2);vec2 texPos0=texPos1-1.0;vec2 texPos3=texPos1+2.0;vec2 texPos12=texPos1+offset12;texPos0/=texSize;texPos3/=texSize;texPos12/=texSize;vec4 result=vec4(0.0);result+=texture2D(tex,vec2(texPos12.x,texPos0.y))*w12.x*w0.y;result+=texture2D(tex,vec2(texPos0.x,texPos12.y))*w0.x*w12.y;result+=texture2D(tex,vec2(texPos12.x,texPos12.y))*w12.x*w12.y;result+=texture2D(tex,vec2(texPos3.x,texPos12.y))*w3.x*w12.y;result+=texture2D(tex,vec2(texPos12.x,texPos3.y))*w12.x*w3.y;return result;}vec3 choose_motion_vector(){
#ifdef CHOOSE_LONGEST_MOTION_VECTOR
float longest=-1.0;vec3 v_choose=vec3(-1.0);for(int i=0;i<9;i++){vec3 v=texture2D(velocityBuffer,vTexCoords[i]).rgb;float l=length(v.xy);if(l>longest){longest=l;v_choose=v;}}return v_choose;
#else
float closest_depth=1000.0;vec2 closest_uv_offset=vec2(0.0);for(int i=0;i<9;i++){float neighbor_depth=texture2D(depthBuffer,vTexCoords[i]).r;if(neighbor_depth<closest_depth){closest_uv_offset=vTexCoords[i];closest_depth=neighbor_depth;}}return texture2D(velocityBuffer,closest_uv_offset).rgb;
#endif
}vec4 clipAabb(vec3 aabb_min,vec3 aabb_max,vec4 avg,vec4 input_texel){const float FLT_EPS=0.00000001;vec3 p_clip=0.5*(aabb_max+aabb_min);vec3 e_clip=0.5*(aabb_max-aabb_min)+FLT_EPS;vec4 v_clip=input_texel-vec4(p_clip,avg.w);vec3 v_unit=v_clip.xyz/e_clip;vec3 a_unit=abs(v_unit);float ma_unit=max(a_unit.x,max(a_unit.y,a_unit.z));if(ma_unit>1.0){return vec4(p_clip,avg.w)+v_clip/ma_unit;}else{return input_texel;}}vec3 clip_aabb_variance(in vec3 cOld,in vec3 cNew,in vec3 centre,in vec3 halfSize){if(all(lessThanEqual(abs(cOld-centre),halfSize))){return cOld;}vec3 dir=(cNew-cOld);vec3 near=centre-sign(dir)*halfSize;vec3 tAll=(near-cOld)/dir;float t=0.0001;for(int i=0;i<3;i++){if(tAll[i]>=0.0&&tAll[i]<t){t=tAll[i];}}if(t>=0.0001){return cOld;}return cOld+dir*t;}void main(){vec3 v=choose_motion_vector();vec2 velocity=v.rg;vec2 previousPixelPos=vUv-velocity;vec4 currentColor=sample_color(inputBuffer,vUv);
#ifdef USE_CATMULL_ROM
vec4 previousColor=sample_catmull_rom(historyBuffer,previousPixelPos,resolution);
#else
vec4 previousColor=sample_color(historyBuffer,previousPixelPos);
#endif
#ifdef USE_YCOCG
previousColor=vec4(RGB_YCoCg(previousColor.rgb),previousColor.a);
#endif
vec4 ctl=sample_color(inputBuffer,vTexCoords[0]);vec4 ctc=sample_color(inputBuffer,vTexCoords[1]);vec4 ctr=sample_color(inputBuffer,vTexCoords[2]);vec4 cml=sample_color(inputBuffer,vTexCoords[3]);vec4 cmc=sample_color(inputBuffer,vTexCoords[4]);vec4 cmr=sample_color(inputBuffer,vTexCoords[5]);vec4 cbl=sample_color(inputBuffer,vTexCoords[6]);vec4 cbc=sample_color(inputBuffer,vTexCoords[7]);vec4 cbr=sample_color(inputBuffer,vTexCoords[8]);vec4 cmin=min(ctl,min(ctc,min(ctr,min(cml,min(cmc,min(cmr,min(cbl,min(cbc,cbr))))))));vec4 cmax=max(ctl,max(ctc,max(ctr,max(cml,max(cmc,max(cmr,max(cbl,max(cbc,cbr))))))));vec4 cavg=(ctl+ctc+ctr+cml+cmc+cmr+cbl+cbc+cbr)/9.0;vec4 cmin5=min(ctc,min(cml,min(cmc,min(cmr,cbc))));vec4 cmax5=max(ctc,max(cml,max(cmc,max(cmr,cbc))));vec4 cavg5=(ctc+cml+cmc+cmr+cbc)/5.0;cmin=0.5*(cmin+cmin5);cmax=0.5*(cmax+cmax5);cavg=0.5*(cavg+cavg5);
#ifdef USE_YCOCG
vec2 chroma_extent=vec2(0.25*0.5*(cmax.r-cmin.r));vec2 chroma_center=currentColor.gb;cmin.yz=chroma_center-chroma_extent;cmax.yz=chroma_center+chroma_extent;cavg.yz=chroma_center;
#endif
vec4 previousColorClipped=clamp(previousColor,cmin,cmax);
#ifdef LUMINANCE_DIFFERENCES
#ifdef USE_YCOCG
float lum0=currentColor.r;float lum1=previousColorClipped.r;
#else
float lum0=luminance(currentColor.rgb);float lum1=luminance(previousColorClipped.rgb);
#endif
float unbiased_diff=abs(lum0-lum1)/max(lum0,max(lum1,0.2));float unbiased_weight=1.0-unbiased_diff;float unbiased_weight_sqr=unbiased_weight*unbiased_weight;float k_feedback=mix(feedback_min,feedback_max,unbiased_weight_sqr);vec4 result=mix(currentColor,previousColorClipped,vec4(k_feedback));
#else
const float alpha=0.1;vec4 result=mix(currentColor,previousColorClipped,1.0-alpha);
#endif
#ifdef USE_YCOCG
gl_FragColor=vec4(YCoCg_RGB(result.rgb).rgb,result.a);
#else
gl_FragColor=result;
#endif
}`; var OI = `#define GLSLIFY 1
varying vec2 vUv;void main(){gl_Position=vec4(position.xy,1.0,1.0);vUv=position.xy*0.5+0.5;}`; var RI = `#define GLSLIFY 1
layout(location=1)out vec4 gVelocity;varying vec2 vUv;uniform sampler2D inputBuffer;void main(){gl_FragColor=texture2D(inputBuffer,vUv);gVelocity=vec4(0.0);}`; var id = class extends it { constructor() { super({ name: "PassthroughMaterial", uniforms: { inputBuffer: new oe(null) }, blending: Ot, depthWrite: !1, depthTest: !1, vertexShader: OI, fragmentShader: RI }) } set inputBuffer (t) { this.uniforms.inputBuffer.value = t } }, hv = class extends Fn { constructor() { super("TAAResolvePass"); this.MRTCompatible = !0; this.needsSwap = !1, this.passThroughMaterial = new id, this.resolutionVector = new B, this.resolveMaterial = new it({ name: "TAAResolveMaterial", uniforms: { inputBuffer: new oe(null), historyBuffer: new oe(null), velocityBuffer: new oe(null), depthBuffer: new oe(null), resolution: new oe(new B) }, blending: Ot, depthWrite: !1, depthTest: !1, vertexShader: II, fragmentShader: DI }), this.historyRenderTarget = new at(1024, 1024, { minFilter: Ke, stencilBuffer: !1, depthBuffer: !1 }), this.historyRenderTarget.texture.name = "TAA.History", this.resultRenderTarget = new at(1024, 1024, { minFilter: Ke, stencilBuffer: !1, depthBuffer: !1 }), this.resultRenderTarget.texture.name = "TAA.Output" } setSize (e, n) { this.historyRenderTarget.setSize(e, n), this.resultRenderTarget.setSize(e, n) } render (e, n) { this.fullscreenMaterial = this.resolveMaterial, this.resolveMaterial.uniforms.inputBuffer.value = n.texture[0], this.resolveMaterial.uniforms.velocityBuffer.value = n.texture[1], this.resolveMaterial.uniforms.depthBuffer.value = n.depthTexture, this.resolveMaterial.uniforms.historyBuffer.value = this.historyRenderTarget.texture, this.resolveMaterial.uniforms.resolution.value.set(n.width, n.height), e.setRenderTarget(this.resultRenderTarget), e.render(this.scene, this.camera), this.fullscreenMaterial = this.passThroughMaterial, this.passThroughMaterial.inputBuffer = this.resultRenderTarget.texture, e.setRenderTarget(this.historyRenderTarget), e.render(this.scene, this.camera); let r = this.renderToScreen ? null : n; this.fullscreenMaterial = this.passThroughMaterial, this.passThroughMaterial.inputBuffer = this.resultRenderTarget.texture, e.setRenderTarget(r), e.render(this.scene, this.camera) } dispose () { this.resultRenderTarget.dispose(), this.historyRenderTarget.dispose(), this.resolveMaterial.dispose(), this.passThroughMaterial.dispose() } }; var dv = class extends Fn { constructor(e, n, r) { super("TransmissionPass", void 0, n); this.MRTCompatible = !0; this.depthPass = new GS(e, n, { renderTarget: r.transmissionDepthTarget }), this.passThroughMaterial = new id, this.splineScene = e, this.needsSwap = !1 } updatePasses (e) { this.passThroughMaterial = new id, this.depthPass = new GS(this.splineScene, this.camera, { renderTarget: e.transmissionDepthTarget }) } setCamera (e) { this.camera = e } setScene (e) { this.splineScene = e } render (e, n, r) { let s = this.camera.layers.mask, o = e; o.setRenderTarget(o.transmissionRenderTarget), this.fullscreenMaterial = this.passThroughMaterial, this.passThroughMaterial.inputBuffer = n.texture[0], o.clear(), o.render(this.scene, this.camera), this.camera.layers.disable(3), this.depthPass.render(e, n, r), o.shadowMap.needsUpdate = !1, o.shadowMap.autoUpdate = !1; let a = this.renderToScreen ? null : n; this.camera.layers.set(3), e.setRenderTarget(a), e.render(this.splineScene, this.camera), this.camera.layers.mask = s } }; var LI = new yr, N8 = new it({
	transparent: !0, vertexShader: `
        void main() {
            gl_Position = vec4(0.0);
        }
    `, fragmentShader: `
        layout(location = 1) out vec4 gVelocity;

        void main() {
            gl_FragColor = vec4(0.0);
			gVelocity = vec4(0.0);
        }
    `}), Zl = class extends Fn { constructor(e, n, r) { super("OpaquePass", n ?? LI, r); this.MRTCompatible = !0; this.hasTransmissionPass = !1; this.clear = !0; this.clearColorOnly = !1; this.clearDepth = !1; this.needsSwap = !1, this.originalMaterials = new Map, this.MRTCompatible = e } setCamera (e) { this.camera = e } setScene (e) { this.scene = e ?? LI } getScene () { return this.scene } render (e, n) { this.camera.layers.enable(3), this.hasTransmissionPass && (this.originalMaterials.clear(), this.scene.traverse(s => { s.layers.isEnabled(3) && s instanceof Ht && (this.originalMaterials.set(s.id, s.material), s.material = N8) }), e.shadowMap.needsUpdate = !0, e.shadowMap.autoUpdate = !0), this.camera.layers.enable(8); let r = this.renderToScreen ? null : n; e.setRenderTarget(r), this.clearColorOnly && e.clear(!0, !1, !0), this.clear && e.clear(), e.render(this.scene, this.camera), this.clearDepth && e.clear(!1, !0, !1), this.hasTransmissionPass && this.originalMaterials.forEach((s, o) => { let a = this.scene.getObjectById(o); a && (a.material = s) }) } }; var fv = class { constructor(t, { depthBuffer: e = !0, stencilBuffer: n = !1, multisampling: r = 0, frameBufferType: s = 0 } = {}) { this.renderer = t; this.helperStartIndex = 0; this.copyPass = new cp; this.depthTexture = null; this.timer = new bI; this._width = 1; this._height = 1; this.passes = []; this.helperPasses = []; this.autoRenderToScreen = !0; this.inputBuffer = this.createBuffer(e, n, s, r, !0, "input buffer mrt"), this.inputBufferSingle = this.createBuffer(e, n, s, r, !1, " input buffer single"), this.inputBufferSingle.texture.dispose(), this.inputBufferSingle.depthTexture.dispose(), this.inputBufferSingle.texture = this.inputBuffer.texture[0], this.inputBufferSingle.depthTexture = this.inputBuffer.depthTexture, this.outputBuffer = this.inputBuffer.clone(), this.outputBuffer.name = "output buffer mrt", this.outputBufferSingle = this.createBuffer(e, n, s, r, !1, "output buffer single"), this.outputBufferSingle.texture.dispose(), this.outputBufferSingle.depthTexture.dispose(), this.outputBufferSingle.texture = this.outputBuffer.texture[0], this.outputBufferSingle.depthTexture = this.outputBuffer.depthTexture, this.setRenderer(t) } get multisampling () { return this.inputBuffer.samples || 0 } set multisampling (t) { let e = this.inputBuffer, n = this.multisampling; n > 0 && t > 0 ? (this.inputBuffer.samples = t, this.outputBuffer.samples = t, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : n !== t && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), console.log("creating new input buffer"), this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, t, !0, "new input buffer"), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone()) } getTimer () { return this.timer } getRenderer () { return this.renderer } setRenderer (t) { if (this.renderer = t, t !== null) { let e = t.getSize(new B), n = t.getContext().getContextAttributes()?.alpha ?? !1, r = this.inputBuffer.texture[0].type; r === Zt && t.outputEncoding === Je && (this.inputBuffer.texture[0].encoding = Je, this.outputBuffer.texture[0].encoding = Je, this.inputBuffer.dispose(), this.outputBuffer.dispose(), console.log("doing some kinda dispose??")), t.autoClear = !1, this.setSize(e.width, e.height, !1); for (let s of this.passes) s.initialize(t, n, r) } } replaceRenderer (t, e = !0) { let n = this.renderer, r = n.domElement.parentNode; return this.setRenderer(t), e && r !== null && (r.removeChild(n.domElement), r.appendChild(t.domElement)), n } createDepthTexture () { let t = this.depthTexture = new wi(this._width, this._height); return this.inputBuffer.depthTexture = t, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (t.format = ra, t.type = ea) : t.type = uo, t } deleteDepthTexture () { if (this.depthTexture !== null) { this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose(); for (let t of this.passes) t.setDepthTexture(null) } } createBuffer (t, e, n, r, s, o) { let a = this.renderer, l = a === null ? new B : a.getDrawingBufferSize(new B), u = { minFilter: Ke, magFilter: Ke, wrapS: Yt, wrapT: Yt, stencilBuffer: e, depthBuffer: t }, c; return r > 0 ? (c = new at(l.width, l.height, u), c.samples = r) : (s ? (c = new vm(l.width, l.height, 2, u), c.texture[1].type = cl) : c = new at(l.width, l.height, u), c.depthTexture = new wi(2048, 2048), c.depthTexture.type = gr), n === Zt && a !== null && a.outputEncoding === Je && (Array.isArray(c.texture) ? c.texture.forEach(h => h.encoding = Je) : c.texture.encoding = Je), Array.isArray(c.texture) ? c.texture.forEach((h, d) => { h.name = `EffectComposer.Buffer ${s} ${d}`, h.generateMipmaps = !1 }) : (c.texture.name = `EffectComposer.Buffer ${s}`, c.texture.generateMipmaps = !1), c.name = o, c } addPass (t, e) { let n = this.passes, r = this.renderer, s = r.getDrawingBufferSize(new B), o = r.getContext().getContextAttributes()?.alpha ?? !1, a; if (t.MRTCompatible && (a = this.inputBuffer.texture[0].type), t.MRTCompatible || (a = this.inputBuffer.texture.type), t.setRenderer(r), t.setSize(s.width, s.height), t.initialize(r, o, a), this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1), t.renderToScreen && (this.autoRenderToScreen = !1)), e !== void 0 ? n.splice(e, 0, t) : n.push(t), this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0), t.needsDepthTexture || this.depthTexture !== null) if (this.depthTexture === null) { let l = this.createDepthTexture(); for (t of n) t.setDepthTexture(l) } else t.setDepthTexture(this.depthTexture) } setHelperStartIndex (t) { this.helperStartIndex = t } removePass (t) { let e = this.passes, n = e.indexOf(t); if (n !== -1 && e.splice(n, 1).length > 0) { if (this.depthTexture !== null) { let o = (l, u) => l || u.needsDepthTexture; e.reduce(o, !1) || (t.getDepthTexture() === this.depthTexture && t.setDepthTexture(null), this.deleteDepthTexture()) } this.autoRenderToScreen && n === e.length && (t.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0)) } } removeAllPasses () { let t = this.passes; this.deleteDepthTexture(), t.length > 0 && (this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !1), this.passes = []) } render (t) { let e = this.renderer, n = this.copyPass, r = this.inputBuffer, s = this.outputBuffer, o = this.inputBufferSingle, a = this.outputBufferSingle, l = !1, u, c, h, d; t === void 0 && (t = this.timer.update().getDelta()); for (let f of this.passes) f.enabled && (f.MRTCompatible ? f.render(e, r, s, t, l) : f.render(e, o, a, t, l), f.needsSwap && (l && (n.renderToScreen = f.renderToScreen, u = e.getContext(), c = e.state.buffers.stencil, c.setFunc(u.NOTEQUAL, 1, 4294967295), n.render(e, r, s, t, l), c.setFunc(u.EQUAL, 1, 4294967295)), h = r, d = o, r = s, o = a, s = h, a = d), f instanceof xI ? l = !0 : f instanceof yI && (l = !1)) } setSize (t, e, n) { let r = this.renderer; if (this._width = t, this._height = e, t === void 0 || e === void 0) { let o = r.getSize(new B); t = o.width, e = o.height } r.setSize(t, e, n); let s = r.getDrawingBufferSize(new B); this.inputBuffer.setSize(s.width, s.height), this.outputBuffer.setSize(s.width, s.height), this.inputBufferSingle.setSize(s.width, s.height), this.outputBufferSingle.setSize(s.width, s.height); for (let o of this.passes) o.setSize(s.width, s.height) } reset () { let t = this.timer.isAutoResetEnabled(); this.dispose(), this.autoRenderToScreen = !0, this.timer.setAutoResetEnabled(t) } dispose () { for (let t of this.passes) t.dispose(); this.passes = [], this.inputBuffer !== null && this.inputBuffer.dispose(), this.outputBuffer !== null && this.outputBuffer.dispose(), this.inputBufferSingle !== null && this.inputBufferSingle.dispose(), this.outputBufferSingle !== null && this.outputBufferSingle.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose() } }; var B8 = new it({
		name: "CombineMaterial", uniforms: { inputBufferA: new oe(null), inputBufferB: new oe(null) }, blending: Ot, depthWrite: !1, depthTest: !1, vertexShader: `
varying vec2 vUv;
void main() {
    gl_Position = vec4(position.xy, 1.0, 1.0);
    vUv = position.xy * 0.5 + 0.5;
}
`, fragmentShader: `
    varying vec2 vUv;
    uniform sampler2D inputBufferA;
    uniform sampler2D inputBufferB;

    // TODO: Why do we need these when postpro of framemode is enabled???
    layout(location = 1) out vec4 gVelocity;

    void main() {
	vec4 resA = texture2D(inputBufferA, vUv);
	vec4 resB = texture2D(inputBufferB, vUv);
    float a = resA.a + resB.a * ( 1.0 - resA.a );

	vec4 res;
	res.rgb =  resA.rgb + (resB.rgb * (1.0 - resA.a));
	res.a = resA.a + resB.a * (1.0 - resA.a);
	gl_FragColor = res;
    gVelocity = vec4(0.0);
    }
`}), pv = class extends Fn { constructor(e) { super("HelperPass", void 0, e); this.MRTCompatible = !1; this.fullscreenMaterial = B8, this.helperPass = new Zl(!1, void 0, this.camera), this.helperPass.hasTransmissionPass = !1, this.helperPass.clear = !1, this.helperPass.renderToScreen = !1, this.helperPassOnTop = new Zl(!1, void 0, this.camera), this.helperPassOnTop.hasTransmissionPass = !1, this.helperPassOnTop.clear = !1, this.helperPassOnTop.renderToScreen = !1; let n = new uv({ preset: Fo.LOW, edgeDetectionMode: Xh.COLOR }); this.effectPass = new Kl(this.camera, n), this.rt = new at(10, 10, { minFilter: Ke, magFilter: Ke, wrapS: Yt, wrapT: Yt, depthBuffer: !0 }) } setSize (e, n) { this.rt.setSize(e, n), this.effectPass.setSize(e, n) } set sceneHelpers (e) { this.helperPass.setScene(e) } get sceneHelpers () { return this.helperPass.getScene() } set sceneHelpersOnTop (e) { this.helperPassOnTop.setScene(e) } get sceneHelpersOnTop () { return this.helperPassOnTop.getScene() } setCamera (e) { this.helperPass.setCamera(e), this.helperPassOnTop.setCamera(e) } initialize (e, n, r) { super.initialize(e, n, r), this.effectPass.initialize(e, n, r) } dispose () { super.dispose(), this.rt.dispose(), this.effectPass.dispose() } render (e, n, r) { this.rt.depthTexture = n.depthTexture; let s = e.getClearAlpha(); e.setClearAlpha(0), this.helperPass.clearDepth = !0, this.helperPass.clearColorOnly = !0, this.helperPass.render(e, this.rt), this.helperPassOnTop.render(e, this.rt), this.effectPass.renderToScreen = !1, this.effectPass.render(e, this.rt, r), this.fullscreenMaterial.uniforms.inputBufferA.value = r.texture, this.fullscreenMaterial.uniforms.inputBufferB.value = n.texture, e.setClearAlpha(s), e.setRenderTarget(null), e.clear(), e.render(this.scene, this.camera) } }; var NI = `#define GLSLIFY 1
#include <skinning_pars_vertex>
out vec3 n;void main(){
#include <beginnormal_vertex>
#include <skinbase_vertex>
#include <skinnormal_vertex>
#include <defaultnormal_vertex>
#include <begin_vertex>
#include <skinning_vertex>
vec4 view_space=viewMatrix*modelMatrix*vec4(transformed,1.0);gl_Position=projectionMatrix*view_space;n=normalize(transformedNormal);}`; var BI = `#define GLSLIFY 1
in vec3 n;void main(){gl_FragColor=vec4(n,1.0);}`; var FI = `#define GLSLIFY 1
out vec2 v_uv;void main(){v_uv=uv;gl_Position=vec4(position.xy,1.0,1.0);}`; var kI = `#define GLSLIFY 1
in vec2 v_uv;const float pi=3.14159265;const float num_steps=4.0;const float num_directions=4.0;uniform float near;uniform float far;uniform float fov;uniform vec4 proj_info;uniform bool is_ortho;uniform vec2 resolution;uniform float radius_of_influence;uniform float radius_in_screen_space;uniform float exponent;uniform vec3 ao_color;uniform float bias;uniform sampler2D texture_depth;uniform sampler2D texture_normals;uniform sampler2D texture_blue_noise;uniform sampler2D texture_blue_noise_in_disk;uniform sampler2D texture_color_pass;uniform int frame_index;uniform bool fog_enabled;uniform float fog_near;uniform float fog_far;vec3 uv_to_view_space(vec2 uv,float eye_z){return vec3((uv*proj_info.xy+proj_info.zw)*(is_ortho ? 1.0 : eye_z),eye_z);}float linearize_depth(float depth_sampled){float z=is_ortho ? depth_sampled : depth_sampled*2.0-1.0;return mix((2.0*near*far)/(far+near-z*(far-near)),near+z*(far-near),float(is_ortho));}vec3 get_view_position(vec2 uv_coords){float linear_depth=linearize_depth(texture(texture_depth,uv_coords).x);return uv_to_view_space(uv_coords,linear_depth);}vec3 min_difference(vec3 p,vec3 right,vec3 left){vec3 v1=right-p;vec3 v2=p-left;return(dot(v1,v1)<dot(v2,v2))? v1 : v2;}vec3 rebuild_normal(in vec2 uv,in vec3 p){vec2 one_over_resolution=1.0/resolution;vec3 r=get_view_position(uv+vec2(one_over_resolution.x,0));vec3 l=get_view_position(uv+vec2(-one_over_resolution.x,0));vec3 t=get_view_position(uv+vec2(0,one_over_resolution.y));vec3 b=get_view_position(uv+vec2(0,-one_over_resolution.y));return normalize(cross(min_difference(p,r,l),min_difference(p,t,b)));}float falloff(float distance_squared){float neg_inv_r2=-1.0/(radius_of_influence*radius_of_influence);return distance_squared*neg_inv_r2+1.0;}float ao_contribution(vec3 P,vec3 N,vec3 S){vec3 to_sample=S-P;float norm_squared=dot(to_sample,to_sample);float norm=sqrt(norm_squared);float cos_theta=dot(N,to_sample)/norm;return clamp(cos_theta-bias,0.0,1.0)*clamp(falloff(norm_squared),0.0,1.0);}float compute_ambient_occlusion(vec2 uv,float radius_in_screen_space,vec3 pc,vec3 view_space_n){vec2 one_over_resolution=1.0/resolution;ivec2 noise_uv=ivec2(int(mod(gl_FragCoord.x,128.0)),int(mod(gl_FragCoord.y,128.0)));float noise=texelFetch(texture_blue_noise,noise_uv,0).r;noise=fract(noise+0.61803398875*float(frame_index));float theta=noise*2.0*3.1415;float ct=cos(theta);float st=sin(theta);float step_size=radius_in_screen_space/(num_steps+1.0);const float angle_step=2.0*pi/num_directions;float contribution=0.0;for(int i=0;i<int(num_directions);++i){float current_pixel=step_size+1.0;for(int j=0;j<int(num_steps);++j){int index=i*int(num_steps)+j;vec2 blue_noise_sample=texelFetch(texture_blue_noise_in_disk,ivec2(index,0),0).rg;vec2 disk_point;disk_point.x=blue_noise_sample.x*ct-blue_noise_sample.y*st;disk_point.y=blue_noise_sample.x*st+blue_noise_sample.y*ct;vec2 sample_direction=disk_point;vec2 snapped_uv=round(current_pixel*sample_direction)*one_over_resolution+uv;vec3 ps=get_view_position(snapped_uv);current_pixel+=step_size;contribution+=ao_contribution(pc,view_space_n,ps);}}float mult=1.0/(1.0-bias);contribution*=mult/(num_directions*num_steps);return clamp(1.0-contribution*2.0,0.0,1.0);}
#define USE_GBUFFER_NORMALS
void main(){vec3 view_space_p=get_view_position(v_uv);
#ifdef USE_GBUFFER_NORMALS
vec3 view_space_n=texture(texture_normals,v_uv).rgb;view_space_n.z*=-1.0;
#else
vec3 view_space_n=-rebuild_normal(v_uv,view_space_p);
#endif
float radius_ss=radius_in_screen_space/(is_ortho ? 1.0 : view_space_p.z);float ao=compute_ambient_occlusion(v_uv,radius_ss,view_space_p,view_space_n);float final=pow(ao,exponent);if(view_space_p.z>=far){final=1.0;}vec3 color=mix(ao_color,vec3(1.0),final);if(fog_enabled){float fog_factor=smoothstep(fog_near,fog_far,view_space_p.z);color=mix(color,vec3(1.0),fog_factor);}gl_FragColor=vec4(color,1.0);}`; var UI = `#define GLSLIFY 1
out vec2 v_uv;void main(){gl_Position=vec4(position.xy,1.0,1.0);v_uv=uv;}`; var zI = `#define GLSLIFY 1
in vec2 v_uv;uniform sampler2D texture_ao_lrez;uniform sampler2D texture_depth_lrez;uniform sampler2D texture_depth_hrez;uniform float near;uniform float far;float linearize_depth(float depth_sampled){float z=depth_sampled*2.0-1.0;return(2.0*near*far)/(far+near-z*(far-near));}vec2 nearest_depth_filter(in vec2 uv){vec2 resolution=vec2(textureSize(texture_depth_lrez,0));vec2 texel_size=1.0/resolution;vec2 offset=uv-0.5*texel_size;float d_hrez=texture(texture_depth_hrez,uv).r;float a=abs(d_hrez-texture(texture_depth_lrez,offset).r);float b=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(texel_size.x,0.0)).r);float c=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(0.0,texel_size.y)).r);float d=abs(d_hrez-texture(texture_depth_lrez,offset+vec2(texel_size.x,texel_size.y)).r);float min_diff=min(a,min(b,min(c,d)));if(min_diff==a)return offset;if(min_diff==b)return offset+vec2(texel_size.x,0.0);if(min_diff==c)return offset+vec2(0.0,texel_size.y);if(min_diff==d)return offset+vec2(texel_size.x,texel_size.y);}void main(){
#ifdef DEBUG
float d_lrez=texture(texture_depth_lrez,v_uv).r;float d_hrez=texture(texture_depth_hrez,v_uv).r;float output_d=mix(linearize_depth(d_lrez)/far,linearize_depth(d_hrez)/far,step(0.5,v_uv.x));gl_FragColor=vec4(vec3(output_d),1.0);
#else
vec2 filtered_uv=nearest_depth_filter(v_uv);vec4 ao=texture(texture_ao_lrez,filtered_uv);gl_FragColor=vec4(ao.rgb,1.0);gl_FragColor=ao;
#endif
}`; var sd = [[.478712, .875764], [-.337956, -.793959], [-.955259, -.028164], [.864527, .325689], [.209342, -.395657], [-.106779, .672585], [.156213, .235113], [-.413644, -.082856], [-.415667, .323909], [.141896, -.93998], [.954932, -.182516], [-.766184, .410799], [-.434912, -.458845], [.415242, -.078724], [.728335, -.491777], [-.058086, -.066401], [.20299, .686837], [-.808362, -.556402], [.507386, -.640839], [-.723494, -.22924], [.48974, .317826], [-.622663, .765301], [-.01064, .929347], [.663146, .647618], [-.096674, -.413835], [.525945, -.321063], [-.122533, .366019], [.195235, -.687983], [-.563203, .098748], [.418563, .561335], [-.378595, .800367], [.826922, .001024], [-.085372, -.766651], [-.92192, .183673], [-.590008, -.721799], [.167751, -.164393], [.032961, -.56253], [.6329, -.107059], [-.46408, .569669], [-.173676, -.958758], [-.242648, -.234303], [-.275362, .157163], [.382295, -.795131], [.562955, .115562], [.190586, .470121], [.770764, -.297576], [.237281, .93105], [-.666642, -.455871], [-.905649, -.298379], [.33952, .157829], [.701438, -.7041], [-.062758, .160346], [-.220674, .957141], [.642692, .432706], [-.77339, -.015272], [-.671467, .24688], [.158051, .062859], [.806009, .527232], [-.05762, -.247071], [.333436, -.51671], [-.550658, -.315773], [-.652078, .589846], [.008818, .530556], [-.210004, .519896]]; var H8 = new it({ vertexShader: NI, fragmentShader: BI }), mv = new it({ vertexShader: UI, fragmentShader: zI, uniforms: { texture_ao_lrez: new oe(null), texture_depth_lrez: new oe(null), texture_depth_hrez: new oe(null), near: new oe(null), far: new oe(null) } }), gv = class extends Fn { constructor(e, n) { super("AmbientOcclusionPass", void 0, n); this.fogEnabled = !1; this.fogNear = 1; this.fogFar = 1e3; this.frameIndex = 0; this._runHalfRes = !0; this._width = 1; this._height = 1; let r = 1024, s = 1024; this.gBuffer = new at(r, s, { type: gr, depthTexture: new wi(r, s), minFilter: Ke, magFilter: Ke }), this.depthBufferHighRes = new at(r, s, { depthTexture: new wi(r, s) }), this.aoBuffer = new at(r, s, { minFilter: Ke, magFilter: Ke }), this.splineScene = e, this.splineCamera = n; let o = new Float32Array(sd.length * 2); for (let l = 0; l < sd.length; l++) { let u = l * 2; o[u + 0] = sd[l][0], o[u + 1] = sd[l][1] } this.blueNoiseInDiskTexture = new go(o, sd.length, 1, Hx, gr), this.blueNoiseInDiskTexture.wrapS = ji, this.blueNoiseInDiskTexture.wrapT = ji, this.blueNoiseInDiskTexture.needsUpdate = !0, this.hbaoMaterial = new it({ vertexShader: FI, fragmentShader: kI, uniforms: { near: new oe(null), far: new oe(null), fov: new oe(null), proj_info: new oe(new qe), is_ortho: new oe(!1), resolution: new oe(new B), radius_of_influence: new oe(8), radius_in_screen_space: new oe(1), exponent: new oe(1), ao_color: new oe(new A), bias: new oe(.5), texture_depth: new oe(null), texture_normals: new oe(null), texture_blue_noise: new oe(null), texture_blue_noise_in_disk: new oe(this.blueNoiseInDiskTexture), frame_index: new oe(0), fog_enabled: new oe(!1), fog_near: new oe(1), fog_far: new oe(1e3) } }), this.radius = 128, this.aoColor = { r: 0, g: 0, b: 0 }, this.bias = .5, this.hbaoMaterial.uniforms.texture_depth.value = this.gBuffer.depthTexture, this.hbaoMaterial.uniforms.texture_normals.value = this.gBuffer.texture, this.needsSwap = !0, this.aaBuffer = new at(r, s, { minFilter: Ke, magFilter: Ke, wrapS: Yt, wrapT: Yt, depthBuffer: !1, type: gr }); let a = new uv({ preset: Fo.ULTRA, edgeDetectionMode: Xh.COLOR }); this.effectPass = new Kl(this.camera, a) } initialize (e, n, r) { super.initialize(e, n, r), this.effectPass.initialize(e, n, r) } setBlueNoiseTexture (e) { this.hbaoMaterial.uniforms.texture_blue_noise.value = e } setSize (e, n) { this._width = e, this._height = n, this.depthBufferHighRes.setSize(e, n); let r = this._runHalfRes ? .5 : 1, s = e * r, o = n * r; this.gBuffer.setSize(s, o), this.aoBuffer.setSize(s, o), this.hbaoMaterial.uniforms.resolution.value.set(s, o), this.aaBuffer.setSize(s, o), this.effectPass.setSize(s, o) } get runHalfRes () { return this._runHalfRes } set runHalfRes (e) { this._runHalfRes = e, this.setSize(this._width, this._height) } setCamera (e) { this.splineCamera = e } setScene (e) { this.splineScene = e } render (e, n, r) { this.splineScene.overrideMaterial = H8; let s = this.splineCamera.layers.mask; if (this.splineCamera.layers.set(5), e.setRenderTarget(this.gBuffer), e.clear(), e.render(this.splineScene, this.splineCamera), e.setRenderTarget(this.depthBufferHighRes), e.clear(), e.render(this.splineScene, this.splineCamera), this.splineScene.overrideMaterial = null, this.splineCamera.layers.mask = s, this.hbaoMaterial.uniforms.radius_of_influence.value = this.radius, this.hbaoMaterial.uniforms.ao_color.value.set(this.aoColor.r, this.aoColor.g, this.aoColor.b), this.hbaoMaterial.uniforms.bias.value = this.bias, this.hbaoMaterial.uniforms.fog_enabled.value = this.fogEnabled, this.hbaoMaterial.uniforms.fog_near.value = this.fogNear, this.hbaoMaterial.uniforms.fog_far.value = this.fogFar, this.hbaoMaterial.uniforms.frame_index.value = this.frameIndex, this.frameIndex++, this.splineCamera.isPerspectiveCamera) { this.hbaoMaterial.uniforms.near.value = this.splineCamera.perspCamera.near, this.hbaoMaterial.uniforms.far.value = this.splineCamera.perspCamera.far; let o = this.splineCamera.perspCamera.projectionMatrix.elements, a = 2 / o[0], l = 2 / o[5], u = -(1 - o[8]) / o[0], c = -(1 + o[9]) / o[5]; this.hbaoMaterial.uniforms.proj_info.value.set(a, l, u, c); let d = this.splineCamera.perspCamera.fov * (Math.PI / 180), p = this.hbaoMaterial.uniforms.resolution.value.y / (Math.tan(d * .5) * 2), m = this.hbaoMaterial.uniforms.radius_of_influence.value * .5 * p; this.hbaoMaterial.uniforms.radius_in_screen_space.value = m, this.hbaoMaterial.uniforms.is_ortho.value = !1 } else { this.hbaoMaterial.uniforms.near.value = this.splineCamera.orthoCamera.near, this.hbaoMaterial.uniforms.far.value = this.splineCamera.orthoCamera.far; let o = this.splineCamera.orthoCamera.projectionMatrix.elements, a = 2 / o[0], l = 2 / o[5], u = -(1 + o[12]) / o[0], c = -(1 - o[13]) / o[5]; this.hbaoMaterial.uniforms.proj_info.value.set(a, l, u, c); let d = .5 * (this.hbaoMaterial.uniforms.resolution.value.y / l), f = this.hbaoMaterial.uniforms.radius_of_influence.value * d; this.hbaoMaterial.uniforms.radius_in_screen_space.value = f, this.hbaoMaterial.uniforms.is_ortho.value = !0 } this.runHalfRes ? (this.fullscreenMaterial = this.hbaoMaterial, e.setRenderTarget(this.aoBuffer), e.clear(), e.render(this.scene, this.camera), this.fullscreenMaterial = mv, mv.uniforms.texture_ao_lrez.value = this.aoBuffer.texture, mv.uniforms.texture_depth_lrez.value = this.gBuffer.depthTexture, mv.uniforms.texture_depth_hrez.value = this.depthBufferHighRes.depthTexture, e.setRenderTarget(e.aoRenderTarget), e.clear(), e.render(this.scene, this.camera)) : (this.fullscreenMaterial = this.hbaoMaterial, e.setRenderTarget(this.aaBuffer), e.clear(), e.render(this.scene, this.camera), this.effectPass.renderToScreen = !1, this.effectPass.render(e, this.aaBuffer, e.aoRenderTarget)) } dispose () { this.gBuffer.dispose(), this.depthBufferHighRes.dispose(), this.aoBuffer.dispose() } }; var j8 = `
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, W8 = `
uniform sampler2D tInput;
uniform sampler2D tMap;
uniform vec2 resolution;
varying vec2 vUv;

uniform vec2 uResolution;
uniform vec2 uCoords;

// Draws a rectangle at center <st> with size <size>
float rectangle(vec2 st, vec2 size) {
    size = vec2(0.5) - size * 0.5;
    vec2 uv = vec2(step(size.x, st.x), step(size.y, st.y));
    uv *= vec2(step(size.x, 1.0 - st.x), step(size.y, 1.0 - st.y));

    return uv.x * uv.y;
}

uniform vec2 uSize;
uniform float uScale;
uniform float uDPR;
uniform float uCurrent;
uniform vec3 uSceneColor;

void main() {
    vec2 screenUv = gl_FragCoord.xy / uResolution.xy;
    screenUv *= 1.0 / uDPR;

    vec2 center = vec2(0.5, -0.5);
    vec2 outsideUv = screenUv;
    outsideUv += center;
    outsideUv -= uCoords.xy / uResolution.xy;
    outsideUv = (outsideUv - 0.5) + 0.5;
    outsideUv -= center;
    vec2 s = (uSize / uResolution) * uScale;
    float isOutside = 1.0 - rectangle(outsideUv, s);
    
    vec2 mid = vec2(0.5);
    vec2 insideUv = (screenUv - mid + s * mid) / s;
    vec4 background = texture2D(tInput, screenUv);
    vec4 image = texture2D(tMap, insideUv);
    gl_FragColor = mix(image, background, isOutside);
}
`, yv = class extends Fi { constructor() { super(new it({ vertexShader: j8, fragmentShader: W8, uniforms: { tInput: new oe(null), tMap: new oe(null), uResolution: new oe(new B), uSize: new oe(new B), uCoords: new oe(new B), uScale: new oe(1), uSceneColor: new oe(new Le(16711680)), uDPR: new oe(1), uCurrent: new oe(0) } }), "tInput"), this.needsSwap = !0 } get uniforms () { return this.fullscreenMaterial.uniforms } get texture () { return this.uniforms.tMap.value } set texture (t) { this.uniforms.tMap.value = t } }; var q8 = `
void main() {
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`, Y8 = `
uniform sampler2D toScene;
uniform sampler2D fromScene;
uniform vec2 resolution;

uniform vec2 uResolution;
uniform float uDPR;

uniform float mixRatio;
uniform sampler2D tMixTexture;
uniform int useTexture;
uniform float threshold;

void main() {
	vec2 screenUv = gl_FragCoord.xy / uResolution.xy;
	screenUv *= 1.0 / uDPR;

	vec4 texel1 = texture2D( fromScene, screenUv );
	vec4 texel2 = texture2D( toScene, screenUv );

	if (useTexture==1) {
		
		vec4 transitionTexel = texture2D( tMixTexture, screenUv );
		float r = mixRatio * (1.0 + threshold * 2.0) - threshold;
		float mixf=clamp((transitionTexel.r - r)*(1.0/threshold), 0.0, 1.0);
		
		gl_FragColor = mix( texel1, texel2, mixf );
	} else {
		
		gl_FragColor = mix( texel1, texel2, mixRatio );
		
	}
}
`, X8 = [], vv = class extends Fi { constructor() { super(new it({ vertexShader: q8, fragmentShader: Y8, uniforms: { toScene: new oe(null), fromScene: new oe(null), uResolution: new oe(new B), uDPR: new oe(1), mixRatio: new oe(0), threshold: new oe(.1), useTexture: new oe(0), tMixTexture: { value: X8[0] } } }), "toScene"), this.needsSwap = !0 } get uniforms () { return this.fullscreenMaterial.uniforms } get texture () { return this.uniforms.fromScene.value } set texture (t) { this.uniforms.fromScene.value = t } }; function VI (i, t) { return t && t.enabled && i.push(t.effect), i } var Q8 = i => Object.values(ht).includes(i) ? i : ht.NORMAL, up = class extends kt { constructor(e) { super(); this.postprocessingState = Bu.defaultData; this._scene = new yr; this._camera = new Wt; this.effects = new Map; this.blueNoiseTexture = new go; this._renderToScreen = !0; this.clock = new Im, this.renderer = e, this.debug = !1, this.effects.set("bloom", new Qh), this.effects.set("chromaticAberration", new Zh), this.effects.set("vignette", new td), this.effects.set("noise", new ed), this.effects.set("colorAverage", new Jh), this.effects.set("hueSaturation", new $h), this.effects.set("brightnessContrast", new Kh), this.effects.set("depthOfField", new nd), this.effects.set("pixelation", new rd), this.effectComposer = new fv(this.renderer), this.effectComposer.autoRenderToScreen = !1, this.opaquePass = new Zl(!0, this.scene, this.camera), this.opaquePass.clear = !0, this.transmissionPass = new dv(this.scene, this.camera, this.renderer), this.aoPass = new gv(this.scene, this.camera), this.taaPass = new hv, this.taaPass.renderToScreen = !1, this.helperPass = new pv(this.camera), this.helperPass.renderToScreen = !1, this.overlayPass = new yv, this.overlayPass.enabled = !1, this.sceneTransitionPass = new vv, this.sceneTransitionPass.enabled = !1, this._initCopyPass(), this._initPasses() } set overlayTexture (e) { e !== void 0 ? (this.overlayPass.texture = e, this.overlayPass.enabled = !0) : this.overlayPass.enabled = !1 } get overlayTexture () { return this.overlayPass.texture } set sceneHelpers (e) { this.helperPass.sceneHelpers = e } get sceneHelpers () { return this.helperPass.sceneHelpers } set sceneHelpersOnTop (e) { this.helperPass.sceneHelpersOnTop = e } get sceneHelpersOnTop () { return this.helperPass.sceneHelpersOnTop } get scene () { return this._scene } set scene (e) { this._scene = e, this.opaquePass.setScene(e), this.transmissionPass.setScene(e), this.aoPass.setScene(e) } get camera () { return this._camera } set camera (e) { this._camera = e, this.opaquePass.setCamera(e), this.transmissionPass.setCamera(e), this.aoPass.setCamera(e), this.helperPass.setCamera(e) } updateRenderToScreen () { let e = !1; for (let n = this.effectComposer.passes.length - 1; n >= 0; n--) { let r = this.effectComposer.passes[n]; if (r.enabled === !0 && !e && this._renderToScreen) { r.renderToScreen = !0, e = !0; continue } r.renderToScreen = !1 } } disableHelpers () { this.helperPass.enabled = !1, this.updateRenderToScreen() } enableHelpers () { this.helperPass.enabled = !0, this.updateRenderToScreen() } updateBlueNoiseTexture (e) { this.blueNoiseTexture = new go(e, 128, 128), this.blueNoiseTexture.wrapS = ji, this.blueNoiseTexture.wrapT = ji, this.blueNoiseTexture.minFilter = Dt, this.blueNoiseTexture.magFilter = Dt, this.blueNoiseTexture.needsUpdate = !0 } setAmbientOcclusionParams (e, n, r, s, o, a, l, u) { this.aoPass.enabled = e, this.aoPass.radius = n, this.aoPass.bias = r, this.aoPass.aoColor = s, this.aoPass.fogEnabled = o, this.aoPass.fogNear = a, this.aoPass.fogFar = l, this.aoPass.runHalfRes !== !u && (this.aoPass.runHalfRes = !u) } setTransmissionPassEnabled (e) { this.transmissionPass.enabled = e, this.opaquePass.hasTransmissionPass = e } _initPasses () { if (this.uvEffectPass?.dispose(), this.effectPass?.dispose(), this.effectComposer.removeAllPasses(), this.transmissionPass.updatePasses(this.renderer), this.effectComposer.addPass(this.aoPass), this.effectComposer.addPass(this.opaquePass), this.effectComposer.addPass(this.transmissionPass), this.effectComposer.addPass(this.taaPass), this.postprocessingState.enabled) { let e = [this.effects.get("pixelation")].reduce(VI, []); e.length > 0 && (this.uvEffectPass = new Kl(this.camera, ...e), this.uvEffectPass.renderToScreen = !1, this.effectComposer.addPass(this.uvEffectPass)); let n = [this.effects.get("chromaticAberration"), this.effects.get("bloom"), this.effects.get("colorAverage"), this.effects.get("hueSaturation"), this.effects.get("brightnessContrast"), this.effects.get("vignette"), this.effects.get("noise")].reduce(VI, []); n.length > 0 && (this.effectPass = new Kl(this.camera, ...n), this.effectPass.renderToScreen = !1, this.effectComposer.addPass(this.effectPass)) } this.effectComposer.addPass(this.overlayPass), this.effectComposer.addPass(this.sceneTransitionPass), this.effectComposer.addPass(this.helperPass) } _initCopyPass () { if (this._savePass) return; let e = new B; this.renderer.getDrawingBufferSize(e), this._rt = new at(e.x, e.y, { depthBuffer: !1, stencilBuffer: !1, wrapS: ji, wrapT: ji }), this._rt.samples = 0, this._savePass = new cp(this._rt, !1), this._savePass.renderToScreen = !1 } setCopyPass (e) { this._rt = e, this._savePass = new cp(this._rt, !1), this.renderToScreen = !1 } get renderToScreen () { return this._renderToScreen } set renderToScreen (e) { if (this._renderToScreen === e) return; let n = this.effectComposer; !n || (e === !0 ? n.removePass(this._savePass) : n.addPass(this._savePass), this._renderToScreen = e, this.updateRenderToScreen()) } set sceneTransitionFromTexture (e) { e !== this.sceneTransitionPass.texture && (e !== null ? this.sceneTransitionPass.enabled = !0 : (this.sceneTransitionPass.enabled = !1, this.updateRenderToScreen()), this.sceneTransitionPass.texture = e) } get texture () { return this._rt && this._rt.texture } get renderTarget () { return this._rt } updatePostprocessing (e) { let { enabled: n, ...r } = e, s = !1; n !== this.postprocessingState.enabled && (s = !0); for (let o of Object.entries(r)) { let a = o[1], l = this.effects.get(o[0]); if (l) { l.enabled !== a.enabled && (s = !0), l.enabled = a.enabled; for (let [u, c] of Object.entries(a)) u === "blendFunction" ? l.blendFunction = Q8(c) : l[u] = c } } this.postprocessingState = e, s && this._initPasses() } render () { this.effectComposer.render(this.clock.getDelta()) } setScissor (e, n, r, s) { e instanceof qe ? (this.effectComposer.inputBuffer.scissor.set(e.x, e.y, e.z, e.w), this.effectComposer.outputBuffer.scissor.set(e.x, e.y, e.z, e.w)) : (this.effectComposer.inputBuffer.scissor.set(e, n, r, s), this.effectComposer.outputBuffer.scissor.set(e, n, r, s)); let o = this.renderer.getPixelRatio(); this.effectComposer.inputBuffer.scissor.multiplyScalar(o), this.effectComposer.outputBuffer.scissor.multiplyScalar(o), this.renderer.setScissor(e, n, r, s) } setScissorTest (e) { this.effectComposer.inputBuffer.scissorTest = e, this.effectComposer.outputBuffer.scissorTest = e, this.renderer.setScissorTest(e) } setViewport (e, n, r, s) { e instanceof qe ? (this.effectComposer.inputBuffer.viewport.copy(e), this.effectComposer.outputBuffer.viewport.copy(e)) : (this.effectComposer.inputBuffer.viewport.set(e, n, r, s), this.effectComposer.outputBuffer.viewport.set(e, n, r, s)) } resize (e, n, r) { if (this.effectComposer.setSize(e, n, r), this._rt) { let s = this.renderer.getPixelRatio(); this._rt.setSize(e * s, n * s) } } dispose () { this.uvEffectPass?.dispose(), this.effectPass?.dispose(), this.effectComposer.dispose() } }; var K8 = i => `

// PCSS implementation based on:
// https://www.gamedev.net/articles/programming/graphics/contact-hardening-soft-shadows-made-fast-r4906/
// NOTE: This number affects how big the shadow blur can
// possibly get. Bigger number == bigger blur, but less precise results

const float  gPenumbraFilterSize = 80.0;
const int   gPenumbraSamples = ${i};
const int gShadowSamples = ${i};
const float gShadowSamplesRpc = 1.0f / float(gShadowSamples);

#ifdef USE_SHADOWMAP
    #if NUM_DIR_LIGHT_SHADOWS > 0

        uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
        varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];

        struct DirectionalLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];

    #endif

    #if NUM_SPOT_LIGHT_SHADOWS > 0

        uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
        varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_SHADOWS ];

        struct SpotLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
        };

        uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];

    #endif

    #if NUM_POINT_LIGHT_SHADOWS > 0

        uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
        varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];

        struct PointLightShadow {
            float shadowBias;
            float shadowNormalBias;
            float shadowRadius;
            vec2 shadowMapSize;
            float shadowCameraNear;
            float shadowCameraFar;
        };

        uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];

    #endif

    /*
    #if NUM_RECT_AREA_LIGHTS > 0

        // TODO (abelnation): create uniforms for area light shadows

    #endif
    */

float computePenumbra(int index, sampler2D shadowMap, float temporalAngle, float texelSize, vec2 uv, float compare, float texelScalar, float shadowRadius)
{
    float penumbra = 1.0;
    float blockerDepthAvg = 0.0;
    float blockerCount = 0.0;

    #pragma unroll_loop_start
    for(int i = 0; i < gPenumbraSamples; i ++)
    {
        vec2 offset = (vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize) * texelScalar;
        float depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) );

        if(depth < compare + 0.0001)
        {
            blockerDepthAvg += depth;
            blockerCount++;
        }
    }
    #pragma unroll_loop_end

    if (blockerCount > 0.0)
    {
        blockerDepthAvg /= blockerCount;

        // Compute penumbra
        penumbra = (compare - blockerDepthAvg) / (blockerDepthAvg);
        penumbra *= penumbra;
        penumbra *= 200.0 * penumbraSize[min(index, ${5} - 1)]; // Magic number that affects how quickly the penumbra grows

        return clamp(penumbra, 0.00, 1.0);
    }
    return 0.0;
}

float vogelShadow(int index, sampler2D shadowMap, vec2 uv, float texelSize, float compare, float shadowRadius)
{
    float shadow         = 0.0f;

    // NOTE: When using TAA, we should use screen space interleaved gradient noise
    vec2 halton = haltonSequence[frameIndex];
    float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
    float temporalAngle  = temporalOffset * PI2;

    float texelScalar = (gPenumbraFilterSize) / (texelSize * 1024.);
    float penumbra = computePenumbra(index, shadowMap, temporalAngle, texelSize, uv, compare, texelScalar, shadowRadius);
    if (penumbra == -1.0) {
        return 1.0;
    }

    #pragma unroll_loop_start
    for (int i = 0; i < gShadowSamples; i++)
    {
        vec2 vogelSample =  vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;
        // Overall blurring offset
        vec2 offset = vogelSample * (shadowRadius * 2.);

        // Penumbra offset
        offset += vogelSample * (penumbra * texelScalar);

        shadow += step( compare, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );
    }
    #pragma unroll_loop_end

    return shadow * gShadowSamplesRpc;
}


    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {

        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );

    }

    vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {

        return unpackRGBATo2Half( texture2D( shadow, uv ) );

    }

    float VSMShadow (sampler2D shadow, vec2 uv, float compare ){

        float occlusion = 1.0;

        vec2 distribution = texture2DDistribution( shadow, uv );

        float hard_shadow = step( compare , distribution.x ); // Hard Shadow

        if (hard_shadow != 1.0 ) {

            float distance = compare - distribution.x ;
            float variance = max( 0.00000, distribution.y * distribution.y );
            float softness_probability = variance / (variance + distance * distance ); // Chebeyshevs inequality
            softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 ); // 0.3 reduces light bleed
            occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );

        }
        return occlusion;

    }

    float getShadow( int i, sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {

        float shadow = 1.0;

        shadowCoord.xyz /= shadowCoord.w;
        shadowCoord.z += shadowBias;

        // if ( something && something ) breaks ATI OpenGL shader compiler
        // if ( all( something, something ) ) using this instead

        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
        bool inFrustum = all( inFrustumVec );

        bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );

        bool frustumTest = all( frustumTestVec );

        if ( frustumTest ) {

        #if defined( SHADOWMAP_TYPE_PCF )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            return vogelShadow(i, shadowMap, shadowCoord.xy, texelSize.x, shadowCoord.z, shadowRadius );

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )

            vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
            float dx = texelSize.x;
            float dy = texelSize.y;

            vec2 uv = shadowCoord.xy;
            vec2 f = fract( uv * shadowMapSize + 0.5 );
            uv -= f * texelSize;

            shadow = (
                texture2DCompare( shadowMap, uv, shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
                texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
                     f.x ) +
                mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
                     texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
                     f.y ) +
                mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
                          f.x ),
                     mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
                          texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
                          f.x ),
                     f.y )
            ) * ( 1.0 / 9.0 );

        #elif defined( SHADOWMAP_TYPE_VSM )

            shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );

        #else // no percentage-closer filtering:

            shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );

        #endif

        }

        return shadow;

    }

    // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
    // vector suitable for 2D texture mapping. This code uses the following layout for the
    // 2D texture:
    //
    // xzXZ
    //  y Y
    //
    // Y - Positive y direction
    // y - Negative y direction
    // X - Positive x direction
    // x - Negative x direction
    // Z - Positive z direction
    // z - Negative z direction
    //
    // Source and test bed:
    // https://gist.github.com/tschw/da10c43c467ce8afd0c4

    vec2 cubeToUV( vec3 v, float texelSizeY ) {

        // Number of texels to avoid at the edge of each square

        vec3 absV = abs( v );

        // Intersect unit cube

        float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
        absV *= scaleToCube;

        // Apply scale to avoid seams

        // two texels less per square (one texel will do for NEAREST)
        v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );

        // Unwrap

        // space: -1 ... 1 range for each square
        //
        // #X##         dim    := ( 4 , 2 )
        //  # #         center := ( 1 , 1 )

        vec2 planar = v.xy;

        float almostATexel = 1.5 * texelSizeY;
        float almostOne = 1.0 - almostATexel;

        if ( absV.z >= almostOne ) {

            if ( v.z > 0.0 )
                planar.x = 4.0 - v.x;

        } else if ( absV.x >= almostOne ) {

            float signX = sign( v.x );
            planar.x = v.z * signX + 2.0 * signX;

        } else if ( absV.y >= almostOne ) {

            float signY = sign( v.y );
            planar.x = v.x + 2.0 * signY + 2.0;
            planar.y = v.z * signY - 2.0;

        }

        // Transform to UV space

        // scale := 0.5 / dim
        // translate := ( center + 0.5 ) / dim
        return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );

    }

    float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {

        float shadow = 1.0;
        vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );

        // for point lights, the uniform @vShadowCoord is re-purposed to hold
        // the vector from the light to the world-space position of the fragment.
        vec3 lightToPosition = shadowCoord.xyz;

        // dp = normalized distance from light to fragment position
        float compare = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?
        compare += shadowBias;

        // bd3D = base direction 3D
        vec3 bd3D = normalize( lightToPosition );

        vec2 halton = haltonSequence[frameIndex];
        float temporalOffset = getNoiseInterleavedGradient(gl_FragCoord.xy + halton);
        float temporalAngle  = temporalOffset * PI2;

        #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_VSM )
            for (int i = 0; i < gShadowSamples; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                // NOTE: Removed for now
                // Penumbra offset
                //offset += vec3(vogelSample.x, vogelSample.y, vogelSample.y)  * (penumbra * gPenumbraFilterSize);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * gShadowSamplesRpc;

        #elif defined( SHADOWMAP_TYPE_PCF_SOFT )
            for (int i = 0; i < 16; i++) {
                vec2 vogelSample = vogelDiskSample(i, gShadowSamples, temporalAngle) * texelSize;

                // Overall blurring offset
                vec3 offset = vec3(vogelSample.x, vogelSample.y, -vogelSample.x) * (shadowRadius + 5.);

                shadow += texture2DCompare( shadowMap, cubeToUV( bd3D + offset, texelSize.y ), compare );

            }
            return shadow * (1.0 / 16.0);
        #else // no percentage-closer filtering

            return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), compare );

        #endif

    }

#endif
`, Z8 = ot.lights_fragment_begin, J8 = ot.shadowmask_pars_fragment, HI = null, $8 = i => { switch (i) { case "low": return 8; case "medium": return 16; case "high": return 32; default: return 16 } }, jI = (i = "medium") => { if (HI === i) return !1; HI = i; let t = $8(i); ot.shadowmap_pars_fragment = K8(t); let e = Z8.slice(); e = e.replace("getShadow( spotShadowMap[ i ]", `getShadow( UNROLLED_LOOP_INDEX + ${3}, spotShadowMap[ i ]`), e = e.replace("getShadow( directionalShadowMap[ i ]", "getShadow( UNROLLED_LOOP_INDEX, directionalShadowMap[ i ]"), ot.lights_fragment_begin = e; let n = J8.slice(); return n = n.replaceAll("getShadow(", "getShadow( UNROLLED_LOOP_INDEX, "), ot.shadowmask_pars_fragment = n, !0 }; var eq = `
attribute vec3 randomColor;
varying vec3 vNormal;
flat out vec3 vColor;

void main()
{
vNormal = normal;
vColor = randomColor;
gl_Position = projectionMatrix * (modelViewMatrix * vec4(position, 1.0));
}
`, tq = `
uniform float depthContrast;
varying vec3 vNormal;
flat in vec3 vColor;
void main()
{
vec3 normal = (normalize(vNormal)).rgb;

float contrastDepth = (gl_FragCoord.z - 0.5) * depthContrast + 0.5;

vec3 resultColor = mix(mix(vColor, normal, 0.2), vec3(contrastDepth), 0.4);
gl_FragColor = vec4(resultColor, vColor.r);
}
`, xv = new it({ vertexShader: eq, fragmentShader: tq, uniforms: { depthContrast: { value: 1 } } }); var WI = new Qt, bv = class extends Kx { constructor(e) { super(e); this._pixelRatio = this.getPixelRatio(); this.viewportWidth = 1; this.viewportHeight = 1; this.resolution = new B; this.pipeline = new up(this); this.dummyCamra = new Wt; this.sceneTransitionDuration = 0; this.sceneTransitionTimeRemaining = -1; this.isXRCopyPassSet = !1; this.clear = (e = !0, n = !0, r = !0) => { let s = this.getContext(), o = 0; e && (o |= s.COLOR_BUFFER_BIT), n && (o |= s.DEPTH_BUFFER_BIT), r && (o |= s.STENCIL_BUFFER_BIT), s.clear(o), s.clearBufferfv(s.COLOR, 1, [0, 0, 0, 1]) }; this.autoClear = !1; let n = this.setPixelRatio.bind(this), r = this.setSize.bind(this); this.shadowMap.enabled = !0, this.shadowMap.type = Fm; let s = this.getContext(); if (s && "drawingBufferColorSpace" in s) try { s.drawingBufferColorSpace = "display-p3" } catch (o) { console.warn(o) } this.setPixelRatio = o => { this._pixelRatio !== o && (this._pixelRatio = o, n(o)) }, this.setSize = (o, a, l = !0) => { (this.viewportWidth !== o || this.viewportHeight !== a) && (this.viewportWidth = o, this.viewportHeight = a, r(o, a, l), this.normalRenderTarget?.setSize(o * this._pixelRatio, a * this._pixelRatio), this._resizeTransmission(o, a), this.transmissionDepthTarget?.setSize(o * this._pixelRatio / 2, a * this._pixelRatio / 2), this.pipeline.resize(o, a, l)) }, this._superDispose = this.dispose, this.dispose = this._currentDispose } createAORenderTarget () { this.aoRenderTarget === void 0 && (this.aoRenderTarget = new at(this.viewportWidth * this._pixelRatio, this.viewportHeight * this._pixelRatio, { generateMipmaps: !1, minFilter: Ke, magFilter: Ke, wrapS: Yt, wrapT: Yt, depthBuffer: !1 })) } _resizeTransmission (e, n) { this.transmissionRenderTarget?.setSize(e * this._pixelRatio / (this.hdTransmission ? 1 : 2), n * this._pixelRatio / (this.hdTransmission ? 1 : 2)), this.aoRenderTarget?.setSize(e * this._pixelRatio / 1, n * this._pixelRatio / 1) } get hdTransmission () { return Ve.transmissionLod.value === 1 } set hdTransmission (e) { Ve.transmissionLod.value = e === !0 ? 1 : 2, this._resizeTransmission(this.viewportWidth, this.viewportHeight) } createTransmissionRenderTarget () { this.transmissionRenderTarget === void 0 && (this.transmissionRenderTarget = new at(this.viewportWidth * this._pixelRatio / (this.hdTransmission ? 1 : 2), this.viewportHeight * this._pixelRatio / (this.hdTransmission ? 1 : 2), { generateMipmaps: !0, minFilter: ll, magFilter: Ke, wrapS: Yt, wrapT: Yt, depthBuffer: !1 }), this.transmissionDepthTarget = new at(this.viewportWidth * this._pixelRatio / 2, this.viewportHeight * this._pixelRatio / 2, { minFilter: Dt, magFilter: Dt, depthBuffer: !1 })) } createNormalRenderTarget () { this.normalRenderTarget === void 0 && (this.normalRenderTarget = new at(this.viewportWidth * this._pixelRatio, this.viewportHeight * this._pixelRatio, { generateMipmaps: !1, minFilter: Dt, magFilter: Dt, type: gr, depthTexture: new wi(this.viewportWidth * this._pixelRatio, this.viewportHeight * this._pixelRatio) })) } renderNormal (e, n, r) { this.normalRenderTarget && (this.setClearColor(0), r.layers.enable(8), r.layers.disable(0), r.layers.disable(3), n.traverseEntity(s => { s.layers.isEnabled(8) && (s.copyPreviousMatrix = !1) }), this.setRenderTarget(this.normalRenderTarget), this.clear(), r instanceof Wt ? xv.uniforms.depthContrast.value = (r.far - r.near) / 1e4 : xv.uniforms.depthContrast.value = 1, n.overrideMaterial = xv, this.render(n, r), this.setClearColor(n.bgColor, n.bgColor.a), this.setRenderTarget(null), n.overrideMaterial = e.wireframeState ? wv : null, r.layers.enable(0), r.layers.enable(3), n.traverseEntity(s => { s.layers.isEnabled(8) && (s.copyPreviousMatrix = !0) })) } renderSplineSceneWithDummyCamera (e, n, r = 1) { this.dummyCamra.updateCameraState(n.dataPatched); let s = n.height, o = n.width, a = this.viewportWidth / this.viewportHeight; o < s ? o = s * a : s = o / a, this.dummyCamra.setViewplaneSize(o, s); for (let l = 0; l < r; l++)this.renderSplineScene(e, this.dummyCamra) } renderSplineScene (e, n, { sceneHelpers: r = void 0, sceneHelpersOnTop: s = void 0, overrideTransmission: o = void 0, overrideNormal: a = void 0 } = {}) { let l = e instanceof ja ? e.activePage : e, u = l.visible; l.visible = !0; let c = l.scene; this.xr.enabled && (this.isXRCopyPassSet === !1 && this.getRenderTarget() !== null && (this.pipeline.setCopyPass(this.getRenderTarget()), this.isXRCopyPassSet = !0), this.xr.updateCamera(n)), this.setClearColor(l.bgColor, l.bgColor.a), l.penumbraSizeArray.forEach((p, m) => { Ve.penumbraSize.value[m] = p }), Ve.pixelRatioNode.value = this.getPixelRatio(), this.resolution.x !== 0 && this.resolution.y !== 0 ? Ve.resolution.value.set(this.resolution.x, this.resolution.y) : Ve.resolution.value.set(this.viewportWidth * this._pixelRatio, this.viewportHeight * this._pixelRatio), a !== void 0 ? (Ve.normalRenderTarget.value = a, Ve.normalRenderTargetDepth.value = WI) : c.needsNormal() && (this.createNormalRenderTarget(), Ve.normalRenderTarget.value = this.normalRenderTarget.texture, Ve.normalRenderTargetDepth.value = this.normalRenderTarget.depthTexture, this.renderNormal(c, l, n)); let h = l.data.ao, d = h.occlusion; d && (this.createAORenderTarget(), Ve.aoRenderTarget.value = this.aoRenderTarget.texture), Ve.aoEnabled.value = d, this.pipeline.setAmbientOcclusionParams(h.occlusion, h.radius, h.bias, l.aoColor, l.fog !== null, l.backupFog.near, l.backupFog.far, h.aoFullRes), this.pipeline.aoPass.setBlueNoiseTexture(this.pipeline.blueNoiseTexture); let f = !1; if (o !== void 0) Ve.transmissionRenderTarget.value = o, Ve.transmissionRenderTargetDepth.value = WI, this.pipeline.setTransmissionPassEnabled(!1); else { let p = c.needsTransmission(); p && (this.transmissionRenderTarget === void 0 && (f = !0), this.createTransmissionRenderTarget(), Ve.transmissionRenderTarget.value = this.transmissionRenderTarget.texture, Ve.aspectRatio.value = C2(this.viewportWidth, this.viewportHeight), Ve.transmissionRenderTargetDepth.value = this.transmissionDepthTarget.texture), this.pipeline.setTransmissionPassEnabled(p) } n.layers.enable(3), n.layers.enable(8), this.pipeline.sceneHelpers = r, this.pipeline.sceneHelpersOnTop = s, this.pipeline.scene = l, this.pipeline.camera = n, f && this.pipeline.transmissionPass.updatePasses(this), this.pipeline.postprocessingState !== l.postprocessing && (this.pipeline.updatePostprocessing(l.postprocessing), !r && !s && this.pipeline.disableHelpers()), this.clearAlphaOverride !== void 0 && this.setClearAlpha(this.clearAlphaOverride), l.overrideMaterial = c.wireframeState ? wv : null, this.pipeline.render(), Ve.frameIndex.value = (Ve.frameIndex.value + 1) % 16, n instanceof Wt && n.copyHistory(), l.visible = u } renderFromSceneForSceneTransitionPass (e, n, r) { this.pipeline.renderToScreen = !1, this.pipeline.renderTarget, this.renderSplineScene(e, n), this.pipeline.sceneTransitionFromTexture = this.pipeline.renderTarget.texture, this.sceneTransitionDuration = r, this.sceneTransitionTimeRemaining = r, this.pipeline.renderToScreen = !0; let s = this.pipeline.sceneTransitionPass.uniforms; s.uDPR.value = window.devicePixelRatio, s.uResolution.value.set(this.domElement.width, this.domElement.height).divideScalar(window.devicePixelRatio) } _currentDispose () { this._superDispose(), this.pipeline.dispose(), this.aoRenderTarget?.dispose(), this.transmissionRenderTarget?.dispose(), this.transmissionDepthTarget?.dispose(), this.normalRenderTarget?.dispose(), this.normalRenderTarget?.depthTexture?.dispose() } }; var od = class extends Vs(Nm) { constructor(e, n = 15, r = 10066329) { super(e, n, r); this.object = e; this.added = !1; this.name = `DirectionalLightHelper: ${e.uuid}` } raycast (e, n) { Hs(this.object, od.geometryHelper, e, n) } }; var ad = class extends Vs(Lm) { constructor(e, n = 15, r = 6710886) { super(e, n, r); this.object = e; this.name = `PointLightHelper: ${e.uuid}` } raycast (e, n) { Hs(this.object, ad.geometryHelper, e, n) } }; var Sv = class extends Vs(Rm) { constructor(e, n = 6710886) { super(e, n); this.object = e; this.name = `SpotLightHelper: ${e.uuid}` } raycast (e, n) { Hs(this.object, Sv.geometryHelper, e, n) } update () { if (this.object !== void 0) { let e = Sv._vector, n = this.object.distance ? this.object.distance : 1e3, r = n * Math.tan(this.object.angle); this.cone.scale.set(r, r, n), e.setFromMatrixPosition(this.object.target.matrixWorld), this.cone.lookAt(e); let s = this.color !== void 0 ? this.color : this.light.color; if (this.cone.material instanceof Array) for (let o = 0, a = this.cone.material.length; o < a; o++)this.cone.material[o].color.set(s); else this.cone.material.color.set(s) } } }, hp = Sv; hp._vector = new A; function nq (i, t) { i.shadow.camera.right = t / 2, i.shadow.camera.left = -t / 2, i.shadow.camera.top = t / 2, i.shadow.camera.bottom = -t / 2, i.shadow.needsUpdate = !0 } var ld = class extends Yh(Pm, od) { constructor(t, e, n) { super(), this.super_Entity(t, e), this.castShadow = !0, this.shadow.mapSize.width = 2048, this.shadow.mapSize.height = 2048, this.shadow.normalBias = 1, this.layers.enable(3); let s = this.shadow.camera; s.top = 1250, s.bottom = -1250, s.right = 1250, s.left = -1250, s.near = -1e4, s.far = 2500; let o = new ca(this.shadow.camera); o.visible = !1, this.gizmos.shadowmap = o } update () { this.shadow.camera.updateProjectionMatrix(); for (let t in this.gizmos) { let e = this.gizmos[t]; e instanceof ca && e.update() } } updateMatrixWorld (t) { super.updateMatrixWorld(t), this.objectHelper && this.objectHelper.update() } updateState (t, e) { this.updateState_Light(t, e); let n = t.depth !== void 0 && t.depth !== this.shadow.camera.far || t.size !== void 0 && t.size / 2 !== this.shadow.camera.right; t.size !== void 0 && nq(this, t.size), t.shadowRadius !== void 0 && (this.shadow.radius = t.shadowRadius), t.shadowResolution !== void 0 && (this.shadow.mapSize.set(t.shadowResolution, t.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null)), t.penumbraSize !== void 0 && e.scene.markPenumbraSizeDirty(), n && this.update() } }; var qI = new A, YI = new A, XI = new Ye, cd = class extends Yh(Tm, hp) { constructor(t, e, n) { super(), this.super_Entity(t, e), this.castShadow = !0, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024, this.shadow.normalBias = 1, this.layers.enable(3); let s = this.shadow.camera; s.fov = Ge.RAD2DEG * 2 * this.angle, s.aspect = 1, s.near = 100, s.far = 2500; let o = new ca(this.shadow.camera); o.visible = !1, this.gizmos.shadowmap = o, this.update() } update () { this.shadow.camera.updateProjectionMatrix(); for (let t in this.gizmos) { let e = this.gizmos[t]; e instanceof ca && e.update() } } updateMatrixWorld (t) { super.updateMatrixWorld(t), YI.setFromMatrixPosition(this.matrixWorld), XI.setFromRotationMatrix(this.matrixWorld), qI.copy(this.up).applyQuaternion(XI).negate().multiplyScalar(this.distance), this.target.position.copy(YI).add(qI), this.target.updateMatrixWorld(), this.objectHelper && this.objectHelper.update() } updateState (t, e) { this.updateState_Light(t, e), t.distance !== void 0 && (this.distance = t.distance), t.decay !== void 0 && (this.decay = t.decay), t.angle !== void 0 && (this.angle = t.angle), t.penumbra !== void 0 && (this.penumbra = t.penumbra), t.shadowRadius !== void 0 && (this.shadow.radius = t.shadowRadius), t.penumbraSize !== void 0 && e.scene.markPenumbraSizeDirty(), t.shadowResolution !== void 0 && (this.shadow.mapSize.set(t.shadowResolution, t.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null)) } }; var ti = class extends ih(yr) { constructor(e, n) { super(); this.data = n; this.bgColor = new on(1, 1, 1, 1); this.fog = null; this.backupFog = new Ic(16777215, .1, 2e3); this.fogUseBGColor = !1; this.isActive = !1; this.aoColor = new Le; this.penumbraSizeArrayCache = null; this.super_Entity(e, n), this.personalCamera = new Wt(Ti, { ...Ol.defaultData, ...n.camera, name: "Personal Camera" }), this.personalCamera.objectHelper.visible = !1, this.add(this.personalCamera), this.activeCamera = this.personalCamera, this.ambientLight = new Mm(13882323, 8553090, .75), this.ambientLight.name = "Default Ambient Light", this.ambientLight.layers.enable(3), this.ambientLight.removeFromParent(), this.add(this.ambientLight) } get scene () { return this.parent } get postprocessing () { return this.data.postprocessing } updateVisible () { } setBackgroundColor (e) { this.bgColor = e, this.fogUseBGColor === !0 && (this.backupFog.color = e) } updateAmbientLight (e, n) { e.color !== void 0 && (this.ambientLight.color = Ar(e.color, n)), e.intensity !== void 0 && (this.ambientLight.intensity = e.intensity), e.enabled !== void 0 && (e.enabled ? this.add(this.ambientLight) : this.remove(this.ambientLight)) } onDeactive () { this.isActive = !1 } onActive (e) { this.isActive = !0, e.fog = this.fog, this.updateShadow(this.data.shadow) } forceMaterialsUpdate () { this.traverseEntity(e => { if (e instanceof Ri) if (Array.isArray(e.material)) for (let n of e.material) n.needsUpdate = !0; else e.material.needsUpdate = !0, e.material.dispose() }) } updateShadow (e) { e.softShadowQuality !== void 0 && this.isActive && jI(e.softShadowQuality) && this.forceMaterialsUpdate() } updateFog (e, n) { if (e.enabled ? this.fog = this.backupFog : this.fog = null, this.isActive) { let r = this.scene; r.fog = this.fog } this.fogUseBGColor = e.useBackgroundColor, e.useBackgroundColor ? this.backupFog.color.set(this.bgColor) : this.backupFog.color = Ar(e.color, n), this.backupFog.near = e.near, this.backupFog.far = e.far } updateAo (e, n) { e.aoColor !== void 0 && (this.aoColor = Ar(e.aoColor, n)) } updateByOp (e, n, r, s) { super.updateByOp(e, n, r, s); let o = n; Pr(e.path, ["fog"]) ? this.updateFog(o.fog, r.shared) : Pr(e.path, ["ao"]) ? this.updateAo(o.ao, r.shared) : Pr(e.path, ["ambient"]) ? this.updateAmbientLight(o.ambient, r.shared) : Pr(e.path, ["shadow"]) && this.updateShadow(o.shadow) } updateState (e, n) { this.updateState_Entity(e, n), e.backgroundColor !== void 0 && this.setBackgroundColor(Ar(e.backgroundColor, n.shared)), e.fog !== void 0 && this.updateFog(e.fog, n.shared), e.ambient !== void 0 && this.updateAmbientLight(e.ambient, n.shared), e.ao !== void 0 && this.updateAo(e.ao, n.shared), e.shadow !== void 0 && this.updateShadow(e.shadow) } raycast (e, n) { super.raycast(e, n) } switchActiveCamera (e) { e && e.isDescendantOf(this) && (this.activeCamera !== this.personalCamera && (this.activeCamera.objectHelper.visible = !0), this.activeCamera = e, e.objectHelper.visible = !1) } get playCamera () { return this.scene?.find(this.data.publish.playCamera) ?? this.personalCamera } switchToPlayCamera () { this.switchActiveCamera(this.playCamera) } get penumbraSizeArray () { return this.penumbraSizeArrayCache === null && this.updatePenumbraSizeArray(), this.penumbraSizeArrayCache } updatePenumbraSizeArray () { this.penumbraSizeArrayCache = new Array(5).fill(.5); let e = 0, n = 0; this.traverseEntity(r => { if (!r.visible) return !0; r instanceof ld && r.visible && e < 3 && (this.penumbraSizeArrayCache[e] = r.data.penumbraSize, e += 1), r instanceof cd && r.visible && e < 5 - 3 && (this.penumbraSizeArrayCache[3 + n] = r.data.penumbraSize, n += 1) }) } raycastWithClones (e) { let n = [], r = s => { for (let o of s.children) { let a = o.cloner; ct.is(o) && (o.visible || a?.object.data.visible) && ((Ir(o) || ap(o) && this.scene.enableHelpers && o.objectHelper.visible) && (e.intersectObject(o, !1, n), dp(o, e, n, !0)), r(o)) } }; return r(this), n } }; var Av = class extends Yh(Cm, ad) { constructor(t, e, n) { super(), this.super_Entity(t, e), this.castShadow = !0, this.shadow.mapSize.width = 1024, this.shadow.mapSize.height = 1024, this.shadow.normalBias = 1, this.layers.enable(3); let s = this.shadow.camera; s.fov = 90, s.aspect = 1, s.near = 100, s.far = 2500; let o = new A(-s.far + this.position.x, -s.far + this.position.y, -s.far + this.position.z), a = new A(s.far + this.position.x, s.far + this.position.y, s.far + this.position.z), l = new _t(o, a), u = new ua(l, new Le(16755200)); u.visible = !1, this.gizmos.shadowmap = u, this.update() } update () { if (this.shadow && (this.shadow.camera.updateProjectionMatrix(), this.gizmos)) for (let t in this.gizmos) { let e = this.gizmos[t]; if (e instanceof ua) { let n = this.shadow.camera, r = new A(-n.far + this.position.x, -n.far + this.position.y, -n.far + this.position.z), s = new A(n.far + this.position.x, n.far + this.position.y, n.far + this.position.z); e.box.set(r, s), e.updateMatrixWorld(!0) } } } updateMatrixWorld (t) { super.updateMatrixWorld(t), this.objectHelper && this.objectHelper.update() } updateState (t, e) { this.updateState_Light(t, e), t.distance !== void 0 && (this.distance = t.distance), t.decay !== void 0 && (this.decay = t.decay), t.shadowRadius !== void 0 && (this.shadow.radius = t.shadowRadius), t.shadowResolution !== void 0 && (this.shadow.mapSize.set(t.shadowResolution, t.shadowResolution), this.shadow.map && (this.shadow.map.dispose(), this.shadow.map = null)) } }; var _v = class extends jt { get forceComputeSize () { return !0 } get shape () { return this.geometry.userData.shape } updateEntityBoxSize (t, e) { let n = this.geometry.getAttribute("position"); n !== void 0 ? jf(n, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : n.count, t, e) : super.updateEntityBoxSize(t, e) } }; var Wa = class extends jt { constructor(e, n, r) { super(e, n, r); this._shapeId = null; this._context = r } updateState (e, n) { super.updateState(e, n), this.updateShape() } updateShape () { let e = this.data.geometry.extrusion.shape, n; if (e.type === "Custom") { let s = e.shapeId; if (s !== this._shapeId && this.detachShape(), s) { this._shapeId = s; let o = this._context.scene.find(s); o?.data && (o.attachedPaths.add(this), n = o.geometry.userData?.shape), n || this._context.scene.addPendingCommand(() => this.updateShape()) } } else { let s; switch (e.type) { case "Rectangle": s = Ry; break; case "Ellipse": s = dh; break; case "Polygon": s = Oy; break; case "Star": s = Ly; break; default: throw new Error(`Unknown shape type: ${e.type}`) }n = s.create({ parameters: e }).userData.shape } let r = this.geometry; n && r.inputs && (r.inputs.shapeData = n, r.build(), this.attachedSurfaceCloners.forEach(s => s.update())) } detachShape () { this._shapeId !== null && this._context.scene.find(this._shapeId)?.attachedPaths.delete(this) } createGeometryDelayed (e) { this.geometryCreateDeleyed = e.shared, this.updateShape(), this.refreshAttachedPaths(e) } updateTransformState (e) { return super.updateTransformState(e) } updateGeometryInteractions (e, n) { super.updateGeometryInteractions(e, n), this.updateShape() } updateEntityBoxSize (e, n) { let r = this.geometry.getAttribute("position"); r !== void 0 ? jf(r, this.geometry.drawRange.start, this.geometry.drawRange.count < 1 / 0 ? this.geometry.drawRange.count : r.count, e, n) : super.updateEntityBoxSize(e, n) } }; var us = class extends js(vs, Ws) { constructor(e, n, r) { super(); n.type === "Instance" && typeof e == "string" && (n = this.transformAssignData(n, r)), this.super_Entity(e, n), this.objectHelper.update() } get isComponentRoot () { return this.data.type === "Component" && typeof this.identity == "string" } get isInstanceRoot () { return this.data.type === "Instance" && typeof this.identity == "string" } transformAssignData (e, n) { let r = n.scene.data.objects.get(e.component); if (r) { let s, o; for (let a of Ps.rootOverrideProps) e[a] === void 0 ? (s === void 0 && (s = { ...e }), s[a] = r.data[a]) : (o === void 0 && (o = {}), o[a] = e[a], s === void 0 && (s = { ...e }), s[a] = Ss.apply(r.data[a], e[a])); return this.overrideData = o, s } else return { ...br.defaultData, ...e, ...fi(br.defaultData, Ps.rootOverrideProps) } } updateByOp (e, n, r, s) { let o; if (this.isInstanceRoot && !s) { if (n = this.transformAssignData(n, r), e.type === 0 && e.path.length === 0 && this.component) for (let a of Ps.rootOverrideProps) a in e.props && e.props[a] === void 0 && (o === void 0 && (o = { ...e, props: { ...e.props } }), o.props[a] = this.component.data[a]); else if (e.type === 0 && e.path.length > 0 && Ps.rootOverrideProps.includes(e.path[0])) { let a = e.path[0]; o === void 0 && (o = { ...e, path: [], props: { [a]: n[a] } }) } } super.updateByOp(o ?? e, n, r, s) } updateState (e, n) { this.updateState_Entity(e, n) } expandInstanceChildren (e) { let n = this.data; if (this.component === void 0) { let r = e.scene.find(n.component) ?? null, s = !1; if (r !== this.oldComponent) { if (this.oldComponent) { let o = 0; for (let a of this.children) if (ct.is(a)) e.scene.disposeAndUnregisterEntityRecursivelyIfNotReregistered(a), Ev(a), o += 1; else break; this.children.splice(0, o) } s = !0 } if (r) { let o = {}; KI(e, [this.uuid], n.overrides, this, r, r, 0, s, o); for (let a of this.children) if (ct.is(a)) { let l = a.data; l.type === "Empty" && l.animations && a.traverseEntity(u => { if (u instanceof jt && u.isSkinnedMesh) { let c = u.dataPatched; if (c.bones && c.boneInverses) { let h = c.bones.map(p => e.scene.find(o[p])), d = c.boneInverses.map(p => new se().fromArray(p)), f = new ia(h, d); u.bind(f, u.bindMatrix) } } else u.matrixAutoUpdate = !0 }) } } this.oldComponent = this.component } } }; function Ev (i) { if (i.component) { let t = i.component.instances.indexOf(i); t >= 0 && i.component.instances.splice(t, 1); for (let e of i.children) ct.is(e) && Ev(e) } } function QI (i, t, e, n) { return i.component === t && El(i.identity, n) ? i.overrideData === e ? 2 : 1 : 0 } function KI (i, t, e, n, r, s, o, a, l) { if (o > 50) return !1; if (n.component !== r) { if (n.component) { let c = n.component.instances.indexOf(n); c >= 0 && n.component.instances.splice(c, 1) } r.instances.push(n), n.component = r } r instanceof us && r.isInstanceRoot && r.expandInstanceChildren(i); let u = 0; for (let c of r.children) if (ct.is(c)) { let h = [...t, ...typeof c.identity == "string" ? [c.identity] : c.identity], d = ku.resolve(e, h, 1); if (d != null && !(d instanceof Vt)) { if (Object.setPrototypeOf(d, Vt.prototype), !1) debugger; console.error("wrong prototype") } let f = null, p; if (!a) { let m = n.children[u]; if (f = ct.is(m) ? m : null, f !== null) { let g = QI(f, c, d, h); p = g >= 1 ? f.stateSelection : void 0, g !== 2 && (f = null) } if (f === null && (f = i.scene.findInstance(h) ?? null, f !== null)) { let g = QI(f, c, d, h); if (p = g >= 1 ? f.stateSelection : void 0, g !== 2) f = null; else { let y = f.parent.children.indexOf(f); f.parent.children.splice(y, 1), n.children.splice(u, 0, f), f.parent === n ? (y <= u && console.error("not possible"), void 0) : (f.parent = n, f.matrixWorldNeedsUpdate = !0, f.resetBBoxNeedsUpdate(), f.updateVisible(), i.pendingDeletes.delete(f), void 0) } } } if (f === null) { let m = d ? Ss.apply(c.data, d) : c.data; Zi.is(m.type) && (m = { ...m, type: "Empty" }), f = es.createEntity(h, m, i), f.overrideData = d, n.add(f), n.children.splice(n.children.length - 1, 1), n.children.splice(u, 0, f), f.updateState(f.data, i), p && f.changeSelectedState(p, i), i.scene.registerInstanceAndSetUuid(f) } if (f.isBone) { let m = f.identity[f.identity.length - 1]; l[m] = f.uuid } u += 1, KI(i, t, e, f, c, s, o + 1, a, l) } if (!a) { let c = u; for (; ;) { let h = n.children[u]; if (ct.is(h)) i.pendingDeletes.add(h); else break; u += 1 } n.children.splice(c, u - c) } return !0 } var Mv = class extends js(qd, Ws) { constructor(t, e) { super(), this.super_Entity(t, e), this.objectHelper.update(), this.matrixAutoUpdate = !0 } updateState (t, e) { this.updateState_Entity(t, e) } }; function rq (i, t, e) { let n; return t.geometry.type === "TextGeometry" ? new Hh(i, t, e) : (t.geometry.type === "SubdivGeometry" ? n = new as(i, t, e) : t.geometry.type === "PathGeometry" ? n = new Wa(i, t, e) : t.geometry.type === "VectorGeometry" ? n = new _v(i, t, e) : t.geometry.type === "BooleanGeometry" ? n = new Bi(i, t, e) : n = new jt(i, t, e), n) } function Tv (i, t, e) { return t.type === "Mesh" ? rq(i, t, e) : t.type === "Empty" ? new Bo(i, t) : t.type === "Bone" ? new Mv(i, t) : t.type === "Page" ? new ti(i, t) : t.type === "PointLight" ? new Av(i, t, e) : t.type === "SpotLight" ? new cd(i, t, e) : t.type === "DirectionalLight" ? new ld(i, t, e) : t.type === "Component" || t.type === "Instance" ? new us(i, t, e) : Zi.is(t.type) ? new Wt(i, t) : (console.error(t), new Bo(i, t)) } es.createEntity = Tv; function iq (i, t, e) { let n = Tv(i.identity, t, e), r = i.children, s = i.attachedPaths, o = i.parent, a = i.component, l = i.instances, u = i.overrideData, c = i.uuid, h = i.stateSelection; i.dispose(); for (let d of Object.keys(i)) delete i[d]; Object.setPrototypeOf(i, Object.getPrototypeOf(n)); for (let d of Object.keys(n)) i[d] = n[d]; i.children = [...i.children, ...r], i.attachedPaths = s, i.parent = o, i.component = a, i.instances = l, i.uuid = c, i.overrideData = u, i.updateState(i.data, e), h && i.changeSelectedState(h, e), i.resetBBoxNeedsUpdate() } es.changeEntityProptotype = iq; es.Cloner = dr; function ZI (i, t, e, n) { i.updateByOp(t, e, n, !1) } function JI (i, t) { let e = !1, n = t.getLayersOfType("transmission"), r = t.getLayersOfType("outline"); return r.length > 0 && (i.layers.set(8), n.length > 0 && i.layers.enable(3), e = !0, Gh(i), zh(i)), n.length === 0 && r.length === 0 && i.layers.set(0), i instanceof Ri && i.needsAO && i.layers.enable(5), e } function $I (i, t) { if (!t.layers) return !1; let e = !1, n = t.getLayersOfType("transmission").filter(s => s.data.visible), r = t.getLayersOfType("outline").filter(s => s.data.visible); return n.length > 0 && (i.layers.set(3), r.length > 0 && i.layers.enable(8), e = !0), n.length === 0 && r.length === 0 && i.layers.set(0), i.needsAO && i.layers.enable(5), e } function eD (i) { let t = !1; return i.traverseEntity(e => { if (e instanceof Ri) if (Array.isArray(e.material)) for (let n = 0; n < e.material.length; n++)JI(e, e.material[n]) && (t = !0); else JI(e, e.material) && (t = !0) }), t } function tD (i) { let t = !1; return i.traverseEntity(e => { if (e instanceof Ri) if (Array.isArray(e.material)) for (let n = 0; n < e.material.length; n++)$I(e, e.material[n]) && (t = !0); else $I(e, e.material) && (t = !0) }), t } var sq = new qc, oq = new se, aq = new Wi; function dp (i, t, e, n = !1) { let r = i.cloner; if (r) for (let s of r.children) { let o = oq.copy(s.matrixWorld).invert(), a = aq.copy(t.ray).applyMatrix4(o), l = i.matrixWorld; a.applyMatrix4(l); let u = sq; u.set(a.origin, a.direction), u.near = t.near, u.far = t.far; let c = u.intersectObject(i, !1); c.length > 0 && e.push({ ...c[0], object: n ? s : i }) } } var Cv = class { constructor() { this._constraints = new Map } setConstraint (t, e) { e === null ? this._constraints.delete(t) : this._constraints.set(t, e) } removeDependencies (t) { this._constraints.delete(t) } applyConstraints (t) { let e = new Set; this._constraints.forEach((n, r) => { let s = [r, n], o = n; for (; this._constraints.has(o);)o = this._constraints.get(o), e.has(o) || s.push(o); for (let a = s.length - 2; a >= 0; a--)if (!e.has(s[a])) { let l = t.find(s[a]); l ? l.applyPathSnapping(t) : console.warn(`missing entity ${s[a]}`), e.add(s[a]) } }) } findDependency (t, e) { let n = t; for (; this._constraints.has(n);)if (n = this._constraints.get(n), n === e) return !0; return !1 } }; var wv = new po; wv.wireframe = !0; var nD = new A, ja = class extends yr { constructor(e, n) { super(); this.data = e; this.enableHelpers = !1; this.wireframeState = !1; this.needsTransmissionDirty = !0; this.needsNormalDirty = !0; this._needsTransmission = !1; this._needsNormal = !1; this.geometryCacheChanged = !1; this.entityByUuid = {}; this.entityIdentityToEntity = {}; this.toExpandCloner = new Set; this.toUpdateCloner = new Set; this.pendingCommands = []; this.pathConstraints = new Cv; this.errorPage = new ti("fdasfa", { ...Mo.defaultData, name: "" }); this.needsRecomputeInstances = !1; this.init(e, n), this.matrixAutoUpdate = !1 } markGeometryCacheDirty () { this.geometryCacheChanged = !0 } markNeedsUpdateRendererDirty () { this.needsTransmissionDirty = !0, this.needsNormalDirty = !0 } needsTransmission () { return this.needsTransmissionDirty && (this._needsTransmission = tD(this), this.needsTransmissionDirty = !1), this._needsTransmission } needsNormal () { return this.needsNormalDirty && (this._needsNormal = eD(this), this.needsNormalDirty = !1), this._needsNormal } registerInstanceAndSetUuid (e) { let n = e.identity.join("-"), r = this.entityIdentityToEntity[n]; r && (e.uuid = r.uuid), this.entityIdentityToEntity[n] = e, this.entityByUuid[e.uuid] = e } markPenumbraSizeDirty () { for (let e of this.children) e instanceof ti && (e.penumbraSizeArrayCache = null) } findInstance (e) { return this.entityIdentityToEntity[e.join("-")] } get bgColor () { return this.activePage.bgColor } get postprocessing () { return this.activePage.data.postprocessing } getWithSortKey (e) { let n = this.find(e); if (n === void 0) return; let r = [], s = n; for (; s !== this;) { let o = s; s = s.parent; let a = s.children.indexOf(o); r.splice(0, 0, a) } return { entity: n, sortKey: r } } getAllSorted (e) { let n = []; for (let r of e) { let s = this.getWithSortKey(r.id); s !== void 0 && n.push(s) } return n.sort((r, s) => ST(r.sortKey, s.sortKey)), n.map(r => r.entity) } nonExistOrDescendantOf (e, n) { let r = this.find(e); if (r === void 0) return !0; for (; r;) { if (r.uuid === n) return !0; r = r.parent } return !1 } find (e) { if (this.activePage && this.activePage.personalCamera.parent) { if (e === "f23858d0-4a3b-4bd8-8173-66ed0af7f6fb-personalCamera") return this.activePage.personalCamera; if (e === Ti) return this.activePage.personalCamera } if (e === "" || e === void 0) return; let n = this.entityByUuid[e]; return n === void 0 ? this.getObjectByProperty("uuid", e) : n } debugEnsureEntity (e) { let n = this.find(e); if (n) { if (Array.isArray(n.identity) && this.findInstance(n.identity) === void 0) { console.error("not found instance"); debugger } } else { console.error("not found"); debugger } } addPendingExpandCloner (e) { this.toExpandCloner.add(e) } addPendingUpdateCloner (e) { this.toUpdateCloner.add(e) } markToExpandCloner (e) { this.toExpandCloner.add(e), e.traverseEntityAncestors(n => { this.toExpandCloner.add(n) }) } doPendingExpandCloner () { this.toExpandCloner.forEach(e => { e.expandCloner(this) }), this.toExpandCloner.clear() } doPendingUpdateCloner () { this.toUpdateCloner.forEach(e => { e.cloner?.update() }), this.toUpdateCloner.clear() } doPendingUpdates () { this.doPendingExpandCloner(), this.doPendingUpdateCloner(), this.applyPendingCommands() } addPendingCommand (e) { this.pendingCommands.push(e) } applyPendingCommands () { this.pendingCommands.forEach(e => e()), this.pendingCommands.length = 0 } updateTreeByOp (e, n) { if (e.path.length === 0 && e.type === 7) { let r = e.parent === null ? this : this.find(e.parent); if (r === void 0) throw new Error("unexpected"); let s = this.createObject(e.id, e.data, e.children, r, e.localIndex, n); s.updateVisible(), s.resetBBoxNeedsUpdate(), Ir(s) && Hr(s.parent) && (s.invalidateUpstreamBooleanData(), s.parent.invalidateDownstreamBooleanData().recomputeBoolean()), this.markNeedsRecomputeInstancesForAncessors(r), this.markNeedsRecomputeInstancesForChildren(s), this.markToExpandCloner(s), this.markPenumbraSizeDirty() } else if (e.path.length === 0 && e.type === 8) { let r = this.find(e.id); if (r === void 0) throw new Error("unexpected"); this.markToExpandCloner(r), r.resetBBoxNeedsUpdate(), this.unregisterObject(r); let s = r.parent; this.markNeedsRecomputeInstancesForAncessors(s), this.markNeedsRecomputeInstancesForChildren(r), this.markPenumbraSizeDirty(), r.parent.remove(r), Hr(r.parent) && (r.parent.invalidateUpstreamBooleanData(), r.parent.invalidateDownstreamBooleanData().recomputeBoolean()), Ir(r) && (r.freeBooleanPointer(), s instanceof Bi && s.invalidateDownstreamBooleanData().recomputeBoolean()), r instanceof Wa && r.detachShape(), this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(r), this.pathConstraints.removeDependencies(r.uuid) } else if (e.path.length === 0 && e.type === 9) { let r = this.find(e.id); if (r === void 0) throw new Error("unexpected"); this.markNeedsRecomputeInstancesForChildren(r); let s = r.parent; this.markNeedsRecomputeInstancesForAncessors(s), r.cloner?.resetOnMove(), this.markToExpandCloner(r); let o = e.parent === null ? this : this.find(e.parent); if (o === void 0) throw new Error("unexpected"); o.add(r), this.markNeedsRecomputeInstancesForAncessors(o), this.markToExpandCloner(r), r.invalidateClonerTransform(r), r.updateVisible(), r.resetBBoxNeedsUpdate(), this.markPenumbraSizeDirty(); let a = e.localIndex; o.children.splice(a, 0, o.children.pop()), Ir(r) && (r.invalidateUpstreamBooleanData(), Hr(r.parent) ? r.parent.invalidateDownstreamBooleanData().recomputeBoolean() : s instanceof Bi && s.invalidateDownstreamBooleanData().recomputeBoolean()) } this.markNeedsUpdateRendererDirty(), this.markGeometryCacheDirty() } get playPage () { return this.find(this.data.publish.playPage) ?? this.errorPage } updatePage (e) { this.activePage && this.activePage.onDeactive(), this.activePage = this.errorPage; for (let n of this.children) n instanceof ti && (n.visible = n.uuid === e, n.visible && (this.activePage = n, this.activePage.onActive(this))) } updateEntityByOp (e, n, r, s) { if (n.type === 0) { if (("overrides" in n.props || "component" in n.props) && this.markNeedsRecomputeInstances(), "visible" in n.props && this.markPenumbraSizeDirty(), n.path.includes("overrides") && "states" in n.props) { let { rest: a } = n.props; n = { ...n, props: a }, this.markNeedsRecomputeInstances() } n.path[0] === "pathSnapping" && n.props.pathId !== void 0 && this.pathConstraints.setConstraint(e, n.props.pathId) } let o = this.find(e); if (o) try { ZI(o, n, r, { scene: this, shared: s }), o instanceof jt && o.updateGeometryGroupsIfNeeded() } catch (a) { console.error(a) } } get activeCamera () { return this.activePage.activeCamera } switchActiveCamera (e) { this.activePage.switchActiveCamera(e) } init (e, n) { this.createChildrenObjects(e.objects, this, n), this.updatePage(e.publish.playPage), this.activePage.switchToPlayCamera(), this.expandInstances(n, !0), this.traverseEntity(r => { Hr(r) && r.recomputeBoolean(), r instanceof Wt && r.updateUp() }), this.doPendingExpandCloner(), this.applyPendingCommands() } markNeedsRecomputeInstances () { this.needsRecomputeInstances = !0 } markNeedsRecomputeInstancesForChildren (e) { e.traverseEntity(n => { (n.data.type === "Component" || n.data.type === "Instance") && this.markNeedsRecomputeInstances() }) } markNeedsRecomputeInstancesForAncessors (e) { ct.is(e) && (e.data.type === "Component" && this.markNeedsRecomputeInstances(), e.traverseAncestors(n => { ct.is(n) && n.data.type === "Component" && this.markNeedsRecomputeInstances() })) } relativeizeInner (e, n, r, s, o, a, l) { if (e) { let u = s.find(e); u && u !== s && o.forInstancesRec(c => { c.data = Du(c.data, h => { let d = h.events.data(l.id), f = c.goUp(a); if (f) { let p = [...pg(f.identity), e].join("-"), m = this.entityIdentityToEntity[p]; if (m) { let g = m.uuid, y = Fr.zoom(d, n); y[r] = g } else { if (!1) debugger; console.warn("cannot find instance") } } }).data }) } } rewriteActions (e, n, r, s, o, a) { e.forEach(l => { l.data.type === "Transition" ? this.relativeizeInner(l.data.object, [...n, l.id], "object", r, s, o, a) : l.data.type === "Animation" && this.relativeizeInner(l.data.object, [...n, l.id], "object", r, s, o, a) }) } rewriteEventsBeforeGoToPlayMode () { this.traverseEntity(e => { if (e instanceof us && typeof e.identity == "string" && e.data.type === "Component") return e.traverseEntity((n, r) => { n.data.events.forEach(s => { if (s.data.type === "GameControl") { let o = !1; if (n.forInstancesRec(a => { a.data = Du(a.data, l => { a.isInstanceRoot || (l.events.delete(s.id), o = !0) }).data }), o === !1) for (let a of iy.list) this.rewriteActions(s.data.gameActions[a], ["gameActions", a], e, n, r, s) } else s.data.type === "Conditional" ? (s.data.condition.type === "Distance" ? (this.relativeizeInner(s.data.condition.fromObject, ["condition"], "fromObject", e, n, r, s), this.relativeizeInner(s.data.condition.toObject, ["condition"], "toObject", e, n, r, s)) : s.data.condition.type === "State" ? this.relativeizeInner(s.data.condition.object, ["condition"], "object", e, n, r, s) : s.data.condition.type === "Comparison" && (s.data.condition.lOperand.type === "Property" && this.relativeizeInner(s.data.condition.lOperand.value[0], ["condition", "lOperand", "value"], 0, e, n, r, s), s.data.condition.rOperand.type === "Property" && this.relativeizeInner(s.data.condition.rOperand.value[0], ["condition", "rOperand", "value"], 0, e, n, r, s)), this.rewriteActions(s.data.inActions, ["inActions"], e, n, r, s), this.rewriteActions(s.data.outActions, ["outActions"], e, n, r, s)) : "actions" in s.data && this.rewriteActions(s.data.actions, ["actions"], e, n, r, s) }) }), !0 }) } expandInstances (e, n, r) { let s = new Set; this.traverseEntity(o => { if (o instanceof us && o.isInstanceRoot) return o.expandInstanceChildren({ scene: this, shared: e, pendingDeletes: s }), n || o.resetBBoxNeedsUpdate(), r && o.traverseEntity(a => { r.addClip(a) }), !0 }); for (let o of s) this.disposeAndUnregisterEntityRecursivelyIfNotReregistered(o), Ev(o) } recomputeInstances (e, n) { this.needsRecomputeInstances && (this.needsRecomputeInstances = !1, this.traverseEntity(r => { r instanceof us && r.isInstanceRoot && (r.component = void 0) }), this.expandInstances(e, !1, n)) } disposeAndUnregisterEntityRecursivelyIfNotReregistered (e) { e.traverseEntity(n => { let r = typeof n.identity == "string" ? n.identity : n.identity.join("-"); this.entityIdentityToEntity[r] === n && (delete this.entityByUuid[n.uuid], delete this.entityIdentityToEntity[r]), n.dispose() }) } clearScene () { for (let e of this.children) ct.is(e) && e.disposeRecursively(); this.children.length = 0 } resetAfterClear (e, n) { this.init(e, n) } raycast (e) { return this.raycast1(e, !1) } raycast1 (e, n) { let r = [], s = o => { for (let a of o.children) { let l = a.cloner; if (ct.is(a) && !a.raycastLock && (a.visible || l?.object.data.visible)) if (n === !0 && a.isInstanceRoot) { let u = []; if (e.intersectObject(a, !0, u), u.length) { let c = u[0]; c.object = a, c.point.applyMatrix4(c.object.matrixWorld); let h = a.matrixWorld.clone().invert(); c.point.applyMatrix4(h), r.push(c) } } else (Ir(a) || ap(a) && this.enableHelpers && a.objectHelper.visible) && (e.intersectObject(a, !1, r), dp(a, e, r)), s(a) } }; return s(this), r } raycastWithClones (e) { let n = [], r = s => { for (let o of s.children) { let a = o.cloner; ct.is(o) && (o.visible || a?.object.data.visible) && ((Ir(o) || ap(o) && this.enableHelpers && o.objectHelper.visible) && (e.intersectObject(o, !1, n), dp(o, e, n, !0)), r(o)) } }; return r(this), n } forEachEntity (e) { for (let n of this.children) ct.is(n) && e(n) } traverseConcreteEntity (e) { for (let n of this.children) ct.is(n) && n.isConcreteEntity && n.traverseEntity(e) } traverseEntity (e) { for (let n of this.children) ct.is(n) && n.traverseEntity(e) } traverseObject (e) { for (let n of this.children) th.is(n) && n.traverseObject(e) } traverseVisibleEntity (e) { for (let n of this.children) ct.is(n) && n.visible && n.traverseVisibleEntity(e) } dispose () { this.clearScene() } createChildrenObjects (e, n, r) { let s = 0; for (let o of e) this.createObject(o.id, o.data, o.children, n, s, r), s += 1 } registerObjectCreatedInLegacy (e) { this.entityByUuid[e.uuid] = e } unregisterObject (e) { delete this.entityByUuid[e.uuid]; for (let n of e.children) this.unregisterObject(n) } createObject (e, n, r, s, o, a) { let l = { scene: this, shared: a }, u = Tv(e, n, l); return u && (this.entityByUuid[e] = u, s.add(u), s.children.splice(o, 0, s.children.pop()), r.length > 0 && (u.isInstanceRoot ? console.error("instance should not have children!") : this.createChildrenObjects(r, u, a)), u.updateState(n, l), u instanceof jt && u.updateGeometryGroupsIfNeeded(), u.updateVisible(), u.cloner && this.toExpandCloner.add(u), n.pathSnapping?.pathId && this.pathConstraints.setConstraint(e, n.pathSnapping.pathId)), n.type === "Empty" && n.animations && u.traverseEntity(c => { if (c instanceof jt && c.isSkinnedMesh) { let h = c.dataPatched; if (h.bones && h.boneInverses) { let d = h.bones.map(m => this.find(m)), f = h.boneInverses.map(m => new se().fromArray(m)), p = new ia(d, f); c.bind(p, c.bindMatrix) } } else c.matrixAutoUpdate = !0 }), u } getCenter (e) { let n = []; for (let s = 0, o = e.length; s < o; ++s) { let { id: a, recursive: l } = e[s], u = this.find(a), c = l ? u.recursiveBBox : u.singleBBox; n.push(...c.vertices) } let r = new _t; return r.setFromPoints(n), r.getCenter(nD), nD } copyMatrixWorld (e, n) { if (e === null) { n.identity(); return } let r = this.find(e); r ? n.copy(r.matrixWorld) : n.identity() } copyParentMatrixWorld (e, n) { if (e === null) { n.identity(); return } let r = this.find(e)?.parent; r ? n.copy(r.matrixWorld) : n.identity() } traverseMaterial (e) { this.traverseEntity(n => { if (n instanceof Ht) if (Array.isArray(n.material)) for (let r = 0; r < n.material.length; r++)n.material[r] instanceof $r && e(n.material[r]); else n.material instanceof $r && e(n.material) }) } updateViewPlaneSize (e, n, r = !1) { this.traverseConcreteEntity(s => { s instanceof Wt && s.setViewplaneSize(e, n, r) }) } }; var fp = (i, t) => { let e = t.x - i.x, n = t.y - i.y; return Math.sqrt(e * e + n * n) }, rD = (i, t) => { let e = t.x - i.x, n = t.y - i.y; return lq(Math.atan2(n, e)) }, iD = (i, t, e) => { let n = { x: 0, y: 0 }; return e = Pv(e), n.x = i.x - t * Math.cos(e), n.y = i.y - t * Math.sin(e), n }, Pv = i => i * (Math.PI / 180), lq = i => i * (180 / Math.PI), sD = i => isNaN(i.buttons) ? i.pressure !== 0 : i.buttons !== 0, jS = new Map, WS = i => { jS.has(i) && clearTimeout(jS.get(i)), jS.set(i, setTimeout(i, 100)) }, ud = (i, t, e) => { let n = t.split(/[ ,]+/g), r; for (let s = 0; s < n.length; s += 1)r = n[s], i.addEventListener ? i.addEventListener(r, e, !1) : i.attachEvent && i.attachEvent(r, e) }, qS = (i, t, e) => { let n = t.split(/[ ,]+/g), r; for (let s = 0; s < n.length; s += 1)r = n[s], i.removeEventListener ? i.removeEventListener(r, e) : i.detachEvent && i.detachEvent(r, e) }; var Iv = i => (i.preventDefault(), i.type.match(/^touch/) ? i.changedTouches : i), YS = () => { if (typeof window > "u") return; let i = window.pageXOffset !== void 0 ? window.pageXOffset : (document.documentElement || document.body.parentNode || document.body).scrollLeft, t = window.pageYOffset !== void 0 ? window.pageYOffset : (document.documentElement || document.body.parentNode || document.body).scrollTop; return { x: i, y: t } }, Dv = (i, t) => { t.top || t.right || t.bottom || t.left ? (i.style.top = t.top, i.style.right = t.right, i.style.bottom = t.bottom, i.style.left = t.left) : (i.style.left = t.x + "px", i.style.top = t.y + "px") }, Ov = (i, t, e) => { let n = aD(i); for (let r in n) if (n.hasOwnProperty(r)) if (typeof t == "string") n[r] = t + " " + e; else { let s = ""; for (let o = 0, a = t.length; o < a; o += 1)s += t[o] + " " + e + ", "; n[r] = s.slice(0, -2) } return n }, oD = (i, t) => { let e = aD(i); for (let n in e) e.hasOwnProperty(n) && (e[n] = t); return e }, aD = i => { let t = {}; return t[i] = "", ["webkit", "Moz", "o"].forEach(function (n) { t[n + i.charAt(0).toUpperCase() + i.slice(1)] = "" }), t }, Rv = (i, t) => { for (let e in t) t.hasOwnProperty(e) && (i[e] = t[e]); return i }, lD = (i, t) => { let e = {}; for (let n in i) i.hasOwnProperty(n) && t.hasOwnProperty(n) ? e[n] = t[n] : i.hasOwnProperty(n) && (e[n] = i[n]); return e }, pp = (i, t) => { if (i.length) for (let e = 0, n = i.length; e < n; e += 1)t(i[e]); else t(i) }, cD = (i, t, e) => ({ x: Math.min(Math.max(i.x, t.x - e), t.x + e), y: Math.min(Math.max(i.y, t.y - e), t.y + e) }); typeof window < "u" && (uD = "ontouchstart" in window, hD = !!window.PointerEvent, dD = !!window.MSPointerEvent); var uD, hD, dD, mp = { touch: { start: "touchstart", move: "touchmove", end: "touchend, touchcancel" }, mouse: { start: "mousedown", move: "mousemove", end: "mouseup" }, pointer: { start: "pointerdown", move: "pointermove", end: "pointerup, pointercancel" }, MSPointer: { start: "MSPointerDown", move: "MSPointerMove", end: "MSPointerUp" } }, hd, gp = {}; hD ? hd = mp.pointer : dD ? hd = mp.MSPointer : uD ? (hd = mp.touch, gp = mp.mouse) : hd = mp.mouse; function $l () { } $l.prototype.on = function (i, t) { var e = this, n = i.split(/[ ,]+/g), r; e._handlers_ = e._handlers_ || {}; for (var s = 0; s < n.length; s += 1)r = n[s], e._handlers_[r] = e._handlers_[r] || [], e._handlers_[r].push(t); return e }; $l.prototype.off = function (i, t) { var e = this; return e._handlers_ = e._handlers_ || {}, i === void 0 ? e._handlers_ = {} : t === void 0 ? e._handlers_[i] = null : e._handlers_[i] && e._handlers_[i].indexOf(t) >= 0 && e._handlers_[i].splice(e._handlers_[i].indexOf(t), 1), e }; $l.prototype.trigger = function (i, t) { var e = this, n = i.split(/[ ,]+/g), r; e._handlers_ = e._handlers_ || {}; for (var s = 0; s < n.length; s += 1)r = n[s], e._handlers_[r] && e._handlers_[r].length && e._handlers_[r].forEach(function (o) { o.call(e, { type: r, target: e }, t) }) }; $l.prototype.config = function (i) { var t = this; t.options = t.defaults || {}, i && (t.options = lD(t.options, i)) }; $l.prototype.bindEvt = function (i, t) { var e = this; return e._domHandlers_ = e._domHandlers_ || {}, e._domHandlers_[t] = function () { typeof e["on" + t] == "function" ? e["on" + t].apply(e, arguments) : console.warn('[WARNING] : Missing "on' + t + '" handler.') }, ud(i, hd[t], e._domHandlers_[t]), gp[t] && ud(i, gp[t], e._domHandlers_[t]), e }; $l.prototype.unbindEvt = function (i, t) { var e = this; return e._domHandlers_ = e._domHandlers_ || {}, qS(i, hd[t], e._domHandlers_[t]), gp[t] && qS(i, gp[t], e._domHandlers_[t]), delete e._domHandlers_[t], this }; var dd = $l; function Qn (i, t) { return this.identifier = t.identifier, this.position = t.position, this.frontPosition = t.frontPosition, this.collection = i, this.defaults = { size: 100, threshold: .1, color: "white", fadeTime: 250, dataOnly: !1, restJoystick: !0, restOpacity: 1, mode: "dynamic", zone: document.body, lockX: !1, lockY: !1, shape: "circle" }, this.config(t), this.options.mode === "dynamic" && (this.options.restOpacity = 0), this.id = Qn.id, Qn.id += 1, this.buildEl().stylize(), this.instance = { el: this.ui.el, on: this.on.bind(this), off: this.off.bind(this), show: this.show.bind(this), hide: this.hide.bind(this), add: this.addToDom.bind(this), remove: this.removeFromDom.bind(this), destroy: this.destroy.bind(this), setPosition: this.setPosition.bind(this), resetDirection: this.resetDirection.bind(this), computeDirection: this.computeDirection.bind(this), trigger: this.trigger.bind(this), position: this.position, frontPosition: this.frontPosition, ui: this.ui, identifier: this.identifier, id: this.id, options: this.options }, this.instance } Qn.prototype = new dd; Qn.constructor = Qn; Qn.id = 0; Qn.prototype.buildEl = function (i) { return this.ui = {}, this.options.dataOnly ? this : (this.ui.el = document.createElement("div"), this.ui.back = document.createElement("div"), this.ui.front = document.createElement("div"), this.ui.el.class = "nipple collection_" + this.collection.id, this.ui.back.class = "back", this.ui.front.class = "front", this.ui.el.setAttribute("id", "nipple_" + this.collection.id + "_" + this.id), this.ui.el.appendChild(this.ui.back), this.ui.el.appendChild(this.ui.front), this) }; Qn.prototype.stylize = function () { if (this.options.dataOnly) return this; var i = this.options.fadeTime + "ms", t = oD("borderRadius", "50%"), e = Ov("transition", "opacity", i), n = {}; return n.el = { position: "absolute", opacity: this.options.restOpacity, display: "block", zIndex: 999 }, n.back = { position: "absolute", display: "block", width: this.options.size + "px", height: this.options.size + "px", marginLeft: -this.options.size / 2 + "px", marginTop: -this.options.size / 2 + "px", background: "rgba(255, 255, 255, .4)", border: "solid 2px rgba(0, 0, 0, .1)" }, n.front = { width: this.options.size / 2 + "px", height: this.options.size / 2 + "px", position: "absolute", display: "block", marginLeft: -this.options.size / 4 + "px", marginTop: -this.options.size / 4 + "px", background: "rgba(255, 255, 255, .8)", border: "solid 2px rgba(0, 0, 0, .1)" }, Rv(n.el, e), this.options.shape === "circle" && Rv(n.back, t), Rv(n.front, t), this.applyStyles(n), this }; Qn.prototype.applyStyles = function (i) { for (var t in this.ui) if (this.ui.hasOwnProperty(t)) for (var e in i[t]) this.ui[t].style[e] = i[t][e]; return this }; Qn.prototype.addToDom = function () { return this.options.dataOnly || document.body.contains(this.ui.el) ? this : (this.options.zone.appendChild(this.ui.el), this) }; Qn.prototype.removeFromDom = function () { return this.options.dataOnly || !document.body.contains(this.ui.el) ? this : (this.options.zone.removeChild(this.ui.el), this) }; Qn.prototype.destroy = function () { clearTimeout(this.removeTimeout), clearTimeout(this.showTimeout), clearTimeout(this.restTimeout), this.trigger("destroyed", this.instance), this.removeFromDom(), this.off() }; Qn.prototype.show = function (i) { var t = this; return t.options.dataOnly || (clearTimeout(t.removeTimeout), clearTimeout(t.showTimeout), clearTimeout(t.restTimeout), t.addToDom(), t.restCallback(), setTimeout(function () { t.ui.el.style.opacity = 1 }, 0), t.showTimeout = setTimeout(function () { t.trigger("shown", t.instance), typeof i == "function" && i.call(this) }, t.options.fadeTime)), t }; Qn.prototype.hide = function (i) { var t = this; if (t.options.dataOnly) return t; if (t.ui.el.style.opacity = t.options.restOpacity, clearTimeout(t.removeTimeout), clearTimeout(t.showTimeout), clearTimeout(t.restTimeout), t.removeTimeout = setTimeout(function () { var e = t.options.mode === "dynamic" ? "none" : "block"; t.ui.el.style.display = e, typeof i == "function" && i.call(t), t.trigger("hidden", t.instance) }, t.options.fadeTime), t.options.restJoystick) { let e = t.options.restJoystick, n = {}; n.x = e === !0 || e.x !== !1 ? 0 : t.instance.frontPosition.x, n.y = e === !0 || e.y !== !1 ? 0 : t.instance.frontPosition.y, t.setPosition(i, n) } return t }; Qn.prototype.setPosition = function (i, t) { var e = this; e.frontPosition = { x: t.x, y: t.y }; var n = e.options.fadeTime + "ms", r = {}; r.front = Ov("transition", ["top", "left"], n); var s = { front: {} }; s.front = { left: e.frontPosition.x + "px", top: e.frontPosition.y + "px" }, e.applyStyles(r), e.applyStyles(s), e.restTimeout = setTimeout(function () { typeof i == "function" && i.call(e), e.restCallback() }, e.options.fadeTime) }; Qn.prototype.restCallback = function () { var i = this, t = {}; t.front = Ov("transition", "none", ""), i.applyStyles(t), i.trigger("rested", i.instance) }; Qn.prototype.resetDirection = function () { this.direction = { x: !1, y: !1, angle: !1 } }; Qn.prototype.computeDirection = function (i) { var t = i.angle.radian, e = Math.PI / 4, n = Math.PI / 2, r, s, o; if (t > e && t < e * 3 && !i.lockX ? r = "up" : t > -e && t <= e && !i.lockY ? r = "left" : t > -e * 3 && t <= -e && !i.lockX ? r = "down" : i.lockY || (r = "right"), i.lockY || (t > -n && t < n ? s = "left" : s = "right"), i.lockX || (t > 0 ? o = "up" : o = "down"), i.force > this.options.threshold) { var a = {}, l; for (l in this.direction) this.direction.hasOwnProperty(l) && (a[l] = this.direction[l]); var u = {}; this.direction = { x: s, y: o, angle: r }, i.direction = this.direction; for (l in a) a[l] === this.direction[l] && (u[l] = !0); if (u.x && u.y && u.angle) return i; (!u.x || !u.y) && this.trigger("plain", i), u.x || this.trigger("plain:" + s, i), u.y || this.trigger("plain:" + o, i), u.angle || this.trigger("dir dir:" + r, i) } else this.resetDirection(); return i }; var fD = Qn; function En (i, t) { var e = this; e.nipples = [], e.idles = [], e.actives = [], e.ids = [], e.pressureIntervals = {}, e.manager = i, e.id = En.id, En.id += 1, e.defaults = { zone: document.body, multitouch: !1, maxNumberOfNipples: 10, mode: "dynamic", position: { top: 0, left: 0 }, catchDistance: 200, size: 100, threshold: .1, color: "white", fadeTime: 250, dataOnly: !1, restJoystick: !0, restOpacity: 1, lockX: !1, lockY: !1, shape: "circle", dynamicPage: !1, follow: !1 }, e.config(t), (e.options.mode === "static" || e.options.mode === "semi") && (e.options.multitouch = !1), e.options.multitouch || (e.options.maxNumberOfNipples = 1); let n = getComputedStyle(e.options.zone.parentElement); return n && n.display === "flex" && (e.parentIsFlex = !0), e.updateBox(), e.prepareNipples(), e.bindings(), e.begin(), e.nipples } En.prototype = new dd; En.constructor = En; En.id = 0; En.prototype.prepareNipples = function () { var i = this, t = i.nipples; t.on = i.on.bind(i), t.off = i.off.bind(i), t.options = i.options, t.destroy = i.destroy.bind(i), t.ids = i.ids, t.id = i.id, t.processOnMove = i.processOnMove.bind(i), t.processOnEnd = i.processOnEnd.bind(i), t.get = function (e) { if (e === void 0) return t[0]; for (var n = 0, r = t.length; n < r; n += 1)if (t[n].identifier === e) return t[n]; return !1 } }; En.prototype.bindings = function () { var i = this; i.bindEvt(i.options.zone, "start"), i.options.zone.style.touchAction = "none", i.options.zone.style.msTouchAction = "none" }; En.prototype.begin = function () { var i = this, t = i.options; if (t.mode === "static") { var e = i.createNipple(t.position, i.manager.getIdentifier()); e.add(), i.idles.push(e) } }; En.prototype.createNipple = function (i, t) { var e = this, n = e.manager.scroll, r = {}, s = e.options, o = { x: e.parentIsFlex ? n.x : n.x + e.box.left, y: e.parentIsFlex ? n.y : n.y + e.box.top }; if (i.x && i.y) r = { x: i.x - o.x, y: i.y - o.y }; else if (i.top || i.right || i.bottom || i.left) { var a = document.createElement("DIV"); a.style.display = "hidden", a.style.top = i.top, a.style.right = i.right, a.style.bottom = i.bottom, a.style.left = i.left, a.style.position = "absolute", s.zone.appendChild(a); var l = a.getBoundingClientRect(); s.zone.removeChild(a), r = i, i = { x: l.left + n.x, y: l.top + n.y } } var u = new fD(e, { color: s.color, size: s.size, threshold: s.threshold, fadeTime: s.fadeTime, dataOnly: s.dataOnly, restJoystick: s.restJoystick, restOpacity: s.restOpacity, mode: s.mode, identifier: t, position: i, zone: s.zone, frontPosition: { x: 0, y: 0 }, shape: s.shape }); return s.dataOnly || (Dv(u.ui.el, r), Dv(u.ui.front, u.frontPosition)), e.nipples.push(u), e.trigger("added " + u.identifier + ":added", u), e.manager.trigger("added " + u.identifier + ":added", u), e.bindNipple(u), u }; En.prototype.updateBox = function () { var i = this; i.box = i.options.zone.getBoundingClientRect() }; En.prototype.bindNipple = function (i) { var t = this, e, n = function (r, s) { e = r.type + " " + s.id + ":" + r.type, t.trigger(e, s) }; i.on("destroyed", t.onDestroyed.bind(t)), i.on("shown hidden rested dir plain", n), i.on("dir:up dir:right dir:down dir:left", n), i.on("plain:up plain:right plain:down plain:left", n) }; En.prototype.pressureFn = function (i, t, e) { var n = this, r = 0; clearInterval(n.pressureIntervals[e]), n.pressureIntervals[e] = setInterval(function () { var s = i.force || i.pressure || i.webkitForce || 0; s !== r && (t.trigger("pressure", s), n.trigger("pressure " + t.identifier + ":pressure", s), r = s) }.bind(n), 100) }; En.prototype.onstart = function (i) { var t = this, e = t.options, n = i; i = Iv(i), t.updateBox(); var r = function (s) { t.actives.length < e.maxNumberOfNipples ? t.processOnStart(s) : n.type.match(/^touch/) && (Object.keys(t.manager.ids).forEach(function (o) { if (Object.values(n.touches).findIndex(function (l) { return l.identifier === o }) < 0) { var a = [i[0]]; a.identifier = o, t.processOnEnd(a) } }), t.actives.length < e.maxNumberOfNipples && t.processOnStart(s)) }; return pp(i, r), t.manager.bindDocument(), !1 }; En.prototype.processOnStart = function (i) { var t = this, e = t.options, n, r = t.manager.getIdentifier(i), s = i.force || i.pressure || i.webkitForce || 0, o = { x: i.pageX, y: i.pageY }, a = t.getOrCreate(r, o); a.identifier !== r && t.manager.removeIdentifier(a.identifier), a.identifier = r; var l = function (c) { c.trigger("start", c), t.trigger("start " + c.id + ":start", c), c.show(), s > 0 && t.pressureFn(i, c, c.identifier), t.processOnMove(i) }; if ((n = t.idles.indexOf(a)) >= 0 && t.idles.splice(n, 1), t.actives.push(a), t.ids.push(a.identifier), e.mode !== "semi") l(a); else { var u = fp(o, a.position); if (u <= e.catchDistance) l(a); else { a.destroy(), t.processOnStart(i); return } } return a }; En.prototype.getOrCreate = function (i, t) { var e = this, n = e.options, r; return /(semi|static)/.test(n.mode) ? (r = e.idles[0], r ? (e.idles.splice(0, 1), r) : n.mode === "semi" ? e.createNipple(t, i) : (console.warn("Coudln't find the needed nipple."), !1)) : (r = e.createNipple(t, i), r) }; En.prototype.processOnMove = function (i) { var t = this, e = t.options, n = t.manager.getIdentifier(i), r = t.nipples.get(n), s = t.manager.scroll; if (!sD(i)) { this.processOnEnd(i); return } if (!r) { console.error("Found zombie joystick with ID " + n), t.manager.removeIdentifier(n); return } if (e.dynamicPage) { var o = r.el.getBoundingClientRect(); r.position = { x: s.x + o.left, y: s.y + o.top } } r.identifier = n; var a = r.options.size / 2, l = { x: i.pageX, y: i.pageY }; e.lockX && (l.y = r.position.y), e.lockY && (l.x = r.position.x); var u = fp(l, r.position), c = rD(l, r.position), h = Pv(c), d = u / a, f = { distance: u, position: l }, p, m; if (r.options.shape === "circle" ? (p = Math.min(u, a), m = iD(r.position, p, c)) : (m = cD(l, r.position, a), p = fp(m, r.position)), e.follow) { if (u > a) { let x = l.x - m.x, b = l.y - m.y; r.position.x += x, r.position.y += b, r.el.style.top = r.position.y - (t.box.top + s.y) + "px", r.el.style.left = r.position.x - (t.box.left + s.x) + "px", u = fp(l, r.position) } } else l = m, u = p; var g = l.x - r.position.x, y = l.y - r.position.y; r.frontPosition = { x: g, y }, e.dataOnly || Dv(r.ui.front, r.frontPosition); var v = { identifier: r.identifier, position: l, force: d, pressure: i.force || i.pressure || i.webkitForce || 0, distance: u, angle: { radian: h, degree: c }, vector: { x: g / a, y: -y / a }, raw: f, instance: r, lockX: e.lockX, lockY: e.lockY }; v = r.computeDirection(v), v.angle = { radian: Pv(180 - c), degree: 180 - c }, r.trigger("move", v), t.trigger("move " + r.id + ":move", v) }; En.prototype.processOnEnd = function (i) { var t = this, e = t.options, n = t.manager.getIdentifier(i), r = t.nipples.get(n), s = t.manager.removeIdentifier(r.identifier); !r || (e.dataOnly || r.hide(function () { e.mode === "dynamic" && (r.trigger("removed", r), t.trigger("removed " + r.id + ":removed", r), t.manager.trigger("removed " + r.id + ":removed", r), r.destroy()) }), clearInterval(t.pressureIntervals[r.identifier]), r.resetDirection(), r.trigger("end", r), t.trigger("end " + r.id + ":end", r), t.ids.indexOf(r.identifier) >= 0 && t.ids.splice(t.ids.indexOf(r.identifier), 1), t.actives.indexOf(r) >= 0 && t.actives.splice(t.actives.indexOf(r), 1), /(semi|static)/.test(e.mode) ? t.idles.push(r) : t.nipples.indexOf(r) >= 0 && t.nipples.splice(t.nipples.indexOf(r), 1), t.manager.unbindDocument(), /(semi|static)/.test(e.mode) && (t.manager.ids[s.id] = s.identifier)) }; En.prototype.onDestroyed = function (i, t) { var e = this; e.nipples.indexOf(t) >= 0 && e.nipples.splice(e.nipples.indexOf(t), 1), e.actives.indexOf(t) >= 0 && e.actives.splice(e.actives.indexOf(t), 1), e.idles.indexOf(t) >= 0 && e.idles.splice(e.idles.indexOf(t), 1), e.ids.indexOf(t.identifier) >= 0 && e.ids.splice(e.ids.indexOf(t.identifier), 1), e.manager.removeIdentifier(t.identifier), e.manager.unbindDocument() }; En.prototype.destroy = function () { var i = this; i.unbindEvt(i.options.zone, "start"), i.nipples.forEach(function (e) { e.destroy() }); for (var t in i.pressureIntervals) i.pressureIntervals.hasOwnProperty(t) && clearInterval(i.pressureIntervals[t]); i.trigger("destroyed", i.nipples), i.manager.unbindDocument(), i.off() }; var pD = En; function fr (i) { var t = this; t.ids = {}, t.index = 0, t.collections = [], t.scroll = YS(), t.config(i), t.prepareCollections(); var e = function () { var r; t.collections.forEach(function (s) { s.forEach(function (o) { r = o.el.getBoundingClientRect(), o.position = { x: t.scroll.x + r.left, y: t.scroll.y + r.top } }) }) }; if (typeof window > "u") return t.collections; ud(window, "resize", function () { WS(e) }); var n = function () { t.scroll = YS() }; return ud(window, "scroll", function () { WS(n) }), t.collections } fr.prototype = new dd; fr.constructor = fr; fr.prototype.prepareCollections = function () { var i = this; i.collections.create = i.create.bind(i), i.collections.on = i.on.bind(i), i.collections.off = i.off.bind(i), i.collections.destroy = i.destroy.bind(i), i.collections.get = function (t) { var e; return i.collections.every(function (n) { return e = n.get(t), !e }), e } }; fr.prototype.create = function (i) { return this.createCollection(i) }; fr.prototype.createCollection = function (i) { var t = this, e = new pD(t, i); return t.bindCollection(e), t.collections.push(e), e }; fr.prototype.bindCollection = function (i) { var t = this, e, n = function (r, s) { e = r.type + " " + s.id + ":" + r.type, t.trigger(e, s) }; i.on("destroyed", t.onDestroyed.bind(t)), i.on("shown hidden rested dir plain", n), i.on("dir:up dir:right dir:down dir:left", n), i.on("plain:up plain:right plain:down plain:left", n) }; fr.prototype.bindDocument = function () { var i = this; i.binded || (i.bindEvt(document, "move").bindEvt(document, "end"), i.binded = !0) }; fr.prototype.unbindDocument = function (i) { var t = this; (!Object.keys(t.ids).length || i === !0) && (t.unbindEvt(document, "move").unbindEvt(document, "end"), t.binded = !1) }; fr.prototype.getIdentifier = function (i) { var t; return i ? (t = i.identifier === void 0 ? i.pointerId : i.identifier, t === void 0 && (t = this.latest || 0)) : t = this.index, this.ids[t] === void 0 && (this.ids[t] = this.index, this.index += 1), this.latest = t, this.ids[t] }; fr.prototype.removeIdentifier = function (i) { var t = {}; for (var e in this.ids) if (this.ids[e] === i) { t.id = e, t.identifier = this.ids[e], delete this.ids[e]; break } return t }; fr.prototype.onmove = function (i) { var t = this; return t.onAny("move", i), !1 }; fr.prototype.onend = function (i) { var t = this; return t.onAny("end", i), !1 }; fr.prototype.oncancel = function (i) { var t = this; return t.onAny("end", i), !1 }; fr.prototype.onAny = function (i, t) { var e = this, n, r = "processOn" + i.charAt(0).toUpperCase() + i.slice(1); t = Iv(t); var s = function (a, l, u) { u.ids.indexOf(l) >= 0 && (u[r](a), a._found_ = !0) }, o = function (a) { n = e.getIdentifier(a), pp(e.collections, s.bind(null, a, n)), a._found_ || e.removeIdentifier(n) }; return pp(t, o), !1 }; fr.prototype.destroy = function () { var i = this; i.unbindDocument(!0), i.ids = {}, i.index = 0, i.collections.forEach(function (t) { t.destroy() }), i.off() }; fr.prototype.onDestroyed = function (i, t) { var e = this; if (e.collections.indexOf(t) < 0) return !1; e.collections.splice(e.collections.indexOf(t), 1) }; var mD = fr; var gD = new mD, yD = { create: function (i) { return gD.create(i) }, factory: gD }; var vD = new Map, yp = new Map, Xs = class { constructor(t, e, n, r) { this.data = e; let { audio: s, volume: o, delay: a, loop: l } = e; if (!s) throw new Error("Missing property"); let u = typeof s == "string" ? r.getAudio(s).src : s.data; this.audioPlayer = new Lo({ src: u, volume: o, delay: a, loop: l }), yp.has(n.uuid) ? yp.get(n.uuid).push(this) : yp.set(n.uuid, [this]), vD.set(t, this) } playByToggle () { this.data.toggle === "stop" ? this.audioPlayer.status === "playing" ? this.audioPlayer.stop() : (this.audioPlayer.stop(), this.audioPlayer.play()) : this.data.toggle === "pause" ? this.audioPlayer.status === "playing" ? this.audioPlayer.pause() : this.audioPlayer.play() : (this.audioPlayer.stop(), this.audioPlayer.play()) } dispose () { this.audioPlayer.stop() } }, fd = class { constructor(t) { this.data = t } dispatch () { this.data.playAudio ? this.pauseAudio(this.data.playAudio) : this.data.object ? this.pauseAllAudiosFromObject(this.data.object) : this.pauseAllAudios() } pauseAudio (t) { let e = vD.get(t); !e || (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => { e.audioPlayer[this.data.interaction](), this.disposeDelay() }, this.data.delay)) : e.audioPlayer[this.data.interaction]()) } pauseAllAudiosFromObject (t) { let e = yp.get(t); !e?.length || (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => { e.forEach(n => n.audioPlayer[this.data.interaction]()), this.disposeDelay() }, this.data.delay)) : e.forEach(n => n.audioPlayer[this.data.interaction]())) } pauseAllAudios () { let t = [...yp.values()]; !t.length || (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => { t.forEach(e => { e.forEach(n => { n.audioPlayer[this.data.interaction]() }) }), this.disposeDelay() }, this.data.delay)) : t.forEach(e => { e.forEach(n => { n.audioPlayer[this.data.interaction]() }) })) } disposeDelay () { clearTimeout(this.timeoutId), delete this.timeoutId } dispose () { clearTimeout(this.timeoutId), delete this.timeoutId } }, ko = class { constructor(t, e, n, r) { this.data = e; if (e.interaction === "play") this.interaction = new Xs(t, e, n, r); else if (e.interaction === "pause" || e.interaction === "stop") this.interaction = new fd(e); else throw new Error("Missing property") } dispatchBasic () { this.interaction instanceof Xs ? this.interaction.playByToggle() : this.interaction.dispatch() } dispatchConditional () { this.interaction instanceof Xs ? this.interaction.audioPlayer.play() : this.interaction.dispatch() } dispatchGameControl (t) { this.interaction instanceof Xs && (t === "start" ? this.interaction.audioPlayer.play() : this.interaction.audioPlayer.stop()) } dispose () { this.interaction.dispose() } }; var cq = "text/plain", uq = "us-ascii", xD = (i, t) => t.some(e => e instanceof RegExp ? e.test(i) : e === i), hq = (i, { stripHash: t }) => { let e = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(i); if (!e) throw new Error(`Invalid URL: ${i}`); let { type: n, data: r, hash: s } = e.groups, o = n.split(";"); s = t ? "" : s; let a = !1; o[o.length - 1] === "base64" && (o.pop(), a = !0); let l = (o.shift() || "").toLowerCase(), c = [...o.map(h => { let [d, f = ""] = h.split("=").map(p => p.trim()); return d === "charset" && (f = f.toLowerCase(), f === uq) ? "" : `${d}${f ? `=${f}` : ""}` }).filter(Boolean)]; return a && c.push("base64"), (c.length > 0 || l && l !== cq) && c.unshift(l), `data:${c.join(";")},${a ? r.trim() : r}${s ? `#${s}` : ""}` }; function XS (i, t) { if (t = { defaultProtocol: "http:", normalizeProtocol: !0, forceHttp: !1, forceHttps: !1, stripAuthentication: !0, stripHash: !1, stripTextFragment: !0, stripWWW: !0, removeQueryParameters: [/^utm_\w+/i], removeTrailingSlash: !0, removeSingleSlash: !0, removeDirectoryIndex: !1, sortQueryParameters: !0, ...t }, i = i.trim(), /^data:/i.test(i)) return hq(i, t); if (/^view-source:/i.test(i)) throw new Error("`view-source:` is not supported as it is a non-standard protocol"); let e = i.startsWith("//"); !e && /^\.*\//.test(i) || (i = i.replace(/^(?!(?:\w+:)?\/\/)|^\/\//, t.defaultProtocol)); let r = new URL(i); if (t.forceHttp && t.forceHttps) throw new Error("The `forceHttp` and `forceHttps` options cannot be used together"); if (t.forceHttp && r.protocol === "https:" && (r.protocol = "http:"), t.forceHttps && r.protocol === "http:" && (r.protocol = "https:"), t.stripAuthentication && (r.username = "", r.password = ""), t.stripHash ? r.hash = "" : t.stripTextFragment && (r.hash = r.hash.replace(/#?:~:text.*?$/i, "")), r.pathname) { let o = /\b[a-z][a-z\d+\-.]{1,50}:\/\//g, a = 0, l = ""; for (; ;) { let c = o.exec(r.pathname); if (!c) break; let h = c[0], d = c.index, f = r.pathname.slice(a, d); l += f.replace(/\/{2,}/g, "/"), l += h, a = d + h.length } let u = r.pathname.slice(a, r.pathname.length); l += u.replace(/\/{2,}/g, "/"), r.pathname = l } if (r.pathname) try { r.pathname = decodeURI(r.pathname) } catch { } if (t.removeDirectoryIndex === !0 && (t.removeDirectoryIndex = [/^index\.[a-z]+$/]), Array.isArray(t.removeDirectoryIndex) && t.removeDirectoryIndex.length > 0) { let o = r.pathname.split("/"), a = o[o.length - 1]; xD(a, t.removeDirectoryIndex) && (o = o.slice(0, -1), r.pathname = o.slice(1).join("/") + "/") } if (r.hostname && (r.hostname = r.hostname.replace(/\.$/, ""), t.stripWWW && /^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(r.hostname) && (r.hostname = r.hostname.replace(/^www\./, ""))), Array.isArray(t.removeQueryParameters)) for (let o of [...r.searchParams.keys()]) xD(o, t.removeQueryParameters) && r.searchParams.delete(o); if (t.removeQueryParameters === !0 && (r.search = ""), t.sortQueryParameters) { r.searchParams.sort(); try { r.search = decodeURIComponent(r.search) } catch { } } t.removeTrailingSlash && (r.pathname = r.pathname.replace(/\/$/, "")); let s = i; return i = r.toString(), !t.removeSingleSlash && r.pathname === "/" && !s.endsWith("/") && r.hash === "" && (i = i.replace(/\/$/, "")), (t.removeTrailingSlash || r.pathname === "/") && r.hash === "" && t.removeSingleSlash && (i = i.replace(/\/$/, "")), e && !t.normalizeProtocol && (i = i.replace(/^http:\/\//, "//")), t.stripProtocol && (i = i.replace(/^(?:https?:)?\/\//, "")), i } var Nv = class { constructor({ url: t, context: e }, n) { this.eventManager = n; if (!t) throw new Error("Missing property"); this.url = t.startsWith("mailto:") ? t : XS(t, { removeTrailingSlash: !1, removeSingleSlash: !1 }), this.context = e ?? "tab" } dispatch () { fg ? window.location.assign(this.url) : (this.context === "tab" ? window.open(this.url, "_blank") : this.context === "window" ? window.open(this.url, "_blank", `width=${window.innerWidth}, height=${window.innerHeight}`) : window.open(this.url, "_parent"), this.eventManager.controlsManager.orbitControls?.onPointerUp(je[0]), _T()) } }; var vp = class { constructor(t, e, n) { this.data = t; this.page = e; this.eventManager = n; this.timeoutIdQueue = []; this.dispatchInner = () => { this.objects.forEach(this.destroyCallback) }; this.destroyCallback = t => { this.timeoutIdQueue.shift(); let e = this.page.scene.find(t); if (e === void 0) return; let n = this.controlsManager.sharedGameControlGlobals.rapierWorld, r = n ? e.dataPatched.physics?.fusedBody : !0; if (e.cloner) { for (let s of e.cloner.children) r ? (s.playModeVisible = !1, s.rigidBody && e.dataPatched.physics?.rigidBody === "positioned" && (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(s.rigidBody.collider(0).handle), n.removeRigidBody(s.rigidBody), s.rigidBody = void 0), s.bvhGeometry && (s.bvhGeometry = void 0)) : this.clone === void 0 || this.clone === s ? (s.playModeVisible = !1, s.rigidBody && (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(s.rigidBody.collider(0).handle), n.removeRigidBody(s.rigidBody), s.rigidBody = void 0)) : s.playModeVisible === void 0 && (s.playModeVisible = !0); (r || this.clone === void 0 || this.clone === !1) && (e.visible = !1, e.rigidBody && (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(e.rigidBody.collider(0).handle), n.removeRigidBody(e.rigidBody), e.rigidBody = void 0), e.bvhGeometry && (e.bvhGeometry = void 0)) } else e.rigidBody && (this.controlsManager.sharedGameControlGlobals.colliderToEntity.delete(e.rigidBody.collider(0).handle), n.removeRigidBody(e.rigidBody), e.rigidBody = void 0), e.bvhGeometry && (e.bvhGeometry = void 0), e.visible = !1; n === void 0 ? this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim = this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.filter(s => s.bvhGeometry !== void 0) : this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim = this.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.filter(s => s.rigidBody !== void 0), this.eventManager.requestRender() }; this.objects = [...t.objects], this.controlsManager = n.controlsManager } dispatch (t) { this.clone = t, this.data.delay ? this.timeoutIdQueue.push(window.setTimeout(this.dispatchInner, this.data.delay * 1e3)) : this.dispatchInner() } dispatchFromStart () { this.timeoutIdQueue.push(window.setTimeout(this.dispatchInner, this.data.delay * 1e3)) } dispose () { this.timeoutIdQueue.forEach(t => window.clearTimeout(t)) } }; var Bv = class { constructor(t, e, n) { this.page = t; this.eventManager = n; this.sharedAssets = e } dispatch () { pd(this.page, this.sharedAssets, !0), this.eventManager.reset(), this.eventManager.controlsManager.gameControl?.reset(!0), this.page.switchToPlayCamera(), this.eventManager.controlsManager.requestRender() } }; var ED = { update: null, begin: null, loopBegin: null, changeBegin: null, change: null, changeComplete: null, timelineChangeComplete: null, loopComplete: null, complete: null, loop: 1, direction: "normal", autoplay: !0, timelineOffset: 0, rewind: !0 }, JS = { duration: 1e3, delay: 0, endDelay: 0, startOnceDelay: 0, pingPongDelayCorrection: 0, pingPongEndDelayCorrection: 0, easing: "easeOutElastic(1, .5)", round: 0 }, dq = ["translateX", "translateY", "translateZ", "rotate", "rotateX", "rotateY", "rotateZ", "scale", "scaleX", "scaleY", "scaleZ", "skew", "skewX", "skewY", "perspective", "matrix", "matrix3d"], kv = { CSS: {}, springs: {} }; function hs (i, t, e) { return Math.min(Math.max(i, t), e) } function xp (i, t) { return i.indexOf(t) > -1 } function QS (i, t) { return i.apply(null, t) } var tt = { arr: function (i) { return Array.isArray(i) }, obj: function (i) { return xp(Object.prototype.toString.call(i), "Object") }, pth: function (i) { return tt.obj(i) && i.hasOwnProperty("totalLength") }, svg: function (i) { return i instanceof SVGElement }, inp: function (i) { return i instanceof HTMLInputElement }, dom: function (i) { return !("isNode" in i) && (i.nodeType || tt.svg(i)) }, str: function (i) { return typeof i == "string" }, fnc: function (i) { return typeof i == "function" }, und: function (i) { return typeof i > "u" }, hex: function (i) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(i) }, rgb: function (i) { return /^rgb/.test(i) }, hsl: function (i) { return /^hsl/.test(i) }, col: function (i) { return tt.hex(i) || tt.rgb(i) || tt.hsl(i) }, key: function (i) { return !ED.hasOwnProperty(i) && !JS.hasOwnProperty(i) && i !== "targets" && i !== "keyframes" } }; function MD (i) { var t = /\(([^)]+)\)/.exec(i); return t ? t[1].split(",").map(function (e) { return parseFloat(e) }) : [] } function TD (i, t) { var e = MD(i), n = hs(tt.und(e[0]) ? 1 : e[0], .1, 100), r = hs(tt.und(e[1]) ? 100 : e[1], .1, 100), s = hs(tt.und(e[2]) ? 10 : e[2], .1, 100), o = hs(tt.und(e[3]) ? 0 : e[3], .1, 100), a = Math.sqrt(r / n), l = s / (2 * Math.sqrt(r * n)), u = l < 1 ? a * Math.sqrt(1 - l * l) : 0, c = 1, h = l < 1 ? (l * a + -o) / u : -o + a; function d (p) { var m = t ? t * p / 1e3 : p; return l < 1 ? m = Math.exp(-m * l * a) * (c * Math.cos(u * m) + h * Math.sin(u * m)) : m = (c + h * m) * Math.exp(-m * a), p === 0 || p === 1 ? p : 1 - m } function f () { var p = kv.springs[i]; if (p) return p; for (var m = 1 / 6, g = 0, y = 0; ;)if (g += m, d(g) === 1) { if (y++, y >= 16) break } else y = 0; var v = g * m * 1e3; return kv.springs[i] = v, v } return t ? d : f } function fq (i) { return i === void 0 && (i = 10), function (t) { return Math.ceil(hs(t, 1e-6, 1) * i) * (1 / i) } } var pq = function () { var i = 11, t = 1 / (i - 1); function e (c, h) { return 1 - 3 * h + 3 * c } function n (c, h) { return 3 * h - 6 * c } function r (c) { return 3 * c } function s (c, h, d) { return ((e(h, d) * c + n(h, d)) * c + r(h)) * c } function o (c, h, d) { return 3 * e(h, d) * c * c + 2 * n(h, d) * c + r(h) } function a (c, h, d, f, p) { var m, g, y = 0; do g = h + (d - h) / 2, m = s(g, f, p) - c, m > 0 ? d = g : h = g; while (Math.abs(m) > 1e-7 && ++y < 10); return g } function l (c, h, d, f) { for (var p = 0; p < 4; ++p) { var m = o(h, d, f); if (m === 0) return h; var g = s(h, d, f) - c; h -= g / m } return h } function u (c, h, d, f) { if (!(0 <= c && c <= 1 && 0 <= d && d <= 1)) return; var p = new Float32Array(i); if (c !== h || d !== f) for (var m = 0; m < i; ++m)p[m] = s(m * t, c, d); function g (y) { for (var v = 0, x = 1, b = i - 1; x !== b && p[x] <= y; ++x)v += t; --x; var S = (y - p[x]) / (p[x + 1] - p[x]), _ = v + S * t, E = o(_, c, d); return E >= .001 ? l(y, _, c, d) : E === 0 ? _ : a(y, v, v + t, c, d) } return function (y) { return c === h && d === f || y === 0 || y === 1 ? y : s(g(y), h, f) } } return u }(), CD = function () { var i = { linear: function () { return function (n) { return n } } }, t = { Sine: function () { return function (n) { return 1 - Math.cos(n * Math.PI / 2) } }, Circ: function () { return function (n) { return 1 - Math.sqrt(1 - n * n) } }, Back: function () { return function (n) { return n * n * (3 * n - 2) } }, Bounce: function () { return function (n) { for (var r, s = 4; n < ((r = Math.pow(2, --s)) - 1) / 11;); return 1 / Math.pow(4, 3 - s) - 7.5625 * Math.pow((r * 3 - 2) / 22 - n, 2) } }, Elastic: function (n, r) { n === void 0 && (n = 1), r === void 0 && (r = .5); var s = hs(n, 1, 10), o = hs(r, .1, 2); return function (a) { return a === 0 || a === 1 ? a : -s * Math.pow(2, 10 * (a - 1)) * Math.sin((a - 1 - o / (Math.PI * 2) * Math.asin(1 / s)) * (Math.PI * 2) / o) } } }, e = ["Quad", "Cubic", "Quart", "Quint", "Expo"]; return e.forEach(function (n, r) { t[n] = function () { return function (s) { return Math.pow(s, r + 2) } } }), Object.keys(t).forEach(function (n) { var r = t[n]; i["easeIn" + n] = r, i["easeOut" + n] = function (s, o) { return function (a) { return 1 - r(s, o)(1 - a) } }, i["easeInOut" + n] = function (s, o) { return function (a) { return a < .5 ? r(s, o)(a * 2) / 2 : 1 - r(s, o)(a * -2 + 2) / 2 } } }), i }(); function $S (i, t) { if (tt.fnc(i)) return i; var e = i.split("(")[0], n = CD[e], r = MD(i); switch (e) { case "spring": return TD(i, t); case "cubicBezier": return QS(pq, r); case "steps": return QS(fq, r); default: return QS(n, r) } } function PD (i) { try { var t = document.querySelectorAll(i); return t } catch { return } } function Uv (i, t) { for (var e = i.length, n = arguments.length >= 2 ? arguments[1] : void 0, r = [], s = 0; s < e; s++)if (s in i) { var o = i[s]; t.call(n, o, s, i) && r.push(o) } return r } function zv (i) { return i.reduce(function (t, e) { return t.concat(tt.arr(e) ? zv(e) : e) }, []) } function bD (i) { return tt.arr(i) ? i : (tt.str(i) && (i = PD(i) || i), i instanceof NodeList || i instanceof HTMLCollection ? [].slice.call(i) : [i]) } function e1 (i, t) { return i.some(function (e) { return e === t }) } function t1 (i) { var t = {}; for (var e in i) t[e] = i[e]; return t } function KS (i, t) { var e = t1(i); for (var n in i) e[n] = t.hasOwnProperty(n) ? t[n] : i[n]; return e } function Gv (i, t) { var e = t1(i); for (var n in t) e[n] = tt.und(i[n]) ? t[n] : i[n]; return e } function mq (i) { var t = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(i); return t ? "rgba(" + t[1] + ",1)" : i } function gq (i) { var t = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, e = i.replace(t, function (a, l, u, c) { return l + l + u + u + c + c }), n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e), r = parseInt(n[1], 16), s = parseInt(n[2], 16), o = parseInt(n[3], 16); return "rgba(" + r + "," + s + "," + o + ",1)" } function yq (i) { var t = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(i) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(i), e = parseInt(t[1], 10) / 360, n = parseInt(t[2], 10) / 100, r = parseInt(t[3], 10) / 100, s = t[4] || 1; function o (d, f, p) { return p < 0 && (p += 1), p > 1 && (p -= 1), p < 1 / 6 ? d + (f - d) * 6 * p : p < 1 / 2 ? f : p < 2 / 3 ? d + (f - d) * (2 / 3 - p) * 6 : d } var a, l, u; if (n == 0) a = l = u = r; else { var c = r < .5 ? r * (1 + n) : r + n - r * n, h = 2 * r - c; a = o(h, c, e + 1 / 3), l = o(h, c, e), u = o(h, c, e - 1 / 3) } return "rgba(" + a * 255 + "," + l * 255 + "," + u * 255 + "," + s + ")" } function vq (i) { if (tt.rgb(i)) return mq(i); if (tt.hex(i)) return gq(i); if (tt.hsl(i)) return yq(i) } function Uo (i) { var t = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(i); if (t) return t[1] } function xq (i) { if (xp(i, "translate") || i === "perspective") return "px"; if (xp(i, "rotate") || xp(i, "skew")) return "deg" } function ZS (i, t) { return tt.fnc(i) ? i(t.target, t.id, t.total) : i } function Qs (i, t) { return i.getAttribute(t) } function n1 (i, t, e) { var n = Uo(t); if (e1([e, "deg", "rad", "turn"], n)) return t; var r = kv.CSS[t + e]; if (!tt.und(r)) return r; var s = 100, o = document.createElement(i.tagName), a = i.parentNode && i.parentNode !== document ? i.parentNode : document.body; a.appendChild(o), o.style.position = "absolute", o.style.width = s + e; var l = s / o.offsetWidth; a.removeChild(o); var u = l * parseFloat(t); return kv.CSS[t + e] = u, u } function ID (i, t, e) { if (t in i.style) { var n = t.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), r = i.style[t] || getComputedStyle(i).getPropertyValue(n) || "0"; return e ? n1(i, r, e) : r } } function r1 (i, t) { if (tt.dom(i) && !tt.inp(i) && (Qs(i, t) || tt.svg(i) && i[t])) return "attribute"; if (tt.dom(i) && e1(dq, t)) return "transform"; if (tt.dom(i) && t !== "transform" && ID(i, t)) return "css"; if (i[t] != null) return "object" } function DD (i) { if (tt.dom(i)) { for (var t = i.style.transform || "", e = /(\w+)\(([^)]*)\)/g, n = new Map, r; r = e.exec(t);)n.set(r[1], r[2]); return n } } function bq (i, t, e, n) { var r = xp(t, "scale") ? 1 : 0 + xq(t), s = DD(i).get(t) || r; return e && (e.transforms.list.set(t, s), e.transforms.last = t), n ? n1(i, s, n) : s } function i1 (i, t, e, n) { switch (r1(i, t)) { case "transform": return bq(i, t, n, e); case "css": return ID(i, t, e); case "attribute": return Qs(i, t); default: return i[t] || 0 } } function s1 (i, t) { var e = /^(\*=|\+=|-=)/.exec(i); if (!e) return i; var n = Uo(i) || 0, r = parseFloat(t), s = parseFloat(i.replace(e[0], "")); switch (e[0][0]) { case "+": return r + s + n; case "-": return r - s + n; case "*": return r * s + n } } function OD (i, t) { if (tt.col(i)) return vq(i); if (/\s/g.test(i)) return i; var e = Uo(i), n = e ? i.substr(0, i.length - e.length) : i; return t ? n + t : n } function o1 (i, t) { return Math.sqrt(Math.pow(t.x - i.x, 2) + Math.pow(t.y - i.y, 2)) } function wq (i) { return Math.PI * 2 * Qs(i, "r") } function Sq (i) { return Qs(i, "width") * 2 + Qs(i, "height") * 2 } function Aq (i) { return o1({ x: Qs(i, "x1"), y: Qs(i, "y1") }, { x: Qs(i, "x2"), y: Qs(i, "y2") }) } function RD (i) { for (var t = i.points, e = 0, n, r = 0; r < t.numberOfItems; r++) { var s = t.getItem(r); r > 0 && (e += o1(n, s)), n = s } return e } function _q (i) { var t = i.points; return RD(i) + o1(t.getItem(t.numberOfItems - 1), t.getItem(0)) } function LD (i) { if (i.getTotalLength) return i.getTotalLength(); switch (i.tagName.toLowerCase()) { case "circle": return wq(i); case "rect": return Sq(i); case "line": return Aq(i); case "polyline": return RD(i); case "polygon": return _q(i) } } function Eq (i) { var t = LD(i); return i.setAttribute("stroke-dasharray", t), t } function Mq (i) { for (var t = i.parentNode; tt.svg(t) && tt.svg(t.parentNode);)t = t.parentNode; return t } function ND (i, t) { var e = t || {}, n = e.el || Mq(i), r = n.getBoundingClientRect(), s = Qs(n, "viewBox"), o = r.width, a = r.height, l = e.viewBox || (s ? s.split(" ") : [0, 0, o, a]); return { el: n, viewBox: l, x: l[0] / 1, y: l[1] / 1, w: o / l[2], h: a / l[3] } } function Tq (i, t) { var e = tt.str(i) ? PD(i)[0] : i, n = t || 100; return function (r) { return { property: r, el: e, svg: ND(e), totalLength: LD(e) * (n / 100) } } } function Cq (i, t) { function e (a) { a === void 0 && (a = 0); var l = t + a >= 1 ? t + a : 0; return i.el.getPointAtLength(l) } var n = ND(i.el, i.svg), r = e(), s = e(-1), o = e(1); switch (i.property) { case "x": return (r.x - n.x) * n.w; case "y": return (r.y - n.y) * n.h; case "angle": return Math.atan2(o.y - s.y, o.x - s.x) * 180 / Math.PI } } function wD (i, t) { var e = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g, n = OD(tt.pth(i) ? i.totalLength : i, t) + ""; return { original: n, numbers: n.match(e) ? n.match(e).map(Number) : [0], strings: tt.str(i) || t ? n.split(e) : [] } } function BD (i) { var t = i ? zv(tt.arr(i) ? i.map(bD) : bD(i)) : []; return Uv(t, function (e, n, r) { return r.indexOf(e) === n }) } function FD (i) { var t = BD(i); return t.map(function (e, n) { return { target: e, id: n, total: t.length, transforms: { list: DD(e) } } }) } function Pq (i, t) { var e = t1(t); if (/^spring/.test(e.easing) && (e.duration = TD(e.easing)), tt.arr(i)) { var n = i.length, r = n === 2 && !tt.obj(i[0]); r ? i = { value: i } : tt.fnc(t.duration) || (e.duration = t.duration / n) } var s = tt.arr(i) ? i : [i]; return s.map(function (o, a) { var l = tt.obj(o) && !tt.pth(o) ? o : { value: o }; return tt.und(l.delay) && (l.delay = a ? 0 : t.delay), tt.und(l.endDelay) && (l.endDelay = a === s.length - 1 ? t.endDelay : 0), l }).map(function (o) { return Gv(o, e) }) } function Iq (i) { for (var t = Uv(zv(i.map(function (s) { return Object.keys(s) })), function (s) { return tt.key(s) }).reduce(function (s, o) { return s.indexOf(o) < 0 && s.push(o), s }, []), e = {}, n = function (s) { var o = t[s]; e[o] = i.map(function (a) { var l = {}; for (var u in a) tt.key(u) ? u == o && (l.value = a[u]) : l[u] = a[u]; return l }) }, r = 0; r < t.length; r++)n(r); return e } function Dq (i, t) { var e = [], n = t.keyframes; n && (t = Gv(Iq(n), t)); for (var r in t) tt.key(r) && e.push({ name: r, tweens: Pq(t[r], i) }); return e } function Oq (i, t) { var e = {}; for (var n in i) { var r = ZS(i[n], t); tt.arr(r) && (r = r.map(function (s) { return ZS(s, t) }), r.length === 1 && (r = r[0])), e[n] = r } return e.duration = parseFloat(e.duration), e.delay = parseFloat(e.delay), e } function Rq (i, t) { var e; return i.tweens.map(function (n) { var r = Oq(n, t), s = r.value, o = tt.arr(s) ? s[1] : s, a = Uo(o), l = i1(t.target, i.name, a, t), u = e ? e.to.original : l, c = tt.arr(s) ? s[0] : u, h = Uo(c) || Uo(l), d = a || h; return tt.und(o) && (o = u), r.from = wD(c, d), r.to = wD(s1(o, c), d), r.start = e ? e.end : 0, r.end = r.start + r.delay + r.duration + r.endDelay, r.easing = $S(r.easing, r.duration), r.isPath = tt.pth(s), r.isColor = tt.col(r.from.original), r.isColor && (r.round = 1), e = r, r }) } var kD = { css: function (i, t, e) { return i.style[t] = e }, attribute: function (i, t, e) { return i.setAttribute(t, e) }, object: function (i, t, e) { return i[t] = e }, transform: function (i, t, e, n, r) { if (n.list.set(t, e), t === n.last || r) { var s = ""; n.list.forEach(function (o, a) { s += a + "(" + o + ") " }), i.style.transform = s } } }; function UD (i, t) { var e = FD(i); e.forEach(function (n) { for (var r in t) { var s = ZS(t[r], n), o = n.target, a = Uo(s), l = i1(o, r, a, n), u = a || Uo(l), c = s1(OD(s, u), l), h = r1(o, r); kD[h](o, r, c, n.transforms, !0) } }) } function Lq (i, t) { var e = r1(i.target, t.name); if (e) { var n = Rq(t, i), r = n[n.length - 1]; return { type: e, property: t.name, animatable: i, tweens: n, duration: r.end, delay: n[0].delay, endDelay: r.endDelay } } } function Nq (i, t) { return Uv(zv(i.map(function (e) { return t.map(function (n) { return Lq(e, n) }) })), function (e) { return !tt.und(e) }) } function zD (i, t) { var e = i.length, n = function (s) { return s.timelineOffset ? s.timelineOffset : 0 }, r = {}; return r.duration = e ? Math.max.apply(Math, i.map(function (s) { let o = s.startOnceDelay ?? 0, a = s.pingPongDelayCorrection ?? 0, l = s.pingPongEndDelayCorrection ?? 0; return n(s) + o + a + l + s.duration * (s.loop ?? 1) })) : t.duration, r.delay = e ? Math.min.apply(Math, i.map(function (s) { let o = s.startOnceDelay ?? 0, a = s.pingPongDelayCorrection ?? 0; return n(s) + o + a + s.delay })) : t.delay, r.endDelay = e ? r.duration - Math.max.apply(Math, i.map(function (s) { let o = s.startOnceDelay ?? 0, a = s.pingPongDelayCorrection ?? 0, l = s.pingPongEndDelayCorrection ?? 0; return n(s) + o + a + s.duration * (s.loop ?? 1) - s.endDelay - l })) : t.endDelay, r } var SD = 0; function Bq (i) { var t = KS(ED, i), e = KS(JS, i), n = Dq(e, i), r = FD(i.targets), s = Nq(r, n), o = zD(s, e), a = SD; return SD++, Gv(t, { id: a, children: [], animatables: r, animations: s, duration: o.duration, delay: o.delay, endDelay: o.endDelay, startOnceDelay: e.startOnceDelay, pingPongDelayCorrection: e.pingPongDelayCorrection, pingPongEndDelayCorrection: e.pingPongEndDelayCorrection }) } var ki = [], AD = [], Fv, Fq = function () { function i () { Fv = requestAnimationFrame(t) } function t (e) { var n = ki.length; if (n) { for (var r = 0; r < n;) { var s = ki[r]; s.paused ? (ki.splice(r, 1), n -= 1) : (s.tick(e), r++) } i() } else Fv = cancelAnimationFrame(Fv) } return i }(); function kq (i) { document.hidden ? (ki.forEach(function (t) { return t.pause(i.timeStamp) }), AD = ki.slice(0), Mn.running = ki = []) : AD.forEach(function (t) { return t.play(i.timeStamp) }) } typeof document < "u" && document.addEventListener("visibilitychange", kq); function Mn (i) { i === void 0 && (i = {}); var t = 0, e = 0, n = 0, r, s, o = 0, a = null; function l (E) { var w = window.Promise && new Promise(function (M) { return a = M }); return E.finished = w, w } var u = Bq(i), c = l(u); function h () { var E = u.direction; E !== "alternate" && (u.direction = E !== "normal" ? "normal" : "reverse"), u.reversed = !u.reversed, s.forEach(function (w) { (w.loop === 1 || w.loop % 2 === 0) && (w.reversed = u.reversed) }) } function d () { u.direction = "normal", u.reversed = !1, s.forEach(function (E) { return E.reversed = !1 }) } function f (E) { return u.reversed ? u.duration - E : E } function p () { t = 0, e = f(u.currentTime) * (1 / Mn.speed) } function m (E, w, M = !1) { w && (u.reversed ? w.seek(w.duration * w.loop - (E - w.timelineOffset - w.pingPongDelayCorrection), M) : w.seek(E - w.timelineOffset - w.startOnceDelay - w.pingPongDelayCorrection, M)) } function g (E, w = !1) { if (u.reversed) for (var T = o; T--;)m(E, s[T], w); else for (var M = 0; M < o; M++)m(E, s[M], w) } function y (E) { var w = 0, M = u.animations, T = M.length; for (u.direction !== "alternate" && u.parent?.direction === "alternate" ? u.parent?.rewind === !1 && u.reversePlayback === !0 && u.rewind === !1 && (u.parent?.reversed && u.direction === "alternate" ? E = u.duration - u.delay + u.endDelay - E : E = u.duration + u.delay - u.endDelay - E) : S(!1, u.parent?.rewind, u.rewind, u.parent?.reversePlayback, u.reversePlayback) && (u.parent?.reversed && u.direction === "alternate" ? E = u.duration - u.delay + u.endDelay - E : E = u.duration + u.delay - u.endDelay - E); w < T;) { var I = M[w], C = I.animatable, P = I.tweens, D = P.length - 1, L = P[D]; D && (L = Uv(P, function (W) { return E < W.end })[0] || L); let Q; u.parent?.reversed && u.direction === "alternate" ? Q = hs(E - L.start - L.endDelay, 0, L.duration) / L.duration : Q = hs(E - L.start - L.delay, 0, L.duration) / L.duration; for (var H = isNaN(Q) ? 1 : L.easing(Q), U = L.to.strings, V = L.round, G = [], z = L.to.numbers.length, $ = void 0, F = 0; F < z; F++) { var j = void 0; let W, ge; u.direction !== "alternate" ? u.parent?.rewind === !1 && u.reversePlayback === !0 && u.rewind === !1 ? (W = L.to.numbers[F], ge = L.from.numbers[F] || 0) : (ge = L.to.numbers[F], W = L.from.numbers[F] || 0) : S(!0, u.parent?.rewind, u.rewind, u.parent?.reversePlayback, u.reversePlayback) ? (W = L.to.numbers[F], ge = L.from.numbers[F] || 0) : (ge = L.to.numbers[F], W = L.from.numbers[F] || 0), L.isPath ? j = Cq(L.value, H * ge) : j = W + H * (ge - W), V && (L.isColor && F > 2 || (j = Math.round(j * V) / V)), G.push(j) } var X = U.length; if (!X) $ = G[0]; else { $ = U[0]; for (var q = 0; q < X; q++) { var k = U[q], Z = U[q + 1], K = G[q]; isNaN(K) || (Z ? $ += K + Z : $ += K + " ") } } kD[I.type](C.target, I.property, $, C.transforms), I.currentValue = $, w++ } } function v (E) { u[E] && !u.passThrough && u[E](u) } function x () { u.remaining && u.remaining !== !0 && u.remaining-- } let b = { 0: !1, 1: !0, 2: !1, 3: !0, 4: !1, 5: !1, 6: !1, 7: !1, 8: !1, 9: !0, 10: !0, 11: !1, 12: !1, 13: !1, 14: !0, 15: !0, 16: !1, 17: !0, 18: !0, 19: !1, 20: !1, 21: !1, 22: !0, 23: !0, 24: !1, 25: !0, 26: !1, 27: !0, 28: !1, 29: !1, 30: !1, 31: !1 }; function S (E, w, M, T, I) { return b[E << 4 | w << 3 | M << 2 | T << 1 | I] } function _ (E, w = !1) { var M = u.duration; let T = u.delay, I = M - u.endDelay; u.parent?.reversed && u.direction === "alternate" && (T = u.endDelay, I = M - u.delay); var C = f(E); if (u.progress = hs(C / M * 100, 0, 100), w || (u.reversePlayback = C < u.currentTime), o && g(C, w), !u.began && u.currentTime >= 0 && (u.began = !0, v("begin")), !u.loopBegan && u.currentTime > 0 && (u.loopBegan = !0, v("loopBegin")), (u.reversed || C >= 0) && C <= T && u.currentTime !== 0 && (y(0), v("change")), (C >= I && u.currentTime !== M + u.pingPongDelayCorrection || !M) && (y(M), v("change")), C > T && C < I ? (u.changeBegan || (u.changeBegan = !0, u.changeCompleted = !1, v("changeBegin")), y(C), v("change")) : u.changeBegan ? (u.changeCompleted = !0, u.changeBegan = !1, v("change"), o && v("timelineChangeComplete")) : u.began && C > I && v("changeComplete"), u.currentTime = hs(C, 0, M + u.pingPongDelayCorrection), u.began && v("update"), E >= M) if (x(), !u.remaining) u.paused = !0, u.completed || (u.completed = !0, v("loopComplete"), v("complete"), !u.passThrough && "Promise" in window && (a(), c = l(u))); else { o ? t += u.duration / Mn.speed : t += u.duration; for (let P of s) P.setStartTime(0), P.remaining = P.loop; v("loopComplete"), u.loopBegan = !1, u.direction === "alternate" ? h() : o && d() } } return u.reset = function () { var E = u.direction; u.passThrough = !1, u.currentTime = 0, u.progress = 0, u.paused = !0, u.began = !1, u.loopBegan = !1, u.changeBegan = !1, u.completed = !1, u.changeCompleted = !1, u.reversePlayback = !1, u.reversed = E === "reverse", u.remaining = u.loop, s = u.children, o = s.length; for (var w = o; w--;)u.children[w].reset(); (u.reversed && u.loop !== !0 || E === "alternate" && u.loop === 1) && u.remaining++, y(u.reversed ? u.duration : 0) }, u.setStartTime = function (E) { t = E }, u.set = function (E, w) { return UD(E, w), u }, u.tick = function (E) { n = E, t || (t = n), _((n + (e - t)) * Mn.speed) }, u.seek = function (E, w = !1) { _(E - t, w) }, u.pause = function (E) { u.paused = !0, o && (r = E ?? performance.now()) }, u.play = function (E) { !u.paused || (u.completed && u.reset(), u.paused = !1, ki.push(u), o && r !== void 0 && (t += (E ?? performance.now()) - r), Fv || Fq()) }, u.reverse = function () { h(), u.completed = !u.reversed, p() }, u.restart = function () { u.reset(), u.play() }, u.reset(), u.autoplay && u.play(), u } function _D (i, t) { for (var e = t.length; e--;)e1(i, t[e].animatable.target) && t.splice(e, 1) } function Uq (i) { for (var t = BD(i), e = ki.length; e--;) { var n = ki[e], r = n.animations, s = n.children; _D(t, r); for (var o = s.length; o--;) { var a = s[o], l = a.animations; _D(t, l), !l.length && !a.children.length && s.splice(o, 1) } !r.length && !s.length && n.pause() } } function zq (i, t) { t === void 0 && (t = {}); var e = t.direction || "normal", n = t.easing ? $S(t.easing) : null, r = t.grid, s = t.axis, o = t.from || 0, a = o === "first", l = o === "center", u = o === "last", c = tt.arr(i), h = parseFloat(c ? i[0] : i), d = c ? parseFloat(i[1]) : 0, f = Uo(c ? i[1] : i) || 0, p = t.start || 0 + (c ? h : 0), m = [], g = 0; return function (y, v, x) { if (a && (o = 0), l && (o = (x - 1) / 2), u && (o = x - 1), !m.length) { for (var b = 0; b < x; b++) { if (!r) m.push(Math.abs(o - b)); else { var S = l ? (r[0] - 1) / 2 : o % r[0], _ = l ? (r[1] - 1) / 2 : Math.floor(o / r[0]), E = b % r[0], w = Math.floor(b / r[0]), M = S - E, T = _ - w, I = Math.sqrt(M * M + T * T); s === "x" && (I = -M), s === "y" && (I = -T), m.push(I) } g = Math.max.apply(Math, m) } n && (m = m.map(function (P) { return n(P / g) * g })), e === "reverse" && (m = m.map(function (P) { return s ? P < 0 ? P * -1 : -P : Math.abs(g - P) })) } var C = c ? (d - h) / g : h; return p + C * (Math.round(m[v] * 100) / 100) + f } } function Gq (i) { i === void 0 && (i = {}); var t = Mn(i); return t.duration = 0, t.add = function (e, n) { var r = ki.indexOf(t), s = t.children; r > -1 && ki.splice(r, 1); function o (d) { d.passThrough = !0 } for (var a = 0; a < s.length; a++)o(s[a]); var l = Gv(e, KS(JS, i)); l.targets = l.targets || i.targets; var u = t.duration; l.autoplay = !1, l.timelineOffset = tt.und(n) ? u : s1(n, u), o(t); var c = Mn(l); o(c), s.push(c), c.parent = t; var h = zD(s, i); return t.delay = h.delay, t.endDelay = h.endDelay, t.duration = h.duration, c.loop === !0 && (t.duration = 1 / 0), t.seek(0), t.reset(), t.autoplay && t.play(), t }, t } Mn.version = "3.2.0"; Mn.speed = 1; Mn.running = ki; Mn.remove = Uq; Mn.get = i1; Mn.set = UD; Mn.convertPx = n1; Mn.path = Tq; Mn.setDashoffset = Eq; Mn.stagger = zq; Mn.timeline = Gq; Mn.easing = $S; Mn.penner = CD; Mn.random = function (i, t) { return Math.floor(Math.random() * (t - i + 1)) + i }; var Vv = Mn; var GD = new A, VD = new A, HD = new Ye; function jD (i, t, e, n) { if (n === 0) return e.copy(i); if (n === 1) return e.copy(t); let r = i.w * t.w + i.x * t.x + i.y * t.y + i.z * t.z; if (r >= 1) return e.copy(i); let s = 1 - r * r; if (s <= Number.EPSILON) { let c = 1 - n; return e.w = c * i.w + n * t.w, e.x = c * i.x + n * t.x, e.y = c * i.y + n * t.y, e.z = c * i.z + n * t.z, e.normalize(), e } let o = Math.sqrt(s), a = Math.atan2(o, r), l = Math.sin((1 - n) * a) / o, u = Math.sin(n * a) / o; return e.w = i.w * l + t.w * u, e.x = i.x * l + t.x * u, e.y = i.y * l + t.y * u, e.z = i.z * l + t.z * u, e } function ds (i, t, e, n, r) { let s = e[i] ? e[i] : void 0, o = n[i]; if (o == null) return; let a = s ?? t[i], l = o; if (a !== l) return { update: u => { let c = Ge.lerp(a, l, u); r ? t[i] = Math.trunc(c) : t[i] = c }, start: () => { t[i] = a }, end: () => { t[i] = l } } } function a1 (i, t, e, n, r) { let s = e[i] ? e[i] : void 0, o = n[i]; if (!o) return; let a = t[i], l = [...s ?? a], u = [...o]; if (!(l.length !== u.length || El(l, u))) return { update: c => { l.forEach((h, d) => { let f = Ge.lerp(h, u[d], c); t[i][d] = r ? Math.trunc(f) : f }) }, start: () => { Object.assign(t[i], l) }, end: () => { Object.assign(t[i], u) } } } function l1 (i, t, e, n) { let r = e[i] ? e[i] : void 0, s = n[i]; if (!s) return; let o = t[i], a = r ? new A().fromArray(r) : o.clone(), l = new A().fromArray(s); if (!a.equals(l)) return { update: u => { o.lerpVectors(a, l, u) }, start: () => { o.copy(a) }, end: () => { o.copy(l) } } } function WD (i, t, e, n) { let r = e[i] ? e[i] : void 0, s = n[i]; if (!s) return; let o = t[i], a = r ? new se().fromArray(r) : o.clone(), l = new A, u = new Ye, c = new A; a.decompose(l, u, c); let h = new se().fromArray(s), d = new A, f = new Ye, p = new A; if (h.decompose(d, f, p), !a.equals(h)) return { update: m => { HD.slerpQuaternions(u, f, m), GD.lerpVectors(l, d, m), VD.lerpVectors(c, p, m), o.compose(GD, HD, VD) }, start: () => { o.compose(l, u, c) }, end: () => { o.compose(d, f, p) } } } function qD (i, t, e, n, r) { let s = e[i] ? e[i] : void 0, o = n[i]; if (!o) return; let a = t[i], l = s ? typeof s == "string" ? r.getColor(s).clone() : new Le().setRGB(s.r, s.g, s.b) : a.clone(), u = typeof o == "string" ? r.getColor(o).clone() : new Le().setRGB(o.r, o.g, o.b); if (l.equals(u)) return; let c = a.clone(); return t[i] = c, { update: h => { c.lerpColors(l, u, h) }, start: () => { c.copy(l) }, end: () => { c.copy(u) } } } function Ks (i, t, e, n) { if (typeof t[i] == "number") return ds(i, t, e ?? {}, n); if (Array.isArray(t[i])) return a1(i, t, e ?? {}, n) } function YD (i, t, e) { let n = [], r = i.cameraType === "OrthographicCamera" ? t.orthographic?.zoom : t.perspective?.zoom, s = i.cameraType === "OrthographicCamera" ? e.orthographic?.zoom : e.perspective?.zoom; if (s !== void 0) { let o = r ?? i.zoom, a = s; o !== a && n.push({ update: l => { i.zoom = Ge.lerp(o, a, l), i.updateProjectionMatrix() }, start: () => { i.zoom = o, i.updateProjectionMatrix() }, end: () => { i.zoom = a, i.updateProjectionMatrix() } }) } if (e.targetOffset !== void 0) { let o = ds("targetOffset", i, t, e); o && n.push(o) } return n } function Vq (i, t, e, n) { if (e.scaleBaked === void 0) return; let r = t.scaleBaked ?? i.data.geometry.scaleBaked, s = e.scaleBaked; if (Ts.isEqual(r, s)) return; let o = []; return o.push({ update: a => { i.updateGeometryInteractions({ scaleBaked: [Ge.lerp(r[0], s[0], a), Ge.lerp(r[1], s[1], a), Ge.lerp(r[2], s[2], a)] }, n), i.invalidateDownstreamBooleanData() }, start: () => { i.updateGeometryInteractions({ scaleBaked: r }, n), i.invalidateDownstreamBooleanData() }, end: () => { i.updateGeometryInteractions({ scaleBaked: s }, n), i.invalidateDownstreamBooleanData() } }), o } function Hq (i, t, e) { if (!e.extrusion) return; let n = i.extrusion, r = t.extrusion ?? {}, s = e.extrusion, o = []; return Xb.forEach(a => { let l = Ks(a, n, r, s); l && o.push(l) }), o } function XD (i, t, e, n) { let r = []; if (!("geometry" in e)) return r; let s = i.geometry.userData.parameters, o = "geometry" in t ? t.geometry : {}, a = e.geometry; if (i instanceof as) { let l = Vq(i, o, a, n); l && r.push(...l) } else { let l = {}; if (Object.assign(l, fi(s, Qb)), Qb.forEach(u => { let c = Ks(u, l, o, a); c && r.push(c) }), i instanceof Wa) { Object.assign(l, { extrusion: { ...s.extrusion } }); let u = Hq(l, o, a); u && r.push(...u) } r.length && r.push({ update: u => { i.updateGeometryInteractions(l, n), i.updateGeometryGroupsIfNeeded() }, start: u => { i.updateGeometryInteractions(l, n), i.updateGeometryGroupsIfNeeded() }, end: u => { i.updateGeometryInteractions(l, n), i.updateGeometryGroupsIfNeeded() } }) } return r } function QD (i, t, e, n) { let r = []; if (e.intensity !== void 0) { let s = ds("intensity", i, t, e); s && r.push(s) } if (e.color !== void 0) { let s = qD("color", i, t, e, n); s && r.push(s) } return r } function ZD (i, t, e, n) { let r = []; if (Array.isArray(i.material)) { if (!("materials" in e && e.materials)) return r; let s = "materials" in t && t.materials ? t.materials : [], o = e.materials; i.material.forEach((a, l) => { if (!o[l]) return; let u = s[l] ?? {}, c = o[l]; typeof u == "string" || typeof c == "string" || r.push(...KD(a, u, c, n)) }) } else { if (!("material" in e && e.material)) return r; let s = "material" in t && t.material ? t.material : {}, o = e.material; if (typeof s == "string" || typeof o == "string") return r; r.push(...KD(i.material, s, o, n)) } return r } function KD (i, t, e, n) { let r = [], s = ep(e, n) || !!t.layers && ep(t, n); r.push(Jq(i, s)); for (let o of i.layers) { let a = t.layers?.data(o.uuid), l = e.layers.data(o.uuid); if (!l || !(o.visible ?? !0) || !(l.visible ?? !0)) continue; let u = o.getNames().filter(c => !Xg.some(h => c.includes(h))); for (let c of u) try { let h = o.getValue(c), d; if (c === "colors") d = Kq(o, a, l, c); else if (Array.isArray(h)) c === "steps" && (d = Qq(o, a, l, c)); else if (typeof h == "number") d = jq(o, a, l, c); else { if (typeof h == "boolean") continue; h instanceof B ? d = Wq(o, a, l, c) : h instanceof A ? d = qq(o, a, l, c) : h instanceof on ? d = Xq(o, a, l, c, n) : h instanceof Le ? d = Yq(o, a, l, c, n) : "isTexture" in h && (d = Zq(o, a, l, c)) } d && (Array.isArray(d) ? r.push(...d) : r.push(d)) } catch (h) { console.error(`lerpMaterial: unexpected material layer for ${c}`, h) } } return r } function jq (i, t, e, n) { if (!i.hasValue(n) || !(n in e)) return; let r = t ? t[n] : i.getValue(n), s = e[n]; if (r !== s) return { update: o => { i.setValue(n, Ge.lerp(r, s, o)) }, start: () => { i.setValue(n, r) }, end: () => { i.setValue(n, s) } } } function Wq (i, t, e, n) { if (!i.hasValue(n) || !(n in e)) return; let r = i.getValue(n), s = t ? new B().fromArray(t[n]) : r.clone(), o = new B().fromArray(e[n]); if (!s.equals(o)) return { update: a => { r.lerpVectors(s, o, a) }, start: () => { r.copy(s) }, end: () => { r.copy(o) } } } function qq (i, t, e, n) { if (!i.hasValue(n) || !(n in e)) return; let r = i.getValue(n), s = t ? new A().fromArray(t[n]) : r.clone(), o = new A().fromArray(e[n]); if (!s.equals(o)) return { update: a => { r.lerpVectors(s, o, a) }, start: () => { r.copy(s) }, end: () => { r.copy(o) } } } function Yq (i, t, e, n, r) { if (!i.hasValue(n) || !(n in e)) return; let s = t ? t[n] : void 0, o = e[n], a = i.getValue(n), l = s ? typeof s == "string" ? r.getColor(s).clone() : new Le().setRGB(s.r, s.g, s.b) : a.clone(), u = typeof o == "string" ? r.getColor(o).clone() : new Le().setRGB(o.r, o.g, o.b); if (l.equals(u)) return; let c = a.clone(); return { update: h => { i.getValue(n) !== c && i.setValue(n, c), c.lerpColors(l, u, h) }, start: () => { c.copy(l) }, end: () => { c.copy(u) } } } function Xq (i, t, e, n, r) { if (!i.hasValue(n) || !(n in e)) return; let s = t ? t[n] : void 0, o = e[n], a = i.getValue(n), l = s ? typeof s == "string" ? r.getColor(s).clone() : new Le().setRGB(s.r, s.g, s.b) : a.clone(), u = typeof o == "string" ? r.getColor(o).clone() : new on(o.r, o.g, o.b, o.a); if (l.equals(u)) return; let c = a.clone(); return { update: h => { i.getValue(n) !== c && i.setValue(n, c), c.lerpColors(l, u, h) }, start: () => { c.copy(l) }, end: () => { c.copy(u) } } } function Qq (i, t, e, n = "steps") { if (!i.hasValue(n) || !(n in e)) return; let r = [], s = i.getValue(n), o = t ? t[n] : s, a = e[n]; for (let l = 0; l < s.length; ++l) { let u = o[l], c = a[l]; u !== c && r.push({ update: h => { s[l] = Ge.lerp(u, c, h) }, start: () => { s[l] = u }, end: () => { s[l] = c } }) } return r.length ? r : void 0 } function Kq (i, t, e, n = "colors") { if (!i.hasValue(n) || !(n in e)) return; let r = [], s = i.getValue(n), o = t ? t[n] : s.map(l => l.toArray()), a = e[n]; for (let l = 0; l < s.length; ++l) { let u = [...o[l]], c = [...a[l]]; wf.isEqual(u, c) || r.push({ update: h => { s[l].fromArray(wf.lerp(u, c, h)) }, start: () => { s[l].fromArray(u) }, end: () => { s[l].fromArray(c) } }) } return r.length ? r : void 0 } function Zq (i, t, e, n = "texture") { if (!i.hasValue(n) || !(n in e)) return; let r = i.getNode("mat"); if (!r) return; let s = t ? t[n] : r, o = e[n], a = [...s.repeat], l = [...s.offset], u = [...o.repeat], c = [...o.offset]; if (!Il.isEqual(a, u) || !Il.isEqual(l, c)) return { update: h => { r.repeat = Il.lerp(a, u, h), r.offset = Il.lerp(l, c, h), r.updateMatrix() }, start: () => { r.repeat = [...a], r.offset = [...l], r.updateMatrix() }, end: () => { r.repeat = [...u], r.offset = [...c], r.updateMatrix() } } } function Jq (i, t) { return { update: () => { i.transparent = t } } } var c1 = new A, JD = new Gt; function $D (i, t, e, n) { let r = [], s, o, a, l, u, c, h = { slide: (t.pathSnapping ?? i.updatedPathSnapping ?? i.dataPatched.pathSnapping).slide, offset: (t.pathSnapping ?? i.updatedPathSnapping ?? i.dataPatched.pathSnapping).offset }; if (u = ds("slide", h, t.pathSnapping ?? i.updatedPathSnapping ?? i.dataPatched.pathSnapping, e.pathSnapping ?? i.dataPatched.pathSnapping), u && r.push(u), c = ds("offset", h, t.pathSnapping ?? i.updatedPathSnapping ?? i.dataPatched.pathSnapping, e.pathSnapping ?? i.dataPatched.pathSnapping), c && r.push(c), !u && !c && (s = l1("position", i, t, e), s && r.push(s), o = l1("scale", i, t, e), o && r.push(o), a = $q(i, t, e, n), a && r.push(a), l = WD("hiddenMatrix", i, t, e), l && r.push(l)), s || o || a || l || u || c) { let d = () => { i.updateMatrix(), i.hasNonUniformScale && (i.updateMatrixWorld(), i.updateMatrixWorldSVD()), i.parent?.matrixWorldFusedFalse && (i.matrixWorld.multiplyMatrices(i.parent.matrixWorldFusedFalse, i.matrix), i.matrixWorldNeedsUpdate = !1), Ir(i) && Hr(i.parent) && i.invalidateDownstreamBooleanData(!0), i.updatePathSnapping(Object.assign({}, t.pathSnapping, h)) }; r.push({ update: d, start: d, end: d }) } return r } function $q (i, t, e, n) { let r = t?.rotation ? t.rotation : void 0, s = e.rotation; if (!s) return; let o = r ? new A().fromArray(r) : new A().setFromEuler(i.rotation), a = new A().fromArray(s); if (o.equals(a)) return; let l = c1.subVectors(a, o); if (n && l.toArray().every(u => Math.abs(u) < 2 * Math.PI)) { let u = new Ye().setFromEuler(JD.setFromVector3(o)), c = new Ye().setFromEuler(JD.setFromVector3(a)); return { update: h => { jD(u, c, i.quaternion, h) }, start: () => { i.rotation.setFromVector3(o) }, end: () => { i.rotation.setFromVector3(a) } } } else return { update: u => { c1.lerpVectors(o, a, u), i.rotation.setFromVector3(c1) }, start: () => { i.rotation.setFromVector3(o) }, end: () => { i.rotation.setFromVector3(a) } } } function eO (i, t, e) { let n = []; if (!("cloner" in e) || !i.cloner) return n; let r = i.cloner, s = "cloner" in t ? t.cloner : {}, o = e.cloner; Ub.forEach(d => { let f; d === "count" ? f = ds("count", r.parameters, s, o, !0) : f = Ks(d, r.parameters, s ?? {}, o), f && n.push(f) }); let a = e9(r, s, o); a?.length && n.push(...a); let l = t9(r, s, o); l?.length && n.push(...l); let u = n9(r, s, o); u?.length && n.push(...u); let c = r9(r, s, o); c?.length && n.push(...c); let h = i9(r, s, o); return h?.length && n.push(...h), n.length && n.push({ update: () => { r.update() } }), n } function e9 (i, t, e) { if (i.parameters.type !== "radial") return; let n = t.radial, r = e.radial; if (!r) return; let s = i.parameters.radial, o = []; return zb.forEach(a => { let l = Ks(a, s, n ?? {}, r); l && o.push(l) }), o } function t9 (i, t, e) { if (i.parameters.type !== "linear") return; let n = t.linear, r = e.linear; if (!r) return; let s = [], o = i.parameters.linear; return Gb.forEach(a => { let l = Ks(a, o, n ?? {}, r); l && s.push(l) }), s } function n9 (i, t, e) { if (i.parameters.type !== "grid") return; let n = t.grid, r = e.grid; if (!r) return; let s = [], o = i.parameters.grid; return Vb.forEach(a => { let l; a === "count" ? l = a1(a, o, n ?? {}, r, !0) : l = Ks(a, o, n ?? {}, r), l && s.push(l) }), s } function r9 (i, t, e) { if (i.parameters.type !== "toObject") return; let n = t.toObject, r = e.toObject; if (!r) return; let s = [], o = i.parameters.toObject; return Hb.forEach(a => { let l; a === "count" ? l = ds(a, o, n ?? {}, r, !0) : l = Ks(a, o, n ?? {}, r), l && s.push(l) }), s } function i9 (i, t, e) { if (!i.parameters.randomness) return; let n = t.randomnessObject, r = e.randomnessObject; if (!r) return; let s = [], o = i.parameters.randomnessObject; return jb.forEach(a => { let l = Ks(a, o, n ?? {}, r); l && s.push(l) }), s } function u1 (i, t, e, n, r) { let s = []; return i.data.visible && s.push(...$D(i, t, e, r)), i.data.visible && s.push(...eO(i, t, e)), Ir(i) ? (i instanceof jt && i.data.visible && s.push(...XD(i, t, e, n)), i.data.visible && s.push(...ZD(i, t, e, n))) : lI(i) ? i.data.visible && s.push(...QD(i, t, e, n)) : aI(i) && s.push(...YD(i, t, e)), s.length ? { update: o => { s.forEach(a => a.update(o)) }, start: o => { s.forEach(a => a.start?.(o)) }, end: o => { s.forEach(a => a.end?.(o)) } } : void 0 } var tO = new A; function pd (i, t, e = !1) { let n = []; i.traverseChildren(r => { if (e && (r.rigidBody?.setTranslation(r.position0, !0), r.rigidBody?.setRotation(r.rotation0, !0), r.rigidBody?.setLinvel(tO, !0), r.rigidBody?.setAngvel(tO, !0)), !ct.is(r)) return; let s = r.uuid, o = r.data; if (delete r.states, r.uuid === Ti) return; let a = !1; n.some(l => i.scene.find(s)?.isDescendantOf(l)) ? a = !0 : o.physics?.fusedBody === !0 && o.physics.rigidBody === "dynamic" && n.push(s), r.data = o, r.currentState = null, r.reversibleToState = null, r.currentTransitionEvent = null; for (let l of o.states) { let u = { ...l.data }; i.data.globalPhysics.usePhysics === !0 && o.physics && (o.physics.rigidBody === "dynamic" || a) && (l.data.position !== void 0 && delete u.position, l.data.rotation !== void 0 && delete u.rotation, l.data.hiddenMatrix !== void 0 && delete u.hiddenMatrix), r.states || (r.states = {}), r.states[l.id] = To.patch(o, u) } o9(i.scene, r, null, t, o.events.find(l => l.data.type === "Follow" || l.data.type === "LookAt") !== void 0), s9(i) }) } function s9 (i) { i.traverseEntity(t => { for (let e of t.data.events) { let n = []; switch (e.data.type) { case "Follow": case "MouseHover": case "Scroll": case "MouseDown": case "MouseUp": case "MousePress": case "KeyUp": case "KeyDown": case "KeyPress": case "Collision": n.push(...e.data.actions); break; case "GameControl": for (let r of Object.values(e.data.gameActions)) n.push(...r); break; case "DragDrop": n.push(...e.data.dragDropActions.drag, ...e.data.dragDropActions.drop); break; case "Conditional": n.push(...e.data.inActions, ...e.data.outActions); break }for (let r of n) if (r.data.type === "Create" && r.data.hideBase === "Yes") { let s = i.scene.find(r.data.object); s && (s.visible = !1) } } }) } function o9 (i, t, e, n, r = !1) { if (t instanceof jt && t.removeInteractionGeometry(), t.changeSelectedState(e, { scene: i, shared: n }, r), t instanceof jt && t.updateGeometryGroupsIfNeeded(), t instanceof Wt && t.updateCameraState(t.dataPatched, { scene: i, shared: n }), t.cloner) for (let s of t.cloner.children) s.playModeVisible = void 0; t.updateVisible() } function h1 (i) {
	let t; if (i.easing === 5) {
		let { control1: e, control2: n } = i; t = `cubicBezier(
			${e[0]}, ${e[1]}, ${n[0]}, ${n[1]}
		)`} else if (i.easing === 6) { let { mass: e, stiffness: n, damping: r, velocity: s } = i; t = `spring( ${e}, ${n}, ${r}, ${s} )` } else { let e; switch (i.easing) { case 0: e = Eo.linear; break; case 1: e = Eo.ease; break; case 2: e = Eo.easeIn; break; case 3: e = Eo.easeOut; break; case 4: e = Eo.easeInOut; break; default: e = Eo.linear }let [n, r, s, o] = e; t = `cubicBezier( ${n}, ${r}, ${s}, ${o} )` } return { duration: i.duration, easing: t }
} function nO (i) { let t = { delay: 0, loop: i.repeat === -1 ? !0 : i.repeat + 1 }; if (i.repeat === 0) t.direction = "normal", t.rewind = !1; else switch (i.direction) { case "pingpong": t.direction = "alternate", t.rewind = !1; break; case "pingpong-rewind": t.direction = "alternate", t.rewind = !0; break; default: t.direction = "normal", t.rewind = !1; break }switch (t.delay = 0, t.endDelay = 0, t.startOnceDelay = 0, t.pingPongDelayCorrection = 0, t.pingPongEndDelayCorrection = 0, i.delayDirection) { case "start-once": t.startOnceDelay = i.delay; break; case "start": t.delay = i.delay; break; case "end": t.endDelay = i.delay; break; case "start-end": case void 0: t.delay = i.delay, t.endDelay = i.delay; break }return t.direction === "alternate" && (t.delay /= 2, t.endDelay /= 2, i.delayDirection === "start" ? (t.pingPongDelayCorrection = t.delay, typeof t.loop == "number" && t.loop % 2 === 0 && (t.pingPongEndDelayCorrection = t.delay)) : i.delayDirection === "end" ? typeof t.loop == "number" && t.loop % 2 !== 0 && (t.pingPongEndDelayCorrection = t.endDelay) : i.delayDirection === "start-end" && (t.pingPongDelayCorrection = t.delay, t.pingPongEndDelayCorrection = t.endDelay)), t } var a9 = { type: "beginState" }, l9 = { type: "completeState", isfromEntity: !1 }, jv = class { constructor(t, e, n, r, s, o) { this.object = t; this.data = r; this.sharedAssets = s; this.allowSlerp = o; this.targets = { t: 0 }; this.firstLoop = !0; this._changeBegan = !1; this._changeCompleted = !0; this.onChange = () => { this.callback && (this.callback.update(this.targets.t), this.object.dispatchEvent({ type: "requestRender" })), this.targets.t === 0 || this.targets.t === 1 ? this._changeCompleted || (this._changeCompleted = !0, this._changeBegan = !1, this.onChangeComplete()) : (this._changeCompleted && (this._changeCompleted = !1), this._changeBegan || (this._changeBegan = !0, this.onChangeBegin())) }; this.onChangeBegin = () => { this.object.reversibleToState = this.to.id; let t = this.targets.t > .5 ? this.from.id : this.to.id; this.object.prevState !== this.object.currentState && (this.object.prevState = this.object.currentState), this.object.currentState = t, this.object.dispatchEvent({ type: "beginState", state: t }), this.object.traverseEntity(e => { e !== this.object && e instanceof Wt && e.dispatchEvent(a9) }) }; this.onChangeComplete = () => { this.firstLoop && (this.onFirstLoop(), this.firstLoop = !1), this.object.reversibleToState = this.to.id; let t = this.targets.t < .5 ? this.from.id : this.to.id; this.object.prevState !== this.object.currentState && (this.object.prevState = this.object.currentState), this.object.currentState = t, this.object.dispatchEvent({ type: "completeState", state: t }), this.object.traverseEntity(e => { e !== this.object && e instanceof Wt && e.dispatchEvent(l9) }) }; this.onFirstLoop = () => { this.useCurrentState && (this.callback = u1(this.object, this.from.data, this.to.data, this.sharedAssets, this.allowSlerp)) }; if (e === void 0) { let a = Hv(this.object, this.object.currentState === n ? this.object.prevState : this.object.currentState); if (!a) throw new Error("Missing property"); this.from = a } else { let a = Hv(this.object, e); if (!a) throw new Error("Missing property"); this.from = a } if (n === void 0) throw new Error("Missing property"); { let a = Hv(this.object, n); if (!a) throw new Error("Missing property"); this.to = a } this.useCurrentState = e === void 0 || n === void 0, this.params = { targets: this.targets, t: 1, autoplay: !1, ...nO(r), ...h1(r), change: this.onChange }, this.callback = u1(this.object, e === void 0 ? {} : this.from.data, n === void 0 ? {} : this.to.data, this.sharedAssets, this.allowSlerp) } get changeBegan () { return this._changeBegan } get changeCompleted () { return this._changeCompleted } }, zo = class extends kt { constructor(e, n, r) { super(); this.data = e; this.page = n; this.sharedAssets = r; this.toggleIsForward = !1; this.timelineNeedsRebuild = !1; this.useToggle = !1; this.onTimelineChangeComplete = () => { this.data.tweens[0].data.direction !== "normal" && (this.toggleIsForward = !this.toggleIsForward), this.timelineNeedsRebuild !== !1 && (this.timeline?.pause(), this.buildTimeline({ isForward: this.toggleIsForward, isRebuild: !0 }), this.timeline.play()) }; if (!e.object) throw new Error("Missing property"); let s = this.page.scene.find(e.object); if (!s) throw new Error("Missing property"); if (!s.states) throw new Error("Missing property"); if (this.object = s, e.tweens.length < 2) throw new Error("Missing property"); this.tweens = Array(this.data.tweens.length - 1), this.startOnceDelay = e.tweens[0].data.delayDirection === "start-once" ? e.tweens[0].data.delay : 0, this.init() } get playing () { return this.tweens.some(e => e.changeBegan) ?? !1 } init () { this.initialCurrentState = Hv(this.object, this.object.currentState).id, this.toggleIsForward = !1 } get currentState () { return this.useToggle ? this.initialCurrentState : this.object.currentState } buildTimeline ({ isForward: e = !0, isRebuild: n = !1 } = {}) { try { let r = nO(this.data.tweens[0].data), s = r.loop; n && typeof r.loop == "number" && r.loop--, this.timeline?.pause(), this.timeline = Vv.timeline({ autoplay: !1, ...r, ...s === !0 || s > 1 ? { timelineChangeComplete: this.onTimelineChangeComplete } : {} }); let o = this.tweens.findIndex(a => a?.changeBegan); if (this.timelineNeedsRebuild = o !== -1 && (s === !0 || s > 1), r.pingPongDelayCorrection && n === !1 && (this.timelineNeedsRebuild = !0), e) { let a = o === -1 ? 0 : o; for (let l = a; l < this.data.tweens.length - 1; l++) { let u = this.data.tweens[l], c = this.data.tweens[l + 1], h; l === a && (this.object.wasMovedByUser === !0 || this.object.previousAction?.playing === !0) ? (h = void 0, this.object instanceof Wt && (this.object.wasMovedByUser = !1)) : h = u.data.state === void 0 ? this.currentState : u.data.state; let d = new jv(this.object, h, c.data.state === void 0 ? this.currentState : c.data.state, c.data, this.sharedAssets, this.data.allowSlerp ?? !1); o !== -1 && l === a && Object.assign(d.params, { startOnceDelay: 0 }), this.tweens[l] = d, this.timeline.add(d.params, this.timeline.duration + (l === a ? r.delay : 0) + (l === a && !n ? r.pingPongDelayCorrection : 0)) } this.timeline.duration += r.endDelay } else { let a = o === -1 ? this.data.tweens.length - 1 : o + 1; for (let l = a; l > 0; l--) { let u = this.data.tweens[l], c = this.data.tweens[l - 1], h; l === a && (this.object.wasMovedByUser === !0 || this.object.previousAction?.playing === !0) ? (h = void 0, this.object instanceof Wt && (this.object.wasMovedByUser = !1)) : h = u.data.state === void 0 ? this.currentState : u.data.state; let d = new jv(this.object, h, c.data.state === void 0 ? this.currentState : c.data.state, u.data, this.sharedAssets, this.data.allowSlerp ?? !1); o !== -1 && l === a && Object.assign(d.params, { startOnceDelay: 0 }), this.tweens[l - 1] = d, this.timeline.add(d.params, this.timeline.duration + (l === a ? r.endDelay : 0)) } this.timeline.duration += r.delay + (n ? 0 : r.pingPongDelayCorrection) } } catch (r) { r instanceof Error && console.error(r.message) } this.object.previousAction?.playing === !0 && this.object.previousAction.pause(), this.object.previousAction = this } play () { if (this.playing) return !1; clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => { try { this.buildTimeline(), this.timeline.play() } catch (e) { e instanceof Error && console.error(e.message) } }, this.startOnceDelay) } pause () { this.timeline?.pause(), clearTimeout(this.timeoutId), this.tweens = Array(this.data.tweens.length - 1), delete this.timeoutId } stop () { this.pause(); let e = this.data.tweens[0].data.state === void 0 ? this.initialCurrentState : this.data.tweens[0].data.state; this.object.changeSelectedState(e, { scene: this.page.scene, shared: this.sharedAssets }), this.object.currentState = e } seek (e) { this.timeline === void 0 && this.buildTimeline(), this.timeline?.seek(e * this.timeline.duration, !0) } toggle (e) { this.useToggle = !0, clearTimeout(this.timeoutId), this.toggleIsForward = e ?? !this.toggleIsForward, this.playing ? (this.timeline?.pause(), this.buildTimeline({ isForward: this.toggleIsForward }), this.timeline.play()) : this.timeoutId = window.setTimeout(() => { this.timeline?.pause(), this.buildTimeline({ isForward: this.toggleIsForward }), this.timeline.play() }, this.startOnceDelay) } playFromCurrent () { this.toggle(!0) } reverseFromCurrent () { this.toggle(!1) } dispose () { this.pause() } }; function Hv (i, t) { let e, n; if (typeof t == "string" ? (e = t, n = i.states?.[e]) : t === null && (e = null, n = i.data), !(e === void 0 || n === void 0)) return { id: e, data: n } } var c9 = { type: "beginState" }, rO = { type: "completeState", isfromEntity: !1 }, iO = { type: "requestRender" }, wp = class extends kt { constructor(e, n) { super(); this.data = e; this.page = n; this.toggleIsForward = !1; this.useToggle = !1; this.posStart = new A; this.posEnd = new A; this.qStart = new Ye; this.qEnd = new Ye; this.zoomStart = 1; this.zoomEnd = 1; this.toCamera = this.page.scene.find(e.targetCamera) } init () { } get playing () { return this.animation && this.animation.began && !this.animation.completed } buildAnimation (e = !1) { if (!this.data.animate) return; let n = { t: 0 }; this.posStart.copy(this.page.activeCamera.position), this.qStart.copy(this.page.activeCamera.quaternion), this.zoomStart = this.page.activeCamera.zoom, this.animation = Vv({ targets: n, t: 1, ...h1(this.data), update: () => { n.t === 0 && (this.useToggle && !this.toggleIsForward ? (this.posEnd.copy(this.fromCamera.position), this.qEnd.copy(this.fromCamera.quaternion), this.zoomEnd = this.fromCamera.zoom, this.switchCamera(this.fromCamera)) : (this.posEnd.copy(this.toCamera.position), this.qEnd.copy(this.toCamera.quaternion), this.zoomEnd = this.toCamera.zoom, this.fromCamera = this.page.activeCamera, this.switchCamera(this.toCamera)), this.page.activeCamera.dispatchEvent(c9)); let r = this.page.activeCamera; r.position.lerpVectors(this.posStart, this.posEnd, n.t), r.quaternion.slerpQuaternions(this.qStart, this.qEnd, n.t), r.zoom = this.zoomStart + (this.zoomEnd - this.zoomStart) * n.t, r.wasMovedBySwitchCameraAction = !0, r.updateMatrix(), r.updateMatrixWorld(), r.updateProjectionMatrix(), r.dispatchEvent(iO), n.t === 1 && r.dispatchEvent(rO) } }) } switchCamera (e) { this.page.switchActiveCamera(e), this.page.activeCamera.dispatchEvent({ type: "cameraChange", camera: e }) } play () { this.playing || this.page.activeCamera !== this.toCamera && (clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => { delete this.timeoutId; try { this.data.animate ? (this.buildAnimation(), this.animation?.play()) : this.switchCamera(this.toCamera) } catch (e) { e instanceof Error && console.error(e.message) } }, this.data.delay * 1e3)) } pause () { this.animation?.pause(), clearTimeout(this.timeoutId), delete this.timeoutId } toggle (e) { this.useToggle = !0, clearTimeout(this.timeoutId), this.toggleIsForward = e ?? !this.toggleIsForward, this.playing ? (this.animation?.pause(), this.buildAnimation(!0), this.animation?.play()) : this.timeoutId = window.setTimeout(() => { delete this.timeoutId, this.data.animate ? (this.animation?.pause(), this.buildAnimation(), this.animation?.play()) : (this.toggleIsForward ? (this.fromCamera = this.page.activeCamera, this.switchCamera(this.toCamera)) : this.switchCamera(this.fromCamera), this.page.activeCamera.dispatchEvent(rO), this.page.activeCamera.dispatchEvent(iO)) }, this.data.delay * 1e3) } playFromCurrent () { this.toggle(!0) } reverseFromCurrent () { this.toggle(!1) } dispose () { this.pause(), this.toggleIsForward = !1 } }; var Go = class extends kt { constructor(e, n, r) { super(); this.page = n; this.animationControls = r; this.startOnceDelay = 0; this.toggleIsForward = !1; let s = e.object, o = n.scene.find(e.object); o && Array.isArray(o.identity) && (s = o.identity[0]), this.data = { ...e, object: s }; let a = this.animationControls.clipIdToAction[e.clipId + "/" + s]; this.duration = a?.getClip()?.duration ?? 1; let l = a?.getClip()?.tracks[0]?.times.length ?? 1 / 0; this.leftFrameTime = this.data.crop[0] / l * this.duration, this.rightFrameTime = this.data.crop[1] / l * this.duration, this.startOnceDelay = e.delay } get playing () { return this.threeAnimAction?.isRunning() ?? !1 } play (e = !1) { window.clearTimeout(this.timeoutId), this.timeoutId = window.setTimeout(() => { if (this.threeAnimAction = this.animationControls.play(this.data), !this.threeAnimAction) return; this.threeAnimAction.reset(), this.threeAnimAction.time = this.leftFrameTime, this.threeAnimAction._clip.start = this.leftFrameTime, this.threeAnimAction._clip.duration = this.rightFrameTime; let n = this.data.object; Object.entries(this.animationControls.clipIdToAction).forEach(([r, s]) => { let o = r.split("/")[1]; this.threeAnimAction !== s && o === n && s.isRunning() && (e ? s.fadeOut(.2) : s.stop()) }), e && this.threeAnimAction?.fadeIn(.2) }, this.startOnceDelay) } pause () { this.threeAnimAction && (this.threeAnimAction.paused = !0), window.clearTimeout(this.timeoutId), delete this.timeoutId } stop () { this.threeAnimAction?.fadeOut(.2) } seek (e) { this.threeAnimAction = this.animationControls.play(this.data), this.threeAnimAction && (this.threeAnimAction.paused = !0, this.threeAnimAction.time = Ge.clamp(this.threeAnimAction.time + 1 / 60 * e, this.leftFrameTime, this.rightFrameTime - 16e-5), this.animationControls.needsUpdate = !0, this.animationControls.requestRender()) } toggle (e, n = !1) { this.toggleIsForward = e ?? !this.toggleIsForward, this.threeAnimAction && (this.threeAnimAction._loopCount = 0), this.playing ? this.threeAnimAction && (this.threeAnimAction.timeScale = this.toggleIsForward ? 1 : -1, this.toggleIsForward ? (this.threeAnimAction._clip.start = this.leftFrameTime, this.threeAnimAction._clip.duration = this.rightFrameTime) : (this.threeAnimAction._clip.start = this.rightFrameTime, this.threeAnimAction._clip.duration = this.leftFrameTime)) : this.timeoutId = window.setTimeout(() => { if (this.threeAnimAction = this.animationControls.play(this.data), this.threeAnimAction) { this.toggleIsForward ? (this.threeAnimAction.time = this.leftFrameTime, this.threeAnimAction._clip.start = this.leftFrameTime, this.threeAnimAction._clip.duration = this.rightFrameTime) : (this.threeAnimAction.time = this.rightFrameTime, this.threeAnimAction._clip.start = this.rightFrameTime, this.threeAnimAction._clip.duration = this.leftFrameTime), this.threeAnimAction.paused = !1, this.threeAnimAction.timeScale = this.toggleIsForward ? 1 : -1; let r = this.data.clipId.split("/")[1]; Object.entries(this.animationControls.clipIdToAction).forEach(([s, o]) => { let a = s.split("/")[1]; this.threeAnimAction !== o && a === r && o.isRunning() && (n ? o.fadeOut(.2) : o.stop()) }), n && this.threeAnimAction?.fadeIn(.2) } }, this.startOnceDelay) } playFromCurrent () { this.toggle(!0) } reverseFromCurrent () { this.toggle(!1) } dispose () { let e = this.animationControls.clipIdToAction[this.data.clipId + "/" + this.data.object]?.getClip(); e && (e.duration = this.duration), this.pause() } }; var Sp = class { constructor(t, e, n, r) { this.data = t; this.page = e; this.eventManager = n; this.shared = r; this.timeOutId = -1; this.scene = e.scene } dispatch () { this.data.target !== this.page.uuid && (window.clearTimeout(this.timeOutId), this.timeOutId = window.setTimeout(() => { this.play() }, this.data.delay * 1e3)) } dispose () { window.clearTimeout(this.timeOutId) } play () { if (this.scene.children.every(n => n.uuid !== this.data.target)) return; this.data.transition === "fade" && this.data.duration > 0 && this.eventManager.eventContext.renderer.renderFromSceneForSceneTransitionPass(this.scene, this.scene.activeCamera, this.data.duration * 1e3), this.eventManager.deactivate(), this.eventManager.controlsManager.deactivate(); let t = this.scene.activeCamera; this.scene.updatePage(this.data.target), this.scene.activePage.switchToPlayCamera(), this.scene.activeCamera.copyViewPlaneSize(t), pd(this.scene.activePage, this.shared), this.eventManager.activate(), this.eventManager.controlsManager.activate(this.eventManager) } }; function un (i, t, e, n, r, s) { let o = { Audio: [], Video: [], Link: [], Destroy: [], Create: [], Reset: [], Transition: [], SwitchCamera: [], Animation: [], SceneTransition: [] }; return t.forEach(({ id: a, data: l }) => { try { l.type === "Audio" ? Ki[i.type].includes("Audio") && o.Audio.push(new ko(a, l, s, n)) : l.type === "Video" ? Ki[i.type].includes("Video") && o.Video.push(new ec(a, l, s)) : l.type === "Link" ? Ki[i.type].includes("Link") && o.Link.push(new Nv(l, r)) : l.type === "Create" ? Ki[i.type].includes("Create") && o.Create.push(new Vo(l, e, r.controlsManager)) : l.type === "Destroy" ? Ki[i.type].includes("Destroy") && o.Destroy.push(new vp(l, e, r)) : l.type === "Reset" ? Ki[i.type].includes("Reset") && o.Reset.push(new Bv(e, n, r)) : l.type === "Transition" ? Ki[i.type].includes("Transition") && o.Transition.push(new zo(l, e, n)) : l.type === "SwitchCamera" ? Ki[i.type].includes("SwitchCamera") && o.SwitchCamera.push(new wp(l, e)) : l.type === "SceneTransition" ? Ki[i.type].includes("SceneTransition") && o.SceneTransition.push(new Sp(l, e, r, n)) : l.type === "Animation" && Ki[i.type].includes("Animation") && o.Animation.push(new Go(l, e, r.animationControls)) } catch (u) { !1 && console.log(u) } }), o } function en (i) { Object.values(i).forEach(t => { t.forEach(e => { (e instanceof ko || e instanceof ec || e instanceof Go || e instanceof zo || e instanceof Vo || e instanceof vp || e instanceof wp || e instanceof Sp) && e.dispose() }) }) } function sO (i, t) { let e; if ("material" in i) { let n = i.material; Array.isArray(n) ? e = i.material[0].layers.find(r => r.uuid === t) : e = i.material.layers.find(r => r.uuid === t) } if (e) return e.color.texture.image.img instanceof HTMLVideoElement ? e.color.texture.image.img : void 0 } var oO = new Map, Ap = new Map, Ho = class { constructor(t, e, n) { this.data = e; this.delay = 0; this.status = "stopped"; let { layerId: r, loop: s, volume: o, delay: a } = e; if (this.object = n, r === void 0) throw new Error("Missing property"); let l = sO(n, r); l && (this.videoElement = l, this.videoElement.loop = s === 1 / 0, this.videoElement.autoplay = !0, o !== void 0 && (this.videoElement.volume = o)), a !== void 0 && (this.delay = a), Ap.has(n.uuid) ? Ap.get(n.uuid).push(this) : Ap.set(n.uuid, [this]), oO.set(t, this), this.pause() } mute () { !this.videoElement || (this.videoElement.muted = !0) } unMute () { !this.videoElement || (this.videoElement.muted = !1) } play (t) { if (!this.videoElement) return; let e = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent); t ? (this.mute(), this.delay += 150) : e ? (this.mute(), window.setTimeout(() => { this.unMute() }, 100)) : this.unMute(), this.delayTimerId = window.setTimeout(() => { if (!this.videoElement) return; let n = this.videoElement.play(); n !== void 0 && n.then(r => { }).catch(r => { this.play() }), this.clearDelay() }, this.delay), this.status = "playing" } clearDelay () { this.delayTimerId && (clearTimeout(this.delayTimerId), delete this.delayTimerId) } pause () { !this.videoElement || (this.videoElement.pause(), this.status = "paused") } stop () { !this.videoElement || (this.videoElement.pause(), this.videoElement.currentTime = 0, this.status = "stopped", this.clearDelay()) } playByToggle () { this.data.toggle === "stop" ? this.status === "playing" ? this.stop() : (this.stop(), this.play()) : this.data.toggle === "pause" ? this.status === "playing" ? this.pause() : this.play() : (this.stop(), this.play()) } dispose () { !this.videoElement || (this.stop(), this.videoElement.muted = !0) } }, md = class { constructor(t) { this.data = t } dispatch () { this.data.playVideo ? this.pauseVideo(this.data.playVideo) : this.data.object ? this.pauseAllVideosFromObject(this.data.object) : this.pauseAllVideos() } pauseVideo (t) { let e = oO.get(t); !e || (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => { e[this.data.interaction](), this.disposeDelay() }, this.data.delay)) : e[this.data.interaction]()) } pauseAllVideosFromObject (t) { let e = Ap.get(t); !e?.length || (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => { e.forEach(n => n[this.data.interaction]()), this.disposeDelay() }, this.data.delay)) : e.forEach(n => n[this.data.interaction]())) } pauseAllVideos () { let t = [...Ap.values()]; !t.length || (this.data.delay > 0 ? (this.disposeDelay(), this.timeoutId = window.setTimeout(() => { t.forEach(e => { e.forEach(n => { n[this.data.interaction]() }) }), this.disposeDelay() }, this.data.delay)) : t.forEach(e => { e.forEach(n => { n[this.data.interaction]() }) })) } disposeDelay () { clearTimeout(this.timeoutId), delete this.timeoutId } dispose () { clearTimeout(this.timeoutId), delete this.timeoutId } }, ec = class { constructor(t, e, n) { this.data = e; if (e.interaction === "play") this.interaction = new Ho(t, e, n); else if (e.interaction === "pause" || e.interaction === "stop") this.interaction = new md(e); else throw new Error("Missing property") } dispatchBasic () { this.interaction instanceof Ho ? this.interaction.playByToggle() : this.interaction.dispatch() } dispatchConditional () { this.interaction instanceof Ho ? this.interaction.play() : this.interaction.dispatch() } dispose () { this.interaction.dispose() } }; var aO = (() => { let i, t, e, n; function r (a) { !i && !lO() && t?.sharedGameControlGlobals.createdObjects.length > 0 && (i = requestAnimationFrame(s)), a && (t = a, n = a.requestRender) } function s (a) { let l = e ? a - e : 0, u = t.sharedGameControlGlobals.createdObjects, c = t.sharedGameControlGlobals.nCreatedPerAction, h = u.length, d = 0; for (; d < h;) { let f = u[d]; f.userData.createdTime === void 0 && (f.userData.createdTime = a), f.userData.lifetime === void 0 && f.userData.quantity === void 0 || f.userData.lifetime && a - f.userData.createdTime < f.userData.lifetime || f.userData.quantity && c[f.userData.actionId] <= f.userData.quantity ? (f.userData.velocity && (f.position.addScaledVector(f.userData.velocity, l / 1e3), f.updateMatrix(), n()), d++) : (c[f.userData.actionId] > f.userData.quantity && c[f.userData.actionId]--, u.splice(d, 1), f.removeFromParent(), t.sharedGameControlGlobals.rapierWorld && f.rigidBody ? (t.sharedGameControlGlobals.colliderToEntity.delete(f.rigidBody.collider(0).handle), t.sharedGameControlGlobals.rapierWorld.removeRigidBody(f.rigidBody)) : (f.bvhGeometry = void 0, t.sharedGameControlGlobals.entitiesWithTransformAnim = t.sharedGameControlGlobals.entitiesWithTransformAnim.filter(p => p.bvhGeometry !== void 0)), h--, n()) } i = d > 0 ? requestAnimationFrame(s) : void 0, e = d > 0 ? a : void 0 } function o () { lO() ? i && (cancelAnimationFrame(i), i = void 0, e = void 0) : r() } return typeof document < "u" && document.addEventListener("visibilitychange", o), r })(); function lO () { return !!document && document.hidden } var cO = new Ye, u9 = new A, h9 = new A, Vo = class { constructor(t, e, n) { this.data = t; this.page = e; this.controlsManager = n; this.intervalId = null; this.timeoutIdQueue = []; this.uniqueId = Ge.generateUUID(); this.dispatch = () => { this.data.delay ? this.timeoutIdQueue.push(window.setTimeout(this.dispatchInner, this.data.delay * 1e3)) : this.dispatchInner() }; this.dispatchFromStart = () => { this.timeoutIdQueue.push(window.setTimeout(this.dispatchInner, this.data.delay * 1e3)) }; this.dispatchThrottled = gb(this.dispatch, 1e3 / this.data.creationSpeed); this.dispatchStart = () => { this.intervalId === null && (this.intervalId = window.setInterval(this.dispatch, 1e3 / this.data.creationSpeed)) }; this.dispatchStop = () => { this.intervalId !== null && (window.clearInterval(this.intervalId), this.intervalId = null) }; this.dispatchInner = () => { this.timeoutIdQueue.shift(); let t = new sn(this.object); if (t.playModeVisible = !0, t.expand(), this.data.coordinateSystem !== "world") { let n = this.data.coordinateSystem, r = this.page.scene.find(n); r && (r.updateMatrixWorldSVD(), t.hiddenMatrix.copy(r.matrixWorldRigid)) } t.position.fromArray(this.data.position), t.rotation.fromArray(this.data.rotation), t.updateMatrix(), this.page.add(t); let e = this.controlsManager.sharedGameControlGlobals; e.createdObjects.push(t), e.nCreatedPerAction[this.uniqueId] === void 0 ? e.nCreatedPerAction[this.uniqueId] = 1 : e.nCreatedPerAction[this.uniqueId]++, t.updateWorldMatrix(!0, !0), t.traverseObject(this.traverseObjectCB), aO(), this.controlsManager.requestRender() }; this.traverseObjectCB = t => { t.hasNonUniformScale && t.updateMatrixWorldSVD(); let e; if (this.controlsManager.sharedGameControlGlobals.rapierWorld) { if (t instanceof dr) if (t.objectForSample) { if (t.objectForSample.dataPatched.physics.fusedBody) return; e = t.object } else return t.object.dataPatched.physics.fusedBody === !0 && t.object.dataPatched.physics.rigidBody === "dynamic" ? !0 : void 0; else if (t instanceof sn) e = t.object; else if (e = t, e.dataPatched.cloner?.hideBase) return !0 } else { if (t instanceof dr) return; t instanceof sn ? e = t.object : e = t } this.data.destroy === "Time" ? t.userData.lifetime = this.data.lifetime * 1e3 : this.data.destroy === "Quantity" && (t.userData.quantity = this.data.destroyAfterQuantity, t.userData.actionId = this.uniqueId); let n = new A().fromArray(this.data.velocity), r = e.dataPatched; if (!(r.physics.enabled === "visibility" ? !r.visible : !r.physics.enabled) && (this.controlsManager.sharedGameControlGlobals.rapierWorld ? (this.controlsManager.addRigidBody(t, e, { fromCreate: !0, dynamic: this.data.dynamic }), this.data.destroy === "Collision" && (t.rigidBody?.collider(0).setActiveEvents(1), t.userData.hasCollisionDestroy = !0), t.matrixWorld.decompose(u9, cO, h9), n.applyQuaternion(cO), this.data.velocity.some(s => s !== 0) && this.data.dynamic && t.rigidBody?.setLinvel(n.divideScalar(this.controlsManager.pixelsPerMeter), !0)) : ("geometry" in t.object && this.controlsManager.addBoundsTree(t), this.data.velocity.some(s => s !== 0) && this.data.dynamic && (t.userData.velocity = n)), e.dataPatched.physics?.fusedBody === !0)) return !0 }; let r = this.page.scene.find(this.data.object); if (!r) throw new Error("Missing Property"); if (this.object = r, this.data.coordinateSystem !== "world" && !this.page.scene.find(this.data.coordinateSystem)) throw new Error("Missing Property"); aO(n) } dispose () { this.intervalId !== null && (window.clearInterval(this.intervalId), this.intervalId = null), this.timeoutIdQueue.forEach(t => window.clearTimeout(t)), this.dispatchThrottled.cancel(), this.page.remove(...this.controlsManager.sharedGameControlGlobals.createdObjects), this.controlsManager.sharedGameControlGlobals.createdObjects = [] } }; var y1 = 200, d1 = .02, f1 = .3, d9 = 65, ODe = new A, uO = new A, hO = new A, f9 = new A, _r = new A, jr = new A, qa = new A, Wv = new se, p1 = new se, p9 = new se, RDe = new se, yi = new Ye, jo = new Ye, Zs = new Gt(0, 0, 0, "YXZ"), m9 = new A(1, 0, 0), fs = new A(0, 1, 0), g9 = new A(0, 0, 1), m1 = new A(1, 1, 1), g1 = new dn, y9 = 1, v9 = .025, x9 = 16e-6, dO = 12, b9 = 20, pr = new Hn, Ui = new _t, w9 = { type: "requestRender" }, S9 = { type: "updateMatrix" }, fO = Math.PI / 6, qv = class extends kt { constructor(e, n, r, s, o, a, l, u, c) { super(); this.object = e; this.domElement = n; this.data = r; this.gloabalPhysics = s; this.controlsManager = o; this.cameraFollow = a; this.camera = l; this.page = u; this.sharedAssets = c; this.enableDamping = !0; this.hiddenMatrix0 = new se; this.target0 = new A; this.zoom0 = 1; this.rotForce = 1; this.moveForce = 1; this.pixelsPerMeter = y1; this.euler0 = new Gt(0, 0, 0, "YXZ"); this.position0Cam = new A; this.quat0Cam = new Ye; this.scale0Cam = new A; this.hiddenMatrix0Cam = new se; this.threshEndTranslate = .01; this.threshEndRotate = 1e-8; this.threshEndRotVel = .005; this.collider = { type: "capsule", radius: 40, segment: new Hn(new A(0, -40, 0), new A(0, 40, 0)), matrix: new se, position: new A, rotation: new Ye }; this.euler = new Gt(0, 0, 0, "YXZ"); this.eulerDelta = new A; this.lastPosition = new A; this.lastCameraQuaternion = new Ye; this.lastCameraPosition = new A; this.PI_2 = Math.PI / 2; this.prevMouse = new B; this.velocityTarget = new A; this.velocity = new A; this.directionXZ = new A; this.rotVelocityStick = new A; this.rotVelocityTarget = new A; this.rotVelocity = new A; this.rotDirection = new A; this.nonColliderRotOffset = new se; this.nonColliderPosOffset = new se; this.firstPointerId = -1; this.rot = new A; this.path = []; this.movementState = { moveNegZ: 0, movePosZ: 0, moveNegX: 0, movePosX: 0, moveNegY: 0, movePosY: 0, rotPosX: 0, rotNegX: 0, rotPosY: 0, rotNegY: 0, jump: 0, run: 0 }; this.vrEulerYOffset = 0; this.onObject = !1; this.actionState = {}; this.keyAssignments = [["moveNegZ", "W"], ["moveNegX", "A"], ["movePosZ", "S"], ["movePosX", "D"], ["rotPosX", "ArrowUp"], ["rotPosY", "ArrowLeft"], ["rotNegX", "ArrowDown"], ["rotNegY", "ArrowRight"], ["jump", " "]]; this.collisionEnabled = !0; this.offsetMatrix = new se; this.objectToTarget = new A; this.objectToTarget0 = new A; this.objectToCamXZ = new A; this.objectToCamXZ0 = new A; this.targetToCamera = new A; this.targetToCamera0 = new A; this.cameraPolarAxis0 = new A; this.targetPos = new A; this.targetQuat = new Ye; this.lerpFactorPos = new A().setScalar(.3); this.lerpFactorPosStart = .3; this.lerpFactorPosEnd = .3; this.lerpFactorRotStart = .3; this.lerpFactorRotEnd = .3; this.lerpFactorPosCamera = .3; this.lerpFactorRotCamera = .3; this.objXZQuat = new Ye; this.objXZQuatInv = new Ye; this.objXZRotMat = new se; this.isFirstPerson = !1; this.actions = {}; this.didHit = !1; this.groundVelocity = new A; this.pushedVelocity = new A; this.groundYRotation = 0; this.objectRealQuat = new Ye; this.colliderWorldQuat = new Ye; this.groundNormal = new A; this.groundTilt = new Ye; this.groundTiltInv = new Ye; this.lastHitObj = null; this.isFirstFrame = !0; this.rotationAccumWhenOrientWithCamera = 0; this.navMeshPathDest = null; this.position = new A; this.quaternion = new Ye; this.scale = new A; this.initialAction = !0; this.onPointerDown = e => { e.target !== this.domElement || this.firstPointerId !== -1 || (this.firstPointerId = e.pointerId, this.domElement.ownerDocument.addEventListener("pointermove", this.onPointerMove), this.domElement.ownerDocument.addEventListener("pointerup", this.onPointerUp), this.rotBy !== "keys" && !Wn && (!yb || vb >= 15.5) && this.domElement.requestPointerLock(), this.prevMouse.set(e.clientX, e.clientY)) }; this.onPointerUp = e => { this.firstPointerId = -1, this.domElement.ownerDocument.removeEventListener("pointermove", this.onPointerMove), this.domElement.ownerDocument.removeEventListener("pointerup", this.onPointerUp), e.pointerType === "mouse" && this.domElement.ownerDocument.exitPointerLock() }; this.onPointerMove = e => { if (e.pointerId !== this.firstPointerId) return; let n = e.clientX - this.prevMouse.x, r = e.clientY - this.prevMouse.y; this.prevMouse.set(e.clientX, e.clientY), e.pointerType === "mouse" && this.rotBy !== "keys" && (yb && vb < 15.5 && !Wn ? (this.eulerDelta.y = -n * this.mouseOrbitSensitivity, this.eulerDelta.x = -r * this.mouseOrbitSensitivity) : (this.eulerDelta.y = -e.movementX * this.mouseOrbitSensitivity, this.eulerDelta.x = -e.movementY * this.mouseOrbitSensitivity)), e.pointerType !== "mouse" && this.rotByTouch === "drag" && (this.eulerDelta.y = -n * this.mouseOrbitSensitivity * 5, this.eulerDelta.x = -r * this.mouseOrbitSensitivity * 5), this.controlsManager.requestRender() }; this.onPointerlockChange = e => { this.domElement.ownerDocument.pointerLockElement === this.domElement ? qv.isLocked = !0 : qv.isLocked = !1 }; this.onPointerlockError = () => { console.error("SPE.GameControls: Unable to use Pointer Lock API") }; this.handleVisibilityChange = () => { if (document?.hidden) for (let e in this.movementState) this.movementState[e] = 0 }; this.onKeyDown = e => { !(e.target instanceof HTMLInputElement) && (e.code === "ArrowLeft" || e.code === "ArrowUp" || e.code === "ArrowRight" || e.code === "ArrowDown" || e.code === "Space") && e.preventDefault(); for (let n of this.keyAssignments) if (e.key.toUpperCase() === n[1] || e.key === n[1]) { this.movementState[n[0]] = 1; break } this.controlsManager.requestRender() }; this.onKeyUp = e => { for (let n of this.keyAssignments) if (e.key.toUpperCase() === n[1] || e.key === n[1] || e.code.slice(3, e.code.length).toUpperCase() === n[1]) { this.movementState[n[0]] = 0; break } }; this.copyVRGamePadValues = (e, n) => { for (let r = 2; r < 4; r++) { let s = e.axes[r]; n === 0 ? r === 2 ? this.movementState.movePosX = s : this.movementState.movePosZ = s : (e.buttons[3].pressed ? this.movementState.jump = 1 : this.movementState.jump = 0, r === 2 ? (Math.abs(this.movementState.rotPosY) < .3 && Math.abs(s) >= .3 && (this.vrEulerYOffset += s < 0 ? 1 : -1), this.movementState.rotPosY = s) : this.moveMode === "fly" && (this.movementState.moveNegY = s)) } }; this.sharedGameControlGlobals = o.sharedGameControlGlobals, e === l && (this.isFirstPerson = !0), this.hiddenMatrix0.copy(this.object.hiddenMatrix), this.object.parent ? this.object.hiddenMatrix.copy(this.object.parent.matrixWorld).invert() : this.object.hiddenMatrix.identity(), this.object.matrix.copy(this.object.matrixWorld), this.object.matrix.decompose(this.position, this.quaternion, this.scale), this.euler0.setFromQuaternion(this.quaternion, "YXZ"); let h = this.euler0.clone(), d = h.y; if (this.objectRealQuat.copy(this.quaternion), h.y = 0, this.quaternion.setFromEuler(h), this.objXZQuat.copy(this.quaternion), this.objXZQuatInv.copy(this.objXZQuat).invert(), this.objXZRotMat.makeRotationFromQuaternion(this.quaternion), h.set(0, d, 0), this.quaternion.setFromEuler(h), this.rot.setFromEuler(h), this.object.matrixAutoUpdate = !1, (this.isFirstPerson || this.cameraFollow === !0) && (this.target0.copy(this.camera.getTarget()), this.zoom0 = this.camera.zoom), this.cameraFollow === !0) { this.position0Cam.copy(this.camera.position), this.quat0Cam.copy(this.camera.quaternion), this.scale0Cam.copy(this.camera.scale), this.hiddenMatrix0Cam.copy(this.camera.hiddenMatrix), this.camera.parent ? (this.camera.hiddenMatrix.copy(this.camera?.parent.matrixWorld), this.camera.matrix.copy(this.camera.matrixWorld)) : this.camera.hiddenMatrix.identity(), this.camera.matrix.copy(this.camera.matrixWorld), this.camera.matrix.decompose(this.camera.position, this.camera.quaternion, this.camera.scale), this.camera.matrixAutoUpdate = !1, this.offsetMatrix.copy(this.object.matrix).invert().multiply(this.camera.matrix); let g = new A(0, 0, -1).applyQuaternion(this.camera.quaternion), y = new A().subVectors(this.position, this.camera.position); this.objectToCamXZ.copy(y), this.objectToCamXZ.y = 0, this.objectToCamXZ0.copy(this.objectToCamXZ); let v, x; Math.abs(g.y) < 1e-6 ? (y.y = 0, g.y = 0, x = y.projectOnVector(g)) : y.y / g.y > 0 ? x = g.multiplyScalar(y.y / g.y) : x = g.multiplyScalar(y.length()), this.targetToCamera0.copy(x).negate(), v = this.camera.position.clone().add(x), this.objectToTarget0.subVectors(v, this.position); let b = new Gt().setFromQuaternion(this.camera.quaternion, "YXZ"); this.cameraPolarOffset = -b.x, b.x = 0, b.z = 0, b.y -= Math.PI / 2, this.cameraPolarAxis0.set(0, 0, -1).applyEuler(b) } if (this.object instanceof Wt && (this.object.matrixAutoUpdate = !1), this.euler.setFromQuaternion(this.quaternion, "YXZ"), this.rotByTouch = r.rotByTouch ?? "joystick", this.rotBy = r.rotBy ?? "keys", this.rotationMode = r.rotationMode ?? "normal", this.moveMode = r.moveMode ?? "walk", this.collisionEnabled = r.collisionEnabled, this.speedTranslate = (r.speedTranslate ?? 250) * y9, this.speedOrbit = (r.speedRotate ?? 100) * v9, this.mouseOrbitSensitivity = (r.speedRotate ?? 100) * x9, this.keyAssignments = r.keyAssignments.map(g => { let y = [g[0], g[1]]; return y[1] === "\u25B2" ? y[1] = "ArrowUp" : y[1] === "\u25C0" ? y[1] = "ArrowLeft" : y[1] === "\u25BC" ? y[1] = "ArrowDown" : y[1] === "\u25B6" ? y[1] = "ArrowRight" : y[1] === "\u21E7" ? y[1] = "Shift" : y[1] === "\u21B5" ? y[1] = "Enter" : y[1] === "Space" ? y[1] = " " : y[1] === "\u2318" ? y[1] = "Meta" : y[1] === "Ctrl" ? y[1] = "Control" : y[1] === "Esc" && (y[1] = "Escape"), y }), r.rotBy === "mouse") { let g; g = this.keyAssignments.findIndex(y => y[0] === "rotNegX"), g !== -1 && (this.keyAssignments[g][1] = ""), g = this.keyAssignments.findIndex(y => y[0] === "rotPosX"), g !== -1 && (this.keyAssignments[g][1] = ""), g = this.keyAssignments.findIndex(y => y[0] === "rotPosY"), g !== -1 && (this.keyAssignments[g][1] = ""), g = this.keyAssignments.findIndex(y => y[0] === "rotNegY"), g !== -1 && (this.keyAssignments[g][1] = "") } this.lerpFactorPosStart = 1 - .02 ** (1 / ((r.delayPos[0] ?? .3) * 60)), this.lerpFactorPosEnd = 1 - .02 ** (1 / ((r.delayPos[1] ?? .3) * 60)), this.lerpFactorPos.setScalar(this.lerpFactorPosStart), this.lerpFactorRotStart = 1 - .02 ** (1 / ((r.delayRot[0] ?? .3) * 60)), this.lerpFactorRotEnd = 1 - .02 ** (1 / ((r.delayRot[1] ?? .3) * 60)), this.lerpFactorPosCamera = 1 - .02 ** (1 / ((r.delayPosCamera ?? .3) * 60)), this.lerpFactorRotCamera = 1 - .02 ** (1 / ((r.delayRotCamera ?? .3) * 60)), this.gravity = (this.gloabalPhysics.gravity ?? Ma.defaultData.gravity) * dO, this.usePhysics = this.gloabalPhysics.usePhysics ?? Ma.defaultData.usePhysics, this.jumpPower = r.jumpPower * b9, this.resetYPosition = this.position.y + Math.abs(r.resetYPosition) * (this.gravity > 0 ? 1 : -1), this.alignToGround = r.alignToGround ?? !1, this.orientMode = r.autoOrientMove ? r.orientMode : "none", this.orientWith = r.orientWith ?? Gu.defaultDataThirdPerson.orientWith, this.slopeThresh = d9 * Math.PI / 180, r.collider.type === "capsule" ? (this.collider.radius = r.collider.radius, this.collider.segment.start.y = r.collider.height / 2 - r.collider.radius, this.collider.segment.end.y = -this.collider.segment.start.y, this.offset = r.collider.height * d1 / this.pixelsPerMeter, this.stepThresh = r.collider.height * f1 / this.pixelsPerMeter, this.colliderHeight = r.collider.height) : r.collider.type === "sphere" ? (this.collider.radius = r.collider.radius, this.collider.segment.start.y = 0, this.collider.segment.end.y = 0, this.offset = 2 * r.collider.radius * d1 / this.pixelsPerMeter, this.stepThresh = 2 * r.collider.radius * f1 / this.pixelsPerMeter, this.colliderHeight = r.collider.radius * 2) : (this.offset = r.collider.height * d1 / this.pixelsPerMeter, this.stepThresh = r.collider.height * f1 / this.pixelsPerMeter, this.colliderHeight = r.collider.height), this.collider.type = r.collider.type; let f = new A().fromArray(r.collider.position), p = new Ye().setFromEuler(new Gt().fromArray([...r.collider.rotation, "XYZ"])); this.collider.position.copy(f).multiply(this.scale), this.collider.rotation.copy(p), this.collider.matrix.compose(f, p, m1), r.cameraXAxis !== void 0 && (this.cameraXAxis = r.cameraXAxis, this.cameraYAxis = r.cameraYAxis, this.minPolarAngle = r.cameraRotXLimits[0], this.maxPolarAngle = r.cameraRotXLimits[1], this.minAzimuthAngleRel = r.cameraRotYLimits[0], this.maxAzimuthAngleRel = r.cameraRotYLimits[1]), this.forwardDir = r.forwardDirection ?? "-z", this.runMultiplier = r.runMultiplier ?? 2; let m = r.navmesh.destinationHelperRadius * 2; if (m > 0) { let g = new Ue; g.push({ fi: 0, data: { ...ar.defaultData("light", "phong"), alpha: 0 }, id: "layer1" }), g.push({ fi: 0, data: { ...ar.defaultData("color"), color: r.navmesh.destinationHelperColor, alpha: r.navmesh.destinationHelperColor.a }, id: "layer2" }); let y = new Ro({ layers: g }, { scene: this.page.scene, shared: this.sharedAssets }); this.navMeshPathDest = new Rn(wy.create({ parameters: { width: m, height: m / 10, hollow: .7 } }), y), this.navMeshPathDest.material.userData.opacity0 = r.navmesh.destinationHelperColor.a } this.activate() } reset (e = !1) { if (this.object.hiddenMatrix.copy(this.hiddenMatrix0), e) { this.object.updateMatrix(), this.object.updateMatrixWorld(), this.object.matrix.copy(this.object.matrixWorld), this.object.matrix.decompose(this.position, this.quaternion, this.scale), this.object.parent ? this.object.hiddenMatrix.copy(this.object.parent.matrixWorld).invert() : this.object.hiddenMatrix.identity(); let n = new Gt().setFromQuaternion(this.quaternion, "YXZ"), r = n.y; this.objectRealQuat.copy(this.quaternion), n.y = 0, this.quaternion.setFromEuler(n), this.objXZQuat.copy(this.quaternion), this.objXZQuatInv.copy(this.objXZQuat).invert(), this.objXZRotMat.makeRotationFromQuaternion(this.quaternion), n.set(0, r, 0), this.quaternion.setFromEuler(n), this.rot.setFromEuler(n), this.euler.setFromQuaternion(this.quaternion, "YXZ"), this.velocityTarget.set(0, 0, 0), this.velocity.set(0, 0, 0) } else this.object instanceof Wt ? this.object.matrixAutoUpdate = !0 : this.object.updateMatrix(); this.cameraFollow === !0 && (this.camera.quaternion.copy(this.quat0Cam), this.camera.position.copy(this.position0Cam), this.camera.scale.copy(this.scale0Cam), this.camera.hiddenMatrix.copy(this.hiddenMatrix0Cam), this.camera.matrixAutoUpdate = !0), this.controlsManager.requestRender() } activate () { this.instantiateActions(), this.domElement.ownerDocument.addEventListener("pointerdown", this.onPointerDown), this.domElement.ownerDocument.addEventListener("keydown", this.onKeyDown), this.domElement.ownerDocument.addEventListener("keyup", this.onKeyUp), this.domElement.ownerDocument.addEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.addEventListener("pointerlockerror", this.onPointerlockError), this.domElement.ownerDocument.addEventListener("visibilitychange", this.handleVisibilityChange) } deactivate () { this.disposeActions(), this.domElement.ownerDocument.removeEventListener("pointerdown", this.onPointerDown), this.domElement.ownerDocument.removeEventListener("keydown", this.onKeyDown), this.domElement.ownerDocument.removeEventListener("keyup", this.onKeyUp), this.domElement.ownerDocument.removeEventListener("pointerlockchange", this.onPointerlockChange), this.domElement.ownerDocument.removeEventListener("pointerlockerror", this.onPointerlockError), this.domElement.ownerDocument.removeEventListener("visibilitychange", this.handleVisibilityChange) } dispose () { this.deactivate(), this.navMeshPathDest?.parent && this.page.remove(this.navMeshPathDest) } instantiateActions () { let e = this.data, n = this.page, r = this.sharedAssets, s = this.object; e.gameActions !== void 0 && Object.entries(e.gameActions).forEach(([o, a], l) => { a.forEach(({ id: u, data: c }) => { try { this.actions[o] === void 0 && (this.actions[o] = []), c.type === "Transition" ? this.actions[o].push(new zo(c, n, r)) : c.type === "Animation" ? this.actions[o].push(new Go(c, n, this.controlsManager.eventManager.animationControls)) : c.type === "Audio" ? this.actions[o].push(new ko(u, c, s, r)) : c.type === "Video" ? this.actions[o].push(new ec(u, c, s)) : c.type === "Create" && this.actions[o].push(new Vo(c, n, this.controlsManager)) } catch { } }) }), this.dispatchStopEvent("move"), this.dispatchStopEvent("run"), this.dispatchStopEvent("jump"), this.dispatchStartEvent("idle"), this.initialAction && (this.initialAction = !1) } disposeActions () { this.initialAction = !1, this.dispatchStopEvent("idle"), this.dispatchStopEvent("move"), this.dispatchStopEvent("run"), this.dispatchStopEvent("jump"), en(this.actions) } dispatchStartEvent (e) { this.actions[e] !== void 0 && (this.actionState[e] || (this.actionState[e] = !0, this.actions[e].forEach(n => { n instanceof zo ? n.play() : n instanceof Go ? n.play(this.initialAction === !1) : n instanceof Vo ? n.dispatchStart() : n instanceof ko && n.dispatchGameControl("start") }))) } dispatchStopEvent (e) { this.actions[e] !== void 0 && (!this.actionState[e] || (this.actionState[e] = !1, this.actions[e].forEach(n => { n instanceof zo ? (n.stop(), n.object.currentState !== null && n.object.changeSelectedState(null, { scene: this.page.scene, shared: this.sharedAssets })) : n instanceof Go || (n instanceof Vo ? n.dispatchStop() : n instanceof ko && n.dispatchGameControl("stop")) }))) } get colliderWorldPosition () { return _r.copy(this.collider.position).applyQuaternion(this.objectRealQuat).add(this.position) } update (e, n, r) { if (this.gravity < 0 ? this.position.y < this.resetYPosition : this.position.y > this.resetYPosition) return this.reset(!0), !0; this.sharedGameControlGlobals.gamePads.forEach(this.copyVRGamePadValues); let s = (this.isFirstFrame ? 16.6 : e) / 1e3; this.isFirstFrame && (this.isFirstFrame = !1); let o = s * 60, a = !1; if (this.usePhysics && this.collisionEnabled) { let u = jr.set(0, (this.velocity.y === 0 ? this.pixelsPerMeter * Math.max(Math.abs(this.gravity) / (10 * dO), 1) * (this.gravity > 0 ? 1 : -1) : this.velocity.y) * s, 0).divideScalar(this.pixelsPerMeter), c = this.sharedGameControlGlobals.rapierWorld.castShape(this.colliderWorldPosition.divideScalar(this.pixelsPerMeter), this.colliderWorldQuat, u, this.object.rigidBody?.collider(0).shape, 1, !1, 16, void 0, void 0, this.object.rigidBody); if (c) { this.onObject = !0, this.groundNormal.set(c.normal2.x, c.normal2.y, c.normal2.z).applyQuaternion(this.colliderWorldQuat).negate(), this.alignToGround && this.groundTiltAdjustment(this.groundNormal), Math.acos(this.groundNormal.y) < this.slopeThresh && (a = !0), c.collider.parent()?.bodyType() === 0 && Math.acos(this.groundNormal.y) * (180 / Math.PI) > 45 && (this.onObject = !1); let h = c.collider.parent(); this.groundYRotation = 0, this.groundVelocity.set(0, 0, 0); for (let d of this.sharedGameControlGlobals.entitiesWithTransformAnim) if (d.rigidBody === h && d.userData.isFollowingObj !== this.object.uuid) { (d.hasNonUniformScale ? d.matrixWorldRigid : d.matrixWorld).decompose(_r, jo, jr), this.groundVelocity.subVectors(_r, d.prevT), this.object.getWorldPosition(jr).add(this.collider.position).sub(_r), this.groundYRotation = Zs.setFromQuaternion(jo).y - d.prevR.y, qa.copy(jr).applyAxisAngle(fs, this.groundYRotation), this.groundVelocity.add(qa.sub(jr)).divideScalar(s); break } } else this.onObject = !1 } if (this.moveMode === "walk" && this.collisionEnabled && (this.movementState.jump === 1 && this.onObject && (this.velocityTarget.y = this.jumpPower, this.movementState.jump = 0, this.dispatchStopEvent("idle"), this.dispatchStopEvent("move"), this.dispatchStopEvent("run"), this.dispatchStopEvent("jump"), this.dispatchStartEvent("jump"), this.onObject = !1), this.onObject ? this.velocityTarget.y /= 2 : this.velocityTarget.y += this.gravity * o), this.moveMode === "fly" && (this.velocityTarget.y = (this.movementState.movePosY - this.movementState.moveNegY) * this.speedTranslate), this.directionXZ.z = this.movementState.movePosZ - this.movementState.moveNegZ, this.directionXZ.x = this.movementState.movePosX - this.movementState.moveNegX, this.forwardDir === "+z" && this.directionXZ.multiplyScalar(-1), this.directionXZ.manhattanLength() > 0 && (this.path = []), this.navMeshPathDest) { let u = this.navMeshPathDest.material; if (this.moveMode === "walk" && this.path.length > 1) { this.navMeshPathDest.position.copy(this.path[this.path.length - 1]), this.navMeshPathDest.parent || this.page.add(this.navMeshPathDest); let c = _r.subVectors(this.path[1], this.position), h = jr.subVectors(this.path[1], this.path[0]); c.dot(h) < 0 ? this.path.shift() : (this.directionXZ.x = h.x, this.directionXZ.z = h.z), u.opacity = u.userData.opacity0 } else u.opacity -= .05 * u.userData.opacity0, this.navMeshPathDest.material.opacity <= 0 && this.navMeshPathDest.parent && this.page.remove(this.navMeshPathDest) } this.directionXZ.normalize(), this.movementState.run ? this.moveForce = this.runMultiplier : this.moveForce = 1, this.velocityTarget.z = this.directionXZ.z * this.speedTranslate * this.moveForce, this.velocityTarget.x = this.directionXZ.x * this.speedTranslate * this.moveForce, (this.moveMode === "walk" ? this.velocityTarget.x + this.velocityTarget.z === 0 : this.velocityTarget.manhattanLength() === 0) ? this.lerpFactorPos.setScalar(this.lerpFactorPosEnd) : this.lerpFactorPos.setScalar(this.lerpFactorPosStart), this.moveMode === "walk" && (this.lerpFactorPos.y = 1), this.didHit === !1 && this.pushedVelocity.manhattanLength() === 0 || this.usePhysics === !1 ? (this.velocity.x += (this.velocityTarget.x - this.velocity.x) * (1 - (1 - this.lerpFactorPos.x) ** o), this.velocity.y += (this.velocityTarget.y - this.velocity.y) * (1 - (1 - this.lerpFactorPos.y) ** o), this.velocity.z += (this.velocityTarget.z - this.velocity.z) * (1 - (1 - this.lerpFactorPos.z) ** o)) : this.velocity.copy(this.velocityTarget), (this.moveMode === "walk" ? this.velocity.x ** 2 + this.velocity.z ** 2 < this.speedTranslate : this.velocity.lengthSq() < this.speedTranslate) ? (this.dispatchStopEvent("move"), this.dispatchStopEvent("run"), this.onObject && (this.dispatchStopEvent("jump"), this.dispatchStartEvent("idle"))) : (this.dispatchStopEvent("idle"), this.onObject && (this.dispatchStopEvent("jump"), this.movementState.run ? (this.dispatchStopEvent("move"), this.dispatchStartEvent("run")) : (this.dispatchStopEvent("run"), this.dispatchStartEvent("move")))); let l = f9.copy(this.velocity); if (this.orientMode !== "none" && this.isFirstPerson === !1) { let u = jr.copy(l); u.y = 0, l.set(0, l.y, u.length() * (this.forwardDir === "+z" ? 1 : -1)) } if (this.directionXZ.manhattanLength() > 0 && this.orientMode !== "none") if (this.orientWith === "camera" && this.path.length <= 1) { let u = _r; this.camera.getWorldDirection(u); let c = qa.copy(fs).multiplyScalar(u.dot(fs)); u.sub(c); let h = jr.copy(this.directionXZ); h.x *= -1, this.rot.y = u.angleTo(h) * (u.cross(h).y > 0 ? -1 : 1) + this.rotationAccumWhenOrientWithCamera } else this.rot.y = (this.path.length > 1 ? 0 : this.euler.y) + Math.atan2(-this.directionXZ.z, this.directionXZ.x) + Math.PI / 2 * (this.forwardDir === "+z" ? 1 : -1); if (Zs.setFromVector3(this.rot), this.moveMode === "walk" && (Zs.x = 0), l.applyEuler(Zs), a && (jo.setFromUnitVectors(fs, this.groundNormal), l.applyQuaternion(jo)), r) { let u = Zs.set(0, this.vrEulerYOffset * fO, 0); r.applyEuler(u), l.x += r.x, l.z += r.z, this.nonColliderPosOffset.elements[13] += r.y * s } if (this.usePhysics === !0) { let u = jr; this.pushedVelocity.set(0, 0, 0); for (let c of this.sharedGameControlGlobals.entitiesWithTransformAnim) { let h = qa.setFromMatrixPosition(c.matrixWorld).sub(c.prevT).divideScalar(s).divideScalar(this.pixelsPerMeter), d = c.rigidBody.collider(0).castCollider(h, this.object.rigidBody.collider(0), _r.copy(l).divideScalar(this.pixelsPerMeter), s, !1); h.multiplyScalar(this.pixelsPerMeter); let f = ct.is(c) ? c : c.object; if (d !== null && this.lastHitObj !== f) { let p; c instanceof sn && (p = c); let m = this.sharedGameControlGlobals.entityToCollisionEvents[f.uuid]; if (m) for (let g of m) g.data.target === "character" && (g.dispatch(p), f.dispatchEvent(Yv)); this.lastHitObj = f } if (d !== null) { this.pushedVelocity.copy(h), u.copy(d.normal1).applyQuaternion(c.quaternion); break } } if (this.pushedVelocity.manhattanLength() !== 0) { let c = u.dot(l); c < 0 && l.addScaledVector(u, -c), l.add(this.pushedVelocity) } else l.add(this.groundVelocity) } if (this.rotDirection.y = Number(this.movementState.rotPosY) - Number(this.movementState.rotNegY), this.rotDirection.x = Number(this.movementState.rotPosX) - Number(this.movementState.rotNegX), this.rotDirection.normalize(), this.rotationMode === "normal" && (this.movementState.rotPosX || this.movementState.rotNegX) || this.rotationMode === "steer" && (this.movementState.rotPosX || this.movementState.rotNegX) && (this.movementState.movePosZ || this.movementState.moveNegZ || this.moveMode === "walk") ? this.rotVelocityStick.x = -this.rotDirection.x * this.speedOrbit * this.rotForce : this.rotVelocityStick.x = 0, this.rotationMode === "normal" && (this.movementState.rotPosY || this.movementState.rotNegY) || this.rotationMode === "steer" && (this.movementState.rotPosY || this.movementState.rotNegY) && (this.movementState.movePosZ || this.movementState.moveNegZ) ? this.rotVelocityStick.y = -this.rotDirection.y * this.speedOrbit * this.rotForce : this.rotVelocityStick.y = 0, this.rotVelocityTarget.subVectors(this.eulerDelta.divideScalar(s), this.rotVelocityStick), this.rotVelocityTarget.manhattanLength() === 0 ? this.rotVelocity.lerp(this.rotVelocityTarget, 1 - (1 - this.lerpFactorRotEnd) ** o) : this.rotVelocity.lerp(this.rotVelocityTarget, 1 - (1 - this.lerpFactorRotStart) ** o), this.euler.x += this.rotVelocity.x * s, this.euler.y += this.rotVelocity.y * s + this.groundYRotation, this.rotVelocityTarget.y === 0 && this.directionXZ.manhattanLength() === 0 ? this.rotationAccumWhenOrientWithCamera = 0 : (this.cameraFollow === !1 || this.cameraYAxis === "Locked") && (this.rotationAccumWhenOrientWithCamera += this.rotVelocity.y * s), this.isFirstPerson === !1 && this.orientMode !== "none" && this.directionXZ.manhattanLength() > 0) { if (this.orientMode === "radial") { this.objectToCamXZ.copy(this.objectToCamXZ0).applyAxisAngle(fs, this.euler.y - this.euler0.y); let u = jr.copy(this.objectToCamXZ).normalize(), c = qa.copy(l).multiplyScalar(s); c.y = 0; let h = c.sub(_r.copy(u).multiplyScalar(c.dot(u))).cross(u).y; this.euler.y -= Math.atan2(h, this.objectToCamXZ.length()) } } else this.rot.y += this.rotVelocity.y * s + this.groundYRotation, this.rotVelocityTarget.y !== 0 && (this.cameraFollow === !1 || this.cameraYAxis === "Locked") && (this.euler.y = this.rot.y); if (this.cameraFollow === !0 && (this.moveMode === "walk" ? this.cameraXAxis === "Limit" ? this.euler.x = Ge.clamp(this.euler.x, -this.maxPolarAngle + this.cameraPolarOffset + 1e-6, -this.minPolarAngle + this.cameraPolarOffset - 1e-6) : this.euler.x = Ge.clamp(this.euler.x, -this.PI_2 + this.cameraPolarOffset, this.PI_2 + this.cameraPolarOffset) : this.cameraXAxis === "Limit" && (this.euler.x = Ge.clamp(this.euler.x, -this.PI_2, this.PI_2))), this.moveMode === "fly" ? this.rot.x = this.euler.x : this.isFirstPerson && (n ? (Zs.copy(n), Zs.y = 0) : (Zs.copy(this.euler), Zs.y = 0), this.nonColliderRotOffset.makeRotationFromEuler(Zs)), n && (this.moveMode === "walk" ? (this.rot.y = n.y, this.rot.x = 0, this.rot.z = 0) : this.rot.setFromEuler(n), this.rot.y += this.vrEulerYOffset * fO), yi.setFromAxisAngle(m9, this.rot.x), jo.setFromAxisAngle(fs, this.rot.y), jo.multiply(yi), yi.setFromAxisAngle(g9, this.rot.z), jo.multiply(yi), this.quaternion.copy(jo), this.objectRealQuat.multiplyQuaternions(this.quaternion, this.objXZQuat), this.objectRealQuat.multiply(this.objXZQuat), this.colliderWorldQuat.copy(this.objectRealQuat).multiply(this.collider.rotation), this.collisionEnabled) if (this.usePhysics) { let u = jr.copy(l).multiplyScalar(s / this.pixelsPerMeter), c = null; this.didHit = !1; let h = new A; for (let d = 0; d < 5; d++) { let f = u.length(), p = qa.copy(u).normalize(); if (c = this.sharedGameControlGlobals.rapierWorld.castShape(this.colliderWorldPosition.divideScalar(this.pixelsPerMeter).add(h), this.colliderWorldQuat, p, this.object.rigidBody?.collider(0).shape, f, !1, 24, void 0, void 0, this.object.rigidBody), c !== null) { this.didHit = !0; let m = this.sharedGameControlGlobals.colliderToEntity.get(c.collider.handle); if (m !== this.lastHitObj && d === 0) { this.lastHitObj = m; let x = this.sharedGameControlGlobals.entityToCollisionEvents[m?.uuid]; if (x) { for (let b of x) if (b.data.target === "character") { let S = (this.sharedGameControlGlobals.rapierWorld?.getCollider(c.collider.handle))._parent, _; if (m.cloner) { for (let E of m.cloner.children) if (E.rigidBody === S) { _ = E; break } } b.dispatch(_), m.dispatchEvent(Yv) } } } let g = uO.set(c.normal2.x, c.normal2.y, c.normal2.z).applyQuaternion(this.colliderWorldQuat), y = hO.copy(p).multiplyScalar(c.toi).dot(g), v = c.toi; if (v === 0 && (this.position.y += this.offset * this.pixelsPerMeter), y > this.offset && (v = c.toi * (y - this.offset) / y, h.addScaledVector(p, v)), u.copy(p).multiplyScalar(f - v), Math.acos(-g.y) > this.slopeThresh) { let x = this.colliderWorldPosition.divideScalar(this.pixelsPerMeter).add(h), b = qa.copy(c.witness2).applyQuaternion(this.colliderWorldQuat); b.y = 0; let S = x.add(b); S.y += this.stepThresh; let _ = this.sharedGameControlGlobals.rapierWorld.castShape(S, this.colliderWorldQuat, u, this.object.rigidBody?.collider(0).shape, 1, !1, 24, void 0, void 0, this.object.rigidBody); _ !== null && _.toi === 0 && (g.y = 0, g.normalize()) } u.addScaledVector(g, -u.dot(g)) } else { d === 0 && this.directionXZ.manhattanLength() !== 0 && (this.lastHitObj = null), h.add(u); break } } this.position.addScaledVector(h, this.pixelsPerMeter), this.object.rigidBody?.setTranslation(_r.copy(this.position).divideScalar(this.pixelsPerMeter), !0), this.object.rigidBody?.setRotation(yi.copy(this.quaternion).premultiply(this.groundTilt).multiply(this.objXZQuat), !0) } else { let u = this.onObject ? 1 : 5, c = l.multiplyScalar(s / u); for (let h = 0; h < u; h++)this.position.add(c), h === 0 && this.checkTrigger(), this.collisionAdjustment(s / u) } else this.position.addScaledVector(l, s); if (this.moveMode === "walk" && this.onObject && (this.velocityTarget.y = 0, this.velocity.y = 0), this.quaternion.premultiply(this.groundTilt).multiply(this.objXZQuat), this.object.matrix.compose(this.position, this.quaternion, this.scale), this.object.matrixWorldNeedsUpdate = !0, this.object.matrix.multiply(this.nonColliderPosOffset).multiply(this.nonColliderRotOffset), this.quaternion.premultiply(this.groundTiltInv).multiply(this.objXZQuatInv), this.cameraFollow === !0) { this.updateFollowArms(); let u = this.objectToTarget.add(this.position), c = this.targetToCamera.add(u); Wv.lookAt(c, u, fs).setPosition(c), Wv.decompose(this.targetPos, this.targetQuat, _r), this.camera.quaternion.slerp(this.targetQuat, 1 - (1 - this.lerpFactorRotCamera) ** o), this.camera.position.lerp(this.targetPos, 1 - (1 - this.lerpFactorPosCamera) ** o), this.camera.updateMatrix(), this.camera.updateMatrixWorld(), this.cameraYAxis === "Limit" && this.orientMode === "cartesian" && (this.euler.y = Ge.clamp(this.euler.y, this.minAzimuthAngleRel, this.maxAzimuthAngleRel)), this.euler.x = Ge.clamp(this.euler.x, -this.PI_2 + (this.cameraPolarOffset < 0 ? this.cameraPolarOffset : 0), this.PI_2 + (this.cameraPolarOffset > 0 ? this.cameraPolarOffset : 0)) } return this.eulerDelta.set(0, 0, 0), this.object.dispatchEvent(S9), this.path.length < 2 && this.lastPosition.distanceToSquared(this.position) < this.threshEndTranslate && Math.abs(this.rotVelocity.x) < this.threshEndRotVel && Math.abs(this.rotVelocity.y) < this.threshEndRotVel && (this.camera === void 0 || this.isFirstPerson || this.lastCameraPosition.distanceToSquared(this.camera.position) < this.threshEndTranslate && 8 * (1 - this.lastCameraQuaternion.dot(this.camera.quaternion)) < this.threshEndRotate) && (this.moveMode === "fly" || this.onObject === !0 || this.collisionEnabled === !1) && this.navMeshPathDest?.material?.opacity < -.04 * this.navMeshPathDest?.material?.userData.opacity0 ? !1 : (this.camera && (this.lastCameraPosition.copy(this.camera.position), this.lastCameraQuaternion.copy(this.camera.quaternion)), this.lastPosition.copy(this.position), this.object.dispatchEvent(w9), !0) } updateFollowArms () { this.objectToTarget.copy(this.objectToTarget0), this.targetToCamera.copy(this.targetToCamera0); let e = yi.setFromAxisAngle(fs, this.cameraYAxis === "Limit" && this.orientMode !== "radial" ? Ge.clamp(this.euler.y - this.euler0.y, this.minAzimuthAngleRel, this.maxAzimuthAngleRel) : this.euler.y - this.euler0.y); (this.cameraYAxis !== "Locked" || this.orientMode === "radial") && this.objectToTarget.applyQuaternion(e); let n; this.cameraXAxis === "Limit" ? n = Ge.clamp(this.euler.x, -this.maxPolarAngle + this.cameraPolarOffset + 1e-6, -this.minPolarAngle + this.cameraPolarOffset - 1e-6) : n = Ge.clamp(this.euler.x, -this.PI_2 + this.cameraPolarOffset + 1e-6, this.PI_2 + this.cameraPolarOffset - 1e-6); let r = _r.copy(this.cameraPolarAxis0); (this.cameraYAxis !== "Locked" || this.orientMode === "radial") && r.applyQuaternion(e); let s = jo.setFromAxisAngle(r, n); this.cameraYAxis !== "Locked" && this.targetToCamera.applyQuaternion(e), this.cameraXAxis !== "Locked" && this.targetToCamera.applyQuaternion(s) } groundTiltAdjustment (e) { fs.angleTo(e) * 180 / Math.PI < 15 || fs.angleTo(e) * 180 / Math.PI > 85 ? yi.identity() : yi.setFromUnitVectors(fs, e), this.groundTilt.slerp(yi, .06), this.groundTiltInv.copy(this.groundTilt).invert() } checkTrigger () { let e; for (let n = 0; n < this.sharedGameControlGlobals.triggers.length; n++) { let [r, s, o, a] = this.sharedGameControlGlobals.triggers[n]; for (let l = 0; l < this.sharedGameControlGlobals.entitiesWithTransformAnim.length; l++) { let u = this.sharedGameControlGlobals.entitiesWithTransformAnim[l]; if (o === u || a.isValidTriggeringObject(ct.is(u) ? u : u.object) === !1) continue; let c = p1.copy(o.matrixWorld).decompose(_r, yi, jr).compose(_r, yi, m1).multiply(s), h = Wv.copy(u.matrixWorld).invert().multiply(c); r instanceof _t ? e = u.bvhGeometry.boundsTree.intersectsBox(r, h) : (g1.radius = r, g1.center.setFromMatrixPosition(h), e = u.bvhGeometry.boundsTree.intersectsSphere(g1)), e ? a.currentIntersectedObjects.indexOf(u) === -1 && (a.currentIntersectedObjects.push(u), a.dispatch(), o.dispatchEvent(pO)) : a.currentIntersectedObjects = a.currentIntersectedObjects.filter(d => d !== u) } } } collisionAdjustment (e) { let n = hO.set(0, 0, 0); this.object.matrix.compose(this.position, this.quaternion, this.scale); let r = Wv.multiplyMatrices(this.object.matrix, this.objXZRotMat).multiply(this.collider.matrix).decompose(_r, yi, jr).compose(_r, yi, m1); this.sharedGameControlGlobals.entitiesWithTransformAnim.forEach(o => { if (o === this.object || o.isDescendantOf(this.object)) return; Ui.makeEmpty(), o.updateMatrixWorldSVD(); let a = o.matrixWorldRigid, l = p1.copy(a).invert(), u = p9.copy(p1).multiply(r); pr.copy(this.collider.segment), pr.start.applyMatrix4(u), pr.end.applyMatrix4(u); let c = uO.copy(this.position).applyMatrix4(l); Ui.expandByPoint(pr.start), Ui.expandByPoint(pr.end), Ui.min.addScalar(-this.collider.radius), Ui.max.addScalar(this.collider.radius), o.bvhGeometry.boundsTree.shapecast({ traverseBoundsOrder (h) { return h.distanceToPoint(pr.end) }, intersectsBounds: h => h.intersectsBox(Ui), intersectsTriangle: h => { let d = _r, f = jr, p = h.closestPointToSegment(pr, d, f); if (p < this.collider.radius) { let m = this.collider.radius - p, g = f.sub(d).normalize(), y = qa.copy(c); y.addScaledVector(g, m); let v = y.applyMatrix4(a).sub(this.position); n.add(v), pr.start.addScaledVector(g, m), pr.end.addScaledVector(g, m) } } }) }), Ui.makeEmpty(), pr.copy(this.collider.segment), pr.start.applyMatrix4(r), pr.end.applyMatrix4(r), Ui.expandByPoint(pr.start), Ui.expandByPoint(pr.end), Ui.min.addScalar(-this.collider.radius), Ui.max.addScalar(this.collider.radius), this.sharedGameControlGlobals.staticMeshBVH?.shapecast({ traverseBoundsOrder (o) { return o.distanceToPoint(pr.end) }, intersectsBounds: o => o.intersectsBox(Ui), intersectsTriangle: o => { let a = _r, l = jr, u = o.closestPointToSegment(pr, a, l); if (u < this.collider.radius) { let c = this.collider.radius - u, h = l.sub(a).normalize(); this.alignToGround && this.groundTiltAdjustment(h), n.addScaledVector(h, c), pr.start.addScaledVector(h, c), pr.end.addScaledVector(h, c) } } }), this.onObject = Math.abs(n.y) > Math.abs(e * this.velocity.y * .25), this.onObject && this.dispatchStopEvent("jump"); let s = Math.max(0, n.length() - 1e-5); n.normalize().multiplyScalar(s), this.position.add(n) } }, _p = qv; _p.isLocked = !1; var mO = sc(yw()); function ps (i, t) { let e = new Ce; if (!i.getAttribute("position")) return e.setAttribute("position", new _e([], 3)), e.setIndex([]), e; let { positions: n, triIndices: r } = Ul(i.getAttribute("position"), i.getIndex()); return e.setAttribute("position", new _e(n, 3)), e.setIndex(r), t && e.applyMatrix4(t), e } var A9 = new se, _9 = new se, Js = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]; function v1 (i) { let t = i.elements; Js[0][0] = t[0], Js[0][1] = t[4], Js[0][2] = t[8], Js[1][0] = t[1], Js[1][1] = t[5], Js[1][2] = t[9], Js[2][0] = t[2], Js[2][1] = t[6], Js[2][2] = t[10]; let { u: e, v: n } = (0, mO.SVD)(Js), r = A9.set(e[0][0], e[0][1], e[0][2], 0, e[1][0], e[1][1], e[1][2], 0, e[2][0], e[2][1], e[2][2], 0, 0, 0, 0, 1), s = _9.set(n[0][0], n[0][1], n[0][2], 0, n[1][0], n[1][1], n[1][2], 0, n[2][0], n[2][1], n[2][2], 0, 0, 0, 0, 1); return r.multiply(s.transpose()) } var Xv = class extends qc { constructor() { super(), this.layers.enable(3), this.layers.enable(8) } setFromCamera (t, e) { e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, -1).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld), this.camera = e) : e.isPerspectiveCamera ? (this.ray.origin.set(t.x, t.y, -1).unproject(e), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize(), this.camera = e) : console.error("Raycaster: Unsupported camera type.") } intersectVisibleObjects (t, e = !0, n = []) { return t.forEach(r => { r.visible && this.intersectObject(r, e, n) }), n } createRaycastLineHelper () { let t = new Si({ color: 65280, linewidth: 10 }), e = new A(this.ray.origin.x, this.ray.origin.y, this.ray.origin.z), n = new A(this.ray.direction.x, this.ray.direction.y, this.ray.direction.z), r = this.camera.far - this.camera.near, s = new A().addVectors(e, n.multiplyScalar(r)), o = new Ce; return o.setFromPoints([e, s]), new dl(o, t) } }; var gO = i => i instanceof Bo || i instanceof us; function E9 (i, t) { return i.distance - t.distance } function yO (i, t, e) { if (!(!Ls(t) || !t.visible)) { Ir(t) && t.raycast(i, e); for (let n of t.children) yO(i, n, e) } } function Ep (i, t, e) { if (!e.some(r => gd(i, r) !== void 0)) return []; let n = []; return t.children.forEach(r => yO(i, r, n)), n.sort(E9), n } function Mp (i) { let t = []; if (i.length) { let e = i[0].object; Ls(e) && t.push(e); let n = e.parent; for (; n;)gO(n) && t.push(n), n = n.parent } return t } function gd (i, t) { if (Ir(t)) { if (t.visible) { let e = []; return t.raycast(i, e), e.length ? e[0] : void 0 } } else if (gO(t)) return vO(i, t) } function vO (i, t) { if (!(!Ls(t) || !t.visible)) { if (Ir(t)) { let e = []; if (t.raycast(i, e), e.length) return e[0] } for (let e of t.children) { let n = vO(i, e); if (n) return n } } } function M9 (i, t, e) { return { x: (i - (e.left + window.scrollX)) / e.width * 2 - 1, y: -((t - (e.top + window.scrollY)) / e.height) * 2 + 1 } } var Qv = class { constructor(t, e, n, r, s, o, a) { this.renderer = t; this.publish = e; this.scene = n; this.getCamera = r; this.sharedAssets = s; this.requestRender = o; this.isExport = a; this.raycaster = new Xv; this.raycasterNeedsUpdate = !0; this._useWindowEvents = !1; this._useWindowEvents = e.mouseEventTarget === "window", this.domElement = t.domElement, this.eventElement = this._useWindowEvents ? window : t.domElement } get stopRaycast () { return this.publish.stopRaycast } get page () { return this.scene.activePage } set useWindowEvents (t) { this._useWindowEvents = t, this.eventElement = t ? window : this.renderer.domElement } get useWindowEvents () { return this._useWindowEvents } updateRaycaster (t) { if (!this.raycasterNeedsUpdate) return; this.raycasterNeedsUpdate = !1; let { pageX: e, pageY: n } = t.touches?.length > 0 ? t.touches[0] : t, r = this.domElement.getBoundingClientRect(); this.raycaster.setFromCamera(M9(e, n, r), this.getCamera()) } }; var x1 = (a => (a[a.keydown = 0] = "keydown", a[a.keyup = 1] = "keyup", a[a.pointerdown = 2] = "pointerdown", a[a.pointerup = 3] = "pointerup", a[a.pointermove = 4] = "pointermove", a[a.wheel = 5] = "wheel", a[a.scroll = 6] = "scroll", a))(x1 || {}), gn = class { constructor(t) { this.eventContext = t; this.domEventsNeeded = new Set; this.hasVideoAction = !1 } connect () { } disconnect () { } }; var b1 = [["start", "Start"], ["keyDown", "KeyDown"], ["keyUp", "KeyUp"], ["mouseDown", "MouseDown"], ["mouseUp", "MouseUp"], ["mouseHover", "MouseHover"], ["collision", "Collision"], ["lookAt", "LookAt"], ["follow", "Follow"], ["scroll", "Scroll"]], xO = i => b1.find(([t, e]) => e === i)?.[0], $s = i => b1.find(([t]) => t === i)?.[1], T9 = (i, t) => { let e = xO(i); if (e) { let n = new CustomEvent(e, { bubbles: !0 }); return Object.defineProperty(n, "target", { writable: !1, value: t }), n } }, Kv = class extends gn { constructor(e) { super(e); this.objectsPerEvents = new Map; this.splineEvents = {}; this.onBeginEvent = e => { if (!e.eventName || !e.target || e.eventName === "Scroll") return; let n = this.splineEvents[xO(e.eventName)]?.[e.target.uuid]; if (!n) return; e.eventName === "Scroll" && e.deltaY !== void 0 && Object.assign(n, { deltaY: e.deltaY }); let { domElement: r } = this.eventContext; r.dispatchEvent(n) }; let { page: n } = this.eventContext; n.traverseEntity(r => { if (r.data?.events.length) { for (let [s, o] of b1) if (r.data.events.some(a => a.data.type === o && !a.data.disabled)) { this.objectsPerEvents.has(s) ? this.objectsPerEvents.get(s)?.push(r) : this.objectsPerEvents.set(s, [r]); let a = { id: r.uuid, name: r.name }, l = T9(o, a), u = this.splineEvents[s]; u ? u[r.uuid] = l : this.splineEvents[s] = { [r.uuid]: l } } } }) } connect () { this.objectsPerEvents.forEach(e => { e.forEach(n => { n.addEventListener("beginEvent", this.onBeginEvent) }) }) } disconnect () { this.objectsPerEvents.forEach(e => { e.forEach(n => { n.removeEventListener("beginEvent", this.onBeginEvent) }) }) } }; var w1 = class { constructor(t, e, n, r, s, o) { this.id = t; this.data = e; this.object = n; this.entered = !1; this.alreadyPlayedNonTogglingActions = new Set; if (this.useToggle = e.toggle, (e.type === "KeyDown" || e.type === "KeyUp" || e.type === "KeyPress") && !e.key) throw new Error("Missing property"); this.actions = un(e, e.actions, r, s, o, n) } disconnect () { en(this.actions) } dispatchHeld (t) { this.actions.Create.forEach(e => { t && e.dispatchThrottled.cancel(), e.dispatchThrottled() }) } dispatch (t = !1) { this.actions.Transition.forEach(e => { e.object.currentTransitionEvent !== this ? (e.object.currentTransitionEvent = this, e.init()) : this.useToggle === !1 && this.alreadyPlayedNonTogglingActions.add(e) }), this.useToggle ? (this.actions.Transition.forEach(e => { e.toggle() }), this.actions.Animation.forEach(e => { e.toggle() }), this.actions.SwitchCamera.forEach(e => { e.toggle() })) : this.data.type === "MousePress" || this.data.type === "KeyPress" ? this.entered || (this.entered = !0, this.actions.Transition.forEach(e => e.playFromCurrent()), this.actions.Animation.forEach(e => e.playFromCurrent()), this.actions.SwitchCamera.forEach(e => e.playFromCurrent()), this.actions.Create.forEach(e => e.dispatchStart())) : (this.actions.Transition.some(r => r.playing) || this.actions.Transition.forEach(r => { this.alreadyPlayedNonTogglingActions.has(r) === !1 && r.play() }), this.actions.SwitchCamera.some(r => r.playing) || this.actions.SwitchCamera.forEach(r => { r.play() }), this.actions.Animation.forEach(r => { r.play() })), this.actions.Link.forEach(e => { e.dispatch() }), this.actions.SceneTransition.forEach(e => { e.dispatch() }), t === !1 && this.actions.Create.forEach(e => { e.dispatch() }), this.actions.Destroy.forEach(e => { e.dispatch() }), this.actions.Reset.forEach(e => { e.dispatch() }), this.actions.Audio.forEach(e => { e.dispatchBasic() }), this.actions.Video.forEach(e => { e.dispatchBasic() }) } dispatchRelease () { this.entered && (this.entered = !1, this.actions.Transition.forEach(t => t.reverseFromCurrent()), this.actions.Animation.forEach(t => t.reverseFromCurrent()), this.actions.SwitchCamera.forEach(t => t.reverseFromCurrent()), this.actions.Create.forEach(t => t.dispatchStop())) } dispatchUserEvent (t) { this.actions.Transition.forEach(e => { e.object.currentTransitionEvent !== this && (e.object.currentTransitionEvent = this, e.init()) }), t ? (this.actions.Transition.forEach(e => e.reverseFromCurrent()), this.actions.Animation.forEach(e => e.reverseFromCurrent()), this.actions.SwitchCamera.forEach(e => e.reverseFromCurrent())) : (this.actions.Transition.forEach(e => e.playFromCurrent()), this.actions.Animation.forEach(e => e.playFromCurrent()), this.actions.SwitchCamera.forEach(e => e.playFromCurrent())), this.actions.Link.forEach(e => { e.dispatch() }), this.actions.SceneTransition.forEach(e => { e.dispatch() }), this.actions.Create.forEach(e => { e.dispatch() }), this.actions.Destroy.forEach(e => { e.dispatch() }), this.actions.Reset.forEach(e => { e.dispatch() }), this.actions.Audio.forEach(e => { e.dispatchBasic() }), this.actions.Video.forEach(e => { e.dispatchBasic() }) } }, Zv = class extends gn { constructor(e, n) { super(e); this.objectsPerTypes = { MouseDown: [], MouseUp: [], MousePress: [], KeyDown: [], KeyUp: [], KeyPress: [] }; this.canvasMouseEvents = []; this.windowMouseEvents = []; this.eventsPerObjects = { MouseDown: {}, MouseUp: {}, MousePress: {}, KeyDown: {}, KeyUp: {}, KeyPress: {} }; this.heldKeys = {}; this.heldKeysPress = {}; this._prevObjects = []; this.onWindowMouseDown = e => { (e.target === this.eventContext.domElement || e.target.tagName === "SPLINE-VIEWER") && this.canvasMouseEvents.forEach(n => { (n.data.type === "MouseDown" || n.data.type === "MousePress") && n.dispatch() }), this.windowMouseEvents.forEach(n => { (n.data.type === "MouseDown" || n.data.type === "MousePress") && n.dispatch() }) }; this.onWindowMouseUp = e => { (e.target === this.eventContext.domElement || e.target.tagName === "SPLINE-VIEWER") && this.canvasMouseEvents.forEach(n => { n.data.type === "MouseUp" ? n.dispatch() : n.data.type === "MousePress" && n.dispatchRelease() }), this.windowMouseEvents.forEach(n => { n.data.type === "MouseUp" ? n.dispatch() : n.data.type === "MousePress" && n.dispatchRelease() }) }; this.onMouseDown = e => { je.length > 1 || (this.eventContext.updateRaycaster(e), this.handleMouseEvent("MouseDown")) }; this.onMouseUp = e => { je.length > 1 || (this.eventContext.updateRaycaster(e), this.handleMouseEvent("MouseUp")) }; this.onMousePressDown = e => { je.length > 1 || (this.eventContext.updateRaycaster(e), this.handleMousePressEvent()) }; this.onMousePressRelease = e => { je.length > 1 || (this.eventContext.updateRaycaster(e), this.handleMousePressEvent(!0)) }; this.onKeyDown = e => { this.heldKeys[e.key] || (this.handleKeyEvent(e, "KeyDown"), this.handleKeyEventHeld(e, "KeyDown", !0)), this.heldKeys[e.key] = !0 }; this.onKeyUp = e => { this.handleKeyEvent(e, "KeyUp"), this.handleKeyEventHeld(e, "KeyUp", !0) }; this.onKeyPressDown = e => { this.heldKeysPress[e.key] ? this.handleKeyEventHeld(e, "KeyPress") : (this.handleKeyEvent(e, "KeyPress"), this.handleKeyEventHeld(e, "KeyPress", !0)), this.heldKeysPress[e.key] = !0 }; this.onKeyPressUp = e => { this.handleKeyEvent(e, "KeyPress", !0) }; this.releaseHeldKey = e => { delete this.heldKeys[e.key] }; this.releaseHeldKeyPress = e => { delete this.heldKeysPress[e.key] }; this._onUserEvent = ({ eventName: e, target: n, reverse: r }) => { if (!e || !n) return; let s = $s(e); s && (s === "MouseDown" || s === "MouseUp" || s === "MousePress" ? (n.dispatchEvent({ type: "beginEvent", eventName: s }), this.eventsPerObjects[s]?.[n.uuid]?.forEach(o => { o.dispatchUserEvent(r) })) : (s === "KeyDown" || s === "KeyUp" || s === "KeyPress") && (n.dispatchEvent({ type: "beginEvent", eventName: s }), this.eventsPerObjects[s]?.[n.uuid]?.forEach(o => { o.dispatchUserEvent() }))) }; let { page: r, sharedAssets: s } = this.eventContext; r.traverseEntity(o => { if (!o.data?.events.length) return; let a = ["MouseDown", "MouseUp", "MousePress", "KeyDown", "KeyUp", "KeyPress"]; for (let l of a) { let u = this.eventsPerObjects[l]; o.data.events.filter(({ data: c }) => c.type === l && c.disabled !== !0).forEach(({ id: c, data: h }) => { try { let d = new w1(c, h, o, r, s, n); d.actions.Video.length && (this.hasVideoAction = !0), (h.type === "MouseDown" || h.type === "MouseUp" || h.type === "MousePress") && (h.mode === "Canvas" || h.mode === "Window") ? h.mode === "Canvas" && this.canvasMouseEvents.push(d) : u[o.uuid] ? u[o.uuid].push(d) : u[o.uuid] = [d] } catch (d) { !1 && console.log(d) } }), u[o.uuid]?.length && this.objectsPerTypes[l].push(o) } }) } connect () { let { domElement: e } = this.eventContext; this.heldKeys = {}, this.heldKeysPress = {}, this.domEventsNeeded.clear(), typeof window < "u" && (window.addEventListener("pointerdown", this.onWindowMouseDown, { capture: !0 }), window.addEventListener("pointerup", this.onWindowMouseUp, { capture: !0 })), this.objectsPerTypes.MouseDown?.length && (this.domEventsNeeded.add("pointerdown"), e.addEventListener("pointerdown", this.onMouseDown)), this.objectsPerTypes.MouseUp?.length && (this.domEventsNeeded.add("pointerup"), e.addEventListener("pointerup", this.onMouseUp)), this.objectsPerTypes.MousePress?.length && (this.domEventsNeeded.add("pointerdown"), e.addEventListener("pointerdown", this.onMousePressDown), this.domEventsNeeded.add("pointerup"), e.addEventListener("pointerup", this.onMousePressRelease)), this.objectsPerTypes.KeyDown?.length && (this.domEventsNeeded.add("keydown"), document.addEventListener("keydown", this.onKeyDown), document.addEventListener("keyup", this.releaseHeldKey)), this.objectsPerTypes.KeyUp?.length && (this.domEventsNeeded.add("keyup"), document.addEventListener("keyup", this.onKeyUp)), this.objectsPerTypes.KeyPress?.length && (this.domEventsNeeded.add("keydown"), document.addEventListener("keydown", this.onKeyPressDown), document.addEventListener("keyup", this.releaseHeldKeyPress), this.domEventsNeeded.add("keyup"), document.addEventListener("keyup", this.onKeyPressUp)), Object.entries(this.objectsPerTypes).forEach(([n, r]) => { r.forEach(s => { s.addEventListener("userEvent", this._onUserEvent) }) }) } disconnect () { let { domElement: e } = this.eventContext; this.domEventsNeeded.clear(), this.heldKeys = {}, this.heldKeysPress = {}, typeof window < "u" && (window.removeEventListener("pointerdown", this.onWindowMouseDown, { capture: !0 }), window.removeEventListener("pointerup", this.onWindowMouseUp, { capture: !0 })), e.removeEventListener("pointerdown", this.onMouseDown), e.removeEventListener("pointerdown", this.onMousePressDown), e.removeEventListener("pointerup", this.onMouseUp), e.removeEventListener("pointerup", this.onMousePressRelease), document.removeEventListener("keydown", this.onKeyDown), document.removeEventListener("keyup", this.onKeyUp), document.removeEventListener("keydown", this.onKeyPressDown), document.removeEventListener("keyup", this.onKeyPressUp), document.removeEventListener("keyup", this.releaseHeldKey), Object.values(this.eventsPerObjects).forEach(n => { Object.values(n).forEach(r => { r.forEach(s => { s.disconnect() }) }) }), this.canvasMouseEvents.forEach(n => { n.disconnect() }), Object.entries(this.objectsPerTypes).forEach(([n, r]) => { r.forEach(s => { s.removeEventListener("userEvent", this._onUserEvent) }) }) } handleMouseEvent (e) { let { stopRaycast: n, raycaster: r, page: s } = this.eventContext, o = this.objectsPerTypes[e]; if (o.length) if (n) { let a = Ep(r, s, o); Mp(a).forEach(l => { this.eventsPerObjects[e][l.uuid] && this.handleObjectMouseEventDispatch(l, e) }) } else o.forEach(a => { gd(r, a) && this.handleObjectMouseEventDispatch(a, e) }) } handleMousePressEvent (e = !1) { let n = "MousePress", r = this.objectsPerTypes[n], s = []; if (r.length) { if (!e) { let { stopRaycast: o, raycaster: a, page: l } = this.eventContext; if (o) { let u = Ep(a, l, r); s = Mp(u) } else r.forEach(u => { gd(a, u) && s.push(u) }) } this._prevObjects.length && this._prevObjects.forEach(o => { s.includes(o) || this.handleObjectMouseEventDispatchRelease(o, n) }), s.length && s.forEach(o => { this.handleObjectMouseEventDispatch(o, n) }), this._prevObjects = s } } handleObjectMouseEventDispatch (e, n) { e.dispatchEvent({ type: "beginEvent", eventName: n }), this.eventsPerObjects[n]?.[e.uuid]?.forEach(r => { r.dispatch() }) } handleObjectMouseEventDispatchRelease (e, n) { e.dispatchEvent({ type: "beginEvent", eventName: n }), this.eventsPerObjects[n]?.[e.uuid]?.forEach(r => { r.dispatchRelease() }) } handleKeyEvent (e, n, r = !1) { this.objectsPerTypes[n].forEach(s => { let o = this.eventsPerObjects[n][s.uuid]; o.some(({ data: a }) => "key" in a && a.key === e.key) && s.dispatchEvent({ type: "beginEvent", eventName: n }), o.forEach(a => { "key" in a.data && a.data.key === e.key && (r ? a.dispatchRelease() : a.dispatch(!0)) }) }) } handleKeyEventHeld (e, n, r = !1) { this.objectsPerTypes[n].forEach(s => { this.eventsPerObjects[n][s.uuid].forEach(a => { "key" in a.data && a.data.key === e.key && a.dispatchHeld(r) }) }) } }; var C9 = new A, P9 = new A; var Jv = class { constructor(t, e, n, r, s) { this.actionsIn = un(t, t.inActions, n, r, s, e), this.actionsOut = un(t, t.outActions, n, r, s, e) } disconnect () { en(this.actionsIn), en(this.actionsOut) } }; var S1 = class extends Jv { constructor(e, n, r, s, o, a) { super(n, r, s, o, a); this.id = e; this.data = n; this.object = r; this.stage = "out"; this.objects = []; this.onUpdateMatrix = () => { for (let s of this.objects) if (!s.visible) return; let e = C9.setFromMatrixPosition(this.objects[0].matrixWorld), n = P9.setFromMatrixPosition(this.objects[1].matrixWorld), r = e.distanceTo(n) <= this.distance ? "in" : "out"; if (this.stage !== r) { this.stage = r; let s = r === "in" ? this.actionsIn : this.actionsOut; s.Audio.forEach(o => o.dispatchConditional()), s.Video.forEach(o => o.dispatchConditional()), s.Link.forEach(o => o.dispatch()), s.Create.forEach(o => o.dispatch()), s.Destroy.forEach(o => o.dispatch()), s.Reset.forEach(o => o.dispatch()), s.Transition.forEach(o => { o.object.currentTransitionEvent !== this && (o.object.currentTransitionEvent = this), o.init() }), s.Transition.forEach(o => o.play()), s.Animation.forEach(o => o.play()), s.SwitchCamera.forEach(o => o.play()), s.SceneTransition.forEach(o => o.dispatch()) } }; let { distance: l, fromObject: u, toObject: c } = n.condition; this.distance = l; for (let h of [u, c]) { if (!h) throw new Error("Missing property"); let d = s.find(h); if (!d) throw new Error("Missing property"); this.objects.push(d) } } connect () { window.setTimeout(() => { this.objects.forEach(e => { e.addEventListener("updateMatrix", this.onUpdateMatrix) }), this.onUpdateMatrix() }, 0) } disconnect () { super.disconnect(), this.stage = "out", this.objects.forEach(e => { e.removeEventListener("updateMatrix", this.onUpdateMatrix) }) } }, A1 = class extends Jv { constructor(e, n, r, s, o, a) { super(n, r, s, o, a); this.id = e; this.data = n; this.object = r; this.onBegin = ({ target: e, state: n }) => { this.toState !== n && (this.actionsOut.Audio.forEach(r => r.dispatchConditional()), this.actionsOut.Video.forEach(r => r.dispatchConditional()), this.actionsOut.Link.forEach(r => r.dispatch()), this.actionsOut.Create.forEach(r => r.dispatch()), this.actionsOut.Destroy.forEach(r => r.dispatch()), this.actionsOut.Reset.forEach(r => r.dispatch()), this.actionsIn.Transition.forEach(r => r.pause()), this.object.currentTransitionEvent = this, this.actionsOut.Transition.forEach(r => r.play()), this.actionsOut.Animation.forEach(r => r.play()), this.actionsIn.SwitchCamera.forEach(r => r.pause()), this.actionsOut.SwitchCamera.forEach(r => r.play()), this.actionsOut.SceneTransition.forEach(r => r.dispatch())) }; this.onComplete = ({ target: e, state: n }) => { this.toState === n && (this.actionsIn.Audio.forEach(r => r.dispatchConditional()), this.actionsIn.Video.forEach(r => r.dispatchConditional()), this.actionsIn.Link.forEach(r => r.dispatch()), this.actionsIn.Create.forEach(r => r.dispatch()), this.actionsIn.Destroy.forEach(r => r.dispatch()), this.actionsIn.Reset.forEach(r => r.dispatch()), this.actionsOut.Transition.forEach(r => r.pause()), this.actionsOut.Transition.forEach(r => r.pause()), this.object.currentTransitionEvent = this, this.actionsIn.Transition.forEach(r => r.play()), this.actionsIn.Animation.forEach(r => r.play()), this.actionsOut.SwitchCamera.forEach(r => r.pause()), this.actionsIn.SwitchCamera.forEach(r => r.play()), this.actionsIn.SceneTransition.forEach(r => r.dispatch())) }; let { condition: l } = n; if (!l.object) throw new Error("Missing property"); let u = s.find(l.object); if (!u) throw new Error("Missing property"); if (this.toObject = u, l.state && !this.toObject.states?.[l.state]) throw new Error("Missing property"); this.toState = l.state } connect () { (this.actionsOut.Audio.length || this.actionsOut.Video.length || this.actionsOut.Create.length || this.actionsOut.Destroy.length || this.actionsOut.Transition.length || this.actionsOut.Animation.length || this.actionsOut.SwitchCamera.length || this.actionsOut.SceneTransition.length) && this.toObject.addEventListener("beginState", this.onBegin), (this.actionsIn.Audio.length || this.actionsIn.Video.length || this.actionsOut.Create.length || this.actionsIn.Destroy.length || this.actionsIn.Transition.length || this.actionsIn.Animation.length || this.actionsIn.SwitchCamera.length || this.actionsIn.SceneTransition.length) && this.toObject.addEventListener("completeState", this.onComplete) } disconnect () { super.disconnect(), (this.actionsOut.Audio.length || this.actionsOut.Video.length || this.actionsOut.Create.length || this.actionsOut.Destroy.length || this.actionsOut.Transition.length || this.actionsOut.Animation.length || this.actionsOut.SwitchCamera.length || this.actionsOut.SceneTransition.length) && this.toObject.removeEventListener("beginState", this.onBegin), (this.actionsIn.Audio.length || this.actionsIn.Video.length || this.actionsOut.Create.length || this.actionsIn.Destroy.length || this.actionsIn.Transition.length || this.actionsIn.Animation.length || this.actionsIn.SwitchCamera.length || this.actionsIn.SceneTransition.length) && this.toObject.removeEventListener("completeState", this.onComplete) } }, $v = class extends gn { constructor(e, n) { super(e); this.eventsPerConditions = { Comparison: [], Distance: [], State: [] }; this.hasVideoAction = !1; let { page: r, sharedAssets: s } = this.eventContext; r.traverseEntity(o => { if (o.data?.events.length) { for (let { id: a, data: l } of o.data.events) if (!l.disabled && l.type === "Conditional") try { let u; l.condition.type === "Comparison" || (l.condition.type === "Distance" ? u = new S1(a, l, o, r, s, n) : l.condition.type === "State" && (u = new A1(a, l, o, r, s, n))), u && (this.eventsPerConditions[l.condition.type].push(u), (u.actionsIn.Video.length || u.actionsOut.Video.length) && (this.hasVideoAction = !0)) } catch (u) { !1 && console.log(u) } } }) } connect () { super.connect(), Object.values(this.eventsPerConditions).forEach(e => e.forEach(n => n.connect())) } disconnect () { super.disconnect(), Object.values(this.eventsPerConditions).forEach(e => e.forEach(n => n.disconnect())) } }; var Tp = new A, Ya = new A, tc = new A, bO = new bn, I9 = .01, Lt = new A, Kn = new A, wO = new A, nc = new Ye, _1 = new Gt, D9 = new se, E1 = new Xt, yd = new A, eo = new A, vd = .2; function M1 (i, t) { !t || (t[0] < t[1] && (i.x = Math.min(Math.max(i.x, t[0]), t[1])), t[2] < t[3] && (i.y = Math.min(Math.max(i.y, t[2]), t[3])), t[4] < t[5] && (i.z = Math.min(Math.max(i.z, t[4]), t[5]))) } var O9 = function () { let i = new se; return (t, e, n) => { let r = t.obj; i.copy(r.hiddenMatrix), r.parent !== null && i.premultiply(r.parent.matrixWorld), i.invert(), r.position.copy(e), t.reference === "global" && M1(r.position, t.limits), r.position.applyMatrix4(i), t.reference === "parent" ? M1(r.position, t.limits) : t.reference === "local" && (nc.copy(t.quat0).invert(), r.position.sub(t.position0), r.position.applyQuaternion(nc), M1(r.position, t.limits), nc.invert(), r.position.applyQuaternion(nc), r.position.add(t.position0)), i.multiply(n ?? r.matrixWorld).decompose(Lt, r.quaternion, Kn), r.updateMatrix(), r.hasNonUniformScale && (r.updateMatrixWorld(), r.updateMatrixWorldSVD()), r instanceof Ht && Hr(r.parent) && r.invalidateDownstreamBooleanData(!0) } }(), T1 = class { constructor(t, e, n, r, s, o) { this.object = t; this.data = e; this.dropDestIds = []; this.activeIdx = null; this.wasDragEventTriggered = !1; this.resetDampingFactor = this.data.resetSpeed === 0 ? 1 : 8 / this.data.resetSpeed + 1, this.snapDampingFactor = this.data.snapSpeed === 0 ? 1 : 8 / this.data.snapSpeed + 1, this.actionsDrag = un(e, e.dragDropActions.drag, n, r, s, this.object), this.actionsDrop = un(e, e.dragDropActions.drop, n, r, s, this.object); let a = []; this.data.objects.forEach(l => { let u = n.find(l); !u || u.data.visible !== !1 && (a.push(u), o[u.uuid] && o[u.uuid].forEach(c => { let h = n.find(c); !h || h.data.visible !== !1 && a.push(h) })) }), this.data.dropDestinations.forEach(l => { let u = n.find(l); !u || u.data.visible !== !1 && (this.dropDestIds.push(u.uuid), o[u.uuid] && o[u.uuid].forEach(c => { let h = n.find(c); !h || h.data.visible !== !1 && this.dropDestIds.push(h.uuid) })) }), this.dragItems = a.map(l => (this.data.planeMode === "locked" && (l.userData.lockedPlane = !0), l.userData.worldPosition0 = new A().setFromMatrixPosition(l.matrixWorld), { obj: l, fromPosition: new A().setFromMatrixPosition(l.matrixWorld), pointStart: new A, pointEnd: new A, paused: !0, currentDampingFactor: this.data.dampingFactor, reset: !1, position0: new A().copy(l.position), quat0: new Ye().copy(l.quaternion), snapped: !1, orientationMatrix: new se, limits: this.data.limits, reference: this.data.referenceFrame })) } get activeDragItem () { return this.activeIdx !== null ? this.dragItems[this.activeIdx] : null } dispose () { en(this.actionsDrag), en(this.actionsDrop), this.dragItems.forEach(t => { t.fromPosition.copy(t.obj.userData.worldPosition0), t.pointStart.copy(t.fromPosition), t.pointEnd.copy(t.pointStart), t.obj.recursiveBBoxNeedsUpdate = !0, t.obj.userData.lockedPlane = void 0, t.obj.position.copy(t.position0), t.obj.quaternion.copy(t.quat0), t.obj.updateMatrix() }) } }, e0 = class extends gn { constructor(e, n) { super(e); this.eventManager = n; this.events = []; this.lastDropDestination = null; this.dragTimeout = null; this.onPointerDown = e => { if (je.length > 1) return; this.eventContext.updateRaycaster(e); let { raycaster: n, page: r } = this.eventContext, s = r.raycastWithClones(n); if (this.lastDropDestination = null, s.length === 0) { this.activeEvent = null; return } for (let o of this.events) { let a = 0; for (let { obj: l, pointEnd: u, pointStart: c } of o.dragItems) { if (l === s[0].object || l === s[0].object.object || ct.is(l) && l.isAncestorOf(s[0].object.uuid)) { if (o.activeIdx = a, o.activeDragItem.reset = !1, o.activeDragItem.currentDampingFactor = o.data.dampingFactor, o.activeDragItem.snapped = !1, o.data.cursor === "hand" && this.setCursor("grabbing"), this.eventManager.controlsManager.usePhysics) { o.activeDragItem.obj.rigidBody && o.activeDragItem.obj.rigidBody.setBodyType(2, !0); let h = o.activeDragItem.obj; l.hasNonUniformScale && l.updateMatrixWorldSVD(), (h.hasNonUniformScale ? h.matrixWorldRigid : h.matrixWorld).decompose(Lt, nc, Kn), _1.setFromQuaternion(nc), h.prevR === void 0 ? (h.prevR = _1.clone(), h.prevT = Lt.clone()) : (h.prevR.copy(_1), h.prevT.copy(Lt)), this.eventManager.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.push(o.activeDragItem.obj) } this.calcPlaneIntersectPos(l, c, o.data.plane, o.data.referenceFrame), u.copy(c), (this.eventManager.controlsManager.usePhysics && l.data.physics?.rigidBody === "dynamic" || o.data.drop === !1 || o.data.resetOnSnapFail === !1) && o.activeDragItem.fromPosition.setFromMatrixPosition(o.activeDragItem.obj.matrixWorld), this.activeEvent = o, this.eventManager.controlsManager.orbitControls && (this.eventManager.controlsManager.orbitControls.enabled = !1); return } a++ } } this.activeEvent = null }; this.onPointerMove = e => { if (je.length > 1) return; this.eventContext.updateRaycaster(e); let { raycaster: n, page: r } = this.eventContext, s = r.raycastWithClones(n); if (je.length === 0) { let o = !1; for (let a of this.events) { for (let { obj: l } of a.dragItems) if (l === s[0]?.object || l === s[0]?.object?.object || ct.is(l) && l.isAncestorOf(s[0]?.object.uuid)) { switch (o = !0, a.data.cursor) { case "hand": this.setCursor("grab"); break; case "move": this.setCursor("move"); break; default: break }break } if (o) break } o || this.setCursor("default"); return } if (this.activeEvent && this.activeEvent.activeDragItem) { let o = this.activeEvent.activeDragItem; o.snapped = !1; let a; if (this.activeEvent.data.drop && (a = s.filter(l => o.obj !== l.object && !o.obj.isAncestorOf(l.object.uuid) && !(l.object instanceof Bo) && (this.activeEvent.data.dropOn === "all" || this.activeEvent.dropDestIds.some(u => u === l.object.uuid || r.scene.find(u).isAncestorOf(l.object.uuid))))[0]), a) { let l = wO.copy(a.face.normal).applyMatrix3(E1.getNormalMatrix(a.object.matrixWorld)); if (this.activeEvent.data.snapTo === "center") o.fromPosition.setFromMatrixPosition(a.object.matrixWorld); else if (this.activeEvent.data.snapTo === "surface") { if (o.fromPosition.copy(a.point), this.activeEvent.data.snapSurfaceMode === "bbox") { Lt.copy(l).applyMatrix3(E1.setFromMatrix4(o.obj.matrixWorld).transpose()); let u = o.obj; Lt.x > vd ? Kn.x = -u.recursiveBBox.min.x : Lt.x < -vd && (Kn.x = -u.recursiveBBox.max.x), Lt.y > vd ? Kn.y = -u.recursiveBBox.min.y : Lt.y < -vd && (Kn.y = -u.recursiveBBox.max.y), Lt.z > vd ? Kn.z = -u.recursiveBBox.min.z : Lt.z < -vd && (Kn.z = -u.recursiveBBox.max.z), Kn.applyMatrix3(E1.invert()) } else Kn.copy(l).multiplyScalar(this.activeEvent.data.snapSurfaceOffset); o.fromPosition.add(Kn) } this.activeEvent.data.autoOrient && (Lt.set(0, 1, 0).cross(l), Lt.length() < 1e-4 && Lt.set(-1, 0, 0).cross(l), Kn.crossVectors(wO, Lt), o.orientationMatrix.makeBasis(Lt, Kn, l)), o.pointStart.copy(o.fromPosition), o.pointEnd.copy(o.pointStart), o.currentDampingFactor = this.activeEvent.snapDampingFactor, o.snapped = !0, this.lastDropDestination !== a.object && (this.lastDropDestination = a.object, this.activeEvent.actionsDrop.Transition.forEach(u => { u.play() }), this.activeEvent.actionsDrop.Animation.forEach(u => { u.play() }), this.activeEvent.actionsDrop.Audio.forEach(u => { u.dispatchGameControl("start") }), this.activeEvent.actionsDrop.Create.forEach(u => { u.dispatchThrottled() })) } else o.orientationMatrix.makeRotationFromQuaternion(o.quat0), this.lastDropDestination = null, o.currentDampingFactor = this.activeEvent.data.dampingFactor, this.calcPlaneIntersectPos(o.obj, o.pointEnd, this.activeEvent.data.plane, this.activeEvent.data.referenceFrame), this.activeEvent.actionsDrop.Transition.forEach(l => { l.stop(), l.object.currentState !== null && l.object.changeSelectedState(null, { scene: this.eventContext.page.scene, shared: this.eventContext.sharedAssets }) }), this.activeEvent.actionsDrop.Animation.forEach(l => { l.stop() }), this.activeEvent.actionsDrop.Audio.forEach(l => { l.dispatchGameControl("stop") }); this.activeEvent.actionsDrag.Create.forEach(l => { l.dispatchThrottled() }), this.activeEvent.wasDragEventTriggered === !1 && (this.activeEvent.wasDragEventTriggered = !0, this.activeEvent.actionsDrag.Transition.forEach(l => { l.play() }), this.activeEvent.actionsDrag.Animation.forEach(l => { l.play() }), this.activeEvent.actionsDrag.Audio.forEach(l => { l.dispatchGameControl("start") })), this.dragTimeout && window.clearTimeout(this.dragTimeout), this.dragTimeout = window.setTimeout(() => { !this.activeEvent || (this.activeEvent.wasDragEventTriggered = !1, this.activeEvent.actionsDrag.Audio.forEach(l => { l.dispatchGameControl("stop") }), this.activeEvent.actionsDrag.Transition.forEach(l => { l.stop(), l.object.currentState !== null && l.object.changeSelectedState(null, { scene: this.eventContext.page.scene, shared: this.eventContext.sharedAssets }) }), this.activeEvent.actionsDrag.Animation.forEach(l => { l.stop() })) }, 500), this.updateDragItem(o), o.obj.dispatchEvent({ type: "requestRender" }) } }; this.onPointerUp = e => { if (this.activeEvent && this.activeEvent.activeDragItem) { this.activeEvent.data.cursor === "hand" && this.setCursor("grab"); let n = this.activeEvent.activeDragItem.obj.data.physics?.rigidBody === "dynamic"; this.activeEvent.activeDragItem.snapped === !1 && this.activeEvent.data.drop && this.activeEvent.data.resetOnSnapFail && (this.eventManager.controlsManager.usePhysics === !1 || !n) && (this.activeEvent.activeDragItem.reset = this.activeEvent.data.resetOnSnapFail, this.activeEvent.activeDragItem.paused = !1, this.activeEvent.activeDragItem.currentDampingFactor = this.activeEvent.resetDampingFactor), this.eventManager.controlsManager.usePhysics && n && (this.eventManager.controlsManager.sharedGameControlGlobals.entitiesWithTransformAnim.pop(), this.activeEvent.activeDragItem.obj.rigidBody.setBodyType(0, !0), this.activeEvent.activeDragItem.paused = !0), this.activeEvent.wasDragEventTriggered === !0 && (this.activeEvent.wasDragEventTriggered = !1, this.activeEvent.actionsDrag.Transition.forEach(r => { r.stop(), r.object.currentState !== null && r.object.changeSelectedState(null, { scene: this.eventContext.page.scene, shared: this.eventContext.sharedAssets }) }), this.activeEvent.actionsDrag.Animation.forEach(r => { r.stop() }), this.activeEvent.actionsDrag.Audio.forEach(r => { r.dispatchGameControl("stop") })), this.eventManager.controlsManager.orbitControls && (this.eventManager.controlsManager.orbitControls.enabled = !0) } }; let r = {}; e.page.traverseEntity(s => { s.component && (r[s.component.uuid] ? r[s.component.uuid].push(s.uuid) : r[s.component.uuid] = [s.uuid]) }), e.page.traverseEntity(s => { s.data?.events.filter(o => o.data.type === "DragDrop" && !o.data.disabled).forEach(o => { this.events.push(new T1(s, o.data, e.page, e.sharedAssets, n, r)) }) }) } connect () { if (!this.events.length) return; this.domEventsNeeded.clear(), this.domEventsNeeded.add("pointerdown"); let e = this.eventContext.domElement; e.addEventListener("pointerdown", this.onPointerDown), e.addEventListener("pointermove", this.onPointerMove), e.addEventListener("pointerup", this.onPointerUp), this.domEventsNeeded.add("pointermove") } disconnect () { if (!this.events.length) return; this.domEventsNeeded.clear(); let e = this.eventContext.domElement; e.removeEventListener("pointerdown", this.onPointerDown), e.removeEventListener("pointermove", this.onPointerMove), e.removeEventListener("pointerup", this.onPointerUp), this.events.forEach(n => n.dispose()) } setCursor (e) { this.eventContext.domElement.style.cursor = e } onAnimationFrameDamping () { for (let e of this.events) for (let n of e.dragItems) n.paused || this.updateDragItem(n, !0) } calcPlaneIntersectPos (e, n, r, s) { let { getCamera: o, raycaster: a } = this.eventContext; o().getWorldDirection(Ya), Ya.negate(); let l = nc.identity(); switch (s === "parent" ? D9.multiplyMatrices(e.parent.matrixWorld, e.hiddenMatrix).decompose(Lt, l, Kn) : s === "local" && e.matrixWorld.decompose(Lt, l, Kn), r) { case "x": Lt.set(1, 0, 0).applyQuaternion(l), yd.copy(Ya).cross(Lt), eo.copy(Lt).cross(yd); break; case "y": Lt.set(0, 1, 0).applyQuaternion(l), yd.copy(Ya).cross(Lt), eo.copy(Lt).cross(yd); break; case "z": Lt.set(0, 0, 1).applyQuaternion(l), yd.copy(Ya).cross(Lt), eo.copy(Lt).cross(yd); break; case "xy": eo.set(0, 0, 1).applyQuaternion(l); break; case "yz": eo.set(1, 0, 0).applyQuaternion(l); break; case "xz": eo.set(0, 1, 0).applyQuaternion(l); break; case "adaptive": Ya.angleTo(Kn.set(0, 1, 0)) > Math.PI / 6 ? (Lt.crossVectors(Kn.set(0, 1, 0), Ya), eo.crossVectors(Lt, Kn)) : eo.set(0, 1, 0); break; default: eo.copy(Ya); break }tc.setFromMatrixPosition(e.matrixWorld); let u = e.userData.lockedPlane ? e.userData.worldPosition0 : tc; if (bO.setFromNormalAndCoplanarPoint(eo, u), !!a.ray.intersectPlane(bO, n) && (r === "x" || r === "y" || r === "z")) { let c = Kn.subVectors(n, u).dot(Lt); n.copy(u).addScaledVector(Lt, c) } } updateDragItem (e, n = !1) { tc.setFromMatrixPosition(e.obj.matrixWorld), e.reset === "current" ? Tp.subVectors(e.fromPosition, tc).divideScalar(e.currentDampingFactor) : e.reset === "original" ? (Tp.subVectors(e.obj.userData.worldPosition0, tc).divideScalar(e.currentDampingFactor), e.fromPosition.copy(e.obj.userData.worldPosition0), e.pointStart.copy(e.fromPosition), e.pointEnd.copy(e.pointStart)) : Tp.subVectors(e.pointEnd, e.pointStart).add(e.fromPosition).sub(tc).divideScalar(e.currentDampingFactor), e.paused = e.currentDampingFactor > 1 ? Tp.length() < I9 : !0, (this.activeEvent && this.activeEvent.data.dampingFactor === 1 || n) && O9(e, Tp.add(tc), this.activeEvent?.data.drop && this.activeEvent?.data.autoOrient ? e.orientationMatrix : null), e.obj.dispatchEvent({ type: "beginEvent", eventName: "DragDrop" }), this.eventManager.requestRender() } }; var xd = new A, C1 = new A, Wo = new A, qo = new A, SO = new bn, R9 = .01, L9 = { type: "requestRender" }, N9 = function () { let i = new A, t = new A; return (e, n, r) => r > 0 ? (i.subVectors(e, n), i.length() <= r ? e : t.copy(n).add(i.normalize().multiplyScalar(r))) : n }(), AO = function () { let i = new se; return (t, e) => { t.position.copy(e), t.parent !== null && (i.copy(t.parent.matrixWorld).invert(), t.position.applyMatrix4(i)), i.copy(t.hiddenMatrix).invert(), t.position.applyMatrix4(i), t.updateMatrix(), t.hasNonUniformScale && (t.updateMatrixWorld(), t.updateMatrixWorldSVD()), t instanceof Ht && Hr(t.parent) && t.invalidateDownstreamBooleanData(!0) } }(), P1 = class { constructor(t, e, n, r, s) { this.data = t; this.object = e; this.paused = !1; this.currentDampingFactor = 1; this.snapComplete = !1; this.isReset = !1; this.worldPosition0 = new A; this.timeoutId = null; this.delayFinished = !0; this.wasOutside = !1; this.data = { ...zg.defaultData, ...t, ...t.resetOnPointerLeave === void 0 && { resetOnPointerLeave: !1 } }, t.target === void 0 || t.target === "cursor" || (this.target = n.find(t.target)), this.data.dampingFactor && (this.currentDampingFactor = this.data.dampingFactor), this.resetDampingFactor = 80 / this.data.resetSpeed + 1, this.object.getWorldPosition(this.worldPosition0), this.actions = un(t, t.actions, n, r, s, e) } }, t0 = class extends gn { constructor(e, n) { super(e); this.events = []; this.pairOfEventListeners = []; this.onMouseMove = e => { if (!(je.length > 1)) { this.eventContext.updateRaycaster(e); for (let n of this.events) n.target === void 0 && this.updateSingleEvent(n) } }; this.onMouseEnter = e => { for (let n of this.events) n.target === void 0 && (n.isReset = !1, n.currentDampingFactor = n.data.dampingFactor) }; this.onMouseLeave = e => { for (let n of this.events) n.target === void 0 && (n.data.resetOnPointerLeave && (n.isReset = !0, n.currentDampingFactor = n.resetDampingFactor), this.updateSingleEvent(n)) }; this.onTargetChange = e => () => { this.updateSingleEvent(e) }; let { page: r } = this.eventContext; r.traverseEntity(s => { let o = s.data?.events.find(a => a.data.type === "Follow" && !a.data.disabled); o && (!r.data.globalPhysics.usePhysics || s.dataPatched.physics?.rigidBody !== "dynamic") && this.events.push(new P1(o.data, s, r, e.sharedAssets, n)) }) } connect () { if (!this.events.length) return; let { domElement: e, eventElement: n } = this.eventContext; this.domEventsNeeded.clear(), Wn && (this.domEventsNeeded.add("pointerdown"), e.addEventListener("pointerdown", this.onMouseMove)), this.domEventsNeeded.add("pointermove"), n.addEventListener("pointermove", this.onMouseMove), this.eventContext.useWindowEvents || (e.addEventListener("pointerenter", this.onMouseEnter), e.addEventListener("pointerleave", this.onMouseLeave)); for (let r of this.events) if (r.target !== void 0) { let s = r.target, o = this.onTargetChange(r); this.pairOfEventListeners.push([s, o]), s.addEventListener("requestRender", o) } } disconnect () { if (!this.events.length) return; let { domElement: e, eventElement: n } = this.eventContext; this.domEventsNeeded.clear(), Wn && e.removeEventListener("pointerdown", this.onMouseMove), n.removeEventListener("pointermove", this.onMouseMove), e.removeEventListener("pointerenter", this.onMouseEnter), e.removeEventListener("pointerleave", this.onMouseLeave); for (let [r, s] of this.pairOfEventListeners) r.removeEventListener("requestRender", s); for (let r of this.events) r.paused = !0, r.isReset = !1, en(r.actions) } onAnimationFrameDamping () { for (let e of this.events) e.paused || this.updateSingleEvent(e, !0) } updateSingleEvent (e, n = !1) { this.events.forEach(l => { l.actions.Create.forEach(u => { u.dispatchThrottled() }) }); let { plane: r, limitDistance: s, limitDistanceEnabled: o } = e.data; if (e.object.getWorldPosition(Wo), e.isReset) qo.copy(e.worldPosition0); else if (e.target) e.target.getWorldPosition(qo); else { let { getCamera: l, raycaster: u } = this.eventContext; if (r === "custom" ? (l().getWorldDirection(C1), C1.negate(), xd.copy(C1)) : r === "xy" ? xd.set(0, 0, 1) : r === "xz" ? xd.set(0, 1, 0) : r === "yz" && xd.set(1, 0, 0), SO.setFromNormalAndCoplanarPoint(xd, Wo), !u.ray.intersectPlane(SO, qo)) return } if (!e.isReset) { if (qo.distanceTo(e.worldPosition0) > s && o && e.target) if (e.snapComplete = !1, e.data.snapDelay && (e.delayFinished = !1, typeof window < "u" && e.timeoutId !== null && (window.clearTimeout(e.timeoutId), e.timeoutId = null)), e.wasOutside = !0, e.data.resetAfterDistanceLimit) qo.copy(e.worldPosition0), e.currentDampingFactor = e.resetDampingFactor; else return; else if (e.wasOutside && (e.data.snapDelay && typeof window < "u" && (e.timeoutId = window.setTimeout(() => { e.delayFinished = !0, e.paused = !1, this.updateSingleEvent(e) }, e.data.snapDelay * 1e3)), e.currentDampingFactor = e.data.dampingFactor, e.wasOutside = !1), e.delayFinished === !1) return } e.data.enabledTranslation[0] === !1 && (qo.x = Wo.x), e.data.enabledTranslation[1] === !1 && (qo.y = Wo.y), e.data.enabledTranslation[2] === !1 && (qo.z = Wo.z); let a = N9(Wo, qo, e.wasOutside ? 0 : e.data.maxDelta); if (e.currentDampingFactor > 1) { let l = xd.subVectors(a, Wo).divideScalar(e.currentDampingFactor); Wo.add(l), n && AO(e.object, Wo), e.paused = l.length() < R9 } else AO(e.object, a), e.paused = !0; e.object?.dispatchEvent({ type: "beginEvent", eventName: "Follow" }), e.object.dispatchEvent(L9) } }; var Cp = new A, n0 = new A, Pp = new se, bd = new Ye, Xa = new Ye, Ip = new A, Dp = new A, rc = new A, Yo = new A, I1 = new bn, B9 = 1e-6, F9 = { type: "requestRender" }, k9 = { type: "changeRotation" }, _O = function () { let i = new se; return function (e, n) { e.parent !== null ? i.multiplyMatrices(e.parent.matrixWorld, e.hiddenMatrix) : i.copy(e.hiddenMatrix), n.premultiply(v1(i).invert()), e.rotation.setFromRotationMatrix(n), e.updateMatrix(), e instanceof Ht && Hr(e.parent) && e.invalidateDownstreamBooleanData(!0) } }(), D1 = class { constructor(t, e, n) { this.object = e; this.paused = !1; this.currentDampingFactor = 1; this.isReset = !1; this.worldQuaternion0 = new Ye; this.timeoutId = null; this.delayFinished = !0; this.wasOutside = !1; this.data = { ...Gg.defaultData, ...t, ...t.resetOnPointerLeave === void 0 && { resetOnPointerLeave: !1 } }, t.target === void 0 || t.target === "cursor" || (this.target = n.find(t.target)), this.data.dampingFactor && (this.currentDampingFactor = this.data.dampingFactor), this.object.getWorldQuaternion(this.worldQuaternion0), this.resetDampingFactor = 80 / this.data.resetSpeed + 1 } }, r0 = class extends gn { constructor(e) { super(e); this.events = []; this.pairOfEventListeners = []; this.pairOfUserEventListeners = []; this.onMouseMove = e => { if (!(je.length > 1)) { this._lastMouseEvent = e, this.eventContext.updateRaycaster(e); for (let n of this.events) n.target === void 0 && this.updateSingleEvent(n) } }; this.onMouseEnter = e => { for (let n of this.events) n.target === void 0 && (n.isReset = !1, n.currentDampingFactor = n.data.dampingFactor) }; this.onMouseLeave = e => { for (let n of this.events) n.target === void 0 && (n.data.resetOnPointerLeave && (n.isReset = !0, n.currentDampingFactor = n.resetDampingFactor), this.updateSingleEvent(n)) }; this.onScroll = e => { if (this._lastMouseEvent) { let n = new PointerEvent("pointermove", { clientX: this._lastMouseEvent.clientX, clientY: this._lastMouseEvent.clientY, bubbles: !0, cancelable: !0, view: window }); this.eventContext.eventElement.dispatchEvent(n) } }; this.onTargetChange = e => () => { this.updateSingleEvent(e) }; this.createUserEventListener = e => ({ eventName: n, target: r }) => { if (!n || !r) return; let s = $s(n); s && s === "LookAt" && this.updateSingleEvent(e) }; let { page: n } = this.eventContext; n.traverseEntity(r => { let s = r.data?.events.find(o => o.data.type === "LookAt" && !o.data.disabled); s && (!n.data.globalPhysics.usePhysics || r.dataPatched.physics?.rigidBody !== "dynamic") && this.events.push(new D1(s.data, r, n)) }) } connect () { if (!this.events.length) return; let { domElement: e, eventElement: n } = this.eventContext; this.domEventsNeeded.clear(), Wn && (this.domEventsNeeded.add("pointerdown"), e.addEventListener("pointerdown", this.onMouseMove)), this.domEventsNeeded.add("pointermove"), n.addEventListener("pointermove", this.onMouseMove), this.eventContext.useWindowEvents ? n.addEventListener("scroll", this.onScroll) : (e.addEventListener("pointerenter", this.onMouseEnter), e.addEventListener("pointerleave", this.onMouseLeave)); for (let r of this.events) { if (r.target !== void 0) { let a = this.onTargetChange(r), l = r.target; this.pairOfEventListeners.push([l, a]), l.addEventListener("requestRender", a) } let s = this.createUserEventListener(r), o = r.object; this.pairOfUserEventListeners.push([o, s]), o.addEventListener("userEvent", s) } } disconnect () { if (!this.events.length) return; let { domElement: e, eventElement: n } = this.eventContext; this.domEventsNeeded.clear(), Wn && e.removeEventListener("pointerdown", this.onMouseMove), n.removeEventListener("pointermove", this.onMouseMove), e.removeEventListener("pointerenter", this.onMouseEnter), e.removeEventListener("pointerleave", this.onMouseLeave), n.removeEventListener("scroll", this.onScroll); for (let [r, s] of this.pairOfEventListeners) r.removeEventListener("requestRender", s); for (let [r, s] of this.pairOfUserEventListeners) r.removeEventListener("userEvent", s); for (let r of this.events) r.paused = !0, r.isReset = !1 } onAnimationFrameDamping () { for (let e of this.events) e.paused || this.updateSingleEvent(e) } updateSingleEvent (e) { let { tilt: n, axis: r, distance: s, plane: o, limitDistance: a, enabledRotation: l, limitDistanceEnabled: u } = e.data, { getCamera: c, raycaster: h } = this.eventContext, { object: d, target: f } = e; if (d.getWorldPosition(Ip), !e.isReset) if (e.target) e.target.getWorldPosition(Dp); else { if (o === "custom" ? (c().getWorldDirection(n0), n0.negate(), I1.setFromNormalAndCoplanarPoint(n0, Ip)) : (o === "xy" ? Cp.set(0, 0, 1) : o === "xz" ? Cp.set(0, 1, 0) : o === "yz" && Cp.set(1, 0, 0), I1.setFromNormalAndCoplanarPoint(Cp, Ip)), !h.ray.intersectPlane(I1, Dp)) return; s > 0 && (o === "custom" || o === void 0) && Dp.addScaledVector(n0, s) } if (e.isReset || (f ? n === "target" ? rc.copy(f.up).applyMatrix4(Pp.extractRotation(f.matrixWorld)).normalize() : l.some(p => p === !1) ? (r === "x" ? (Yo.set(0, 0, 1), l[2] === !1 && Yo.set(0, 1, 0)) : r === "y" ? (Yo.set(1, 0, 0), l[0] === !1 && Yo.set(0, 0, 1)) : (Yo.set(0, 1, 0), l[1] === !1 && Yo.set(1, 0, 0)), rc.copy(Yo).applyQuaternion(e.worldQuaternion0).normalize()) : rc.set(0, 1, 0) : o === "custom" ? rc.set(0, 1, 0) : rc.copy(Cp)), e.isReset) Xa.copy(e.worldQuaternion0); else if (Ip.distanceTo(Dp) > a && u && f) if (e.data.snapDelay && (e.delayFinished = !1, typeof window < "u" && e.timeoutId !== null && (window.clearTimeout(e.timeoutId), e.timeoutId = null)), e.wasOutside = !0, e.data.resetAfterDistanceLimit) Xa.copy(e.worldQuaternion0), e.currentDampingFactor = e.resetDampingFactor; else return; else { if (e.wasOutside && (e.data.snapDelay && typeof window < "u" && (e.timeoutId = window.setTimeout(() => { e.delayFinished = !0, e.paused = !1, this.updateSingleEvent(e) }, e.data.snapDelay * 1e3)), e.currentDampingFactor = e.data.dampingFactor, e.wasOutside = !1), e.delayFinished === !1) return; U9(Pp, Dp, Ip, rc, r, Yo), Xa.setFromRotationMatrix(Pp), bd.setFromUnitVectors(Yo.applyQuaternion(Xa), rc), l.some(p => p === !1) && n !== "target" && Xa.premultiply(bd).normalize() } e.currentDampingFactor > 1 ? (d.updateWorldMatrix(!0, !1), bd.setFromRotationMatrix(v1(d.matrixWorld)), bd.slerp(Xa, 1 / e.currentDampingFactor), _O(d, Pp.makeRotationFromQuaternion(bd)), e.paused = 8 * (1 - bd.dot(Xa)) < B9) : (_O(d, Pp.makeRotationFromQuaternion(Xa)), e.paused = !0), e.object?.dispatchEvent({ type: "beginEvent", eventName: "LookAt" }), d.dispatchEvent(F9), d.dispatchEvent(k9) } }, zi = new A, Zn = new A, Tn = new A; function U9 (i, t, e, n, r, s) { let o = i.elements; Tn.subVectors(t, e), Tn.lengthSq() === 0 && (Tn.z = 1), Tn.normalize(), Zn.crossVectors(n, Tn), Zn.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Tn.x += 1e-4 : Tn.z += 1e-4, Tn.normalize(), Zn.crossVectors(n, Tn)), Zn.normalize(), zi.crossVectors(Tn, Zn), r === "x" ? s.z === 1 ? [Zn, zi, Tn] = [Tn, Zn, zi] : (Zn.negate(), [Zn, Tn] = [Tn, Zn]) : r === "y" ? s.x === 1 ? [Zn, zi, Tn] = [zi, Tn, Zn] : (Zn.negate(), [zi, Tn] = [Tn, zi]) : s.x === 1 && (Zn.negate(), [Zn, zi] = [zi, Zn]), o[0] = Zn.x, o[4] = zi.x, o[8] = Tn.x, o[1] = Zn.y, o[5] = zi.y, o[9] = Tn.y, o[2] = Zn.z, o[6] = zi.z, o[10] = Tn.z } var O1 = class { constructor(t, e, n, r, s, o) { this.id = t; this.data = e; this.object = n; this.entered = !1; this.actions = un(e, e.actions, r, s, o, n) } disconnect () { en(this.actions) } dispatchEnter () { this.actions.Transition.forEach(t => { t.object.currentTransitionEvent !== this && (t.object.currentTransitionEvent = this, t.init()) }), this.entered || (this.entered = !0, this.actions.Transition.forEach(t => t.playFromCurrent()), this.actions.Animation.forEach(t => t.play()), this.actions.Create.forEach(t => t.dispatch()), this.actions.Destroy.forEach(t => t.dispatch()), this.actions.SwitchCamera.forEach(t => t.playFromCurrent()), this.actions.SceneTransition.forEach(t => t.dispatch())) } dispatchLeave () { this.actions.Transition.forEach(t => { t.object.currentTransitionEvent !== this && (t.object.currentTransitionEvent = this, t.init()) }), this.entered && (this.entered = !1, this.actions.Transition.forEach(t => t.reverseFromCurrent()), this.actions.SwitchCamera.forEach(t => t.reverseFromCurrent())) } dispatchUserEvent (t) { this.actions.Transition.forEach(e => { e.object.currentTransitionEvent !== this && (e.object.currentTransitionEvent = this, e.init()) }), t ? (this.actions.Transition.forEach(e => e.reverseFromCurrent()), this.actions.Animation.forEach(e => e.reverseFromCurrent()), this.actions.SwitchCamera.forEach(e => e.reverseFromCurrent())) : (this.actions.Transition.forEach(e => e.playFromCurrent()), this.actions.Animation.forEach(e => e.playFromCurrent()), this.actions.Create.forEach(e => e.dispatch()), this.actions.Destroy.forEach(e => e.dispatch()), this.actions.SwitchCamera.forEach(e => e.playFromCurrent())), this.actions.SceneTransition.forEach(e => e.dispatch()) } }, i0 = class extends gn { constructor(e, n) { super(e); this.eventsPerObjects = {}; this.objects = []; this._prevObjects = []; this.onMouseDown = e => { je.length > 1 || (this.eventContext.updateRaycaster(e), this.handleMouseHoverEvent()) }; this.onMouseUp = e => { je.length > 1 || this.handleMouseHoverEvent(!0) }; this.onMouseMove = e => { je.length > 1 || (this.eventContext.updateRaycaster(e), this.handleMouseHoverEvent()) }; this.onUserEvent = ({ eventName: e, target: n, reverse: r }) => { if (!e || !n) return; let s = $s(e); s && s === "MouseHover" && (n.dispatchEvent({ type: "beginEvent", eventName: "MouseHover" }), this.eventsPerObjects[n.uuid]?.forEach(o => o.dispatchUserEvent(r))) }; let { page: r, sharedAssets: s } = this.eventContext; r.traverseEntity(o => { if (!(!o.visible || !o.data?.events.length)) { for (let { id: a, data: l } of o.data.events) if (!l.disabled && l.type === "MouseHover") try { let u = new O1(a, l, o, r, s, n); this.eventsPerObjects[o.uuid] ? this.eventsPerObjects[o.uuid].push(u) : this.eventsPerObjects[o.uuid] = [u] } catch (u) { !1 && console.log(u) } this.eventsPerObjects[o.uuid]?.length && this.objects.push(o) } }) } connect () { if (!this.objects.length) return; let { domElement: e } = this.eventContext; this.domEventsNeeded.clear(), Wn && (this.domEventsNeeded.add("pointerdown"), e.addEventListener("pointerdown", this.onMouseDown), this.domEventsNeeded.add("pointerup"), e.addEventListener("pointerup", this.onMouseUp)), this.domEventsNeeded.add("pointermove"), e.addEventListener("pointermove", this.onMouseMove), this.objects.forEach(n => { n.addEventListener("userEvent", this.onUserEvent) }) } disconnect () { if (!this.objects.length) return; let { domElement: e } = this.eventContext; this.domEventsNeeded.clear(), Wn && (e.removeEventListener("pointerdown", this.onMouseDown), e.removeEventListener("pointerup", this.onMouseUp)), e.removeEventListener("pointermove", this.onMouseMove), Object.values(this.eventsPerObjects).forEach(n => { n.forEach(r => { r.disconnect() }) }), this.objects.forEach(n => { n.removeEventListener("userEvent", this.onUserEvent) }) } handleMouseHoverEvent (e = !1) { let n = []; if (!e) { let { stopRaycast: r, raycaster: s, page: o } = this.eventContext; if (r) { let a = Ep(s, o, this.objects); n = Mp(a) } else this.objects.forEach(a => { gd(s, a) && n.push(a) }) } this._prevObjects.length && this._prevObjects.forEach(r => { n.includes(r) || (r.dispatchEvent({ type: "beginEvent", eventName: "MouseHover" }), this.eventsPerObjects[r.uuid]?.forEach(s => s.dispatchLeave())) }), n.length && n.forEach(r => { r.dispatchEvent({ type: "beginEvent", eventName: "MouseHover" }), this.eventsPerObjects[r.uuid]?.forEach(s => s.dispatchEnter()) }), this._prevObjects = n } }; var R1 = class { constructor(t, e, n, r, s, o) { this.id = t; this.data = e; this.object = n; this.scrollCounter = 0; this.actions = un(e, e.actions, r, s, o, n) } connect () { this.scrollCounter = 0 } disconnect () { en(this.actions) } dispatch (t) { this.actions.Transition.forEach(r => { r.object.currentTransitionEvent !== this && (r.object.currentTransitionEvent = this, r.init()) }); let e = t > 0 ? 1 : -1; this.scrollCounter += e, this.scrollCounter = Math.min(Math.max(this.scrollCounter, 0), this.data.steps); let n = this.scrollCounter / this.data.steps; this.actions.Transition.forEach(r => r.seek(n)), this.actions.Animation.forEach(r => r.seek(e)), this.actions.Create.forEach(r => r.dispatchThrottled()) } dispatchUserEvent (t) { this.actions.Transition.forEach(e => { e.object.currentTransitionEvent !== this && (e.object.currentTransitionEvent = this, e.init()) }), t ? (this.actions.Transition.forEach(e => e.reverseFromCurrent()), this.actions.Animation.forEach(e => e.reverseFromCurrent())) : (this.actions.Transition.forEach(e => { e.playFromCurrent() }), this.actions.Animation.forEach(e => { e.playFromCurrent() })), this.actions.Create.forEach(e => e.dispatchThrottled()) } }, L1 = class { constructor(t, e, n, r, s, o, a) { this.id = t; this.data = e; this.object = n; this.domElement = o; this.eventManager = a; this.scrollStart = 0; this.scrollEnd = 0; this.actions = un(e, e.actions, r, s, a, n) } computeScrollBounds () { let t = this.domElement.getBoundingClientRect(), e = document.body, n = document.documentElement, r = window.pageYOffset || n.scrollTop || e.scrollTop, s = n.clientTop || e.clientTop || 0, o = Math.round(t.top + r - s); if (this.data.startFrom === "enter") { let a = window.innerHeight, l = t.height, u = this.data.enterAnchor, c = u === "top" ? a : u === "bottom" ? a - l : a - l * .5; this.scrollStart = o - c } else this.scrollStart = 0; this.scrollStart += this.data.startOffset ?? 0, this.scrollEnd = this.scrollStart + (this.data.endAfter ?? 400), this.dispatch({ x: window.scrollX, y: window.scrollY }) } connect () { this.computeScrollBounds() } disconnect () { en(this.actions) } handleResize () { this.computeScrollBounds() } dispatch ({ x: t, y: e }) { this.actions.Transition.forEach(s => { s.object.currentTransitionEvent !== this && (s.object.currentTransitionEvent = this, s.init()) }); let n = this.scrollEnd - this.scrollStart, r = Math.min(1, Math.max(0, (e - this.scrollStart) / n)); this.actions.Transition.forEach(s => s.seek(r)), this.actions.Animation.forEach(s => s.seek(r)), this.actions.Create.forEach(s => s.dispatchThrottled()) } dispatchUserEvent (t) { this.actions.Transition.forEach(e => { e.object.currentTransitionEvent !== this && (e.object.currentTransitionEvent = this, e.init()) }), t ? (this.actions.Transition.forEach(e => e.reverseFromCurrent()), this.actions.Animation.forEach(e => e.reverseFromCurrent())) : (this.actions.Transition.forEach(e => { e.playFromCurrent() }), this.actions.Animation.forEach(e => { e.playFromCurrent() })), this.actions.Create.forEach(e => e.dispatchThrottled()) } }, s0 = class extends gn { constructor(e, n) { super(e); this.wheelEventsPerObject = new Map; this.scrollEventsPerObject = new Map; this.isInview = !0; this.handleResize = () => { [...this.scrollEventsPerObject.entries()].forEach(([e, n]) => { n.forEach(r => r.handleResize()) }) }; this.onScroll = e => { if (!this.isInview) return; let n = { y: window.scrollY, x: window.scrollX };[...this.scrollEventsPerObject.entries()].forEach(([r, s]) => { r.dispatchEvent({ type: "beginEvent", eventName: "Scroll", scroll: n }), s.forEach(o => o.dispatch(n)) }) }; this.onWheel = e => { !this.isInview || e.ctrlKey || [...this.wheelEventsPerObject.entries()].forEach(([n, r]) => { n.dispatchEvent({ type: "beginEvent", eventName: "Scroll", deltaY: e.deltaY }), r.forEach(s => s.dispatch(e.deltaY)) }) }; this.onUserEvent = ({ eventName: e, target: n, reverse: r }) => { if (!e || !n) return; let s = $s(e); s && s === "Scroll" && (n.dispatchEvent({ type: "beginEvent", eventName: "Scroll" }), this.wheelEventsPerObject.get(n)?.forEach(o => { o.dispatchUserEvent(r) })) }; let { page: r, sharedAssets: s, domElement: o, isExport: a } = this.eventContext; r.traverseEntity(l => { if (l.data?.events.length) { for (let { id: u, data: c } of l.data.events) if (!c.disabled && c.type === "Scroll") if (c.trigger === "load" || !a) { let h = new R1(u, c, l, r, s, n); this.wheelEventsPerObject.has(l) ? this.wheelEventsPerObject.get(l)?.push(h) : this.wheelEventsPerObject.set(l, [h]) } else { let h = new L1(u, c, l, r, s, o, n); this.scrollEventsPerObject.has(l) ? this.scrollEventsPerObject.get(l)?.push(h) : this.scrollEventsPerObject.set(l, [h]) } } }), this.intersectionObserver = new IntersectionObserver(l => { let u = l[0]; u && (this.isInview = u.isIntersecting) }, { root: null }) } connect () { this.intersectionObserver.observe(this.eventContext.domElement), [...this.wheelEventsPerObject.entries()].forEach(([e, n]) => { n.forEach(r => r.connect()), e.addEventListener("userEvent", this.onUserEvent) }), [...this.scrollEventsPerObject.entries()].forEach(([e, n]) => { n.forEach(r => r.connect()), e.addEventListener("userEvent", this.onUserEvent) }), [...this.wheelEventsPerObject.values()].some(e => e.length) && (this.domEventsNeeded.add("wheel"), window.addEventListener("wheel", this.onWheel)), [...this.scrollEventsPerObject.values()].some(e => e.length) && (this.domEventsNeeded.add("scroll"), window.addEventListener("scroll", this.onScroll), window.addEventListener("resize", this.handleResize)) } disconnect () { window.removeEventListener("wheel", this.onWheel), window.removeEventListener("scroll", this.onScroll), window.removeEventListener("resize", this.handleResize), this.intersectionObserver.unobserve(this.eventContext.domElement), this.domEventsNeeded.clear(), [...this.wheelEventsPerObject.entries()].forEach(([e, n]) => { n.forEach(r => r.disconnect()), e.removeEventListener("userEvent", this.onUserEvent) }), [...this.scrollEventsPerObject.entries()].forEach(([e, n]) => { n.forEach(r => r.disconnect()), e.removeEventListener("userEvent", this.onUserEvent) }) } }; var N1 = class { constructor(t, e, n, r, s, o) { this.id = t; this.data = e; this.object = n; this.actions = un(e, e.actions, r, s, o, n) } disconnect () { en(this.actions) } dispatch () { this.actions.Transition.forEach(t => { t.play() }), this.actions.Animation.forEach(t => { t.play() }), this.actions.SwitchCamera.forEach(t => { t.play() }), this.actions.SceneTransition.forEach(t => { t.dispatch() }), this.actions.Create.forEach(t => { t.dispatchFromStart() }), this.actions.Destroy.forEach(t => { t.dispatchFromStart() }) } dispatchAfter (t) { this.actions.Audio.forEach(e => { (e.interaction.data.triggerAfter ?? "any") === t && (e.interaction instanceof Xs ? e.interaction.audioPlayer.play() : e.interaction instanceof fd && e.interaction.dispatch()) }), this.actions.Video.forEach(e => { let n = e.interaction.data.triggerAfter ?? "autoplay"; n === t && (e.interaction instanceof Ho ? e.interaction.play(n === "autoplay") : e.interaction instanceof md && e.interaction.dispatch()) }) } dispatchUserEvent (t) { this.actions.Transition.forEach(e => { e.object.currentTransitionEvent !== this && (e.object.currentTransitionEvent = this, e.init()) }), t ? (this.actions.Transition.forEach(e => e.reverseFromCurrent()), this.actions.Animation.forEach(e => e.reverseFromCurrent()), this.actions.SwitchCamera.forEach(e => e.reverseFromCurrent())) : (this.actions.Transition.forEach(e => e.playFromCurrent()), this.actions.Animation.forEach(e => e.playFromCurrent()), this.actions.SwitchCamera.forEach(e => e.playFromCurrent())), this.actions.SceneTransition.forEach(e => e.dispatch()), this.actions.Create.forEach(e => { e.dispatch() }), this.actions.Destroy.forEach(e => { e.dispatch() }), this.actions.Audio.forEach(e => { e.interaction instanceof Xs ? e.interaction.audioPlayer.play() : e.interaction instanceof fd && e.interaction.dispatch() }), this.actions.Video.forEach(e => { e.interaction instanceof Ho ? e.interaction.play() : e.interaction instanceof md && e.interaction.dispatch() }) } }, o0 = class extends gn { constructor(e, n) { super(e); this.eventManager = n; this.eventsPerObject = new Map; this.eventsAfterPerObject = new Map; this.onMouseDown = () => { [...this.eventsAfterPerObject.entries()].forEach(([e, n]) => { e.dispatchEvent({ type: "beginEvent", eventName: "Start" }), n.forEach(r => { r.dispatchAfter("mouseDown") }) }) }; this.onKeyDown = () => { [...this.eventsAfterPerObject.entries()].forEach(([e, n]) => { e.dispatchEvent({ type: "beginEvent", eventName: "Start" }), n.forEach(r => { r.dispatchAfter("keyDown") }) }) }; this.onAny = () => { let { domElement: e, isExport: n } = this.eventContext; (n ? document : e).removeEventListener("pointerdown", this.onAny), document.removeEventListener("keydown", this.onAny), [...this.eventsAfterPerObject.entries()].forEach(([s, o]) => { s.dispatchEvent({ type: "beginEvent", eventName: "Start" }), o.forEach(a => { a.dispatchAfter("any") }) }) }; this.onSceneTransitionAudioVideoPlay = () => { [...this.eventsAfterPerObject.entries()].forEach(([e, n]) => { e.dispatchEvent({ type: "beginEvent", eventName: "Start" }), n.forEach(r => { r.actions.Audio.forEach(s => { s.interaction instanceof Xs && s.interaction.audioPlayer.play() }), r.actions.Video.forEach(s => { let o = s.interaction.data.triggerAfter ?? "autoplay"; s.interaction instanceof Ho && s.interaction.play(o === "autoplay") }) }) }) }; this.onPlay = () => { [...this.eventsAfterPerObject.entries()].forEach(([e, n]) => { e.dispatchEvent({ type: "beginEvent", eventName: "Start" }), n.forEach(r => { r.dispatchAfter("autoplay") }) }) }; this.onUserEvent = ({ eventName: e, target: n, reverse: r }) => { if (!e || !n) return; let s = $s(e); s && s === "Start" && (n.dispatchEvent({ type: "beginEvent", eventName: "Start" }), this.eventsPerObject.get(n)?.forEach(o => { o.dispatchUserEvent(r) }), this.eventsAfterPerObject.get(n)?.forEach(o => { o.dispatchUserEvent(r) })) } } connect () { let { sharedAssets: e, page: n } = this.eventContext; if (n.traverseEntity(r => { if (r.data?.events.length) for (let { id: s, data: o } of r.data.events) { if (o.disabled || o.type !== "Start") continue; let a = new N1(s, o, r, n, e, this.eventManager); (a.actions.Transition.length || a.actions.Animation.length || a.actions.SwitchCamera.length || a.actions.Create.length || a.actions.Destroy.length || a.actions.SceneTransition.length) && (this.eventsPerObject.has(r) ? this.eventsPerObject.get(r)?.push(a) : this.eventsPerObject.set(r, [a])), a.actions.Audio.length && (this.eventsAfterPerObject.has(r) ? this.eventsAfterPerObject.get(r)?.push(a) : this.eventsAfterPerObject.set(r, [a])), a.actions.Video.length && (this.hasVideoAction = !0, this.eventsAfterPerObject.has(r) ? this.eventsAfterPerObject.get(r)?.push(a) : this.eventsAfterPerObject.set(r, [a])) } }), [...this.eventsAfterPerObject.values()].some(r => r.length)) { if (this.eventManager.activateCount === 0) { let { domElement: r, isExport: s } = this.eventContext, o = s ? document : r; o.addEventListener("pointerdown", this.onMouseDown, { once: !0 }), o.addEventListener("mousedown", this.onMouseDown, { once: !0 }), document.addEventListener("keydown", this.onKeyDown, { once: !0 }), o.addEventListener("pointerdown", this.onAny), o.addEventListener("mousedown", this.onAny), document.addEventListener("keydown", this.onAny), [...this.eventsAfterPerObject.entries()].forEach(([a, l]) => { a.addEventListener("userEvent", this.onUserEvent) }) } else this.onSceneTransitionAudioVideoPlay(); this.onPlay() } [...this.eventsPerObject.entries()].forEach(([r, s]) => { r.dispatchEvent({ type: "beginEvent", eventName: "Start" }), s.forEach(o => o.dispatch()), r.addEventListener("userEvent", this.onUserEvent) }) } disconnect () { if ([...this.eventsAfterPerObject.values()].some(e => e.length)) { let { domElement: e, isExport: n } = this.eventContext, r = n ? document : e; r.removeEventListener("pointerdown", this.onMouseDown), r.removeEventListener("mousedown", this.onMouseDown), document.removeEventListener("keydown", this.onKeyDown), r.removeEventListener("pointerdown", this.onAny), r.removeEventListener("mousedown", this.onAny), document.removeEventListener("keydown", this.onAny), [...this.eventsAfterPerObject.entries()].forEach(([s, o]) => { s.removeEventListener("userEvent", this.onUserEvent), o.forEach(a => a.disconnect()) }) } [...this.eventsPerObject.entries()].forEach(([e, n]) => { e.removeEventListener("userEvent", this.onUserEvent), n.forEach(r => r.disconnect()) }), this.eventsPerObject.clear(), this.eventsAfterPerObject.clear() } }; var a0 = class { constructor(t, e, n, r, s, o) { this.id = t; this.data = e; this.object = n; this.disabled = !1; this.actions = un(e, e.actions, r, s, o, n), this.target = e.target, this.useToggle = e.toggle } disconnect () { en(this.actions) } dispatch (t) { this.disabled || (this.actions.Transition.forEach(e => { e.object.currentTransitionEvent !== this && (e.object.currentTransitionEvent = this, e.init()) }), this.object.dispatchEvent({ type: "beginEvent", eventName: "Collision" }), this.useToggle ? (this.actions.Transition.forEach(e => { e.toggle() }), this.actions.Animation.forEach(e => { e.toggle() })) : (this.actions.Transition.forEach(e => { e.play() }), this.actions.Animation.forEach(e => { e.play() })), this.actions.Reset.forEach(e => { e.dispatch() }), this.actions.Link.forEach(e => { e.dispatch() }), this.actions.Reset.forEach(e => { e.dispatch() }), this.actions.Create.forEach(e => { e.dispatch() }), this.actions.Destroy.forEach(e => { e.dispatch(t ?? !1) }), this.actions.Audio.forEach(e => { e.dispatchBasic() }), this.actions.Video.forEach(e => { e.dispatchBasic() })) } }; var MO = !1 ? typeof window < "u" ? window.location.href : "" : "https://unpkg.com/@splinetool/runtime@0.9.437/build/", z9 = !1 ? MO : "https://unpkg.com/@splinetool/navmesh-wasm@0.9.437/build/", G9 = `
(async function() {
	const [wasmImport, wasmBinary] = await Promise.all([
		import('${MO}' + 'navmesh.js'),
		fetch('${z9}' + 'navmesh.wasm').then((res) => res.arrayBuffer()),
	]);
	const wasmModule = wasmImport.default;
	self.module = await wasmModule({ wasmBinary });
	postMessage('ready');
})();
`, V9 = `
(async function() {
	const [wasmImport, wasmBinary] = await Promise.all([
		import(self.location.origin + '/_libraries/navmesh.js'),
		fetch(self.location.origin + '/_libraries/navmesh.wasm').then((res) => res.arrayBuffer()),
	]);
	const wasmModule = wasmImport.default;
	self.module = await wasmModule({ wasmBinary });
	postMessage('ready');
})();
`, H9 = `

onmessage = function(messageEvent) {
	const meshData = messageEvent.data;
	const positions = meshData[0];
	const offset = meshData[1];
	const indices = meshData[2];
	const indicesLength = meshData[3];
	const parameters = meshData[4];

	const module = self.module;
	const rc = new module.rcConfig();
	rc.cs = parameters.cs;
	rc.ch = parameters.ch;
	rc.borderSize = parameters.borderSize ? parameters.borderSize : 0;
	rc.tileSize = parameters.tileSize ? parameters.tileSize : 0;
	rc.walkableSlopeAngle = parameters.walkableSlopeAngle;
	rc.walkableHeight = parameters.walkableHeight;
	rc.walkableClimb = parameters.walkableClimb;
	rc.walkableRadius = parameters.walkableRadius;
	rc.maxEdgeLen = parameters.maxEdgeLen;
	rc.maxSimplificationError = parameters.maxSimplificationError;
	rc.minRegionArea = parameters.minRegionArea;
	rc.mergeRegionArea = parameters.mergeRegionArea;
	rc.maxVertsPerPoly = parameters.maxVertsPerPoly;
	rc.detailSampleDist = parameters.detailSampleDist;
	rc.detailSampleMaxError = parameters.detailSampleMaxError;

	if (!self.navMesh) {
		self.navMesh = new module.NavMesh();
	}
	self.navMesh.build(positions, offset, indices, indicesLength, rc);

	const navmeshData = navMesh.getNavmeshData();
	const arrView = new Uint8Array(module.HEAPU8.buffer, navmeshData.dataPointer, navmeshData.size);
	const ret = new Uint8Array(navmeshData.size);
	ret.set(arrView);
	navMesh.freeNavmeshData(navmeshData);

	postMessage(ret);
}
`, EO = .001, j9 = { cs: 6, ch: 2, walkableSlopeAngle: 90, walkableHeight: 20, walkableClimb: 5, walkableRadius: 0, maxEdgeLen: 12, maxSimplificationError: 1.3, minRegionArea: 8, mergeRegionArea: 20, maxVertsPerPoly: 6, detailSampleDist: 6, detailSampleMaxError: 1 }, TO, mt, Er; IT.then(i => { TO = i, mt = new i.Vec3, Er = new i.Vec3 }); var W9 = new A, l0 = class { constructor(t = !1, e = !1) { this.usePhysics = t; this.isExport = e; this.onPointerDown = t => { if (je.length !== 1) return; let { raycaster: e, page: n } = this.eventContext; this.eventContext.updateRaycaster(t); let r = n.raycastWithClones(e); if (r.length !== 0) { if (this.gameControl) { let s = W9.copy(this.gameControl.colliderWorldPosition); s.y -= this.gameControl.colliderHeight / 2, this.gameControl.path = this.computePath(s, r[0].point) } this.eventContext.requestRender() } }; this.traverseWithPhysics = (t, e) => n => { let r; if (n instanceof dr) if (n.objectForSample) { if (n.objectForSample.dataPatched.physics.fusedBody) return; r = n.object } else return n.object.dataPatched.physics.fusedBody === !0 && n.object.dataPatched.physics.rigidBody === "dynamic" ? !0 : void 0; else if (n instanceof sn) r = n.object; else if (r = n, r.dataPatched.cloner?.disabled === !1 && r.dataPatched.cloner?.hideBase && r.dataPatched.physics?.fusedBody !== !0) return !0; if (e && !r.userData.navmesh) return; let s = r.dataPatched; if (!s.visible && s.physics?.enabled !== !0) return !0; n.updateMatrixWorldSVD(); let o = Op(s), a = r.userData.hasDestroy, l = r.userData.hasDrag, u = !1, c = !1; for (let h of s.events) h.data.disabled !== !0 && (h.data.type === "GameControl" ? u = !0 : h.data.type === "Follow" && (c = !0)); if (u || o || c || a || l) return !0; if (this.usePhysics && s.physics?.rigidBody === "dynamic") { if (this.usePhysics && s.physics?.fusedBody) return !0 } else if ("geometry" in n && n.geometry && t.push(ps(n.geometry, n.matrixWorld)), this.usePhysics && s.physics?.fusedBody) return n.traverseObject((h, d) => { if (d === 0) return; let f; if (h instanceof dr) if (h.objectForSample) { if (h.objectForSample.dataPatched.physics.fusedBody) return; f = h.object } else return h.object.dataPatched.physics.fusedBody === !0 && h.object.dataPatched.physics.rigidBody === "dynamic" ? !0 : void 0; else if (h instanceof sn) f = h.object; else if (f = h, h.dataPatched.cloner?.hideBase) return !0; let p = f.dataPatched; if (!p.visible && p.physics?.enabled !== !0) return !0; "geometry" in h && h.geometry && t.push(ps(h.geometry, h.matrixWorld)) }), !0 }; this.traverseNoPhysics = (t, e) => n => { let r; if (n instanceof dr) return; n instanceof sn ? r = n.object : r = n; let s = r.dataPatched; if (s.physics.enabled === "visibility" ? !s.visible : !s.physics.enabled) return !0; if (e && !r.userData.navmesh) return; let o = n.geometry, a = r.userData.hasDestroy === !0, l = r.userData.hasDrag === !0; if (Op(s) || a || l || r.dataPatched.events.some(u => u.data.disabled !== !0 && u.data.type === "GameControl")) return !0; o && t.push(ps(o, n.matrixWorld)) }; this.navmeshWasm = TO, this.navMesh = new this.navmeshWasm.NavMesh, this._workerURL = URL.createObjectURL(new Blob([(e ? G9 : V9) + H9])), this._worker = new Worker(this._workerURL) } init (t, e, n) { this.gameControl = e, this.eventContext = n, this.resolution = t.ch, this.setDefaultQueryExtent(new A().setScalar(t.ch * t.walkableRadius * 1.2)), this._worker.onmessage = () => { this.createNavMesh(n.page, t, r => { this.buildFromNavmeshData(r.data) }) }, this.eventContext.renderer.domElement.addEventListener("pointerdown", this.onPointerDown) } createNavMesh (t, e, n) { e.objects.forEach(u => { let c = t.scene.find(u); c.traverseEntity(h => { h.userData.navmesh = !0 }), c.cloner?.traverseObject(h => { h.userData.navmesh = !0 }) }); let r = [], s = (this.usePhysics ? this.traverseWithPhysics : this.traverseNoPhysics)(r, e.zones === "custom"); if (t.traverseChildren(s), e.objects.forEach(u => { let c = t.scene.find(u); c.traverseEntity(h => { h.userData.navmesh = void 0 }), c.cloner?.traverseObject(h => { h.userData.navmesh = void 0 }) }), r.length === 0) return !1; let o = Ji(r), { positions: a, triIndices: l } = Ul(o.getAttribute("position"), o.getIndex()); return this._worker.postMessage([a, a.length / 3, l, l.length, { ...j9, ...e }]), this._worker.onmessage = n, !0 } createDebugNavGeometry () { let t, e, n = this.navMesh.getDebugNavMesh(), r = n.getTriangleCount(), s = new Uint32Array(r * 3), o = new Float32Array(r * 3 * 3); for (t = 0; t < r * 3; t++)s[t] = t; for (t = 0; t < r; t++)for (e = 0; e < 3; e++) { let l = n.getTriangle(t).getPoint(e); o[t * 9 + e * 3 + 0] = l.x, o[t * 9 + e * 3 + 1] = l.y, o[t * 9 + e * 3 + 2] = l.z } let a = new Ce; return a.setIndex(new ze(s, 1)), a.setAttribute("position", new ze(o, 3)), a } getClosestPoint (t) { return mt.x = t.x, mt.y = t.y, mt.z = t.z, this.navMesh.getClosestPoint(mt) } getClosestPointToRef (t, e) { mt.x = t.x, mt.y = t.y, mt.z = t.z; let n = this.navMesh.getClosestPoint(mt); e.set(n.x, n.y, n.z) } getRandomPointAround (t, e) { return mt.x = t.x, mt.y = t.y, mt.z = t.z, this.navMesh.getRandomPointAround(mt, e) } getRandomPointAroundToRef (t, e, n) { mt.x = t.x, mt.y = t.y, mt.z = t.z; let r = this.navMesh.getRandomPointAround(mt, e); n.set(r.x, r.y, r.z) } moveAlong (t, e) { return mt.x = t.x, mt.y = t.y, mt.z = t.z, Er.x = e.x, Er.y = e.y, Er.z = e.z, this.navMesh.moveAlong(mt, Er) } moveAlongToRef (t, e, n) { return mt.x = t.x, mt.y = t.y, mt.z = t.z, Er.x = e.x, Er.y = e.y, Er.z = e.z, this.navMesh.moveAlong(mt, Er) } computePath (t, e) { let n = this.getClosestPoint(e); Er.x = n.x, Er.y = n.y, Er.z = n.z, this.getClosestPoint(t); let r = this.navMesh.computePath(mt, Er), s = r.getPointCount(), o = []; for (let a = 0; a < s; a++) { let l = r.getPoint(a); o.push(new A(l.x, l.y, l.z)) } return o } createCrowd (t, e) { return new B1(this, t, e) } setDefaultQueryExtent (t) { mt.x = t.x, mt.y = t.y, mt.z = t.z, this.navMesh.setDefaultQueryExtent(mt) } getDefaultQueryExtent () { return this.navMesh.getDefaultQueryExtent() } buildFromNavmeshData (t) { let e = t.length * t.BYTES_PER_ELEMENT, n = this.navmeshWasm._malloc(e), r = new Uint8Array(this.navmeshWasm.HEAPU8.buffer, n, e); r.set(t); let s = new this.navmeshWasm.NavmeshData; s.dataPointer = r.byteOffset, s.size = t.length, this.navMesh.buildFromNavmeshData(s), this.navmeshWasm._free(r.byteOffset) } getNavmeshData () { let t = this.navMesh.getNavmeshData(), e = new Uint8Array(this.navmeshWasm.HEAPU8.buffer, t.dataPointer, t.size), n = new Uint8Array(t.size); return n.set(e), this.navMesh.freeNavmeshData(t), n } getDefaultQueryExtentToRef (t) { let e = this.navMesh.getDefaultQueryExtent(); t.set(e.x, e.y, e.z) } dispose () { this.navMesh.destroy(), this._worker.terminate(), URL.revokeObjectURL(this._workerURL), this.eventContext?.renderer.domElement.removeEventListener("pointerdown", this.onPointerDown) } addCylinderObstacle (t, e, n) { return mt.x = t.x, mt.y = t.y, mt.z = t.z, this.navMesh.addCylinderObstacle(mt, e, n) } addBoxObstacle (t, e, n) { return mt.x = t.x, mt.y = t.y, mt.z = t.z, Er.x = e.x, Er.y = e.y, Er.z = e.z, this.navMesh.addBoxObstacle(mt, Er, n) } removeObstacle (t) { this.navMesh.removeObstacle(t) } isSupported () { return this.navmeshWasm !== void 0 } }, B1 = class { constructor(t, e, n) { this.navmeshWasmWrapper = t; this.transforms = []; this.agents = new Array; this.reachRadii = new Array; this._agentDestinationArmed = new Array; this._agentDestination = new Array; this.crowd = new this.navmeshWasmWrapper.navmeshWasm.Crowd(e, n, this.navmeshWasmWrapper.navMesh.getNavMesh()) } onReachTarget (t, e) { } addAgent (t, e, n) { let r = new this.navmeshWasmWrapper.navmeshWasm.dtCrowdAgentParams; r.radius = e.radius, r.height = e.height, r.maxAcceleration = e.maxAcceleration, r.maxSpeed = e.maxSpeed, r.collisionQueryRange = e.collisionQueryRange, r.pathOptimizationRange = e.pathOptimizationRange, r.separationWeight = e.separationWeight, r.updateFlags = 7, r.obstacleAvoidanceType = 0, r.queryFilterType = 0, r.userData = 0; let s = this.crowd.addAgent(new this.navmeshWasmWrapper.navmeshWasm.Vec3(t.x, t.y, t.z), r); return this.transforms.push(n), this.agents.push(s), this.reachRadii.push(e.reachRadius ? e.reachRadius : e.radius), this._agentDestinationArmed.push(!1), this._agentDestination.push(new A(0, 0, 0)), s } getAgentPosition (t) { return this.crowd.getAgentPosition(t) } getAgentPositionToRef (t, e) { let n = this.crowd.getAgentPosition(t); e.set(n.x, n.y, n.z) } getAgentVelocity (t) { return this.crowd.getAgentVelocity(t) } getAgentVelocityToRef (t, e) { let n = this.crowd.getAgentVelocity(t); e.set(n.x, n.y, n.z) } getAgentNextTargetPath (t) { return this.crowd.getAgentNextTargetPath(t) } getAgentNextTargetPathToRef (t, e) { let n = this.crowd.getAgentNextTargetPath(t); e.set(n.x, n.y, n.z) } getAgentState (t) { return this.crowd.getAgentState(t) } overOffmeshConnection (t) { return this.crowd.overOffmeshConnection(t) } agentGoto (t, e) { this.crowd.agentGoto(t, new this.navmeshWasmWrapper.navmeshWasm.Vec3(e.x, e.y, e.z)); let n = this.agents.indexOf(t); n > -1 && (this._agentDestinationArmed[n] = !0, this._agentDestination[n].set(e.x, e.y, e.z)) } agentTeleport (t, e) { this.crowd.agentTeleport(t, new this.navmeshWasmWrapper.navmeshWasm.Vec3(e.x, e.y, e.z)) } updateAgentParameters (t, e) { let n = this.crowd.getAgentParameters(t); e.radius !== void 0 && (n.radius = e.radius), e.height !== void 0 && (n.height = e.height), e.maxAcceleration !== void 0 && (n.maxAcceleration = e.maxAcceleration), e.maxSpeed !== void 0 && (n.maxSpeed = e.maxSpeed), e.collisionQueryRange !== void 0 && (n.collisionQueryRange = e.collisionQueryRange), e.pathOptimizationRange !== void 0 && (n.pathOptimizationRange = e.pathOptimizationRange), e.separationWeight !== void 0 && (n.separationWeight = e.separationWeight), this.crowd.setAgentParameters(t, n) } removeAgent (t) { this.crowd.removeAgent(t); let e = this.agents.indexOf(t); e > -1 && (this.agents.splice(e, 1), this.transforms.splice(e, 1), this.reachRadii.splice(e, 1), this._agentDestinationArmed.splice(e, 1), this._agentDestination.splice(e, 1)) } getAgents () { return this.agents } update (t) { if (this.navmeshWasmWrapper.navMesh.update(), t <= EO) return; let e = 1 / 60, n = 10; if (e <= EO) this.crowd.update(t); else { let r = Math.floor(t / e); n && r > n && (r = n), r < 1 && (r = 1); let s = t / r; for (let o = 0; o < r; o++)this.crowd.update(s) } for (let r = 0; r < this.agents.length; r++) { let s = this.agents[r], o = this.getAgentPosition(s); if (this.transforms[r].copy(o), this._agentDestinationArmed[r]) { let a = o.x - this._agentDestination[r].x, l = o.z - this._agentDestination[r].z, u = this.reachRadii[r], c = this._agentDestination[r].y - this.reachRadii[r], h = this._agentDestination[r].y + this.reachRadii[r], d = a * a + l * l; o.y > c && o.y < h && d < u * u && (this.onReachTarget(s, this._agentDestination[r]), this._agentDestinationArmed[r] = !1) } } } setDefaultQueryExtent (t) { let e = new this.navmeshWasmWrapper.navmeshWasm.Vec3(t.x, t.y, t.z); this.crowd.setDefaultQueryExtent(e) } getDefaultQueryExtent () { return this.crowd.getDefaultQueryExtent() } getDefaultQueryExtentToRef (t) { let e = this.crowd.getDefaultQueryExtent(); t.set(e.x, e.y, e.z) } getCorners (t) { let e, n = this.crowd.getCorners(t), r = n.getPointCount(), s = []; for (e = 0; e < r; e++) { let o = n.getPoint(e); s.push(new A(o.x, o.y, o.z)) } return s } dispose () { this.crowd.destroy() } }; function F1 (i) { let t = !1; return i.scene.objects.forEach(e => { e.data.type === "Page" && !t && e.data.publish.gameControlObject && Ca.traverseModuleInstances(i.scene.objects, e.id, (r, s, o) => { for (let a of o) a.data.type === "GameControl" && a.data.navmesh.enabled && (t = !0) }) }), t } var q9 = { type: "change" }, CO = { type: "changeZoom" }, Y9 = { type: "changePan" }, wd = { type: "start" }, Sd = { type: "end", changed: !0 }, X9 = { type: "end", changed: !1 }, k1 = new Ye, PO = new B, Q9 = 2 * Math.PI, K9 = 1e-8, Z9 = .01, U1 = new A, c0 = new B, z1 = new A, u0 = new Ye, IO = new se; var J9 = { type: "requestRender" }, Ad = class extends kt { constructor(e, n, r = { isPlayMode: !1, isExport: !1 }) { super(); this.object = e; this.domElement = n; this.options = r; this.enabled = !0; this.useKeyEvents = !0; this.enableDamping = !1; this.enableZoom = !0; this.enableRotate = !0; this.enablePan = !0; this.autoRotate = !1; this.rotationLimitsMode = 0; this.panLimitsMode = 0; this.rotationSoftLimit = 2; this.panSoftLimit = 2; this.hoverRotatePanMode = 0; this.zoomLimitsEnabled = !1; this.mouseButtons = [0, 5]; this.mouseButtonsPlay = [3, 4, 5]; this.touches = [null, ui.DOLLY_ROTATE, ui.PAN]; this.offset = new A; this.eye = new A; this.lastPosition = new A; this.lastQuaternion = new Ye; this.current = new B; this.overShoot = new B; this.overRatio = new B; this.spherical = new ef; this.sphericalDelta = new ef; this.panOffset = new A; this.panLeftV = new A; this.panUpV = new A; this.panV = new A; this.rotateStart = new B; this.rotateEnd = new B; this.rotateDelta = new B; this.panStart = new B; this.panEnd = new B; this.panDelta = new B; this.dollyStart = new B; this.dollyEnd = new B; this.dollyDelta = new B; this.rotationRangeFactor = new B; this.panRangeFactor = new B; this.state = -1; this.zoomChanged = !1; this.isPointerDown = !1; this.isThetaFlipped = !1; this.prevScale = 0; this.scale = 1; this.gesture = !1; this.timer = -1; this.timerHover = -1; this.minDistance = 0; this.maxDistance = 1 / 0; this.minZoom = 0; this.maxZoom = 1 / 0; this.minPhi = 0; this.maxPhi = Math.PI; this.minTheta = -1 / 0; this.maxTheta = 1 / 0; this.minH = 0; this.maxH = Math.PI; this.minV = -1 / 0; this.maxV = 1 / 0; this.autoRotateClockwise = !0; this.isPanOverShoot = !1; this.isRotateOverShoot = !1; this.resetHoverEffectOnPointerLeave = !1; this.hasChange = !1; this.useWindowEvents = !1; this.isTouchZoom = !0; this.autoRotateSpeed = 2; this.dampingFactor = .125; this.zoomSpeed = 2; this.rotateSpeed = 1; this.panSpeed = 1; this.hoverRotatePanStrength = .1; this.thetaIsFree = !1; this.phiIsFree = !1; this.needsUpdate = !0; this.onCameraChange = e => { this.object.removeEventListener("beginState", this.onBeginState), this.object.removeEventListener("completeState", this.onCompleteState), this.object.removeEventListener("cameraChange", this.onCameraChange), this.object = e.camera, this.object.addEventListener("beginState", this.onBeginState), this.object.addEventListener("completeState", this.onCompleteState), this.object.addEventListener("cameraChange", this.onCameraChange) }; this.update = () => { this.object.updateWorldMatrix(!0, !1), this.object.matrixWorld.decompose(z1, u0, U1), this.offset.copy(z1).sub(this.target), this.spherical.setFromVector3(this.offset), this.object.isUpVectorFlipped && (this.spherical.phi *= -1, this.spherical.theta -= Math.PI), this.autoRotate && this.state === -1 && this.rotateLeft((this.autoRotateClockwise === !0 ? 1 : -1) * this.getAutoRotationAngle()), this.rotationLimitsMode !== 0 && this.applyLimits(this.sphericalDelta, this.rotationLimitsMode, this.rotationSoftLimit, this.maxTheta, this.minTheta, this.maxPhi, this.minPhi, this.rotationRangeFactor), this.rotationLimitsMode !== 2 && (this.spherical.phi += this.sphericalDelta.phi), (this.rotationLimitsMode !== 1 || this.autoRotate === !0) && (this.spherical.theta += this.sphericalDelta.theta), this.spherical.radius *= this.scale, this.zoomLimitsEnabled && (this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius))), this.panLimitsMode !== 0 && (this.target.applyQuaternion(k1.copy(u0).invert()), this.panOffset.applyQuaternion(k1), this.applyLimits(this.panOffset, this.panLimitsMode, this.panSoftLimit, this.maxH, this.minH, this.maxV, this.minV, this.panRangeFactor), this.target.applyQuaternion(u0), this.panOffset.applyQuaternion(u0)), this.panLimitsMode === 2 && (this.panOffset.y = 0), this.panLimitsMode === 1 && (this.panOffset.x = 0), this.state === -1 && !this.gesture ? (this.panOffset.multiplyScalar(1 - this.dampingFactor), this.target.add(this.panOffset)) : (this.target.add(this.panOffset), this.panOffset.set(0, 0, 0)), this.offset.setFromSpherical(this.spherical), z1.copy(this.target).add(this.offset), this.object.position.copy(this.target).add(this.offset), this.object.parent && (IO.copy(this.object.parent.matrixWorld).invert(), this.object.position.applyMatrix4(IO)); let e = this.spherical.phi % Q9; return this.eye.copy(this.offset).normalize(), this.object.up.copy(ft.DEFAULT_UP).applyAxisAngle(this.eye, this.object.angleOffsetFromUp), e > 0 && e > Math.PI || e < 0 && e > -Math.PI ? (this.object.up.negate(), this.object.lookAt(this.target), this.object.isUpVectorFlipped = !0) : (this.object.lookAt(this.target), this.object.isUpVectorFlipped = !1), this.state === -1 || this.enableDamping === !0 ? (this.sphericalDelta.theta *= 1 - this.dampingFactor, this.sphericalDelta.phi *= 1 - this.dampingFactor) : this.sphericalDelta.set(0, 0, 0), this.scale = 1, this.zoomChanged || this.lastPosition.distanceToSquared(this.object.position) > Z9 || 8 * (1 - this.lastQuaternion.dot(this.object.quaternion)) > K9 ? (this.dispatchEvent(q9), this.object.dispatchEvent(J9), this.lastPosition.copy(this.object.position), this.lastQuaternion.copy(this.object.quaternion), this.zoomChanged = !1, !0) : (this.isPanOverShoot = !1, this.isRotateOverShoot = !1, this.object.wasMovedBySwitchCameraAction = !1, this.sphericalDelta.set(0, 0, 0), this.panOffset.set(0, 0, 0), !1) }; this.onPointerDown = e => { this.enabled !== !1 && (e.pointerType === "touch" || e.pointerType === "pen" && Wn ? this.onPointerDownTouch(e) : this.onPointerDownMouse(e), this.state !== -1 && (this.isPointerDown = !0, this.dispatchEvent(wd), this.domElement.addEventListener("pointermove", this.onPointerMove), this.domElement.addEventListener("pointerup", this.onPointerUp), e.stopPropagation(), e.pointerType === "touch" || e.pointerType === "pen" && Wn || this.domElement.setPointerCapture(e.pointerId))) }; this.onPointerLeave = e => { this.resetHoverEffectOnPointerLeave && !this.useWindowEvents ? (this.hoverRotatePanMode === 1 ? (this.sphericalDelta.theta = -this.spherical.theta, this.sphericalDelta.phi = -this.spherical.phi, U1.subVectors(this.position0, this.target0), this.spherical.setFromVector3(U1), this.sphericalDelta.theta += this.spherical.theta, this.sphericalDelta.phi += this.spherical.phi, this.sphericalDelta.theta /= 8, this.sphericalDelta.phi /= 8) : this.hoverRotatePanMode === 2 && this.panOffset.subVectors(this.target0, this.target).divideScalar(8), this.update()) : this.pointerLeaveEvent = e }; this.onPointerEnter = e => { this.resetHoverEffectOnPointerLeave || this.pointerLeaveEvent === void 0 ? c0.set(e.clientX - this.domElement.clientWidth / 2, e.clientY - this.domElement.clientHeight / 2) : c0.set(e.clientX - this.pointerLeaveEvent.clientX, e.clientY - this.pointerLeaveEvent.clientY), this.hoverRotatePanMode === 1 ? (this.rotateDelta.copy(c0).multiplyScalar(this.rotateSpeed * this.hoverRotatePanStrength).rotateAround(PO, -this.object.angleOffsetFromUp), this.rotateLeft(2 * Math.PI * this.rotateDelta.x / this.domElement.clientHeight), this.rotateUp(2 * Math.PI * this.rotateDelta.y / this.domElement.clientHeight), this.rotateStart.set(e.clientX, e.clientY)) : this.hoverRotatePanMode === 2 && (this.panDelta.copy(c0).multiplyScalar(this.panSpeed * this.hoverRotatePanStrength), this.pan(this.panDelta.x, this.panDelta.y), this.panStart.set(e.clientX, e.clientY)), this.update() }; this.onPointerMove = e => { this.enabled !== !1 && (this.checkRaycastLock() || (e.pointerType === "touch" || e.pointerType === "pen" && Wn ? this.onPointerMoveTouch(e) : this.onPointerMoveMouse(e), e.stopPropagation())) }; this.onPointerUp = e => { this.isPointerDown = !1, je.length === 0 && (this.domElement.removeEventListener("pointermove", this.onPointerMove), this.domElement.removeEventListener("pointerup", this.onPointerUp)), je.length > 1 && e.preventDefault(), this.hasChange ? this.dispatchEvent(Sd) : this.dispatchEvent(X9), this.state = -1, e && (e.stopPropagation(), e.pointerType === "touch" || e.pointerType === "pen" && Wn || this.domElement.releasePointerCapture(e.pointerId)) }; this.onPointerDownMouse = e => { let n; switch (this.useKeyEvents ? n = this.mouseButtons[e.button] : n = this.mouseButtonsPlay[e.button], n) { case 0: if (e.altKey === !0 && !e.shiftKey && !df(e)) { if (this.enableRotate === !1) return; this.handleMouseDownRotate(e), this.state = 0 } else if (this.key === " ") { if (this.enablePan === !1) return; this.handleMouseDownPan(e), this.state = 2 } break; case 4: if (this.enablePan === !1) return; this.handleMouseDownPan(e), this.state = 2; break; case 3: if (df(e) || e.shiftKey) { if (this.enablePan === !1) return; this.handleMouseDownPan(e), this.state = 2 } else { if (this.enableRotate === !1) return; this.handleMouseDownRotate(e), this.state = 0 } break; case 5: if (df(e) || e.shiftKey) { if (this.enableRotate === !1) return; this.handleMouseDownRotate(e), this.state = 0 } else { if (this.enablePan === !1) return; this.handleMouseDownPan(e), this.state = 2 } break; default: this.state = -1 } }; this.onPointerMoveMouse = e => { switch (this.state) { case 0: if (this.enableRotate === !1) return; this.handleMouseMoveRotate(e); break; case 1: if (this.enableZoom === !1) return; this.handleMouseMoveDolly(e); break; case 2: if (this.enablePan === !1) return; this.handleMouseMovePan(e); break }this.object.wasMovedByUser = !0 }; this.onPointerDownTouch = e => { switch (je.length > 1 && e.preventDefault(), this.touches[je.length - 1]) { case ui.ROTATE: if (this.enableRotate === !1) { this.state = -1; return } this.handleTouchStartRotate(), this.state = 3; break; case ui.PAN: if (this.enablePan === !1) { this.state = -1; return } this.handleTouchStartPan(), this.state = 4; break; case ui.DOLLY_PAN: if (this.enableZoom === !1 && this.enablePan === !1) return; this.handleTouchStartDollyPan(), this.state = 5; break; case ui.DOLLY_ROTATE: if (this.enableZoom === !1 && this.enableRotate === !1) return; this.handleTouchStartDollyRotate(), this.state = 6; break; default: this.state = -1 } }; this.onPointerMoveTouch = e => { switch (je.length > 1 && e.preventDefault(), this.state) { case 3: if (this.enableRotate === !1) return; this.handleTouchMoveRotate(e), this.update(); break; case 4: if (this.enablePan === !1) return; this.handleTouchMovePan(e), this.update(); break; case 5: if (this.enableZoom === !1 && this.enablePan === !1) return; this.handleTouchMoveDollyPan(e), this.update(); break; case 6: if (this.enableZoom === !1 && this.enableRotate === !1) return; this.handleTouchMoveDollyRotate(e), this.update(); break; default: this.state = -1 }this.object.wasMovedByUser = !0 }; this.dispatchEndDebounced = _l(() => this.dispatchEvent(Sd), 33); this.onMouseWheel = e => { this.enabled === !1 || this.enableZoom === !1 && this.enablePan === !1 || this.checkRaycastLock() || (!this.options.isExport && this.domElement.clientHeight === document.body.clientHeight && this.domElement.clientWidth === document.body.clientWidth && e.preventDefault(), this.dispatchEvent(wd), this.handleMouseWheel(e), this.dispatchEndDebounced(), this.object.wasMovedByUser = !0) }; this.onGesture = e => { if (e.preventDefault(), this.enabled !== !1 && !this.checkRaycastLock() && !fg) if (e.type === "gesturechange") { if (this.enableZoom === !1 || this.isTouchZoom === !1) return; this.dispatchEvent(wd), e.scale > this.prevScale ? this.dollyIn(this.getZoomScale()) : e.scale < this.prevScale && this.dollyOut(this.getZoomScale()), this.prevScale = e.scale, this.update(), this.object.wasMovedByUser = !0 } else this.dispatchEvent(Sd) }; this.onContextMenu = e => { e.preventDefault() }; this.onTouchEnd = e => { e.preventDefault() }; this.onKeyDown = e => { this.enabled !== !1 && (this.key = e.key, e.key === " " && this.dispatchEvent(wd)) }; this.onKeyUp = e => { this.enabled !== !1 && (this.key = void 0, this.state !== -1 && e.key === "Alt" && this.onPointerUp(je[0]), e.key === " " && this.dispatchEvent(Sd)) }; this.onPointerHover = e => { e.pointerType !== "mouse" || this.enabled === !1 || this.state !== -1 || this.hoverRotatePanMode === 2 && this.isPanOverShoot || this.hoverRotatePanMode === 1 && this.isRotateOverShoot || (this.isPointerDown = !0, this.hoverRotatePanMode === 2 ? this.handleMouseMovePan(e, this.hoverRotatePanStrength) : this.hoverRotatePanMode === 1 && this.handleMouseMoveRotate(e, this.hoverRotatePanStrength)) }; this.onBeginState = () => { this.enabled = !1, this.needsUpdate = !1 }; this.onCompleteState = e => { e.isfromEntity && this.options.isPlayMode || (this.enabled = !0, this.needsUpdate = !0, this.object.updateUp(), this.object.getTarget(this.target)) }; this.target = this.object.getTarget(), this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom, this.quat0 = this.object.quaternion.clone(), this.isUpVectorFlipped0 = this.object.isUpVectorFlipped, this.offset.copy(this.object.position).sub(this.target), this.spherical.setFromVector3(this.offset), this.object.isUpVectorFlipped && (this.spherical.phi *= -1, this.spherical.theta -= Math.PI), this.addEventListenersToCamera() } dispatchEvent (e) { e.type === "start" ? this.hasChange = !1 : this.hasChange = !0, super.dispatchEvent(e) } addEventListenersToCamera () { this.object.addEventListener("beginState", this.onBeginState), this.object.addEventListener("completeState", this.onCompleteState), this.object.addEventListener("cameraChange", this.onCameraChange) } removeEventListenersFromCamera () { this.object.removeEventListener("beginState", this.onBeginState), this.object.removeEventListener("completeState", this.onCompleteState), this.object.removeEventListener("cameraChange", this.onCameraChange) } updateUseWindowEvents (e) { if (window.removeEventListener("pointermove", this.onPointerHover), this.domElement.removeEventListener("pointermove", this.onPointerHover), this.useWindowEvents = e, this.hoverRotatePanMode !== 0 && (this.useWindowEvents ? window.addEventListener("pointermove", this.onPointerHover) : this.domElement.addEventListener("pointermove", this.onPointerHover)), this.domElement.removeEventListener("pointerleave", this.onPointerLeave), this.domElement.removeEventListener("pointerenter", this.onPointerEnter), window.removeEventListener("pointerleave", this.onPointerLeave), window.removeEventListener("pointerenter", this.onPointerEnter), this.hoverRotatePanMode !== 0 && !this.useWindowEvents) { let n = this.useWindowEvents ? window : this.domElement; n.addEventListener("pointerleave", this.onPointerLeave), n.addEventListener("pointerenter", this.onPointerEnter) } } fromJSON (e, n) { this.setEnableDampingSpeed(e.enableDamping), this.enablePan = e.enablePan, this.enableZoom = e.enableZoom, this.enableRotate = e.enableRotate, this.rotationLimitsMode = e.rotationLimitsMode, this.thetaIsFree = e.rotationHorizontalOffset.min === e.rotationHorizontalOffset.max && e.rotationHorizontalOffset.min === Math.PI, this.phiIsFree = e.rotationVerticalOffset.min === e.rotationVerticalOffset.max && e.rotationVerticalOffset.min === Math.PI, this.panLimitsMode = e.panLimitsMode, this.panSoftLimit = e.panSoftLimit, this.rotationSoftLimit = e.rotationSoftLimit, this.hoverRotatePanMode = e.hoverRotatePanMode, this.useWindowEvents = n === "window", this.hoverRotatePanMode !== 0 && (this.useWindowEvents ? window.addEventListener("pointermove", this.onPointerHover) : this.domElement.addEventListener("pointermove", this.onPointerHover)); let r = e.hoverRotatePanStrength / 100; this.hoverRotatePanStrength = r ** 2, this.zoomLimitsEnabled = e.zoomLimitsEnabled, this.minZoom = e.zoomLimits.min, this.maxZoom = Math.max(e.zoomLimits.min, e.zoomLimits.max), this.minDistance = 1e3 / e.zoomLimits.max, this.maxDistance = Math.max(this.minDistance, 1e3 / e.zoomLimits.min), this.autoRotate = e.autoRotate, this.autoRotateSpeed = e.autoRotateSpeed, this.autoRotateClockwise = e.autoRotateClockwise; let s = this.object.getTarget().applyQuaternion(k1.copy(this.object.quaternion).invert()); this.minV = -e.panVerticalOffset.min + s.y, this.maxV = e.panVerticalOffset.max + s.y, this.minH = -e.panHorizontalOffset.min + s.x, this.maxH = e.panHorizontalOffset.max + s.x, this.panRangeFactor.set(this.maxH - this.minH, this.maxV - this.minV).divideScalar(2), this.rotationRangeFactor.setScalar(Math.PI).divideScalar(4), this.minPhi = to(this.spherical.phi - e.rotationVerticalOffset.min), this.maxPhi = to(this.spherical.phi + e.rotationVerticalOffset.max), this.minTheta = to(to(this.spherical.theta) - e.rotationHorizontalOffset.min), this.maxTheta = to(to(this.spherical.theta) + e.rotationHorizontalOffset.max), this.isThetaFlipped = this.minTheta > this.maxTheta, e.orbitTouches === 1 && (this.touches[0] = ui.ROTATE), e.panTouches === 1 && (this.touches[0] = ui.PAN), e.orbitTouches === 2 && (this.touches[1] = ui.DOLLY_ROTATE), e.panTouches === 2 && (this.touches[1] = ui.DOLLY_PAN), e.orbitTouches === 3 && (this.touches[2] = ui.ROTATE), e.panTouches === 3 && (this.touches[2] = ui.PAN), this.isTouchZoom = e.isTouchZoom, this.resetHoverEffectOnPointerLeave = e.resetHoverEffectOnPointerLeave ?? !1 } connect () { if (this.domElement.addEventListener("contextmenu", this.onContextMenu), this.domElement.addEventListener("pointerdown", this.onPointerDown), this.domElement.addEventListener("wheel", this.onMouseWheel), window.addEventListener("keydown", this.onKeyDown, !1), window.addEventListener("keyup", this.onKeyUp, !1), this.domElement.addEventListener("gesturestart", this.onGesture), this.domElement.addEventListener("gesturechange", this.onGesture), this.domElement.addEventListener("gestureend", this.onGesture), this.domElement.addEventListener("touchend", this.onTouchEnd), this.hoverRotatePanMode !== 0 && !this.useWindowEvents) { let e = this.useWindowEvents ? window : this.domElement; e.addEventListener("pointerleave", this.onPointerLeave), e.addEventListener("pointerenter", this.onPointerEnter) } this.pointerLeaveEvent = void 0 } dispose () { this.removeEventListenersFromCamera(), this.domElement.removeEventListener("contextmenu", this.onContextMenu), this.domElement.removeEventListener("pointerdown", this.onPointerDown), this.domElement.removeEventListener("wheel", this.onMouseWheel), window.removeEventListener("keydown", this.onKeyDown, !1), window.removeEventListener("keyup", this.onKeyUp, !1), this.domElement.removeEventListener("pointermove", this.onPointerHover), window.removeEventListener("pointermove", this.onPointerHover), this.domElement.removeEventListener("gesturestart", this.onGesture), this.domElement.removeEventListener("gesturechange", this.onGesture), this.domElement.removeEventListener("gestureend", this.onGesture), this.domElement.removeEventListener("touchend", this.onTouchEnd), this.domElement.removeEventListener("pointerleave", this.onPointerLeave), this.domElement.removeEventListener("pointerenter", this.onPointerEnter), window.removeEventListener("pointerleave", this.onPointerLeave), window.removeEventListener("pointerenter", this.onPointerEnter), this.domElement.removeEventListener("pointermove", this.onPointerMove), this.domElement.removeEventListener("pointerup", this.onPointerUp) } applyLimits (e, n, r, s, o, a, l, u) { this.overShoot.set(0, 0); let c, h, d; e instanceof A ? (c = e.x, h = e.y, this.current.set(this.target.x, this.target.y), d = !0) : (c = e.theta, h = e.phi, this.current.set(to(this.spherical.theta), to(this.spherical.phi)), d = !1), r === 0 && (this.current.x += c, this.current.y += h), (n === 3 || n === 2) && (!d && this.isThetaFlipped ? this.current.x > s && this.current.x < 0 ? this.overShoot.x = s - this.current.x : this.current.x < o && this.current.x > 0 && (this.overShoot.x = o - this.current.x) : this.current.x > s ? this.overShoot.x = s - this.current.x : this.current.x < o && (this.overShoot.x = o - this.current.x)), (n === 3 || n === 1) && (this.current.y > a ? this.overShoot.y = a - this.current.y : this.current.y < l && (this.overShoot.y = l - this.current.y)), d || (this.overShoot.x = to(this.overShoot.x), this.overShoot.y = to(this.overShoot.y)), r !== 0 ? (this.overRatio.copy(this.overShoot).divide(u), this.overRatio.x = Math.min(Math.abs(this.overRatio.x), 1), this.overRatio.y = Math.min(Math.abs(this.overRatio.y), 1), r === 1 && (this.overRatio.x = DO(Math.abs(this.overRatio.x)), this.overRatio.y = DO(Math.abs(this.overRatio.y))), this.isPointerDown || r === 1 ? r === 2 && (this.overRatio.x > .9 && !this.thetaIsFree || this.overRatio.y > .9 && !this.phiIsFree) ? this.isPointerDown = !1 : (c * this.overShoot.x < 0 && !this.thetaIsFree && (c *= 1 - this.overRatio.x), h * this.overShoot.y < 0 && !this.phiIsFree && (h *= 1 - this.overRatio.y)) : r === 2 && (!d && (this.overRatio.x > .002 && !this.thetaIsFree || this.overRatio.y > .002 && !this.phiIsFree) || d && (Math.abs(this.overShoot.x) > 2 || Math.abs(this.overShoot.y) > 2) ? (this.thetaIsFree || (c = this.overShoot.x * .05), this.phiIsFree || (h = this.overShoot.y * .05), d ? this.isPanOverShoot = !0 : this.isRotateOverShoot = !0) : d ? this.isPanOverShoot = !1 : this.isRotateOverShoot = !1)) : (c += this.overShoot.x, h += this.overShoot.y), e instanceof A ? (e.x = c, e.y = h) : (this.thetaIsFree || (e.theta = c), this.phiIsFree || (e.phi = h)) } setEnableDampingSpeed (e) { this.enableDamping = e, this.rotateSpeed = e === !0 ? .2 : 1 } stopDamping () { this.sphericalDelta.theta = 0, this.sphericalDelta.phi = 0 } getAutoRotationAngle () { return 2 * Math.PI / 60 / 60 * this.autoRotateSpeed } getZoomScale () { return Math.pow(.95, this.zoomSpeed) } rotateLeft (e) { this.sphericalDelta.theta -= e } rotateUp (e) { this.sphericalDelta.phi -= e } panLeft (e, n) { this.panLeftV.setFromMatrixColumn(n, 0), this.panLeftV.multiplyScalar(-e), this.panOffset.add(this.panLeftV) } panUp (e, n) { this.panUpV.setFromMatrixColumn(n, 1), this.panUpV.multiplyScalar(e), this.panOffset.add(this.panUpV) } pan (e, n) { let r = this.domElement; if (r && this.object.isPerspectiveCamera) { let s = this.object.position; this.panV.copy(s).sub(this.target); let o = this.panV.length(); o *= Math.tan(this.object.fov / 2 * Math.PI / 180), this.panLeft(2 * e * o / r.clientHeight, this.object.matrixWorld), this.panUp(2 * n * o / r.clientHeight, this.object.matrixWorld) } else r && this.object.isOrthographicCamera && (this.panLeft(e * (this.object.right - this.object.left) / this.object.zoom / r.clientWidth, this.object.matrixWorld), this.panUp(n * (this.object.top - this.object.bottom) / this.object.zoom / r.clientHeight, this.object.matrixWorld)); this.dispatchEvent(Y9) } dollyOut (e) { this.object.isPerspectiveCamera ? this.scale /= e : this.object.isOrthographicCamera && (this.object.zoom *= e, this.zoomLimitsEnabled && (this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom))), this.object.updateProjectionMatrix(), this.zoomChanged = !0), this.dispatchEvent(CO) } dollyIn (e) { this.object.isPerspectiveCamera ? this.scale *= e : this.object.isOrthographicCamera && (this.object.zoom /= e, this.zoomLimitsEnabled && (this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom))), this.object.updateProjectionMatrix(), this.zoomChanged = !0), this.dispatchEvent(CO) } zoomOut (e = this.getZoomScale()) { this.dispatchEvent(wd), this.dollyOut(e), this.dispatchEvent(Sd) } zoomIn (e = this.getZoomScale()) { this.dispatchEvent(wd), this.dollyIn(e), this.dispatchEvent(Sd) } handleMouseDownRotate (e) { this.rotateStart.set(e.clientX, e.clientY) } handleMouseDownDolly (e) { this.dollyStart.set(e.clientX, e.clientY) } handleMouseDownPan (e) { this.panStart.set(e.clientX, e.clientY) } handleMouseMoveRotate (e, n = 1) { e.movementX !== void 0 ? this.rotateDelta.set(e.movementX, e.movementY) : (this.rotateEnd.set(e.clientX, e.clientY), this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart), this.rotateStart.copy(this.rotateEnd)), this.rotateDelta.multiplyScalar(this.rotateSpeed * n).rotateAround(PO, -this.object.angleOffsetFromUp); let r = this.domElement, s = this.useWindowEvents ? window.innerHeight : r.clientHeight, o = 2 * Math.PI * this.rotateDelta.x / s, a = 2 * Math.PI * this.rotateDelta.y / s; this.rotateLeft(o), this.rotateUp(a), this.update() } handleMouseMoveDolly (e) { this.dollyEnd.set(e.clientX, e.clientY), this.dollyDelta.subVectors(this.dollyEnd, this.dollyStart), this.dollyDelta.y > 0 ? this.dollyOut(this.getZoomScale()) : this.dollyDelta.y < 0 && this.dollyIn(this.getZoomScale()), this.dollyStart.copy(this.dollyEnd), this.update() } handleMouseMovePan (e, n = 1) { e.movementX !== void 0 ? this.panDelta.set(e.movementX, e.movementY) : (this.panEnd.set(e.clientX, e.clientY), this.panDelta.subVectors(this.panEnd, this.panStart), this.panStart.copy(this.panEnd)), this.panDelta.multiplyScalar(this.panSpeed * n), this.pan(this.panDelta.x, this.panDelta.y), this.update() } handleMouseWheel (e) { if (wT === !1 && df(e) === !1 && $9(e) === !0) { if (this.enablePan === !1) return; this.gesture ? (this.panDelta.set(-e.deltaX, -e.deltaY).multiplyScalar(this.panSpeed), this.panDelta.x = Math.min(Math.abs(this.panDelta.x), 100) * (this.panDelta.x < 0 ? -1 : 1), this.panDelta.y = Math.min(Math.abs(this.panDelta.y), 100) * (this.panDelta.y < 0 ? -1 : 1), e.altKey ? this.pan(0, this.panDelta.y) : e.shiftKey ? this.pan(this.panDelta.x, 0) : this.pan(this.panDelta.x, this.panDelta.y), this.update()) : (this.gesture = !0, this.isPointerDown = !0), window.clearTimeout(this.timer), this.timer = window.setTimeout(() => { this.gesture = !1, this.isPointerDown = !1 }, 30) } else { if (this.enableZoom === !1) return; e.deltaY === 0 ? e.deltaX < 0 ? this.dollyIn(this.getZoomScale()) : e.deltaX > 0 && this.dollyOut(this.getZoomScale()) : e.deltaY < 0 ? this.dollyIn(this.getZoomScale()) : e.deltaY > 0 && this.dollyOut(this.getZoomScale()), this.update(), this.gesture = !1, this.isPointerDown = !1 } } handleTouchStartRotate () { if (je.length === 2) { let e = .5 * (je[0].pageX + je[1].pageX), n = .5 * (je[0].pageY + je[1].pageY); this.rotateStart.set(e, n) } else this.rotateStart.set(je[0].pageX, je[0].pageY) } handleTouchStartPan () { if (je.length === 2) { let e = .5 * (je[0].pageX + je[1].pageX), n = .5 * (je[0].pageY + je[1].pageY); this.panStart.set(e, n) } else this.panStart.set(je[0].pageX, je[0].pageY) } handleTouchStartDolly () { let e = je[0].pageX - je[1].pageX, n = je[0].pageY - je[1].pageY, r = Math.sqrt(e * e + n * n); this.dollyStart.set(0, r) } handleTouchStartDollyPan () { this.enableZoom && this.isTouchZoom === !0 && this.handleTouchStartDolly(), this.enablePan && this.handleTouchStartPan() } handleTouchStartDollyRotate () { this.enableZoom && this.isTouchZoom === !0 && this.handleTouchStartDolly(), this.enableRotate && this.handleTouchStartRotate() } handleTouchMoveRotate (e) { if (je.length === 2) { let r = vg(e), s = .5 * (e.pageX + r.x), o = .5 * (e.pageY + r.y); this.rotateEnd.set(s, o) } else { if (e.pointerId !== je[0].pointerId) return; this.rotateEnd.set(e.pageX, e.pageY) } this.rotateDelta.subVectors(this.rotateEnd, this.rotateStart).multiplyScalar(this.rotateSpeed); let n = this.domElement; n && (this.rotateLeft(2 * Math.PI * this.rotateDelta.x / n.clientHeight), this.rotateUp(2 * Math.PI * this.rotateDelta.y / n.clientHeight)), this.rotateStart.copy(this.rotateEnd) } handleTouchMovePan (e) { if (je.length === 2) { let n = vg(e), r = .5 * (e.pageX + n.x), s = .5 * (e.pageY + n.y); this.panEnd.set(r, s) } else { if (e.pointerId !== je[0].pointerId) return; this.panEnd.set(e.pageX, e.pageY) } this.panDelta.subVectors(this.panEnd, this.panStart).multiplyScalar(this.panSpeed), this.pan(this.panDelta.x, this.panDelta.y), this.panStart.copy(this.panEnd) } handleTouchMoveDolly (e) { let n = vg(e), r = e.pageX - n.x, s = e.pageY - n.y, o = Math.sqrt(r * r + s * s); this.dollyEnd.set(0, o), this.dollyDelta.set(0, Math.pow(this.dollyEnd.y / this.dollyStart.y, this.zoomSpeed)), this.dollyOut(this.dollyDelta.y), this.dollyStart.copy(this.dollyEnd) } handleTouchMoveDollyPan (e) { this.enableZoom && this.isTouchZoom === !0 && this.handleTouchMoveDolly(e), this.enablePan && this.handleTouchMovePan(e) } handleTouchMoveDollyRotate (e) { this.enableZoom && this.isTouchZoom === !0 && this.handleTouchMoveDolly(e), this.enableRotate && this.handleTouchMoveRotate(e) } checkRaycastLock () { if (this.object.data.raycastLock) { if (this.options.isPlayMode) return !1; { let e = this.options?.showCameraLock; return e && e(), !0 } } else return !1 } }; function to (i) { let t = Math.PI * 2; for (; i <= -Math.PI;)i += t; for (; i > Math.PI;)i -= t; return i } function DO (i) { return 1 - Math.pow(1 - i, 4) } function $9 (i) { return i.wheelDeltaY === 0 || i.deltaY === 0 ? Ml && i.shiftKey && Math.abs(i.wheelDeltaX) >= 120 ? !1 : i.wheelDeltaX ? i.wheelDeltaX === -3 * i.deltaX : i.deltaMode === 0 : i.wheelDeltaY ? i.wheelDeltaY === -3 * i.deltaY : i.deltaMode === 0 } var Rp = class { constructor(t, e, n, r, s, o) { this.id = t; this.data = e; this.object = n; this.currentIntersectedObjects = []; this.disabled = !1; this.actions = un(e, e.actions, r, s, o, n), this.target = e.target, this.useToggle = e.toggle, this.triggeringObjects = e.triggeringObjects.map(a => r.scene.find(a)) } isValidTriggeringObject (t) { return this.target === "all" ? !0 : this.triggeringObjects.some(e => e === t || e.isAncestorOf(t.uuid) || t.isAncestorOf(e.uuid)) } disconnect () { en(this.actions) } dispatch () { this.disabled || (this.actions.Transition.forEach(t => { t.object.currentTransitionEvent !== this && (t.object.currentTransitionEvent = this, t.init()) }), this.object.dispatchEvent({ type: "beginEvent", eventName: "Trigger" }), this.useToggle ? (this.actions.Transition.forEach(t => { t.toggle() }), this.actions.SwitchCamera.forEach(t => { t.toggle() })) : (this.actions.Transition.forEach(t => { t.play() }), this.actions.SwitchCamera.forEach(t => { t.play() })), this.actions.Link.forEach(t => { t.dispatch() }), this.actions.Reset.forEach(t => { t.dispatch() }), this.actions.Create.forEach(t => { t.dispatch() }), this.actions.Destroy.forEach(t => { t.dispatch(!1) }), this.actions.Audio.forEach(t => { t.dispatchBasic() }), this.actions.Video.forEach(t => { t.dispatchBasic() }), this.actions.SceneTransition.forEach(t => { t.dispatch() })) } }; var vt; RT.then(i => vt = i); var kn = new A, ms = new Ye, Qa = new A, G1 = new Gt(0, 0, 0, "YXZ"), OO = new Gt(0, 0, 0, "XYZ"), Xo = new A, RO = new A, LO = new A(1, 1, 1), _d = new Ye, V1 = new se, e7 = new se, t7 = { type: "updateMatrix" }, Yv = { type: "beginEvent", eventName: "Collision" }, pO = { type: "beginEvent", eventName: "Trigger" }; function NO (i) { if (Ca.physicsEnabled(i.scene.objects)) return !0; let t = !1; return i.scene.objects.traverse((e, n) => { if (n.events) { for (let r of n.events) if (r.data.disabled !== !0 && r.data.type === "GameControl" && r.data.collisionEnabled) { t = !0; break } } }), t } var Op = i => i.states.some(t => t.data.position !== void 0 || t.data.rotation !== void 0 || t.data.hiddenMatrix !== void 0 || t.data.cloner !== void 0 || t.data.pathSnapping !== void 0), h0 = class {
	constructor(t) { this.eventContext = t; this.isEnabled = !1; this.gameControl = null; this.joysticks = []; this.joystickToGameControls = []; this.sharedGameControlGlobals = { entitiesWithTransformAnim: [], entityToCollisionEvents: {}, colliderToEntity: new Map, triggers: [], gamePads: [], createdObjects: [], nCreatedPerAction: {} }; this.sensorToTriggerEvent = {}; this.eventManager = void 0; this.needsCollisionDetection = !1; this.initializationCounter = -1; this.rigidBodyToMesh = new Map; this.nActiveRigidBodies = 0; this.collisionEvents = []; this.isExport = !1; this.processRigidBody = t => { if (t.bodyType() !== vt.RigidBodyType.Dynamic) return; t.isSleeping() || this.nActiveRigidBodies++; let [e, n, r] = this.rigidBodyToMesh.get(t.handle); if (kn.copy(t.translation()).multiplyScalar(this.pixelsPerMeter), ms.copy(t.rotation()), e.matrixWorld.compose(kn, ms, n), e.hasNonUniformScale && e.matrixWorld.multiply(e.shearScale), e.dispatchEvent(t7), r) { let s = e.cloner; if (s && s.objectForSample === void 0) { s.matrixWorld.copy(e.matrixWorld); for (let o of s.children) o.updateMatrixWorld(!0) } for (let o of e.children) o.updateMatrixWorld(!0) } }; this.accumulator = 0; this.handleCollisionEvents = (t, e, n) => { if (n === !1) return; let r, s; if (this.sensorToTriggerEvent[t] ? (r = this.sensorToTriggerEvent[t], s = this.sharedGameControlGlobals.colliderToEntity.get(e)) : this.sensorToTriggerEvent[e] && (r = this.sensorToTriggerEvent[e], s = this.sharedGameControlGlobals.colliderToEntity.get(t)), r && s && r.isValidTriggeringObject(s)) { r.dispatch(); return } for (let o = this.sharedGameControlGlobals.createdObjects.length - 1; o >= 0; o--) { let a = this.sharedGameControlGlobals.createdObjects[o]; if (a.userData.hasCollisionDestroy && (a.rigidBody?.collider(0).handle === t || a.rigidBody?.collider(0).handle === e)) { this.sharedGameControlGlobals.createdObjects.splice(o, 1), a.removeFromParent(), requestAnimationFrame(() => this.sharedGameControlGlobals.rapierWorld?.removeRigidBody(a.rigidBody)); break } } if (this.gameControl?.object === this.sharedGameControlGlobals.colliderToEntity.get(t)) { let o = this.sharedGameControlGlobals.colliderToEntity.get(e), a = this.sharedGameControlGlobals.entityToCollisionEvents[o.uuid]; if (a === void 0) return; for (let l of a) l.data.target === "character" && this.dispatchCollisionEvent(l, o, e) } else if (this.gameControl?.object === this.sharedGameControlGlobals.colliderToEntity.get(e)) { let o = this.sharedGameControlGlobals.colliderToEntity.get(t), a = this.sharedGameControlGlobals.entityToCollisionEvents[o.uuid]; if (a === void 0) return; for (let l of a) l.data.target === "character" && this.dispatchCollisionEvent(l, o, t) } else { let o = this.sharedGameControlGlobals.colliderToEntity.get(t), a = this.sharedGameControlGlobals.entityToCollisionEvents[o.uuid]; if (a !== void 0) for (let c of a) c.data.target === "scene" && this.dispatchCollisionEvent(c, o, t); let l = this.sharedGameControlGlobals.colliderToEntity.get(e), u = this.sharedGameControlGlobals.entityToCollisionEvents[l?.uuid]; if (u !== void 0) for (let c of u) c.data.target === "scene" && this.dispatchCollisionEvent(c, l, e) } }; this.isExport = t.isExport, this.sharedAssets = t.sharedAssets, this.renderer = t.renderer, this.requestRender = t.requestRender, this.domElement = this.renderer.domElement, this.pixelsPerMeter = y1, this.gravity = this.page.data.globalPhysics.gravity } get page () { return this.eventContext.page } attachVRControllers (t) { t.forEach(e => { e.addEventListener("connected", n => { "gamepad" in n.data && "axes" in n.data.gamepad && this.sharedGameControlGlobals.gamePads.push(n.data.gamepad) }) }) } markIsDestroyTarget () { this.page.traverseVisibleEntity(t => { let e = t.dataPatched; for (let n of e.events) { if (n.data.disabled === !0) continue; let r = n.data.actions?.find(s => s.data.type === "Destroy")?.data; if (r) for (let s of r.objects) { let o = this.page.scene.find(s); o && (o.userData.hasDestroy = !0) } } }) } markIsDragObject () { this.page.traverseVisibleEntity(t => { let e = t.dataPatched; for (let n of e.events) if (!(n.data.disabled === !0 || n.data.type !== "DragDrop")) for (let r of n.data.objects) { let s = this.page.scene.find(r); s && (s.userData.hasDrag = !0) } }) } initBVH () { let t = []; if (this.page.traverseChildren(e => { let n; if (e instanceof dr) return; e instanceof sn ? n = e.object : n = e; let r = n.dataPatched; if (r.physics?.enabled === "visibility" ? !r.visible : !r.physics?.enabled) return !0; let s = e.geometry, o = n.userData.hasDestroy === !0, a = n.userData.hasDrag === !0; if (Op(r) || o || a || n.dataPatched.events.some(l => l.data.disabled !== !0 && l.data.type === "GameControl")) return e.updateMatrixWorldSVD(), this.addBoundsTree(e), !0; s && t.push(ps(s, e.matrixWorld)) }), t.length > 0) { let e = Ji(t, !1); this.sharedGameControlGlobals.staticMeshBVH = new Os(e) } } addRigidBody (t, e, n) { let r = [], s = "geometry" in t ? t.geometry : void 0, o = e.dataPatched; if (s?.getAttribute("position") !== void 0 && r.push(ps(s, t.shearScale)), o.physics.fusedBody) { let a = this.gatherChildrenGeom(t, r); t.traverseObject(a), t.children.forEach(u => u.updateMatrixWorld(!0)); let l = t.cloner; l && l.objectForSample === void 0 && o.physics.rigidBody === "dynamic" && (l.traverseObject(a), l.children.forEach(u => u.updateMatrixWorld(!0))) } if (r.length > 0) { let a, l = !n.fromCreate && o.physics.rigidBody === "dynamic" || n.fromCreate && n.dynamic; l ? (a = vt.RigidBodyDesc.dynamic(), a.setLinearDamping(o.physics.damping).setAngularDamping(o.physics.damping).setAdditionalMass(1e-9).setGravityScale(o.physics.gravityScale).enabledRotations(...o.physics.enabledRotation).enabledTranslations(...o.physics.enabledTranslation)) : (n.hasTransformAnim || n.hasFollow || n.hasDrag) && !n.fromCreate ? (a = vt.RigidBodyDesc.kinematicPositionBased(), this.sharedGameControlGlobals.entitiesWithTransformAnim.push(t)) : a = vt.RigidBodyDesc.fixed(); let u = Ji(r); (t.hasNonUniformScale ? t.matrixWorldRigid : t.matrixWorld).decompose(kn, ms, Qa), t.position0 = kn.clone().divideScalar(this.pixelsPerMeter), t.rotation0 = ms.clone(), kn.divideScalar(this.pixelsPerMeter), a.setTranslation(kn.x, kn.y, kn.z).setRotation(ms), s ? u?.scale(1 / this.pixelsPerMeter, 1 / this.pixelsPerMeter, 1 / this.pixelsPerMeter) : u?.scale(Qa.x / this.pixelsPerMeter, Qa.y / this.pixelsPerMeter, Qa.z / this.pixelsPerMeter); let c = this.sharedGameControlGlobals.rapierWorld.createRigidBody(a); l && this.rigidBodyToMesh.set(c.handle, [t, Qa.clone(), o.physics.fusedBody]); let h = !(o.geometry === void 0 || o.geometry.type === "SubdivGeometry" || o.geometry.type === "NonParametricGeometry" || o.geometry.type === "BooleanGeometry" || o.geometry.type === "VectorGeometry" || o.geometry.type === "StarGeometry" || o.geometry.type === "RectangleGeometry" || o.geometry.type === "EllipseGeometry" || o.geometry.type === "TriangleGeometry" || o.geometry.type === "TorusGeometry" || o.geometry.type === "HelixGeometry"); try { this.addCollider(c, o.physics, u, e, h) } catch { try { this.addCollider(c, o.physics, u, e, !1) } catch (f) { console.error(f) } } t.rigidBody = c } } addBoundsTree (t) { let e = []; if (t.geometry?.getAttribute("position") !== void 0 && e.push(ps(t.geometry, t.shearScale)), t.traverseObject(this.gatherChildrenGeom(t, e)), t.children.forEach(n => n.updateMatrixWorld(!0)), e.length > 0) { let n = Ji(e, !1); t.bvhGeometry = n, t.bvhGeometry.boundsTree = new Os(n), this.sharedGameControlGlobals.entitiesWithTransformAnim.push(t) } } addCollider (t, e, n, r, s = !0) { if (n?.getAttribute("position").count === 0 || n?.getIndex()?.count === 0) return; let o; n && (e.colliderType === "trimesh" ? o = vt.ColliderDesc.trimesh(n.getAttribute("position").array, n.getIndex().array) : o = vt.ColliderDesc.convexMesh(n.getAttribute("position").array, s ? n.getIndex().array : void 0)), o.setFrictionCombineRule(vt.CoefficientCombineRule.Average).setRestitutionCombineRule(vt.CoefficientCombineRule.Average).setDensity(e.density).setFriction(e.friction).setRestitution(e.restitution); let a = this.sharedGameControlGlobals.rapierWorld.createCollider(o, t); this.sharedGameControlGlobals.colliderToEntity.set(a.handle, r), this.sharedGameControlGlobals.entityToCollisionEvents[r.uuid]?.some(l => l.target === "scene") && a.setActiveEvents(vt.ActiveEvents.COLLISION_EVENTS) } gatherChildrenGeom (t, e) { return (n, r) => { if (r === 0) return; let s; if (n instanceof dr) if (n.objectForSample) { if (n.objectForSample.dataPatched.physics.fusedBody) return; s = n.object } else return n.object.dataPatched.physics.fusedBody === !0 && n.object.dataPatched.physics.rigidBody === "dynamic" ? !0 : void 0; else if (n instanceof sn) s = n.object; else if (s = n, s.dataPatched.cloner?.hideBase) return !0; let o = s.dataPatched; if (o.physics.enabled === "visibility" ? !o.visible : !o.physics.enabled) return !0; r === 1 ? t.hasNonUniformScale ? n.matrixWorld.multiplyMatrices(t.shearScale, n.hiddenMatrix) : n.matrixWorld.copy(n.hiddenMatrix) : n.matrixWorld.multiplyMatrices(n.parent.matrixWorld, n.hiddenMatrix), n.matrixWorld.multiply(n.matrix); let a = n.geometry; a?.getAttribute("position") !== void 0 && e.push(ps(a, n.matrixWorld)) } } activate (t) {
		if (this.isEnabled) return; this.isEnabled = !0, this.eventManager = t, this.usePhysics = this.page.data.globalPhysics.usePhysics; let e = this.page.playCamera, n = !1, r, s = 5, o = 8, a = 9, l = "drag", u = this.page.data.publish.gameControlObject, c = u !== null ? this.page.find(u) : null, h = null; if (c) for (let p of c.data.events) { if (p.data.disabled || p.data.type !== "GameControl") break; let m = c; for (; this.usePhysics && (m = m.parent)?.parent !== null && !m.data.physics?.fusedBody;); p.data.collisionEnabled && (this.needsCollisionDetection = !0), h === null && (h = p.data) } if (c && h) { n = n || h.camera === e.uuid || c.uuid === e.uuid; let p = new _p(c, this.renderer.domElement, h, this.eventContext.page.data.globalPhysics, this, c.uuid !== e.uuid && h.camera === e.uuid, e, this.page, this.sharedAssets); this.gameControl = p, r = h.keyAssignments, s = h.joystickPosLoc, o = h.joystickRotLoc, a = h.jumpTouchButtonLoc, l = h.rotByTouch, Wn && h.touchControl && (this.joystickToGameControls[s] = "pos", h.moveMode === "walk" && (this.joystickToGameControls[a] = "jmp"), l === "joystick" && (this.joystickToGameControls[o] = "rot")) } if (this.gameControl && this.gameControl.data.navmesh.enabled) { let p = this.gameControl.data; if (!this.navigationMeshWrapper) { this.navigationMeshWrapper = new l0(this.usePhysics, this.isExport); let m; p.collider.type === "sphere" ? m = p.collider.radius * 2 : m = p.collider.height, m = Math.floor(m / p.navmesh.ch - 1), this.navigationMeshWrapper.init({ ...p.navmesh, walkableHeight: m }, this.gameControl, this.eventContext) } } if (n === !1) { let { enableRotate: p, enablePan: m, enableZoom: g, autoRotate: y, hoverRotatePanMode: v } = this.eventManager.publish.orbitControls; (p || m || g || y || v !== 0) && (this.orbitControls = new Ad(e, this.renderer.domElement, { isExport: this.isExport, isPlayMode: !0 }), this.orbitControls.addEventListener("change", this.requestRender), this.orbitControls.addEventListener("end", this.requestRender), this.orbitControls.addEventListener("start", this.requestRender), this.orbitControls.fromJSON(this.eventManager.publish.orbitControls, this.eventManager.publish.mouseEventTarget), this.orbitControls.useKeyEvents = !1, this.orbitControls.addEventListenersToCamera(), this.orbitControls.connect(), this.orbitControls.update()) } let d = this.renderer.domElement.width / this.renderer.getPixelRatio(), f = this.renderer.domElement.height / this.renderer.getPixelRatio(); this.joystickToGameControls.forEach((p, m) => {
			let g = document.body.appendChild(document.createElement("div")), [y, v, x] = this.eventManager.eventContext.publish.joystickSizeAndXYOffset[m], b = (d - 5 * y) / 4 + y, S = {}, _ = p === "jmp", E = _ ? 0 : y; m < 10 ? (m < 5 ? S.top = E / 2 : S.bottom = E / 2, S.left = E / 2 + m % 5 * b) : m === 10 ? (S.left = E / 2, S.top = f / 2) : (S.right = E / 2, S.top = f / 2), S.top ? S.top -= v[1] : S.bottom += v[1], S.left ? S.left += v[0] : S.right -= v[0]; for (let T in S) S[T] += "px"; if (_) {
				let T = g.appendChild(document.createElement("div")); Object.assign(T.style, S, { position: "absolute", width: y + "px", height: y + "px", backgroundColor: `rgba(255,255,255,${x === "show" ? .4 : 0})`, zIndex: "9999", borderRadius: y + "px", border: x === "show" ? "solid 2px rgba(0, 0, 0, .1)" : "none", display: "flex", alignItems: "center", justifyContent: "center", touchAction: "none" }); let I = y / 16 * 16 * .4; x === "show" && (T.innerHTML = `
						<svg width="${I}" height="${y * .4}" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
							<path d="M2 10L8 4L14 10" stroke="black" stroke-opacity="40%" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
						</svg>
					`), T.addEventListener("pointerdown", () => { this.gameControl.movementState.jump = 1, this.requestRender() }), T.addEventListener("touchend", C => C.preventDefault()), this.joysticks[m] = [void 0, g]; return
			} let w = { zone: g, mode: "static", position: S, size: y }; x === "hide" && (w.restOpacity = 0); let M = yD.create(w); M.on("move", (T, I) => { let C = this.gameControl; p === "pos" ? I.force < .2 ? C.moveForce = 0 : (C.movementState.movePosZ = Math.sin(-I.angle.radian), C.movementState.movePosX = Math.cos(-I.angle.radian), I.force > 1.2 ? C.movementState.run = 1 : C.movementState.run = 0, I.force < .3 ? C.moveForce = (I.force - .2) / .1 : C.moveForce = 1) : p === "rot" && (I.force < .2 ? C.rotForce = 0 : (C.movementState.rotPosX = I.vector.y, C.movementState.rotPosY = -I.vector.x, I.force < .3 ? C.rotForce = (I.force - .2) / .1 : C.rotForce = 1)), this.requestRender() }), M.on("end", (T, I) => { let C = this.gameControl; p === "pos" ? (C.movementState.movePosZ = 0, C.movementState.movePosX = 0, C.moveForce = 1) : p === "rot" && (C.movementState.rotPosX = 0, C.movementState.rotPosY = 0, C.rotForce = 1) }), this.joysticks[m] = [M, g]
		}), this.markIsDestroyTarget(), this.markIsDragObject(), this.rebuildBVH(), this.initializationCounter++, window.setTimeout(() => { this.collisionEvents.forEach(p => p.disabled = !1) }, 80)
	} initPhysics () { this.sharedGameControlGlobals.rapierWorld?.free(), this.sharedGameControlGlobals.rapierWorld = new vt.World(new vt.Vector3(0, this.gravity, 0)), this.events = new vt.EventQueue(!0); let t = [], e = []; if (this.page.traverseChildren(a => { let l; if (a instanceof dr) if (a.objectForSample) { if (a.objectForSample.dataPatched.physics.fusedBody) return; l = a.object } else return a.object.dataPatched.physics.fusedBody === !0 && a.object.dataPatched.physics.rigidBody === "dynamic" ? !0 : void 0; else if (a instanceof sn) l = a.object; else if (l = a, l.dataPatched.cloner?.disabled === !1 && l.dataPatched.cloner?.hideBase && l.dataPatched.physics?.fusedBody !== !0) return !0; let u = l.dataPatched, c; for (let y of u.events) y.data.disabled !== !0 && y.data.type === "GameControl" && (c = y.data); if (!u.physics || (u.physics.enabled === "visibility" ? !u.visible : !u.physics.enabled)) return !0; a.updateMatrixWorldSVD(); let h = Op(u), d = !1, f = l.userData.hasDestroy, p = l.userData.hasDrag, m = !1; for (let y of u.events) if (y.data.disabled !== !0) { if (y.data.type === "Collision") { d = !0; let v = new a0(y.id, y.data, l, this.page, this.sharedAssets, this.eventManager); v.disabled = !0, this.collisionEvents.push(v), this.sharedGameControlGlobals.entityToCollisionEvents[l.uuid] && this.sharedGameControlGlobals.entityToCollisionEvents[l.uuid].every(x => x.id !== y.id) ? this.sharedGameControlGlobals.entityToCollisionEvents[l.uuid].push(v) : this.sharedGameControlGlobals.entityToCollisionEvents[l.uuid] = [v] } else if (y.data.type === "Follow") { m = !0; let v = y.data.target; a.traverseVisible(x => { x.userData.isFollowingObj = v }) } } u.physics.rigidBody === "dynamic" && u.physics.fusedBody === !1 && (a.matrixWorldFusedFalse = a.matrixWorld.clone()); let g = a.geometry; if (c !== void 0) { let y = vt.RigidBodyDesc.kinematicPositionBased(); (a.hasNonUniformScale ? a.matrixWorldRigid : a.matrixWorld).decompose(kn, ms, Qa), a.position0 = kn.clone().divideScalar(this.pixelsPerMeter), a.rotation0 = ms.clone(), kn.divideScalar(this.pixelsPerMeter), y.setTranslation(kn.x, kn.y, kn.z).setRotation(ms); let v = this.sharedGameControlGlobals.rapierWorld.createRigidBody(y); a.rigidBody = v; let x; c.collider.type === "sphere" ? x = vt.ColliderDesc.ball(c.collider.radius / this.pixelsPerMeter) : c.collider.type === "capsule" ? x = vt.ColliderDesc.capsule((c.collider.height / 2 - c.collider.radius) / this.pixelsPerMeter, c.collider.radius / this.pixelsPerMeter) : x = vt.ColliderDesc.cuboid(c.collider.width / this.pixelsPerMeter / 2, c.collider.height / this.pixelsPerMeter / 2, c.collider.depth / this.pixelsPerMeter / 2), x.setFrictionCombineRule(vt.CoefficientCombineRule.Average).setRestitutionCombineRule(vt.CoefficientCombineRule.Average).setDensity(u.physics.density).setFriction(u.physics.friction).setRestitution(u.physics.restitution); let b = this.sharedGameControlGlobals.rapierWorld.createCollider(x, v); this.sharedGameControlGlobals.colliderToEntity.set(b.handle, l), kn.fromArray(c.collider.position).multiply(Qa.setFromMatrixScale(l.matrixWorld)).divideScalar(this.pixelsPerMeter), b.setTranslationWrtParent(kn); let S = new Ye().setFromEuler(new Gt().setFromVector3(new A().fromArray(c.collider.rotation))); b.setRotationWrtParent(S), b.setActiveEvents(vt.ActiveEvents.COLLISION_EVENTS), this.generateSensorColliderDescs(l, !0) } else u.physics.rigidBody === "dynamic" || h || m || f || p || d ? (this.addRigidBody(a, l, { hasFollow: m, hasTransformAnim: h, hasDrag: p }), this.generateSensorColliderDescs(l, u.physics.fusedBody)) : (g && t.push(ps(g, a.matrixWorld)), u.physics.fusedBody && a.traverseObject((y, v) => { if (v === 0) return; let x; if (y instanceof dr) if (y.objectForSample) { if (y.objectForSample.dataPatched.physics.fusedBody) return; x = y.object } else return y.object.dataPatched.physics.fusedBody === !0 && y.object.dataPatched.physics.rigidBody === "dynamic" ? !0 : void 0; else if (y instanceof sn) x = y.object; else if (x = y, x.dataPatched.cloner?.hideBase) return !0; let b = x.dataPatched; if (b.physics.enabled === "visibility" ? !b.visible : !b.physics.enabled) return !0; let S = y.geometry; S?.getAttribute("position") !== void 0 && t.push(ps(S, y.matrixWorld)) }), this.generateSensorColliderDescs(l, u.physics.fusedBody, e)); if (u.physics?.fusedBody === !0 || c) return !0 }), t.length === 0) return; let n = Ji(t); n.scale(1 / this.pixelsPerMeter, 1 / this.pixelsPerMeter, 1 / this.pixelsPerMeter); let r = vt.RigidBodyDesc.fixed(), s = this.sharedGameControlGlobals.rapierWorld.createRigidBody(r), o = vt.ColliderDesc.trimesh(n.getAttribute("position").array, n.getIndex().array).setFrictionCombineRule(vt.CoefficientCombineRule.Multiply).setRestitutionCombineRule(vt.CoefficientCombineRule.Multiply).setFriction(1).setRestitution(1); this.sharedGameControlGlobals.rapierWorld.createCollider(o, s); for (let [a, l] of e) { let u = this.sharedGameControlGlobals.rapierWorld.createCollider(a, s); this.sensorToTriggerEvent[u.handle] = l } } updatePositions () { return this.nActiveRigidBodies = 0, this.sharedGameControlGlobals.rapierWorld.forEachRigidBody(this.processRigidBody), this.nActiveRigidBodies > 0 } rebuildBVH () { this.usePhysics ? (this.gameControl === null || this.needsCollisionDetection) && this.initPhysics() : (this.page.traverseEntity(t => { for (let e of t.dataPatched.events) if (e.data.type === "Trigger" && e.data.disabled !== !0) { let n = new Rp(e.id, e.data, t, this.page, this.sharedAssets, this.eventManager), r = new se().compose(Xo.fromArray(e.data.position), _d.setFromEuler(OO.fromArray(e.data.rotation)), LO); if (e.data.triggerZone === "box") { let s = new _t; s.min.fromArray(e.data.size).multiplyScalar(-.5), s.max.fromArray(e.data.size).multiplyScalar(.5), this.sharedGameControlGlobals.triggers.push([s, r, t, n]) } else this.sharedGameControlGlobals.triggers.push([e.data.radius, r, t, n]) } }), this.needsCollisionDetection && this.initBVH()) } disconnectEvents () { this.collisionEvents.forEach(t => t.disconnect()), this.sharedGameControlGlobals.triggers.forEach(t => t[3].disconnect()), this.sharedGameControlGlobals.triggers.length = 0 } deactivate () { if (this.isEnabled) { this.isEnabled = !1, this.page.traverse(t => { let e = t; e.matrixWorldFusedFalse && (e.matrixWorldFusedFalse = void 0), e.rigidBody && (e.rigidBody = void 0), e.position0 && (e.position0 = void 0), e.rotation0 && (e.rotation0 = void 0) }), this.sharedGameControlGlobals.rapierWorld?.free(), this.sharedGameControlGlobals.rapierWorld = void 0, this.sharedGameControlGlobals.staticMeshBVH = void 0, this.accumulator = 0, this.sharedGameControlGlobals.entitiesWithTransformAnim = [], this.disconnectEvents(), this.gameControl?.reset(), this.gameControl?.dispose(), this.gameControl = null, this.initializationCounter = -1, this.joysticks.forEach(([t, e]) => { t?.destroy(), e.remove() }), this.joystickToGameControls = [], this.joysticks = [], this.orbitControls && (this.orbitControls.dispose(), this.orbitControls = void 0), this.navigationMeshWrapper?.dispose(), this.navigationMeshWrapper = void 0; for (let t of Object.values(this.sharedGameControlGlobals.entityToCollisionEvents)) t.forEach(e => e.disconnect()); this.sharedGameControlGlobals.entityToCollisionEvents = {}, this.page.updateMatrixWorld(!0) } } update (t, e, n) { if (!this.isEnabled) return !0; let r = !0; if (this.orbitControls !== void 0 && this.orbitControls.needsUpdate && (r = !this.orbitControls.update()), this.initializationCounter >= 0 && this.initializationCounter < 2 ? (this.initializationCounter++, r = !1) : this.initializationCounter === 2 && this.gameControl && (r = !this.gameControl.update(t, e, n) && r), this.usePhysics) { let s = .016666666666666666; if (t === 0) r = this.stepPhysics() && r; else { let o = t / 1e3; o < s && o > s * .55 && (o = s), this.accumulator += o; let a = performance.now(), l = 0, u = 6; for (; this.accumulator >= s && l < u && (r = this.stepPhysics() && r, this.accumulator -= s, l++, !(performance.now() - a > s * 1e3));); this.accumulator = this.accumulator % s } } return r } stepPhysics () { for (let e of this.sharedGameControlGlobals.entitiesWithTransformAnim) { (e.hasNonUniformScale ? e.matrixWorldRigid : e.matrixWorld).decompose(kn, ms, Qa), G1.setFromQuaternion(ms); let n = e; n.prevR === void 0 ? (n.prevR = G1.clone(), n.prevT = kn.clone()) : (n.prevR.copy(G1), n.prevT.copy(kn)), e.rigidBody.setNextKinematicTranslation(kn.divideScalar(this.pixelsPerMeter)), e.rigidBody.setNextKinematicRotation(ms) } return this.sharedGameControlGlobals.rapierWorld.step(this.events), this.events?.drainCollisionEvents(this.handleCollisionEvents), !this.updatePositions() } dispatchCollisionEvent (t, e, n) { let r = (this.sharedGameControlGlobals.rapierWorld?.getCollider(n))._parent, s; if (e.cloner) { for (let o of e.cloner.children) if (o.rigidBody === r) { s = o; break } } t.dispatch(s), e.dispatchEvent(Yv) } updateUseWindowEvents (t) { this.orbitControls?.updateUseWindowEvents(t) } generateSensorColliderDescs (t, e, n) { let r = e7.copy(t.matrixWorld).invert(); t.traverseEntity((s, o) => { if (e === !1 && o === 1) return !0; for (let a of s.dataPatched.events) if (a.data.type === "Trigger" && a.data.disabled !== !0) { let l = new Rp(a.id, a.data, s, this.page, this.sharedAssets, this.eventManager), u; if (a.data.triggerZone === "box" ? u = vt.ColliderDesc.cuboid(...a.data.size.map(c => c / (2 * this.pixelsPerMeter))) : u = vt.ColliderDesc.ball(a.data.radius / this.pixelsPerMeter), u.setDensity(0).setSensor(!0).setActiveEvents(vt.ActiveEvents.COLLISION_EVENTS), Xo.fromArray(a.data.position), _d.setFromEuler(OO.fromArray(a.data.rotation)), V1.compose(Xo, _d, LO).premultiply(s.matrixWorld), n ? (V1.decompose(Xo, _d, RO), u.setActiveCollisionTypes(vt.ActiveCollisionTypes.KINEMATIC_FIXED | vt.ActiveCollisionTypes.DYNAMIC_FIXED)) : (V1.premultiply(r).decompose(Xo, _d, RO), t.rigidBody.bodyType() === vt.RigidBodyType.Dynamic || (t.rigidBody.bodyType() === vt.RigidBodyType.Fixed ? u.setActiveCollisionTypes(vt.ActiveCollisionTypes.KINEMATIC_FIXED | vt.ActiveCollisionTypes.DYNAMIC_FIXED) : u.setActiveCollisionTypes(vt.ActiveCollisionTypes.KINEMATIC_KINEMATIC | vt.ActiveCollisionTypes.DYNAMIC_KINEMATIC))), Xo.divideScalar(this.pixelsPerMeter), u.setTranslation(Xo.x, Xo.y, Xo.z), u.setRotation(_d), n) n.push([u, l]); else { let c = this.sharedGameControlGlobals.rapierWorld.createCollider(u, t.rigidBody); this.sensorToTriggerEvent[c.handle] = l } } }) }
}; function BO (i) { let t = this._clip.duration, e = this._clip.start ?? 0, n = this.loop, r = this.time + i, s = this._loopCount, o = n === tf; if (i === 0) return s === -1 ? r : o && (s & 1) === 1 ? t - (r - e) : r; if (n === jx) { s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1)); e: { if (r >= t) r = t; else if (r < 0) r = 0; else { this.time = r; break e } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: i < 0 ? -1 : 1 }) } } else { if (s === -1 && (i >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), r >= t || r < e) { let a = Math.floor((r - e) / (t - e)); r -= (t - e) * a, s += Math.abs(a); let l = this.repetitions - s; if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, o || (r = i > 0 ? t : e, this.repetitions === 1 && (r = t)), this.time = r, this._mixer.dispatchEvent({ type: "finished", action: this, direction: i > 0 ? 1 : -1 }); else { if (l === 1) { let u = i < 0; this._setEndings(u, !u, o) } else this._setEndings(!1, !1, o); this._loopCount = s, this.time = r, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: a }) } } else this.time = r; if (o && (s & 1) === 1) return t - (r - e) } return r } var FO = !1, d0 = class { constructor(t, e, n, r) { this.scene = t; this.requestRender = e; this.updateDisplayProgress = n; this.animationInspectorState = r; this.clipIdToAction = {}; this.activeClip = null; this.needsUpdate = !1; this.addClip = t => { t.data.type === "Empty" && t.data.animations && t.data.animations.forEach((e, n) => { let r = e[0] + "/"; if (Array.isArray(t.identity) ? r += t.identity[0] : r += t.uuid, this.clipIdToAction[r]) return; let s = Vc.parse(JSON.parse(e[2])); t.animations[n] = s; let o = this.mixer.clipAction(s, t); FO === !1 && (Object.getPrototypeOf(o)._updateTime = BO, FO = !0), o.clampWhenFinished = !0, this.clipIdToAction[r] = o }) }; this.mixer = new Dm(t), this.scene.traverseEntity(this.addClip) } deleteClip (t, e) { let n = this.scene.find(e); if (!n) return; let r = n.animations.find(o => o.uuid === t); if (!r) return; let s = this.clipIdToAction[t]; !s || (s.stop(), this.mixer.uncacheClip(r), delete this.clipIdToAction[t], n.animations = n.animations.filter(o => o.uuid !== t)) } get isPlaying () { return Object.values(this.clipIdToAction).some(t => t.isRunning()) } playFromInspector (t) { this.mixer.stopAllAction(); let e = this.clipIdToAction[t]; !e || (e.play(), this.activeClip = e.getClip(), this.requestRender()) } onExitPlayMode () { Object.values(this.clipIdToAction).forEach(t => { t.repetitions = 1 / 0, t.loop = Wx }), this.mixer.stopAllAction(), this.requestRender() } play (t) { let e = t.clipId + "/" + t.object, n = this.clipIdToAction[e]; if (n) return t && (t.repeat >= 0 && (n.repetitions = t.repeat + 1), t.direction === "pingpong" && t.repeat !== 0 && (n.loop = tf)), n.play(), n.paused = !1, this.requestRender(), n } resumeFromInspector (t) { let e = this.clipIdToAction[t]; !e || (e.play(), e.paused = !1, this.requestRender()) } pauseFromInspector (t) { let e = this.clipIdToAction[t]; !e || (e.paused = !0) } stop () { this.mixer.stopAllAction(), this.requestRender() } update (t) { if (this.needsUpdate) this.needsUpdate = !1; else if (this.isPlaying === !1 || this.animationInspectorState?.isScrubbing) return; this.mixer.update(t / 1e3), this.activeClip && this.updateDisplayProgress(Math.round(this.mixer.time / this.activeClip.duration * this.maxFrames % this.maxFrames)), this.requestRender() } get maxFrames () { return this.activeClip?.tracks[0]?.times.length ?? 0 } setProgressFromInspector (t, e) { if (!this.clipIdToAction[e]) return; this.activeClip !== this.clipIdToAction[e].getClip() && this.playFromInspector(e); let n = this.clipIdToAction[e].paused; this.clipIdToAction[e].paused = !1, this.mixer.setTime(Math.min(this.maxFrames ? t / this.maxFrames : 0, .9999) * this.activeClip.duration), this.requestRender(), n && (this.clipIdToAction[e].paused = !0) } }; var H1 = new WeakMap, f0 = class extends Hc {
	constructor(t) { super(t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = { position: "POSITION", normal: "NORMAL", color: "COLOR", uv: "TEX_COORD" }, this.defaultAttributeTypes = { position: "Float32Array", normal: "Float32Array", color: "Float32Array", uv: "Float32Array" } } setDecoderPath (t) { return this.decoderPath = t, this } setDecoderConfig (t) { return this.decoderConfig = t, this } setWorkerLimit (t) { return this.workerLimit = t, this } load (t, e, n, r) { let s = new jc(this.manager); s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(t, o => { this.decodeDracoFile(o, e).catch(r) }, n, r) } decodeDracoFile (t, e, n, r) { let s = { attributeIDs: n || this.defaultAttributeIDs, attributeTypes: r || this.defaultAttributeTypes, useUniqueIDs: !!n }; return this.decodeGeometry(t, s).then(e) } decodeGeometry (t, e) { let n = JSON.stringify(e); if (H1.has(t)) { let l = H1.get(t); if (l.key === n) return l.promise; if (t.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.") } let r, s = this.workerNextTaskID++, o = t.byteLength, a = this._getWorker(s, o).then(l => (r = l, new Promise((u, c) => { r._callbacks[s] = { resolve: u, reject: c }, r.postMessage({ type: "decode", id: s, taskConfig: e, buffer: t }, [t]) }))).then(l => this._createGeometry(l.geometry)); return a.catch(() => !0).then(() => { r && s && this._releaseTask(r, s) }), H1.set(t, { key: n, promise: a }), a } _createGeometry (t) { let e = new Ce; t.index && e.setIndex(new ze(t.index.array, 1)); for (let n = 0; n < t.attributes.length; n++) { let r = t.attributes[n], s = r.name, o = r.array, a = r.itemSize; e.setAttribute(s, new ze(o, a)) } return e } _loadLibrary (t, e) { let n = new jc(this.manager); return n.setPath(this.decoderPath), n.setResponseType(e), n.setWithCredentials(this.withCredentials), new Promise((r, s) => { n.load(t, r, void 0, s) }) } preload () { return this._initDecoder(), this } _initDecoder () {
		if (this.decoderPending) return this.decoderPending; let t = typeof WebAssembly != "object" || this.decoderConfig.type === "js", e = []; return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e).then(n => {
			let r = n[0]; t || (this.decoderConfig.wasmBinary = n[1]); let s = n7.toString(), o = ["/* draco decoder */", r, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`); this.workerSourceURL = URL.createObjectURL(new Blob([o]))
		}), this.decoderPending
	} _getWorker (t, e) { return this._initDecoder().then(() => { if (this.workerPool.length < this.workerLimit) { let r = new Worker(this.workerSourceURL); r._callbacks = {}, r._taskCosts = {}, r._taskLoad = 0, r.postMessage({ type: "init", decoderConfig: this.decoderConfig }), r.onmessage = function (s) { let o = s.data; switch (o.type) { case "decode": r._callbacks[o.id].resolve(o); break; case "error": r._callbacks[o.id].reject(o); break; default: console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"') } }, this.workerPool.push(r) } else this.workerPool.sort(function (r, s) { return r._taskLoad > s._taskLoad ? -1 : 1 }); let n = this.workerPool[this.workerPool.length - 1]; return n._taskCosts[t] = e, n._taskLoad += e, n }) } _releaseTask (t, e) { t._taskLoad -= t._taskCosts[e], delete t._callbacks[e], delete t._taskCosts[e] } debug () { console.log("Task load: ", this.workerPool.map(t => t._taskLoad)) } dispose () { for (let t = 0; t < this.workerPool.length; ++t)this.workerPool[t].terminate(); return this.workerPool.length = 0, this.workerSourceURL !== "" && URL.revokeObjectURL(this.workerSourceURL), this }
}; function n7 () { let i, t; onmessage = function (o) { let a = o.data; switch (a.type) { case "init": i = a.decoderConfig, t = new Promise(function (c) { i.onModuleLoaded = function (h) { c({ draco: h }) }, DracoDecoderModule(i) }); break; case "decode": let l = a.buffer, u = a.taskConfig; t.then(c => { let h = c.draco, d = new h.Decoder, f = new h.DecoderBuffer; f.Init(new Int8Array(l), l.byteLength); try { let p = e(h, d, f, u), m = p.attributes.map(g => g.array.buffer); p.index && m.push(p.index.array.buffer), self.postMessage({ type: "decode", id: a.id, geometry: p }, m) } catch (p) { console.error(p), self.postMessage({ type: "error", id: a.id, error: p.message }) } finally { h.destroy(f), h.destroy(d) } }); break } }; function e (o, a, l, u) { let c = u.attributeIDs, h = u.attributeTypes, d, f, p = a.GetEncodedGeometryType(l); if (p === o.TRIANGULAR_MESH) d = new o.Mesh, f = a.DecodeBufferToMesh(l, d); else if (p === o.POINT_CLOUD) d = new o.PointCloud, f = a.DecodeBufferToPointCloud(l, d); else throw new Error("THREE.DRACOLoader: Unexpected geometry type."); if (!f.ok() || d.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + f.error_msg()); let m = { index: null, attributes: [] }; for (let g in c) { let y = self[h[g]], v, x; if (u.useUniqueIDs) x = c[g], v = a.GetAttributeByUniqueId(d, x); else { if (x = a.GetAttributeId(d, o[c[g]]), x === -1) continue; v = a.GetAttribute(d, x) } m.attributes.push(r(o, a, d, g, y, v)) } return p === o.TRIANGULAR_MESH && (m.index = n(o, a, d)), o.destroy(d), m } function n (o, a, l) { let c = l.num_faces() * 3, h = c * 4, d = o._malloc(h); a.GetTrianglesUInt32Array(l, h, d); let f = new Uint32Array(o.HEAPF32.buffer, d, c).slice(); return o._free(d), { array: f, itemSize: 1 } } function r (o, a, l, u, c, h) { let d = h.num_components(), p = l.num_points() * d, m = p * c.BYTES_PER_ELEMENT, g = s(o, c), y = o._malloc(m); a.GetAttributeDataArrayForAllPoints(l, h, g, m, y); let v = new c(o.HEAPF32.buffer, y, p).slice(); return o._free(y), { name: u, array: v, itemSize: d } } function s (o, a) { switch (a) { case Float32Array: return o.DT_FLOAT32; case Int8Array: return o.DT_INT8; case Int16Array: return o.DT_INT16; case Int32Array: return o.DT_INT32; case Uint8Array: return o.DT_UINT8; case Uint16Array: return o.DT_UINT16; case Uint32Array: return o.DT_UINT32 } } } var Ka; function r7 () { return Ka || (Ka = new f0, Ka.setDecoderPath("https://www.gstatic.com/draco/versioned/decoders/1.5.2/").preload()), Ka.decoderPending } async function i7 (i) { if (Ka) { let t = { attributeIDs: Ka.defaultAttributeIDs, attributeTypes: Ka.defaultAttributeTypes, useUniqueIDs: !1 }, e; try { e = await Ka.decodeGeometry(new Int8Array(i).buffer, t) } catch (n) { console.error(n) } if (e) return { index: e.index ? { array: e.index.array } : void 0, attributes: Object.entries(e.attributes).map(([n, r]) => ({ name: n, itemSize: r.itemSize, array: r.array })) } } return null } async function kO (i, t) { let [e, n] = Eb(kg.deserialize(new Uint8Array(i))); GC(e); let r = []; e.scene.objects.traverse((s, o) => { o.type === "Mesh" && o.geometry.type === "NonParametricGeometry" && o.geometry.data.draco !== void 0 && r.push(o) }), r.length && await r7(); for (let s of r) { let o = await i7(Bn(s.geometry.data.draco)); if (o) { o.index && (s.geometry.data.index = { array: o.index.array, itemSize: 1, normalized: !1, type: "Uint32Array" }); let a = {}; o.attributes.forEach(({ name: l, array: u, itemSize: c }) => { a[l] = { array: u, itemSize: c, type: "Float32Array", normalized: !1 } }), s.geometry.data.attributes = a, s.geometry.data.draco = void 0 } } return t && t(e), n.result().data } var j1 = class { constructor(t, e, n, r, s, o, a) { this.id = t; this.data = e; this.dataEvent = n; this.object = r; this.stage = !1; this.actions = un(n, e.actions, s, o, a, r) } disconnect () { en(this.actions) } dispatchIn () { this.actions.Audio.forEach(t => t.dispatchBasic()), this.actions.Video.forEach(t => t.dispatchBasic()), this.actions.Create.forEach(t => t.dispatch()), this.actions.Destroy.forEach(t => t.dispatch()), this.actions.Reset.forEach(t => t.dispatch()), this.actions.Link.forEach(t => t.dispatch()), this.actions.Transition.forEach(t => { t.object.currentTransitionEvent !== this && (t.object.currentTransitionEvent = this, t.init()) }), this.actions.Transition.forEach(t => t.toggle()), this.actions.Animation.forEach(t => t.play()), this.actions.SwitchCamera.forEach(t => t.play()), this.actions.SceneTransition.forEach(t => t.dispatch()) } dispatchOut () { this.actions.Transition.forEach(t => { t.toggle() }) } }, p0 = class extends gn { constructor(e, n) { super(e); this.eventManager = n; this.breakpoints = []; this.onResize = () => { let e = window.innerWidth, n = window.innerHeight; this.breakpoints.forEach(r => { let s = Vg.deviceToSize(r.data.size), o = r.dataEvent.orientation === "horizontal" ? e : n, a; switch (r.data.operator) { case "<": a = o < s[0]; break; case ">": a = o > s[0]; break; case "<>": a = o > s[0] && o < s[1]; break }r.stage !== a && (r.stage = a, r.stage ? r.dispatchIn() : r.dispatchOut()) }) } } connect () { let { page: e, sharedAssets: n } = this.eventContext; window.addEventListener("resize", this.onResize), e.traverseEntity(r => { if (!(!r.visible || !r.data?.events.length)) for (let { data: s } of r.data.events) s.disabled || s.type === "Resize" && s.breakpoints.forEach(({ data: o, id: a }) => { try { let l = new j1(a, o, s, r, e, n, this.eventManager); this.breakpoints.push(l) } catch (l) { !1 && console.log(l) } }) }), this.onResize() } disconnect () { window.removeEventListener("resize", this.onResize), this.breakpoints.forEach(e => { e.disconnect() }), this.breakpoints = [] } }; var UO = Object.keys(x1).filter(i => isNaN(Number(i))), m0 = class { constructor(t, e, n, r) { this.publish = t; this.controlsManager = e; this.animationControls = n; this.eventContext = r; this.isEnabled = !1; this.activateCount = 0; this.onResetRaycaster = () => { this.eventContext.raycasterNeedsUpdate = !0 }; this.onTouchMovePreventScroll = t => { (t.touches.length > 1 || this.preventTouchScroll) && t.preventDefault() }; this.onMouseWheelPreventScroll = t => { this.preventScroll && t.preventDefault() }; this.stopRaycast = t.stopRaycast, this.preventScroll = t.preventScroll, this.preventTouchScroll = t.preventTouchScroll, this.hideCursor = t.hideCursor, this.requestRender = r.requestRender } activate () { if (this.isEnabled) return; this.isEnabled = !0, this.handlers = { Spline: new Kv(this.eventContext), ["Conditional"]: new $v(this.eventContext, this), ["Start"]: new o0(this.eventContext, this), Basic: new Zv(this.eventContext, this), ["MouseHover"]: new i0(this.eventContext, this), ["Scroll"]: new s0(this.eventContext, this), ["Follow"]: new t0(this.eventContext, this), ["DragDrop"]: new e0(this.eventContext, this), ["LookAt"]: new r0(this.eventContext), ["Resize"]: new p0(this.eventContext, this) }; let { page: t, domElement: e, eventElement: n } = this.eventContext; this.hideCursor && (e.style.cursor = "none"), t.traverseEntity(r => { r.addEventListener("requestRender", this.requestRender) }), Object.values(this.handlers).forEach(r => r.connect()), UO.forEach(r => { (Object.values(this.handlers).some(s => s.domEventsNeeded.has(r)) || r === "pointerdown" && this.controlsManager.navigationMeshWrapper) && (e.addEventListener(r, this.onResetRaycaster), n.addEventListener(r, this.onResetRaycaster)) }), e.addEventListener("wheel", this.onMouseWheelPreventScroll), e.addEventListener("touchmove", this.onTouchMovePreventScroll), this.activateCount++ } deactivate () { if (!this.isEnabled) return; this.isEnabled = !1; let { page: t, domElement: e } = this.eventContext; e.style.cursor = "", Object.values(this.handlers).forEach(n => n.disconnect()), this.controlsManager.gameControl?.disposeActions(), this.controlsManager.disconnectEvents(), t.traverseEntity(n => { n.removeEventListener("requestRender", this.requestRender) }), UO.forEach(n => { e.removeEventListener(n, this.onResetRaycaster) }), e.removeEventListener("touchmove", this.onTouchMovePreventScroll), e.removeEventListener("wheel", this.onMouseWheelPreventScroll), this.animationControls.onExitPlayMode() } get isPaused () { return this.isEnabled } pause () { this.deactivate() } resume () { this.activate() } reset () { this.deactivate(), this.activate(), this.controlsManager.page.updateMatrixWorld(!0), this.controlsManager.rebuildBVH() } updateUseWindowEvents (t) { let e = this.isEnabled; e && this.deactivate(), this.eventContext.useWindowEvents = t, e && this.activate() } }; var g0 = class { constructor(t, e, n, r, s) { this._aspect = 1; this.enableResponsive = !1; this._renderer = t, this._camera = e, this._frameSize = new B().copy(n), this._editorSize = new B().copy(r), this._aspect = e.aspect, this._fov = s ?? e.fov } set frameSize (t) { this._frameSize.copy(t) } updateRenderer () { !this._renderer || this._renderer.setSize(this._frameSize.x, this._frameSize.y) } updateViewport () { if (!this._renderer || !this._camera || this._camera.cameraType !== "PerspectiveCamera") return; let t = this._frameSize.x, e = this._frameSize.y, n = this._editorSize.y; this._aspect = t / e, e <= n && (this._camera.zoom *= n / e), this._renderer.setViewport(0, 0, t, e) } updateCamera (t = !0) { if (this._camera) if (this._camera.cameraType === "PerspectiveCamera") { let e = this._frameSize.y, n = this._editorSize.y, r = this._fov; if (t && e > n) { let s = s7(e, 1080, 2160, 1, 15) / 100; r *= e / n, r *= 1 - s } this._camera.aspect = this._aspect, this._camera.fov = r, this._camera.updateProjectionMatrix() } else this._camera.setViewplaneSize(this._frameSize.x, this._frameSize.y, this.enableResponsive) } setCamera (t) { this._camera = t, this._aspect = t.aspect, this._fov = t.fov } revert () { let t = window.innerWidth, e = window.innerHeight; this._renderer && (this._renderer.setViewport(0, 0, t, e), this._renderer.setSize(t, e)), this._camera && (this._camera.aspect = t / e, this._camera.fov = this._fov, this._camera.setViewplaneSize(t, e, this.enableResponsive), this._camera.updateProjectionMatrix()) } }; function s7 (i, t, e, n, r) { return (i - t) / (e - t) * (r - n) + n } var y0 = class { get sharedAssets () { return this.shared } constructor(t, e = {}) { this.shared = new Yl(t.shared, e), this.scene = new ja(t.scene, this.sharedAssets) } reset (t, e) { this.scene.clearScene(), this.sharedAssets.reset(t.shared), this.scene.resetAfterClear(t.scene, this.sharedAssets) } resetPersonalCameraFromDocumentData () { for (let t of this.scene.children) t instanceof ti && t.personalCamera.updateState(t.data.camera, { scene: this.scene, shared: this.shared }) } dispose () { this.scene.dispose(), this.shared.dispose() } gc () { this.shared.geometryCache.startGc(), this.shared.geometryCache2.startGc(), this.scene.traverseEntity(t => { t instanceof jt && t.markGeometryAsReachable(this.shared) }), this.shared.geometryCache.endGc(), this.shared.geometryCache2.endGc() } }; var v0 = class { constructor({ x: t = 10, y: e = 10 }) { this._startTime = 0; let n = document.getElementById("spe-perfs"); n ? this.element = n : (this.element = document.createElement("div"), document.body.appendChild(this.element), this.element.style.position = "absolute", this.element.style.zIndex = "10000", this.element.style.fontFamily = "monospace", this.element.style.background = "black", this.element.style.color = "white", this.element.style.padding = "10px", this.element.style.opacity = "0.5", this.element.style.fontSize = "11px", this.element.setAttribute("id", "spe-perfs")), this.element.style.left = `${t}px`, this.element.style.top = `${e}px` } dispose () { this.element.parentElement?.removeChild(this.element) } start () { this._startTime = performance.now() } end () { let e = performance.now() - this._startTime; this.element.innerHTML = e.toFixed(3) + " ms" } }; function o7 (i) { let t; if (i.index) for (let e = 0; e < i.index.array.length; e += 3)t = i.index.array[e], i.index.array[e] = i.index.array[e + 2], i.index.array[e + 2] = t } function Lp (i) { return i instanceof as ? "SubdivObject" : i.geometry.type === "NonParametricGeometry" ? "NonParametric" : "Mesh" } function a7 (i, t) { let e = {}; return i.traverseEntity(n => { if (!n.visible || !(n instanceof Ht) || n.type !== "Mesh" || Array.isArray(n.material) || n.states && Object.keys(n.states).length) return; let r = n.parent; for (; r;) { if (r instanceof Ht && n.states && Object.keys(n.states).length) return; r = r.parent } let s = n.material.uuid, o = t.shared.materials[s]; if (o) { if (!Sn.isMergable(o)) return } else { let u = t.scene.objects.get(n.uuid)?.data; if (u && "material" in u && typeof u.material != "string") { if (!Sn.isMergable(u.material)) return; s = Sn.getHash(u.material) } } e[s] || (e[s] = {}); let l = e[s][Lp(n)]; if (l) { if (l.push(n), n.cloner) for (let u of n.cloner.children) l.push(u) } else if (e[s][Lp(n)] = [n], n.cloner) for (let u of n.cloner.children) e[s][Lp(n)].push(u) }), e } function l7 (i) { let t = 0; return Object.values(i).forEach(e => { Object.values(e).forEach(n => { let r = n.length; r > t && (t = r) }) }), t } function zO (i, t) { let e = a7(t, i), n = l7(e), r = new Array(n), s = 0, o = new Array(n), a = 0, l = new Array(n), u = 0, c = new Array(n), h = 0; for (let [d, f] of Object.entries(e)) for (let p of Object.values(f)) { if (a = 0, u = 0, p.forEach(g => { g instanceof Ht && (o[a++] = g.geometry.clone(), l[u++] = g) }), u < 2) continue; for (let g = 0; g < u; g++)l[g].updateWorldMatrix(!0, !1), o[g].applyMatrix4(l[g].matrixWorld), l[g].matrixWorld.determinant() < 0 && o7(o[g]); let m = Ji(o.slice(0, a), !1); if (m) { let g; switch (d) { case "SubdivObject": { console.warn("Turning subdiv object into mesh"), g = new Rn(m, l[0].material); break } default: { g = new Rn(m, l[0].material); break } }g.castShadow = l[0].castShadow, g.receiveShadow = l[0].receiveShadow, t.add(g); let y = v => { h = 0; for (let x of v) x.children && y(x.children), x instanceof Ht && (Array.isArray(x.material) || e[x.material.uuid] && e[x.material.uuid][Lp(x)] && e[x.material.uuid][Lp(x)].length > 1 || (c[h++] = x)); for (let x = 0; x < h; x++)t.attach(c[x]) }; for (let v = 0; v < u; v++) { let x = l[v]; y(x.children), r[s++] = x } } } for (let d = 0; d < s; d++)r[d].removeFromParent() } var jO = sc(VO(), 1); var u7 = new B; function h7 (i) { let t = "The Spline Runtime only accepts .splinecode files that are generated from Spline export panel."; i.endsWith(".spline") ? console.warn(t + " The .spline files are only meant to be used by the Editor.") : i.endsWith(".splinecode") || console.warn(t) } var HO = class { constructor(t, { renderOnDemand: e, renderMode: n = "auto" } = {}) { this._viewportMode = 1; this._viewportWidth = window.innerWidth; this._viewportHeight = window.innerHeight; this._proxyObjectCache = new Map; this._isPaused = !1; this._renderRequested = !1; this._skipRender = !1; this.time = performance.now(); this.dt = 0; this.currentTAAFrame = 0; this.disposed = !1; this._requestRenderAutoMode = () => { this._skipRender = !1 }; this.requestRender = () => { this._renderRequested = !0 }; this.render = t => { if (this.time = t, this._lastTime && (this.dt = this.time - this._lastTime), this._lastTime = this.time, this._perfs?.start(), !this._renderer) { this._perfs?.end(); return } if (!this._isPaused && (this.renderMode === "manual" && !this._renderRequested || this.renderMode === "auto" && this._skipRender)) { this._perfs?.end(); return } if (this._renderRequested = !1, this._skipRender = !0, this._controls && (this._skipRender = this._controls.update(this.dt)), this._eventManager && (this._eventManager.handlers?.Start.hasVideoAction || this._eventManager.handlers?.Basic.hasVideoAction || this._eventManager.handlers?.Conditional.hasVideoAction) && (this._skipRender = !1), this._animationControls?.update(this.dt), this._skipRender ? (this.currentTAAFrame++, this.currentTAAFrame < 32 ? this._skipRender = !1 : this.currentTAAFrame = 0) : this.currentTAAFrame = 0, this._scene && this._scene.activeCamera !== this._camera && (this._camera = this._scene.activeCamera), this._eventManager?.isEnabled && ((this._eventManager.handlers?.Follow).onAnimationFrameDamping(), (this._eventManager.handlers?.LookAt).onAnimationFrameDamping(), (this._eventManager.handlers?.DragDrop).onAnimationFrameDamping()), this._scene && this._camera) { if (this._scene.pathConstraints.applyConstraints(this._scene), this._renderer.sceneTransitionTimeRemaining > 0) { this._renderer.sceneTransitionTimeRemaining -= this.dt; let e = 1 - this._renderer.sceneTransitionTimeRemaining / this._renderer.sceneTransitionDuration; this._renderer.pipeline.sceneTransitionPass.uniforms.mixRatio.value = e, this._skipRender = !1 } else this._renderer.pipeline.sceneTransitionFromTexture = null; this._renderer.renderSplineScene(this._scene, this._camera) } this.canvas.dispatchEvent(this._renderedEvent), this._perfs?.end() }; this._resize = () => { if (this._renderer) { if (this._viewportMode === 1 && this._frameView && (this._frameView.frameSize = u7.set(this._viewportWidth, this._viewportHeight)), this._renderer.setSize(this._viewportWidth, this._viewportHeight, !1), this._camera = this._scene?.activeCamera, this._scene?.updateViewPlaneSize(this._frameView?.frameSize?.x ?? this._viewportWidth, this._frameView?.frameSize?.y ?? this._viewportHeight, this._frameView?.enableResponsive ?? !1), this._camera) { let t = Object.values(this._data?.frames ?? {})[0].preset ?? "fullscreen"; this._frameView?.setCamera(this._camera), this._frameView?.updateCamera(t !== "fullscreen"), this._camera.cameraType === "PerspectiveCamera" && (this._camera.aspect = this._viewportWidth / this._viewportHeight), this._camera.updateProjectionMatrix() } this._requestRenderAutoMode() } }; this._debouncedResize = _l(this._resize, 10); this.canvas = t, this.renderMode = e ? "auto" : n, this._renderedEvent = new CustomEvent("rendered", { bubbles: !0 }), Object.defineProperty(this._renderedEvent, "target", { writable: !1, value: this }), window.location.search.includes("perfs") && (this._perfs = new v0({ x: 10, y: 10 })), TT(t) } async load (t, e) { h7(t), this.disposed = !1; let r = await (await fetch(t, e)).arrayBuffer(); await this.start(r) } async start (t, { interactive: e = !0 } = {}) { if (this.disposed) return; let n = await kO(t); this._data = n, n.version && (0, jO.default)(n.version, "0.9.437") > 0 && console.warn("Your .splinecode file is more recent than the library. Please upgrade @splinetool/runtime to the latest version."), await Promise.all([RS(n) && y2(), j2(n) && u2(), Ca.physicsEnabled(n.scene.objects) && LT(), ES(n) && k2(), F1(n) && DT()].filter(Boolean)), this._eventManager?.deactivate(), this._controls?.deactivate(), this._scene?.dispose(); let r = new y0(n); if (r.resetPersonalCameraFromDocumentData(), this._scene = r.scene, this._sharedAssetsManager = r.sharedAssets, this._camera = this._scene.activeCamera, window.location.search.includes("merge-geometries")) { let o = performance.now(); zO(n, r.scene); let a = performance.now(); console.log("Merged geometries in ", a - o, " ms") } RS(n) && this._scene.traverse(o => { Hr(o) && o.recomputeBoolean() }), this._sharedAssetsManager.setRequestRender(() => { this._requestRenderAutoMode(), this._scene?.traverse(o => { o instanceof dr && o.pendingMediaLoad && o.update() }) }); let s = Object.keys(n.shared.fonts).map(o => this._sharedAssetsManager.getFont(o).loadingPromise); if (Promise.all(s).then(() => { r.scene.markNeedsUpdateRendererDirty(), this._requestRenderAutoMode() }), ES(n) && NO(n) && await Promise.all(s), this._scene.rewriteEventsBeforeGoToPlayMode(), pd(this._scene.activePage, this._sharedAssetsManager), this._renderer || (this._renderer = new bv({ canvas: this.canvas, antialias: !1, alpha: !0, stencil: !1, depth: !1, powerPreference: "high-performance" }), this._renderer.hdTransmission = n.scene.publish.hdTransmission === !0, this._renderer.setPixelRatio(window.devicePixelRatio), this._renderer.pipeline.addEventListener("smaaloaded", this._requestRenderAutoMode)), n.scene.blueNoiseTextureData !== void 0 && this._renderer.pipeline.updateBlueNoiseTexture(n.scene.blueNoiseTextureData), this._frameView) this._frameView.setCamera(this._camera); else { let o = Object.values(n.frames)[0]; o.preset === "fullscreen" ? (this._viewportMode = 1, this.canvas.style.display = "block", this.canvas.parentElement && (this._viewportWidth = this.canvas.parentElement.clientWidth || 300, this.canvas.style.width = "100%"), this.canvas.parentElement && (this._viewportHeight = this.canvas.parentElement.clientHeight || 150, this.canvas.style.height = "100%")) : (this._viewportMode = 2, this._viewportWidth = o.size[0], this._viewportHeight = o.size[1], this.canvas.style.width = `${this._viewportWidth}px`, this.canvas.style.height = `${this._viewportHeight}px`), this._renderer.setSize(this._viewportWidth, this._viewportHeight, !1), this._frameView = new g0(this._renderer, this._camera, new B(this._viewportWidth, this._viewportHeight), new B(window.innerWidth, window.innerHeight)), this._frameView.enableResponsive = (o.allowResponsive ?? !1) && o.preset === "fullscreen" } if (e) { let o = new Qv(this._renderer, this.data.scene.publish, this._scene, () => this._scene.activeCamera, this._sharedAssetsManager, this._requestRenderAutoMode, !0); this._scene.updateMatrixWorld(!0), this._controls = new h0(o), this._animationControls = new d0(this._scene, this._requestRenderAutoMode), this._eventManager = new m0(n.scene.publish, this._controls, this._animationControls, o), this._eventManager.activate(), this._controls.activate(this._eventManager) } this._resize(), this.dt === 0 && (this.render(performance.now()), setTimeout(() => { this._renderer?.setAnimationLoop(this.render) }, 0)), this._resizeObserverTimeout = setTimeout(() => { !this._resizeObserver && this.canvas.parentElement && (this._resizeObserver = new ResizeObserver(() => { this._viewportWidth = this.canvas.clientWidth, this._viewportHeight = this.canvas.clientHeight, this._debouncedResize() }), this._resizeObserver.observe(this.canvas.parentElement)) }, 300) } findObjectById (t) { let e = this._scene?.getObjectByProperty("uuid", t); return this._createProxyObject(e) } findObjectByName (t) { let e = this._scene?.getObjectByName(t); return this._createProxyObject(e) } getAllObjects () { let t = []; return this._scene?.traverseEntity(e => { if (e.uuid !== Ti && !(e instanceof ti)) { let n = this._createProxyObject(e); n && t.push(n) } }), t } getSplineEvents () { return (this._eventManager?.handlers.Spline).splineEvents } emitEvent (t, e) { (this.findObjectById(e) || this.findObjectByName(e))?.emitEvent(t) } emitEventReverse (t, e) { (this.findObjectById(e) || this.findObjectByName(e))?.emitEventReverse(t) } addEventListener (t, e) { this.canvas.addEventListener(t, e) } removeEventListener (t, e) { this.canvas.removeEventListener(t, e) } setZoom (t) { this._controls?.orbitControls instanceof Ad && this._controls?.orbitControls.zoomOut(t) } get eventManager () { return this._eventManager } get controls () { return this._controls } setSize (t, e) { this._viewportWidth = t, this._viewportHeight = e, this._viewportMode = 2, this._resize() } setBackgroundColor (t) { let { r: e, g: n, b: r, a: s } = { r: 0, g: 0, b: 0, a: 1 }, o = new on(e, n, r, s); try { o.setStyle(t) } catch { console.error("This is not a valid css color", t) } this._scene?.activePage.setBackgroundColor(o), this._requestRenderAutoMode() } dispose () { this.disposed = !0, this._eventManager?.deactivate(), this._scene?.dispose(), this._sharedAssetsManager?.dispose(), this._proxyObjectCache.forEach(t => { cb.unsubscribe(t) }), this._renderer?.setAnimationLoop(null), this._renderer?.dispose(), this._renderer = void 0, this._sharedAssetsManager?.dispose(), this._resizeObserver && (this._resizeObserver.disconnect(), this._resizeObserver = void 0), this._resizeObserverTimeout !== void 0 && clearTimeout(this._resizeObserverTimeout), this.canvas.style.width = "", this.canvas.style.height = "", this.canvas.removeAttribute("width"), this.canvas.removeAttribute("height"), this._frameView && (this._frameView = void 0), this._controls?.deactivate(), CT(this.canvas) } get isStopped () { return this._isPaused } stop () { this._isPaused || (this._renderer?.setAnimationLoop(null), this._isPaused = !0, this._eventManager?.pause(), this._controls?.orbitControls && (this._controls.orbitControls.enabled = !1)) } play () { !this._isPaused || (this._isPaused = !1, this._eventManager?.resume(), this._controls?.orbitControls && (this._controls.orbitControls.enabled = !0), this._renderer?.setAnimationLoop(this.render)) } setGlobalEvents (t) { this._eventManager?.updateUseWindowEvents(t) } get data () { return this._data } _createProxyObject (t) { if (t == null) return; if (this._proxyObjectCache.has(t.uuid)) return this._proxyObjectCache.get(t.uuid); let e; t.traverseAncestors(s => { s instanceof ti && (e = s.name) }); let n = { name: t.name, uuid: t.uuid, visible: t.visible, intensity: t.intensity, position: t.position, rotation: t.rotation, scale: t.scale, type: t.data.type, page: e, parentUuid: t.parent instanceof ti || t instanceof ja ? void 0 : t.parent?.uuid, emitEvent (s) { t.dispatchEvent({ type: "userEvent", eventName: s }) }, emitEventReverse (s) { t.dispatchEvent({ type: "userEvent", eventName: s, reverse: !0 }) } }, r = cb(n, (s, o) => { typeof t[s] != "object" && Object.getOwnPropertyDescriptor(t, s)?.writable && (t[s] = o), this._requestRenderAutoMode(), t.updateMatrix() }); return this._proxyObjectCache.set(t.uuid, r), r } }; export { HO as Application };
